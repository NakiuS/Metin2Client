; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonNetworkStream.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R2CNetworkPacketHeaderMap@@8			; CNetworkPacketHeaderMap::`RTTI Base Class Array'
PUBLIC	??_R2CMainPacketHeaderMap@@8			; CMainPacketHeaderMap::`RTTI Base Class Array'
PUBLIC	??_R2?$CFuncObject@VCPythonNetworkStream@@@@8	; CFuncObject<CPythonNetworkStream>::`RTTI Base Class Array'
PUBLIC	??_R2?$CSingleton@VCPythonNetworkStream@@@@8	; CSingleton<CPythonNetworkStream>::`RTTI Base Class Array'
PUBLIC	??_R2CPythonNetworkStream@@8			; CPythonNetworkStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMainPacketHeaderMap@@8		; CMainPacketHeaderMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CNetworkPacketHeaderMap@@8	; CNetworkPacketHeaderMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1HM@?0A@EA@?$CSingleton@VCPythonNetworkStream@@@@8 ; CSingleton<CPythonNetworkStream>::`RTTI Base Class Descriptor at (124,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CFuncObject@VCPythonNetworkStream@@@@8 ; CFuncObject<CPythonNetworkStream>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCPythonNetworkStream@@@@8 ; CSingleton<CPythonNetworkStream>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CPythonNetworkStream@@8		; CPythonNetworkStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CNetworkPacketHeaderMap@@8			; CNetworkPacketHeaderMap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3CMainPacketHeaderMap@@8			; CMainPacketHeaderMap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCNetworkPacketHeaderMap@@@8		; CNetworkPacketHeaderMap `RTTI Type Descriptor'
PUBLIC	??_R0?AVCMainPacketHeaderMap@@@8		; CMainPacketHeaderMap `RTTI Type Descriptor'
PUBLIC	??_R3?$CFuncObject@VCPythonNetworkStream@@@@8	; CFuncObject<CPythonNetworkStream>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$CSingleton@VCPythonNetworkStream@@@@8	; CSingleton<CPythonNetworkStream>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$CFuncObject@VCPythonNetworkStream@@@@@8 ; CFuncObject<CPythonNetworkStream> `RTTI Type Descriptor'
PUBLIC	??_R3CPythonNetworkStream@@8			; CPythonNetworkStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$CSingleton@VCPythonNetworkStream@@@@@8 ; CSingleton<CPythonNetworkStream> `RTTI Type Descriptor'
PUBLIC	??_R0?AVCPythonNetworkStream@@@8		; CPythonNetworkStream `RTTI Type Descriptor'
PUBLIC	??_R4CMainPacketHeaderMap@@6B@			; CMainPacketHeaderMap::`RTTI Complete Object Locator'
PUBLIC	??_R4?$CSingleton@VCPythonNetworkStream@@@@6B@	; CSingleton<CPythonNetworkStream>::`RTTI Complete Object Locator'
PUBLIC	??_R4?$CFuncObject@VCPythonNetworkStream@@@@6B@	; CFuncObject<CPythonNetworkStream>::`RTTI Complete Object Locator'
PUBLIC	??_R4CPythonNetworkStream@@6B?$CSingleton@VCPythonNetworkStream@@@@@ ; CPythonNetworkStream::`RTTI Complete Object Locator'
PUBLIC	??_R4CPythonNetworkStream@@6BCNetworkStream@@@	; CPythonNetworkStream::`RTTI Complete Object Locator'
PUBLIC	??_7?$CFuncObject@VCPythonNetworkStream@@@@6B@	; CFuncObject<CPythonNetworkStream>::`vftable'
PUBLIC	??_7?$CSingleton@VCPythonNetworkStream@@@@6B@	; CSingleton<CPythonNetworkStream>::`vftable'
PUBLIC	??_7CPythonNetworkStream@@6B?$CSingleton@VCPythonNetworkStream@@@@@ ; CPythonNetworkStream::`vftable'
PUBLIC	??_7CPythonNetworkStream@@6BCNetworkStream@@@	; CPythonNetworkStream::`vftable'
PUBLIC	?g_iLastPacket@@3PAHA				; g_iLastPacket
PUBLIC	??_7CMainPacketHeaderMap@@6B@			; CMainPacketHeaderMap::`vftable'
PUBLIC	??_C@_0O@ODIJHOCP@?1phase_select?$AA@		; `string'
PUBLIC	??_C@_05CMMBDMDD@?1quit?$AA@			; `string'
PUBLIC	??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ ; `string'
PUBLIC	??_C@_07FOABJBDD@?1logout?$AA@			; `string'
PUBLIC	??_C@_0FP@JGOINIOH@CPythonNetworkStream?3?3CheckPacke@ ; `string'
PUBLIC	??_C@_0CH@LALGPME@Unknown?5packet?5header?3?5?$CFd?0?5last?3@ ; `string'
PUBLIC	??_C@_0CF@JLNGLGD@recv?5ping?5packet?4?5?$CIsecuritymode?5@ ; `string'
PUBLIC	??_C@_0EA@JMANDMEJ@Phase?5?$CFs?5does?5not?5handle?5this?5he@ ; `string'
PUBLIC	??_C@_0N@HHLEGKEL@SetGamePhase?$AA@		; `string'
PUBLIC	??_C@_0CG@IOPHKJBJ@?C?$LD?$LI?$KO?$LF?G?A?v?5?$LO?J?$MA?$LK?5?F?P?E?$LG?5?G?l?$LE?u?5?$CFd?0?5stat@ ; `string'
PUBLIC	??_C@_0BO@NMFMGDDG@?$CD?$CD?5Network?5?9?5OffLine?5Phase?5?$CD?$CD?$AA@ ; `string'
PUBLIC	??_C@_07NNEFBBEG@OffLine?$AA@			; `string'
PUBLIC	??_C@_0P@MDCECFOM@OBSERVER_COUNT?$AA@		; `string'
PUBLIC	??_C@_0O@PJEEOCNO@SetLoginPhase?$AA@		; `string'
PUBLIC	??_C@_0BO@OMGIOKNA@PythonNetworkMainStream?5Clear?$AA@ ; `string'
PUBLIC	??_C@_0O@FEJHKOEO@BETTING_MONEY?$AA@		; `string'
EXTRN	?OnConnectSuccess@CNetworkStream@@MAEXXZ:PROC	; CNetworkStream::OnConnectSuccess
EXTRN	??1CNetworkAddress@@QAE@XZ:PROC			; CNetworkAddress::~CNetworkAddress
EXTRN	??0CNetworkAddress@@QAE@XZ:PROC			; CNetworkAddress::CNetworkAddress
EXTRN	?ClearRecvBuffer@CNetworkStream@@QAEXXZ:PROC	; CNetworkStream::ClearRecvBuffer
EXTRN	?Get@CNetworkPacketHeaderMap@@QAE_NHPAUSPacketType@1@@Z:PROC ; CNetworkPacketHeaderMap::Get
EXTRN	?Connect@CNetworkStream@@QAE_NKHH@Z:PROC	; CNetworkStream::Connect
EXTRN	?Set@CNetworkAddress@@QAE_NPBDH@Z:PROC		; CNetworkAddress::Set
EXTRN	?IsOnline@CNetworkStream@@QAE_NXZ:PROC		; CNetworkStream::IsOnline
EXTRN	?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z:PROC ; CNetworkPacketHeaderMap::Set
EXTRN	??1CNetworkPacketHeaderMap@@UAE@XZ:PROC		; CNetworkPacketHeaderMap::~CNetworkPacketHeaderMap
EXTRN	??0CNetworkPacketHeaderMap@@QAE@XZ:PROC		; CNetworkPacketHeaderMap::CNetworkPacketHeaderMap
?g_iLastPacket@@3PAHA DD 02H DUP (?)			; g_iLastPacket
_gs_nextDownloadMarkTime DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@FEJHKOEO@BETTING_MONEY?$AA@
CONST	SEGMENT
??_C@_0O@FEJHKOEO@BETTING_MONEY?$AA@ DB 'BETTING_MONEY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OMGIOKNA@PythonNetworkMainStream?5Clear?$AA@
CONST	SEGMENT
??_C@_0BO@OMGIOKNA@PythonNetworkMainStream?5Clear?$AA@ DB 'PythonNetworkM'
	DB	'ainStream Clear', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PJEEOCNO@SetLoginPhase?$AA@
CONST	SEGMENT
??_C@_0O@PJEEOCNO@SetLoginPhase?$AA@ DB 'SetLoginPhase', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MDCECFOM@OBSERVER_COUNT?$AA@
CONST	SEGMENT
??_C@_0P@MDCECFOM@OBSERVER_COUNT?$AA@ DB 'OBSERVER_COUNT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NNEFBBEG@OffLine?$AA@
CONST	SEGMENT
??_C@_07NNEFBBEG@OffLine?$AA@ DB 'OffLine', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NMFMGDDG@?$CD?$CD?5Network?5?9?5OffLine?5Phase?5?$CD?$CD?$AA@
CONST	SEGMENT
??_C@_0BO@NMFMGDDG@?$CD?$CD?5Network?5?9?5OffLine?5Phase?5?$CD?$CD?$AA@ DB '#'
	DB	'# Network - OffLine Phase ##', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IOPHKJBJ@?C?$LD?$LI?$KO?$LF?G?A?v?5?$LO?J?$MA?$LK?5?F?P?E?$LG?5?G?l?$LE?u?5?$CFd?0?5stat@
CONST	SEGMENT
??_C@_0CG@IOPHKJBJ@?C?$LD?$LI?$KO?$LF?G?A?v?5?$LO?J?$MA?$LK?5?F?P?E?$LG?5?G?l?$LE?u?5?$CFd?0?5stat@ DB 0c3H
	DB	0b3H, 0b8H, 0aeH, 0b5H, 0c7H, 0c1H, 0f6H, ' ', 0beH, 0caH, 0c0H
	DB	0baH, ' ', 0c6H, 0d0H, 0c5H, 0b6H, ' ', 0c7H, 0ecH, 0b4H, 0f5H
	DB	' %d, state %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HHLEGKEL@SetGamePhase?$AA@
CONST	SEGMENT
??_C@_0N@HHLEGKEL@SetGamePhase?$AA@ DB 'SetGamePhase', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@JMANDMEJ@Phase?5?$CFs?5does?5not?5handle?5this?5he@
CONST	SEGMENT
??_C@_0EA@JMANDMEJ@Phase?5?$CFs?5does?5not?5handle?5this?5he@ DB 'Phase %'
	DB	's does not handle this header (header: %d, last: %d, %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JLNGLGD@recv?5ping?5packet?4?5?$CIsecuritymode?5@
CONST	SEGMENT
??_C@_0CF@JLNGLGD@recv?5ping?5packet?4?5?$CIsecuritymode?5@ DB 'recv ping'
	DB	' packet. (securitymode %u)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LALGPME@Unknown?5packet?5header?3?5?$CFd?0?5last?3@
CONST	SEGMENT
??_C@_0CH@LALGPME@Unknown?5packet?5header?3?5?$CFd?0?5last?3@ DB 'Unknown'
	DB	' packet header: %d, last: %d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@JGOINIOH@CPythonNetworkStream?3?3CheckPacke@
CONST	SEGMENT
??_C@_0FP@JGOINIOH@CPythonNetworkStream?3?3CheckPacke@ DB 'CPythonNetwork'
	DB	'Stream::CheckPacket - Not enough dynamic packet size: header '
	DB	'%d packet size: %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FOABJBDD@?1logout?$AA@
CONST	SEGMENT
??_C@_07FOABJBDD@?1logout?$AA@ DB '/logout', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ DB '%d.%d.%d.%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMMBDMDD@?1quit?$AA@
CONST	SEGMENT
??_C@_05CMMBDMDD@?1quit?$AA@ DB '/quit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ODIJHOCP@?1phase_select?$AA@
CONST	SEGMENT
??_C@_0O@ODIJHOCP@?1phase_select?$AA@ DB '/phase_select', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CMainPacketHeaderMap@@6B@
CONST	SEGMENT
??_7CMainPacketHeaderMap@@6B@ DD FLAT:??_R4CMainPacketHeaderMap@@6B@ ; CMainPacketHeaderMap::`vftable'
	DD	FLAT:??_ECMainPacketHeaderMap@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?sc_szEmpty@?1??GetAccountCharacterSlotDataz@CPythonNetworkStream@@QAEPBDII@Z@4PBDB
CONST	SEGMENT
?sc_szEmpty@?1??GetAccountCharacterSlotDataz@CPythonNetworkStream@@QAEPBDII@Z@4PBDB DD FLAT:??_C@_00CNPNBAHC@?$AA@ ; `CPythonNetworkStream::GetAccountCharacterSlotDataz'::`2'::sc_szEmpty
CONST	ENDS
;	COMDAT ??_7CPythonNetworkStream@@6BCNetworkStream@@@
CONST	SEGMENT
??_7CPythonNetworkStream@@6BCNetworkStream@@@ DD FLAT:??_R4CPythonNetworkStream@@6BCNetworkStream@@@ ; CPythonNetworkStream::`vftable'
	DD	FLAT:??_ECPythonNetworkStream@@UAEPAXI@Z
	DD	FLAT:?OnConnectSuccess@CNetworkStream@@MAEXXZ
	DD	FLAT:?OnConnectFailure@CPythonNetworkStream@@MAEXXZ
	DD	FLAT:?OnRemoteDisconnect@CPythonNetworkStream@@MAEXXZ
	DD	FLAT:?OnDisconnect@CPythonNetworkStream@@MAEXXZ
	DD	FLAT:?OnProcess@CPythonNetworkStream@@MAE_NXZ
CONST	ENDS
;	COMDAT ??_7CPythonNetworkStream@@6B?$CSingleton@VCPythonNetworkStream@@@@@
CONST	SEGMENT
??_7CPythonNetworkStream@@6B?$CSingleton@VCPythonNetworkStream@@@@@ DD FLAT:??_R4CPythonNetworkStream@@6B?$CSingleton@VCPythonNetworkStream@@@@@ ; CPythonNetworkStream::`vftable'
	DD	FLAT:??_ECPythonNetworkStream@@WHM@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCPythonNetworkStream@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCPythonNetworkStream@@@@6B@ DD FLAT:??_R4?$CSingleton@VCPythonNetworkStream@@@@6B@ ; CSingleton<CPythonNetworkStream>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCPythonNetworkStream@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CFuncObject@VCPythonNetworkStream@@@@6B@
CONST	SEGMENT
??_7?$CFuncObject@VCPythonNetworkStream@@@@6B@ DD FLAT:??_R4?$CFuncObject@VCPythonNetworkStream@@@@6B@ ; CFuncObject<CPythonNetworkStream>::`vftable'
	DD	FLAT:??_E?$CFuncObject@VCPythonNetworkStream@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CPythonNetworkStream@@6BCNetworkStream@@@
rdata$r	SEGMENT
??_R4CPythonNetworkStream@@6BCNetworkStream@@@ DD 00H	; CPythonNetworkStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPythonNetworkStream@@@8
	DD	FLAT:??_R3CPythonNetworkStream@@8
rdata$r	ENDS
;	COMDAT ??_R4CPythonNetworkStream@@6B?$CSingleton@VCPythonNetworkStream@@@@@
rdata$r	SEGMENT
??_R4CPythonNetworkStream@@6B?$CSingleton@VCPythonNetworkStream@@@@@ DD 00H ; CPythonNetworkStream::`RTTI Complete Object Locator'
	DD	07cH
	DD	00H
	DD	FLAT:??_R0?AVCPythonNetworkStream@@@8
	DD	FLAT:??_R3CPythonNetworkStream@@8
rdata$r	ENDS
;	COMDAT ??_R4?$CFuncObject@VCPythonNetworkStream@@@@6B@
rdata$r	SEGMENT
??_R4?$CFuncObject@VCPythonNetworkStream@@@@6B@ DD 00H	; CFuncObject<CPythonNetworkStream>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CFuncObject@VCPythonNetworkStream@@@@@8
	DD	FLAT:??_R3?$CFuncObject@VCPythonNetworkStream@@@@8
rdata$r	ENDS
;	COMDAT ??_R4?$CSingleton@VCPythonNetworkStream@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCPythonNetworkStream@@@@6B@ DD 00H	; CSingleton<CPythonNetworkStream>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCPythonNetworkStream@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCPythonNetworkStream@@@@8
rdata$r	ENDS
;	COMDAT ??_R4CMainPacketHeaderMap@@6B@
rdata$r	SEGMENT
??_R4CMainPacketHeaderMap@@6B@ DD 00H			; CMainPacketHeaderMap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMainPacketHeaderMap@@@8
	DD	FLAT:??_R3CMainPacketHeaderMap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPythonNetworkStream@@@8
data$r	SEGMENT
??_R0?AVCPythonNetworkStream@@@8 DD FLAT:??_7type_info@@6B@ ; CPythonNetworkStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPythonNetworkStream@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCPythonNetworkStream@@@@@8
data$r	SEGMENT
??_R0?AV?$CSingleton@VCPythonNetworkStream@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CPythonNetworkStream> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCPythonNetworkStream@@@@', 00H
data$r	ENDS
;	COMDAT ??_R3CPythonNetworkStream@@8
rdata$r	SEGMENT
??_R3CPythonNetworkStream@@8 DD 00H			; CPythonNetworkStream::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2CPythonNetworkStream@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CFuncObject@VCPythonNetworkStream@@@@@8
data$r	SEGMENT
??_R0?AV?$CFuncObject@VCPythonNetworkStream@@@@@8 DD FLAT:??_7type_info@@6B@ ; CFuncObject<CPythonNetworkStream> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CFuncObject@VCPythonNetworkStream@@@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCPythonNetworkStream@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCPythonNetworkStream@@@@8 DD 00H	; CSingleton<CPythonNetworkStream>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCPythonNetworkStream@@@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CFuncObject@VCPythonNetworkStream@@@@8
rdata$r	SEGMENT
??_R3?$CFuncObject@VCPythonNetworkStream@@@@8 DD 00H	; CFuncObject<CPythonNetworkStream>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CFuncObject@VCPythonNetworkStream@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMainPacketHeaderMap@@@8
data$r	SEGMENT
??_R0?AVCMainPacketHeaderMap@@@8 DD FLAT:??_7type_info@@6B@ ; CMainPacketHeaderMap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMainPacketHeaderMap@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVCNetworkPacketHeaderMap@@@8
data$r	SEGMENT
??_R0?AVCNetworkPacketHeaderMap@@@8 DD FLAT:??_7type_info@@6B@ ; CNetworkPacketHeaderMap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCNetworkPacketHeaderMap@@', 00H
data$r	ENDS
;	COMDAT ??_R3CMainPacketHeaderMap@@8
rdata$r	SEGMENT
??_R3CMainPacketHeaderMap@@8 DD 00H			; CMainPacketHeaderMap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CMainPacketHeaderMap@@8
rdata$r	ENDS
;	COMDAT ??_R3CNetworkPacketHeaderMap@@8
rdata$r	SEGMENT
??_R3CNetworkPacketHeaderMap@@8 DD 00H			; CNetworkPacketHeaderMap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CNetworkPacketHeaderMap@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPythonNetworkStream@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPythonNetworkStream@@8 DD FLAT:??_R0?AVCPythonNetworkStream@@@8 ; CPythonNetworkStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPythonNetworkStream@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCPythonNetworkStream@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCPythonNetworkStream@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCPythonNetworkStream@@@@@8 ; CSingleton<CPythonNetworkStream>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCPythonNetworkStream@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CFuncObject@VCPythonNetworkStream@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CFuncObject@VCPythonNetworkStream@@@@8 DD FLAT:??_R0?AV?$CFuncObject@VCPythonNetworkStream@@@@@8 ; CFuncObject<CPythonNetworkStream>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CFuncObject@VCPythonNetworkStream@@@@8
rdata$r	ENDS
;	COMDAT ??_R1HM@?0A@EA@?$CSingleton@VCPythonNetworkStream@@@@8
rdata$r	SEGMENT
??_R1HM@?0A@EA@?$CSingleton@VCPythonNetworkStream@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCPythonNetworkStream@@@@@8 ; CSingleton<CPythonNetworkStream>::`RTTI Base Class Descriptor at (124,-1,0,64)'
	DD	00H
	DD	07cH
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCPythonNetworkStream@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CNetworkPacketHeaderMap@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CNetworkPacketHeaderMap@@8 DD FLAT:??_R0?AVCNetworkPacketHeaderMap@@@8 ; CNetworkPacketHeaderMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CNetworkPacketHeaderMap@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CMainPacketHeaderMap@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMainPacketHeaderMap@@8 DD FLAT:??_R0?AVCMainPacketHeaderMap@@@8 ; CMainPacketHeaderMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMainPacketHeaderMap@@8
rdata$r	ENDS
;	COMDAT ??_R2CPythonNetworkStream@@8
rdata$r	SEGMENT
??_R2CPythonNetworkStream@@8 DD FLAT:??_R1A@?0A@EA@CPythonNetworkStream@@8 ; CPythonNetworkStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CNetworkStream@@8
	DD	FLAT:??_R1HM@?0A@EA@?$CSingleton@VCPythonNetworkStream@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCPythonNetworkStream@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCPythonNetworkStream@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonNetworkStream@@@@8 ; CSingleton<CPythonNetworkStream>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2?$CFuncObject@VCPythonNetworkStream@@@@8
rdata$r	SEGMENT
??_R2?$CFuncObject@VCPythonNetworkStream@@@@8 DD FLAT:??_R1A@?0A@EA@?$CFuncObject@VCPythonNetworkStream@@@@8 ; CFuncObject<CPythonNetworkStream>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CMainPacketHeaderMap@@8
rdata$r	SEGMENT
??_R2CMainPacketHeaderMap@@8 DD FLAT:??_R1A@?0A@EA@CMainPacketHeaderMap@@8 ; CMainPacketHeaderMap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CNetworkPacketHeaderMap@@8
rdata$r	ENDS
;	COMDAT ??_R2CNetworkPacketHeaderMap@@8
rdata$r	SEGMENT
??_R2CNetworkPacketHeaderMap@@8 DD FLAT:??_R1A@?0A@EA@CNetworkPacketHeaderMap@@8 ; CNetworkPacketHeaderMap::`RTTI Base Class Array'
PUBLIC	??_ECPythonNetworkStream@@WHM@AEPAXI@Z		; [thunk]:CPythonNetworkStream::`vector deleting destructor'
PUBLIC	??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Fill@PAPAU_object@@PAU1@@std@@YAXPAPAU_object@@0ABQAU1@@Z ; std::_Fill<_object * *,_object *>
PUBLIC	??$_Unchecked@PAPAU_object@@@std@@YAPAPAU_object@@PAPAU1@@Z ; std::_Unchecked<_object * *>
PUBLIC	??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$fill@PAPAU_object@@PAU1@@std@@YAXPAPAU_object@@0ABQAU1@@Z ; std::fill<_object * *,_object *>
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getblock
PUBLIC	?deallocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::deallocate
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::deallocate
PUBLIC	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
PUBLIC	?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Free_proxy
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_proxy
PUBLIC	?pop_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pop_back
PUBLIC	?empty@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
PUBLIC	??1?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Tidy@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	?SetPointer@?$CRef@VCNetworkActorManager@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CNetworkActorManager>::SetPointer
PUBLIC	?Clear@?$CRef@VCNetworkActorManager@@@@QAEXXZ	; CRef<CNetworkActorManager>::Clear
PUBLIC	??_G?$CFuncObject@VCPythonNetworkStream@@@@UAEPAXI@Z ; CFuncObject<CPythonNetworkStream>::`scalar deleting destructor'
PUBLIC	??_G?$CSingleton@VCPythonNetworkStream@@@@UAEPAXI@Z ; CSingleton<CPythonNetworkStream>::`scalar deleting destructor'
PUBLIC	?Instance@?$CSingleton@VCGuildMarkUploader@@@@SAAAVCGuildMarkUploader@@XZ ; CSingleton<CGuildMarkUploader>::Instance
PUBLIC	?Instance@?$CSingleton@VCGuildMarkDownloader@@@@SAAAVCGuildMarkDownloader@@XZ ; CSingleton<CGuildMarkDownloader>::Instance
PUBLIC	??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??C?$CRef@VCNetworkActorManager@@@@QBEPAVCNetworkActorManager@@XZ ; CRef<CNetworkActorManager>::operator->
PUBLIC	??4?$CRef@VCNetworkActorManager@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CNetworkActorManager>::operator=
PUBLIC	??1?$CRef@VCNetworkActorManager@@@@QAE@XZ	; CRef<CNetworkActorManager>::~CRef<CNetworkActorManager>
PUBLIC	??0?$CRef@VCNetworkActorManager@@@@QAE@XZ	; CRef<CNetworkActorManager>::CRef<CNetworkActorManager>
PUBLIC	?Run@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ ; CFuncObject<CPythonNetworkStream>::Run
PUBLIC	?IsEmpty@?$CFuncObject@VCPythonNetworkStream@@@@QAE_NXZ ; CFuncObject<CPythonNetworkStream>::IsEmpty
PUBLIC	?Set@?$CFuncObject@VCPythonNetworkStream@@@@QAEXPAVCPythonNetworkStream@@P82@AEXXZ@Z ; CFuncObject<CPythonNetworkStream>::Set
PUBLIC	?Clear@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ ; CFuncObject<CPythonNetworkStream>::Clear
PUBLIC	??1?$CFuncObject@VCPythonNetworkStream@@@@UAE@XZ ; CFuncObject<CPythonNetworkStream>::~CFuncObject<CPythonNetworkStream>
PUBLIC	??0?$CFuncObject@VCPythonNetworkStream@@@@QAE@XZ ; CFuncObject<CPythonNetworkStream>::CFuncObject<CPythonNetworkStream>
PUBLIC	??1?$CSingleton@VCPythonNetworkStream@@@@UAE@XZ	; CSingleton<CPythonNetworkStream>::~CSingleton<CPythonNetworkStream>
PUBLIC	??0?$CSingleton@VCPythonNetworkStream@@@@QAE@XZ	; CSingleton<CPythonNetworkStream>::CSingleton<CPythonNetworkStream>
PUBLIC	??1SMarkAuth@CPythonNetworkStream@@QAE@XZ	; CPythonNetworkStream::SMarkAuth::~SMarkAuth
PUBLIC	??0SMarkAuth@CPythonNetworkStream@@QAE@XZ	; CPythonNetworkStream::SMarkAuth::SMarkAuth
PUBLIC	??_GCPythonNetworkStream@@UAEPAXI@Z		; CPythonNetworkStream::`scalar deleting destructor'
PUBLIC	?SendEmoticon@CPythonNetworkStream@@QAEXI@Z	; CPythonNetworkStream::SendEmoticon
PUBLIC	?__ServerTimeSync_Initialize@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__ServerTimeSync_Initialize
PUBLIC	?EXPORT_GetBettingGuildWarValue@CPythonNetworkStream@@QAEKPBD@Z ; CPythonNetworkStream::EXPORT_GetBettingGuildWarValue
PUBLIC	?__BettingGuildWar_Initialize@CPythonNetworkStream@@AAEXXZ ; CPythonNetworkStream::__BettingGuildWar_Initialize
PUBLIC	?__InitializeMarkAuth@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__InitializeMarkAuth
PUBLIC	?__DirectEnterMode_IsSet@CPythonNetworkStream@@AAE_NXZ ; CPythonNetworkStream::__DirectEnterMode_IsSet
PUBLIC	?__DirectEnterMode_Set@CPythonNetworkStream@@AAEXI@Z ; CPythonNetworkStream::__DirectEnterMode_Set
PUBLIC	?__DirectEnterMode_Initialize@CPythonNetworkStream@@AAEXXZ ; CPythonNetworkStream::__DirectEnterMode_Initialize
PUBLIC	?__ClearSelectCharacterData@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__ClearSelectCharacterData
PUBLIC	?GetEmpireID@CPythonNetworkStream@@QAEKXZ	; CPythonNetworkStream::GetEmpireID
PUBLIC	?SetEmpireID@CPythonNetworkStream@@QAEXK@Z	; CPythonNetworkStream::SetEmpireID
PUBLIC	?GetMainActorSkillGroup@CPythonNetworkStream@@QAEKXZ ; CPythonNetworkStream::GetMainActorSkillGroup
PUBLIC	?GetMainActorEmpire@CPythonNetworkStream@@QAEKXZ ; CPythonNetworkStream::GetMainActorEmpire
PUBLIC	?GetMainActorRace@CPythonNetworkStream@@QAEKXZ	; CPythonNetworkStream::GetMainActorRace
PUBLIC	?GetMainActorVID@CPythonNetworkStream@@QAEKXZ	; CPythonNetworkStream::GetMainActorVID
PUBLIC	?SetHandler@CPythonNetworkStream@@QAEXPAU_object@@@Z ; CPythonNetworkStream::SetHandler
PUBLIC	?SetGameOffline@CPythonNetworkStream@@IAEXXZ	; CPythonNetworkStream::SetGameOffline
PUBLIC	?SetGameOnline@CPythonNetworkStream@@IAEXXZ	; CPythonNetworkStream::SetGameOnline
PUBLIC	?ClosePhase@CPythonNetworkStream@@QAEXXZ	; CPythonNetworkStream::ClosePhase
PUBLIC	?SetOffLinePhase@CPythonNetworkStream@@QAEXXZ	; CPythonNetworkStream::SetOffLinePhase
PUBLIC	?OnProcess@CPythonNetworkStream@@MAE_NXZ	; CPythonNetworkStream::OnProcess
PUBLIC	?RecvDefaultPacket@CPythonNetworkStream@@IAE_NH@Z ; CPythonNetworkStream::RecvDefaultPacket
PUBLIC	?RecvPingPacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvPingPacket
PUBLIC	?RecvPhasePacket@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::RecvPhasePacket
PUBLIC	?RecvErrorPacket@CPythonNetworkStream@@IAE_NH@Z	; CPythonNetworkStream::RecvErrorPacket
PUBLIC	?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z	; CPythonNetworkStream::CheckPacket
PUBLIC	?SetLoginInfo@CPythonNetworkStream@@QAEXPBD0@Z	; CPythonNetworkStream::SetLoginInfo
PUBLIC	?ConnectGameServer@CPythonNetworkStream@@QAEXI@Z ; CPythonNetworkStream::ConnectGameServer
PUBLIC	?SetMarkServer@CPythonNetworkStream@@QAEXPBDI@Z	; CPythonNetworkStream::SetMarkServer
PUBLIC	?ConnectLoginServer@CPythonNetworkStream@@QAEXPBDI@Z ; CPythonNetworkStream::ConnectLoginServer
PUBLIC	?GetAccountCharacterSlotDataz@CPythonNetworkStream@@QAEPBDII@Z ; CPythonNetworkStream::GetAccountCharacterSlotDataz
PUBLIC	?GetAccountCharacterSlotDatau@CPythonNetworkStream@@QAEIII@Z ; CPythonNetworkStream::GetAccountCharacterSlotDatau
PUBLIC	?IsSelectedEmpire@CPythonNetworkStream@@QAE_NXZ	; CPythonNetworkStream::IsSelectedEmpire
PUBLIC	?SetServerCommandParserWindow@CPythonNetworkStream@@QAEXPAU_object@@@Z ; CPythonNetworkStream::SetServerCommandParserWindow
PUBLIC	?ClearPhaseWindow@CPythonNetworkStream@@QAEXIPAU_object@@@Z ; CPythonNetworkStream::ClearPhaseWindow
PUBLIC	?SetPhaseWindow@CPythonNetworkStream@@QAEXIPAU_object@@@Z ; CPythonNetworkStream::SetPhaseWindow
PUBLIC	?__DownloadSymbol@CPythonNetworkStream@@IAEXABV?$vector@KV?$allocator@K@std@@@std@@@Z ; CPythonNetworkStream::__DownloadSymbol
PUBLIC	?__DownloadMark@CPythonNetworkStream@@IAEXXZ	; CPythonNetworkStream::__DownloadMark
PUBLIC	?UploadSymbol@CPythonNetworkStream@@QAEIPBD@Z	; CPythonNetworkStream::UploadSymbol
PUBLIC	?UploadMark@CPythonNetworkStream@@QAEIPBD@Z	; CPythonNetworkStream::UploadMark
PUBLIC	?GetGuildID@CPythonNetworkStream@@QAEKXZ	; CPythonNetworkStream::GetGuildID
PUBLIC	?__IsNotPing@CPythonNetworkStream@@IAE_NXZ	; CPythonNetworkStream::__IsNotPing
PUBLIC	?AbsoluteExitApplication@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::AbsoluteExitApplication
PUBLIC	?AbsoluteExitGame@CPythonNetworkStream@@QAEXXZ	; CPythonNetworkStream::AbsoluteExitGame
PUBLIC	?LogOutGame@CPythonNetworkStream@@QAEXXZ	; CPythonNetworkStream::LogOutGame
PUBLIC	?ExitGame@CPythonNetworkStream@@QAEXXZ		; CPythonNetworkStream::ExitGame
PUBLIC	?ExitApplication@CPythonNetworkStream@@QAEXXZ	; CPythonNetworkStream::ExitApplication
PUBLIC	??1CMainPacketHeaderMap@@UAE@XZ			; CMainPacketHeaderMap::~CMainPacketHeaderMap
PUBLIC	??_GCMainPacketHeaderMap@@UAEPAXI@Z		; CMainPacketHeaderMap::`scalar deleting destructor'
PUBLIC	??0CMainPacketHeaderMap@@QAE@XZ			; CMainPacketHeaderMap::CMainPacketHeaderMap
PUBLIC	?__LeaveOfflinePhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__LeaveOfflinePhase
PUBLIC	??0SPacketType@CNetworkPacketHeaderMap@@QAE@H_N@Z ; CNetworkPacketHeaderMap::SPacketType::SPacketType
PUBLIC	??0CPythonNetworkStream@@QAE@XZ			; CPythonNetworkStream::CPythonNetworkStream
PUBLIC	??1CPythonNetworkStream@@UAE@XZ			; CPythonNetworkStream::~CPythonNetworkStream
PUBLIC	?SetWaitFlag@CPythonNetworkStream@@QAEXXZ	; CPythonNetworkStream::SetWaitFlag
PUBLIC	?ClearLoginInfo@CPythonNetworkStream@@QAEXXZ	; CPythonNetworkStream::ClearLoginInfo
PUBLIC	?SetLoginKey@CPythonNetworkStream@@QAEXK@Z	; CPythonNetworkStream::SetLoginKey
EXTRN	??_ECPythonNetworkStream@@UAEPAXI@Z:PROC	; CPythonNetworkStream::`vector deleting destructor'
EXTRN	??_E?$CSingleton@VCPythonNetworkStream@@@@UAEPAXI@Z:PROC ; CSingleton<CPythonNetworkStream>::`vector deleting destructor'
EXTRN	??_E?$CFuncObject@VCPythonNetworkStream@@@@UAEPAXI@Z:PROC ; CFuncObject<CPythonNetworkStream>::`vector deleting destructor'
EXTRN	??_ECMainPacketHeaderMap@@UAEPAXI@Z:PROC	; CMainPacketHeaderMap::`vector deleting destructor'
;	COMDAT ?s_szAddr@?8??GetAccountCharacterSlotDataz@CPythonNetworkStream@@QAEPBDII@Z@4PADA
_BSS	SEGMENT
?s_szAddr@?8??GetAccountCharacterSlotDataz@CPythonNetworkStream@@QAEPBDII@Z@4PADA DB 0100H DUP (?) ; `CPythonNetworkStream::GetAccountCharacterSlotDataz'::`9'::s_szAddr
_BSS	ENDS
;	COMDAT ?$S1@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4IA
_BSS	SEGMENT
?$S1@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4IA DD 01H DUP (?) ; S1<`template-parameter-2',CPythonNetworkStream::eckPacket,unsigned int, ?? volatile __based( ?? ) ?? ::IA::Z::Z::NPAE::& __ptr64 ?? >
_BSS	ENDS
;	COMDAT ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
_BSS	SEGMENT
?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A DB 0cH DUP (?) ; `CPythonNetworkStream::CheckPacket'::`2'::s_packetHeaderMap
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CPythonNetworkStream@@UAE@XZ DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$??1CPythonNetworkStream@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??1CPythonNetworkStream@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$14
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CPythonNetworkStream@@QAE@XZ DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$??0CPythonNetworkStream@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0CPythonNetworkStream@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$15
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CMainPacketHeaderMap@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CMainPacketHeaderMap@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CMainPacketHeaderMap@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CMainPacketHeaderMap@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z$0
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SetLoginKey@CPythonNetworkStream@@QAEXK@Z
_TEXT	SEGMENT
_dwLoginKey$ = 8					; size = 4
?SetLoginKey@CPythonNetworkStream@@QAEXK@Z PROC		; CPythonNetworkStream::SetLoginKey, COMDAT
; _this$ = ecx

; 494  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 495  : 	m_dwLoginKey = dwLoginKey;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwLoginKey$[ebp]
  00006	89 81 24 01 00
	00		 mov	 DWORD PTR [ecx+292], eax

; 496  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetLoginKey@CPythonNetworkStream@@QAEXK@Z ENDP		; CPythonNetworkStream::SetLoginKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?ClearLoginInfo@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?ClearLoginInfo@CPythonNetworkStream@@QAEXXZ PROC	; CPythonNetworkStream::ClearLoginInfo, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 490  : 	m_stPassword = "";

  00007	81 c1 dc 00 00
	00		 add	 ecx, 220		; 000000dcH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0000d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 491  : }

  00012	c3		 ret	 0
?ClearLoginInfo@CPythonNetworkStream@@QAEXXZ ENDP	; CPythonNetworkStream::ClearLoginInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SetWaitFlag@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?SetWaitFlag@CPythonNetworkStream@@QAEXXZ PROC		; CPythonNetworkStream::SetWaitFlag, COMDAT
; _this$ = ecx

; 849  : 	m_isWaitLoginKey = TRUE;

  00000	c7 81 28 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+296], 1

; 850  : }

  0000a	c3		 ret	 0
?SetWaitFlag@CPythonNetworkStream@@QAEXXZ ENDP		; CPythonNetworkStream::SetWaitFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ??1CPythonNetworkStream@@UAE@XZ
_TEXT	SEGMENT
__Cat$2 = -20						; size = 1
_this$ = -20						; size = 4
__Alval$3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??1CPythonNetworkStream@@UAE@XZ PROC			; CPythonNetworkStream::~CPythonNetworkStream, COMDAT
; _this$ = ecx

; 899  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CPythonNetworkStream@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CPythonNetworkStream@@6BCNetworkStream@@@
  00032	c7 47 7c 00 00
	00 00		 mov	 DWORD PTR [edi+124], OFFSET ??_7CPythonNetworkStream@@6B?$CSingleton@VCPythonNetworkStream@@@@@

; 900  : 	Tracen("PythonNetworkMainStream Clear");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OMGIOKNA@PythonNetworkMainStream?5Clear?$AA@
  0003e	c7 45 fc 0e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00045	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0004a	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1215 : 		_Tidy();

  0004d	8d 8f 24 79 00
	00		 lea	 ecx, DWORD PTR [edi+31012]
  00053	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00058	ff b7 24 79 00
	00		 push	 DWORD PTR [edi+31012]
  0005e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00063	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 907  : 		this->_Myproxy = 0;

  00066	c7 87 24 79 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+31012], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 901  : }

  00070	8d 8f 14 79 00
	00		 lea	 ecx, DWORD PTR [edi+30996]
  00076	e8 00 00 00 00	 call	 ??1CInsultChecker@@UAE@XZ ; CInsultChecker::~CInsultChecker
  0007b	8d 8f f8 78 00
	00		 lea	 ecx, DWORD PTR [edi+30968]
  00081	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00085	e8 00 00 00 00	 call	 ??1CNetworkAddress@@QAE@XZ ; CNetworkAddress::~CNetworkAddress
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0008a	8b 87 20 03 00
	00		 mov	 eax, DWORD PTR [edi+800]
  00090	85 c0		 test	 eax, eax
  00092	74 3f		 je	 SHORT $LN35@CPythonNet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00094	ff 75 ec	 push	 DWORD PTR __Cat$2[ebp]
  00097	8d 4d f3	 lea	 ecx, DWORD PTR __Alval$3[ebp]
  0009a	51		 push	 ecx
  0009b	ff b7 24 03 00
	00		 push	 DWORD PTR [edi+804]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 573  : 		::operator delete(_Ptr);

  000a7	ff b7 20 03 00
	00		 push	 DWORD PTR [edi+800]
  000ad	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b2	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000b5	c7 87 20 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+800], 0

; 1630 : 			this->_Mylast = pointer();

  000bf	c7 87 24 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+804], 0

; 1631 : 			this->_Myend = pointer();

  000c9	c7 87 28 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+808], 0
$LN35@CPythonNet:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 901  : }

  000d3	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h

; 53   : 			if (m_pObject)

  000d7	8b 8f 0c 03 00
	00		 mov	 ecx, DWORD PTR [edi+780]
  000dd	85 c9		 test	 ecx, ecx
  000df	74 0f		 je	 SHORT $LN54@CPythonNet

; 54   : 			{
; 55   : 				m_pObject->Release();

  000e1	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  000e6	c7 87 0c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+780], 0
$LN54@CPythonNet:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 901  : }

  000f0	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000f5	6a 04		 push	 4
  000f7	6a 18		 push	 24			; 00000018H
  000f9	8d 87 a8 02 00
	00		 lea	 eax, DWORD PTR [edi+680]
  000ff	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 13   : 		{

  00109	c7 87 60 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+352], OFFSET ??_7?$CFuncObject@VCPythonNetworkStream@@@@6B@
  00113	c7 87 48 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+328], OFFSET ??_7?$CFuncObject@VCPythonNetworkStream@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0011d	83 bf 40 01 00
	00 10		 cmp	 DWORD PTR [edi+320], 16	; 00000010H
  00124	72 0e		 jb	 SHORT $LN81@CPythonNet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00126	ff b7 2c 01 00
	00		 push	 DWORD PTR [edi+300]
  0012c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00131	83 c4 04	 add	 esp, 4
$LN81@CPythonNet:
  00134	c7 87 40 01 00
	00 0f 00 00 00	 mov	 DWORD PTR [edi+320], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0013e	c7 87 3c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+316], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00148	c6 87 2c 01 00
	00 00		 mov	 BYTE PTR [edi+300], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0014f	83 bf 20 01 00
	00 10		 cmp	 DWORD PTR [edi+288], 16	; 00000010H
  00156	72 0e		 jb	 SHORT $LN113@CPythonNet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00158	ff b7 0c 01 00
	00		 push	 DWORD PTR [edi+268]
  0015e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00163	83 c4 04	 add	 esp, 4
$LN113@CPythonNet:
  00166	c7 87 20 01 00
	00 0f 00 00 00	 mov	 DWORD PTR [edi+288], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00170	c7 87 1c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+284], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0017a	c6 87 0c 01 00
	00 00		 mov	 BYTE PTR [edi+268], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00181	83 bf 08 01 00
	00 10		 cmp	 DWORD PTR [edi+264], 16	; 00000010H
  00188	72 0e		 jb	 SHORT $LN145@CPythonNet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0018a	ff b7 f4 00 00
	00		 push	 DWORD PTR [edi+244]
  00190	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00195	83 c4 04	 add	 esp, 4
$LN145@CPythonNet:
  00198	c7 87 08 01 00
	00 0f 00 00 00	 mov	 DWORD PTR [edi+264], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  001a2	c7 87 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+260], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  001ac	c6 87 f4 00 00
	00 00		 mov	 BYTE PTR [edi+244], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  001b3	83 bf f0 00 00
	00 10		 cmp	 DWORD PTR [edi+240], 16	; 00000010H
  001ba	72 0e		 jb	 SHORT $LN177@CPythonNet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001bc	ff b7 dc 00 00
	00		 push	 DWORD PTR [edi+220]
  001c2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001c7	83 c4 04	 add	 esp, 4
$LN177@CPythonNet:
  001ca	c7 87 f0 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [edi+240], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  001d4	c7 87 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+236], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  001de	c6 87 dc 00 00
	00 00		 mov	 BYTE PTR [edi+220], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  001e5	83 bf d8 00 00
	00 10		 cmp	 DWORD PTR [edi+216], 16	; 00000010H
  001ec	72 0e		 jb	 SHORT $LN209@CPythonNet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001ee	ff b7 c4 00 00
	00		 push	 DWORD PTR [edi+196]
  001f4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001f9	83 c4 04	 add	 esp, 4
$LN209@CPythonNet:
  001fc	c7 87 d8 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [edi+216], 15	; 0000000fH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 901  : }

  00206	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00208	c7 87 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+212], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00212	c6 87 c4 00 00
	00 00		 mov	 BYTE PTR [edi+196], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 19   : 	{ 

  00219	c7 47 7c 00 00
	00 00		 mov	 DWORD PTR [edi+124], OFFSET ??_7?$CSingleton@VCPythonNetworkStream@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00220	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A, 0 ; CSingleton<CPythonNetworkStream>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 901  : }

  0022a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00231	e8 00 00 00 00	 call	 ??1CNetworkStream@@UAE@XZ ; CNetworkStream::~CNetworkStream
  00236	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00239	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00240	59		 pop	 ecx
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	8b e5		 mov	 esp, ebp
  00245	5d		 pop	 ebp
  00246	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CNetworkStream@@UAE@XZ ; CNetworkStream::~CNetworkStream
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$1:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0000e	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCPythonNetworkStream@@@@UAE@XZ ; CSingleton<CPythonNetworkStream>::~CSingleton<CPythonNetworkStream>
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$2:
  00013	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$3:
  00021	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 dc 00 00
	00		 add	 ecx, 220		; 000000dcH
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$4:
  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c1 f4 00 00
	00		 add	 ecx, 244		; 000000f4H
  00038	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$5:
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00046	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$6:
  0004b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  00054	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$7:
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	81 c1 48 01 00
	00		 add	 ecx, 328		; 00000148H
  00062	e9 00 00 00 00	 jmp	 ??1?$CFuncObject@VCPythonNetworkStream@@@@UAE@XZ ; CFuncObject<CPythonNetworkStream>::~CFuncObject<CPythonNetworkStream>
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$8:
  00067	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	81 c1 60 01 00
	00		 add	 ecx, 352		; 00000160H
  00070	e9 00 00 00 00	 jmp	 ??1?$CFuncObject@VCPythonNetworkStream@@@@UAE@XZ ; CFuncObject<CPythonNetworkStream>::~CFuncObject<CPythonNetworkStream>
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$9:
  00075	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0007a	6a 04		 push	 4
  0007c	6a 18		 push	 24			; 00000018H
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	05 a8 02 00 00	 add	 eax, 680		; 000002a8H
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0008c	c3		 ret	 0
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$10:
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	81 c1 0c 03 00
	00		 add	 ecx, 780		; 0000030cH
  00096	e9 00 00 00 00	 jmp	 ??1?$CRef@VCNetworkActorManager@@@@QAE@XZ ; CRef<CNetworkActorManager>::~CRef<CNetworkActorManager>
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$11:
  0009b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	81 c1 20 03 00
	00		 add	 ecx, 800		; 00000320H
  000a4	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$12:
  000a9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	81 c1 f8 78 00
	00		 add	 ecx, 30968		; 000078f8H
  000b2	e9 00 00 00 00	 jmp	 ??1SMarkAuth@CPythonNetworkStream@@QAE@XZ
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$13:
  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	81 c1 14 79 00
	00		 add	 ecx, 30996		; 00007914H
  000c0	e9 00 00 00 00	 jmp	 ??1CInsultChecker@@UAE@XZ ; CInsultChecker::~CInsultChecker
__unwindfunclet$??1CPythonNetworkStream@@UAE@XZ$14:
  000c5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	81 c1 24 79 00
	00		 add	 ecx, 31012		; 00007924H
  000ce	e9 00 00 00 00	 jmp	 ??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??1CPythonNetworkStream@@UAE@XZ:
  000d3	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000d7	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000da	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  000dd	33 c8		 xor	 ecx, eax
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CPythonNetworkStream@@UAE@XZ
  000e9	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CPythonNetworkStream@@UAE@XZ ENDP			; CPythonNetworkStream::~CPythonNetworkStream
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ??0CPythonNetworkStream@@QAE@XZ
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CPythonNetworkStream@@QAE@XZ PROC			; CPythonNetworkStream::CPythonNetworkStream, COMDAT
; _this$ = ecx

; 861  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CPythonNetworkStream@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002d	e8 00 00 00 00	 call	 ??0CNetworkStream@@QAE@XZ ; CNetworkStream::CNetworkStream
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  00039	8b c6		 mov	 eax, esi
  0003b	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], OFFSET ??_7?$CSingleton@VCPythonNetworkStream@@@@6B@
  00042	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A, eax ; CSingleton<CPythonNetworkStream>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 861  : {

  00047	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CPythonNetworkStream@@6BCNetworkStream@@@
  0004d	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], OFFSET ??_7CPythonNetworkStream@@6B?$CSingleton@VCPythonNetworkStream@@@@@
  00054	c7 86 d8 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+216], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0005e	c7 86 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+212], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00068	c6 86 c4 00 00
	00 00		 mov	 BYTE PTR [esi+196], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 861  : {

  0006f	c7 86 f0 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+240], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00079	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00083	c6 86 dc 00 00
	00 00		 mov	 BYTE PTR [esi+220], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 861  : {

  0008a	c7 86 08 01 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+264], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00094	c7 86 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+260], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0009e	c6 86 f4 00 00
	00 00		 mov	 BYTE PTR [esi+244], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 861  : {

  000a5	c7 86 20 01 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+288], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000af	c7 86 1c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+284], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000b9	c6 86 0c 01 00
	00 00		 mov	 BYTE PTR [esi+268], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 861  : {

  000c0	c7 86 40 01 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+320], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000ca	c7 86 3c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+316], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000d4	c6 86 2c 01 00
	00 00		 mov	 BYTE PTR [esi+300], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 7    : 		CFuncObject()

  000db	c7 86 48 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+328], OFFSET ??_7?$CFuncObject@VCPythonNetworkStream@@@@6B@

; 18   : 			m_pSelfObject = NULL;

  000e5	c7 86 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+336], 0

; 19   : 			m_pFuncObject = NULL;

  000ef	c7 86 58 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+344], 0
  000f9	c7 86 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+348], 0

; 7    : 		CFuncObject()

  00103	c7 86 60 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+352], OFFSET ??_7?$CFuncObject@VCPythonNetworkStream@@@@6B@

; 18   : 			m_pSelfObject = NULL;

  0010d	c7 86 68 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+360], 0

; 19   : 			m_pFuncObject = NULL;

  00117	c7 86 70 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+368], 0
  00121	c7 86 74 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+372], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 861  : {

  0012b	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00130	68 00 00 00 00	 push	 OFFSET ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00135	6a 04		 push	 4
  00137	6a 18		 push	 24			; 00000018H
  00139	8d 86 a8 02 00
	00		 lea	 eax, DWORD PTR [esi+680]
  0013f	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h

; 21   : 		{

  00149	c7 86 0c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+780], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00153	c7 86 20 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+800], 0

; 483  : 		_Mylast = pointer();

  0015d	c7 86 24 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+804], 0

; 484  : 		_Myend = pointer();

  00167	c7 86 28 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+808], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 861  : {

  00171	8d 8e f8 78 00
	00		 lea	 ecx, DWORD PTR [esi+30968]
  00177	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  0017b	e8 00 00 00 00	 call	 ??0CNetworkAddress@@QAE@XZ ; CNetworkAddress::CNetworkAddress
  00180	8d 8e 14 79 00
	00		 lea	 ecx, DWORD PTR [esi+30996]
  00186	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  0018a	e8 00 00 00 00	 call	 ??0CInsultChecker@@QAE@XZ ; CInsultChecker::CInsultChecker
  0018f	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00193	8d be 24 79 00
	00		 lea	 edi, DWORD PTR [esi+31012]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00199	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

  0019b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

  001a1	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 774  : 		_Mapsize = 0;

  001a8	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 775  : 		_Myoff = 0;

  001af	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 776  : 		_Mysize = 0;

  001b6	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  001bd	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001c2	83 c4 04	 add	 esp, 4
  001c5	85 c0		 test	 eax, eax
  001c7	75 05		 jne	 SHORT $LN254@CPythonNet

; 29   : 		_Xbad_alloc();	// report no memory

  001c9	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN316@CPythonNet:
$LN254@CPythonNet:
  001ce	89 07		 mov	 DWORD PTR [edi], eax

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  001d0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001d6	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

  001dd	8b 07		 mov	 eax, DWORD PTR [edi]
  001df	89 38		 mov	 DWORD PTR [eax], edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 862  : 	m_rokNetActorMgr=new CNetworkActorManager;

  001e1	6a 20		 push	 32			; 00000020H
  001e3	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  001e7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001ec	83 c4 04	 add	 esp, 4
  001ef	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  001f2	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  001f6	85 c0		 test	 eax, eax
  001f8	74 09		 je	 SHORT $LN3@CPythonNet
  001fa	8b c8		 mov	 ecx, eax
  001fc	e8 00 00 00 00	 call	 ??0CNetworkActorManager@@QAE@XZ ; CNetworkActorManager::CNetworkActorManager
  00201	eb 02		 jmp	 SHORT $LN4@CPythonNet
$LN3@CPythonNet:
  00203	33 c0		 xor	 eax, eax
$LN4@CPythonNet:
  00205	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h

; 67   : 			CReferenceObject* pOldObject = m_pObject;

  00209	8b be 0c 03 00
	00		 mov	 edi, DWORD PTR [esi+780]
  0020f	89 86 0c 03 00
	00		 mov	 DWORD PTR [esi+780], eax

; 68   : 
; 69   : 			m_pObject = pObject;
; 70   : 
; 71   : 			if (m_pObject)

  00215	85 c0		 test	 eax, eax
  00217	74 07		 je	 SHORT $LN286@CPythonNet

; 72   : 				m_pObject->AddReference();

  00219	8b c8		 mov	 ecx, eax
  0021b	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN286@CPythonNet:

; 73   : 
; 74   : 			if (pOldObject)

  00220	85 ff		 test	 edi, edi
  00222	74 07		 je	 SHORT $LN285@CPythonNet

; 75   : 				pOldObject->Release();

  00224	8b cf		 mov	 ecx, edi
  00226	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN285@CPythonNet:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 864  : 	memset(m_akSimplePlayerInfo, 0, sizeof(m_akSimplePlayerInfo));

  0022b	68 fc 00 00 00	 push	 252			; 000000fcH
  00230	8d 86 9c 01 00
	00		 lea	 eax, DWORD PTR [esi+412]
  00236	6a 00		 push	 0
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 _memset
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 18   : 			m_pSelfObject = NULL;

  0023e	c7 86 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+336], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00248	8d 8e 0c 01 00
	00		 lea	 ecx, DWORD PTR [esi+268]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 19   : 			m_pFuncObject = NULL;

  0024e	c7 86 58 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+344], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 864  : 	memset(m_akSimplePlayerInfo, 0, sizeof(m_akSimplePlayerInfo));

  00258	83 c4 0c	 add	 esp, 12			; 0000000cH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 19   : 			m_pFuncObject = NULL;

  0025b	c7 86 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+348], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 868  : 	m_dwEmpireID = 0;

  00265	c7 86 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+180], 0

; 869  : 	m_dwGuildID = 0;

  0026f	c7 86 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+176], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00279	6a 07		 push	 7
  0027b	68 00 00 00 00	 push	 OFFSET ??_C@_07NNEFBBEG@OffLine?$AA@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 871  : 	m_dwMainActorVID = 0;

  00280	c7 86 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+152], 0

; 872  : 	m_dwMainActorRace = 0;

  0028a	c7 86 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+156], 0

; 873  : 	m_dwMainActorEmpire = 0;

  00294	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0

; 874  : 	m_dwMainActorSkillGroup = 0;

  0029e	c7 86 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+164], 0

; 875  : 	m_poHandler = NULL;

  002a8	c7 86 78 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+376], 0

; 876  : 
; 877  : 	m_dwLastGamePingTime = 0;

  002b2	c7 86 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+192], 0

; 878  : 
; 879  : 	m_dwLoginKey = 0;

  002bc	c7 86 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+292], 0

; 880  : 	m_isWaitLoginKey = FALSE;

  002c6	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+296], 0

; 881  : 	m_isStartGame = FALSE;

  002d0	c7 86 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+172], 0

; 882  : 	m_isEnableChatInsultFilter = FALSE;

  002da	66 c7 86 20 79
	00 00 00 00	 mov	 WORD PTR [esi+31008], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  002e3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 886  : 	__InitializeGamePhase();

  002e8	8b ce		 mov	 ecx, esi
  002ea	e8 00 00 00 00	 call	 ?__InitializeGamePhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__InitializeGamePhase

; 887  : 	__InitializeMarkAuth();

  002ef	8b ce		 mov	 ecx, esi
  002f1	e8 00 00 00 00	 call	 ?__InitializeMarkAuth@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__InitializeMarkAuth

; 888  : 
; 889  : 	__DirectEnterMode_Initialize();

  002f6	e8 00 00 00 00	 call	 ?__DirectEnterMode_Initialize@CPythonNetworkStream@@AAEXXZ ; CPythonNetworkStream::__DirectEnterMode_Initialize

; 890  : 	__BettingGuildWar_Initialize();

  002fb	e8 00 00 00 00	 call	 ?__BettingGuildWar_Initialize@CPythonNetworkStream@@AAEXXZ ; CPythonNetworkStream::__BettingGuildWar_Initialize

; 891  : 
; 892  : 	std::fill(m_apoPhaseWnd, m_apoPhaseWnd+PHASE_WINDOW_NUM, (PyObject*)NULL);

  00300	8d 86 7c 01 00
	00		 lea	 eax, DWORD PTR [esi+380]
  00306	8d 8e 98 01 00
	00		 lea	 ecx, DWORD PTR [esi+408]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

  0030c	3b c1		 cmp	 eax, ecx
  0030e	74 0d		 je	 SHORT $LN305@CPythonNet
$LL307@CPythonNet:

; 2600 : 		*_First = _Val;

  00310	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00316	83 c0 04	 add	 eax, 4
  00319	3b c1		 cmp	 eax, ecx
  0031b	75 f3		 jne	 SHORT $LL307@CPythonNet
$LN305@CPythonNet:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 893  : 	m_poSerCommandParserWnd = NULL;

  0031d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 894  : 
; 895  : 	SetOffLinePhase();

  00323	8b ce		 mov	 ecx, esi
  00325	e8 00 00 00 00	 call	 ?SetOffLinePhase@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::SetOffLinePhase

; 896  : }

  0032a	8b c6		 mov	 eax, esi
  0032c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0032f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00336	59		 pop	 ecx
  00337	5f		 pop	 edi
  00338	5e		 pop	 esi
  00339	5b		 pop	 ebx
  0033a	8b e5		 mov	 esp, ebp
  0033c	5d		 pop	 ebp
  0033d	c3		 ret	 0
$LN315@CPythonNet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CNetworkStream@@UAE@XZ ; CNetworkStream::~CNetworkStream
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0000e	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCPythonNetworkStream@@@@UAE@XZ ; CSingleton<CPythonNetworkStream>::~CSingleton<CPythonNetworkStream>
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 dc 00 00
	00		 add	 ecx, 220		; 000000dcH
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$4:
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c1 f4 00 00
	00		 add	 ecx, 244		; 000000f4H
  00038	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$5:
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00046	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$6:
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	81 c1 2c 01 00
	00		 add	 ecx, 300		; 0000012cH
  00054	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$7:
  00059	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	81 c1 48 01 00
	00		 add	 ecx, 328		; 00000148H
  00062	e9 00 00 00 00	 jmp	 ??1?$CFuncObject@VCPythonNetworkStream@@@@UAE@XZ ; CFuncObject<CPythonNetworkStream>::~CFuncObject<CPythonNetworkStream>
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$8:
  00067	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	81 c1 60 01 00
	00		 add	 ecx, 352		; 00000160H
  00070	e9 00 00 00 00	 jmp	 ??1?$CFuncObject@VCPythonNetworkStream@@@@UAE@XZ ; CFuncObject<CPythonNetworkStream>::~CFuncObject<CPythonNetworkStream>
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$9:
  00075	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0007a	6a 04		 push	 4
  0007c	6a 18		 push	 24			; 00000018H
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00081	05 a8 02 00 00	 add	 eax, 680		; 000002a8H
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0008c	c3		 ret	 0
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$10:
  0008d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	81 c1 0c 03 00
	00		 add	 ecx, 780		; 0000030cH
  00096	e9 00 00 00 00	 jmp	 ??1?$CRef@VCNetworkActorManager@@@@QAE@XZ ; CRef<CNetworkActorManager>::~CRef<CNetworkActorManager>
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$11:
  0009b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	81 c1 20 03 00
	00		 add	 ecx, 800		; 00000320H
  000a4	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$12:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	81 c1 f8 78 00
	00		 add	 ecx, 30968		; 000078f8H
  000b2	e9 00 00 00 00	 jmp	 ??1SMarkAuth@CPythonNetworkStream@@QAE@XZ
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$13:
  000b7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	81 c1 14 79 00
	00		 add	 ecx, 30996		; 00007914H
  000c0	e9 00 00 00 00	 jmp	 ??1CInsultChecker@@UAE@XZ ; CInsultChecker::~CInsultChecker
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$14:
  000c5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	81 c1 24 79 00
	00		 add	 ecx, 31012		; 00007924H
  000ce	e9 00 00 00 00	 jmp	 ??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??0CPythonNetworkStream@@QAE@XZ$15:
  000d3	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000dc	59		 pop	 ecx
  000dd	c3		 ret	 0
__ehhandler$??0CPythonNetworkStream@@QAE@XZ:
  000de	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000e2	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000e5	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  000e8	33 c8		 xor	 ecx, eax
  000ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ef	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CPythonNetworkStream@@QAE@XZ
  000f4	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CPythonNetworkStream@@QAE@XZ ENDP			; CPythonNetworkStream::CPythonNetworkStream
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
;	COMDAT ??0SPacketType@CNetworkPacketHeaderMap@@QAE@H_N@Z
_TEXT	SEGMENT
_iSize$ = 8						; size = 4
_bFlag$ = 12						; size = 1
??0SPacketType@CNetworkPacketHeaderMap@@QAE@H_N@Z PROC	; CNetworkPacketHeaderMap::SPacketType::SPacketType, COMDAT
; _this$ = ecx

; 10   : 			SPacketType(int iSize = 0, bool bFlag = false)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11   : 			{
; 12   : 				iPacketSize = iSize;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 13   : 				isDynamicSizePacket = bFlag;

  00008	8a 45 0c	 mov	 al, BYTE PTR _bFlag$[ebp]
  0000b	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 14   : 			}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0SPacketType@CNetworkPacketHeaderMap@@QAE@H_N@Z ENDP	; CNetworkPacketHeaderMap::SPacketType::SPacketType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.h
;	COMDAT ?__LeaveOfflinePhase@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__LeaveOfflinePhase@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::__LeaveOfflinePhase, COMDAT
; _this$ = ecx

; 589  : 		void __LeaveOfflinePhase() {}

  00000	c3		 ret	 0
?__LeaveOfflinePhase@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::__LeaveOfflinePhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ??0CMainPacketHeaderMap@@QAE@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 8
$T3 = -24						; size = 8
$T4 = -24						; size = 8
$T5 = -24						; size = 8
$T6 = -24						; size = 8
$T7 = -24						; size = 8
$T8 = -24						; size = 8
$T9 = -24						; size = 8
$T10 = -24						; size = 8
$T11 = -24						; size = 8
$T12 = -24						; size = 8
$T13 = -24						; size = 8
$T14 = -24						; size = 8
$T15 = -24						; size = 8
$T16 = -24						; size = 8
$T17 = -24						; size = 8
$T18 = -24						; size = 8
$T19 = -24						; size = 8
$T20 = -24						; size = 8
$T21 = -24						; size = 8
$T22 = -24						; size = 8
$T23 = -24						; size = 8
$T24 = -24						; size = 8
$T25 = -24						; size = 8
$T26 = -24						; size = 8
$T27 = -24						; size = 8
$T28 = -24						; size = 8
$T29 = -24						; size = 8
$T30 = -24						; size = 8
$T31 = -24						; size = 8
$T32 = -24						; size = 8
$T33 = -24						; size = 8
$T34 = -24						; size = 8
$T35 = -24						; size = 8
$T36 = -24						; size = 8
$T37 = -24						; size = 8
$T38 = -24						; size = 8
$T39 = -24						; size = 8
$T40 = -24						; size = 8
$T41 = -24						; size = 8
$T42 = -24						; size = 8
$T43 = -24						; size = 8
$T44 = -24						; size = 8
$T45 = -24						; size = 8
$T46 = -24						; size = 8
$T47 = -24						; size = 8
$T48 = -24						; size = 8
$T49 = -24						; size = 8
$T50 = -24						; size = 8
$T51 = -24						; size = 8
$T52 = -24						; size = 8
$T53 = -24						; size = 8
$T54 = -24						; size = 8
$T55 = -24						; size = 8
$T56 = -24						; size = 8
$T57 = -24						; size = 8
$T58 = -24						; size = 8
$T59 = -24						; size = 8
$T60 = -24						; size = 8
$T61 = -24						; size = 8
$T62 = -24						; size = 8
$T63 = -24						; size = 8
$T64 = -24						; size = 8
$T65 = -24						; size = 8
$T66 = -24						; size = 8
$T67 = -24						; size = 8
$T68 = -24						; size = 8
$T69 = -24						; size = 8
$T70 = -24						; size = 8
$T71 = -24						; size = 8
$T72 = -24						; size = 8
$T73 = -24						; size = 8
$T74 = -24						; size = 8
$T75 = -24						; size = 8
$T76 = -24						; size = 8
$T77 = -24						; size = 8
$T78 = -24						; size = 8
$T79 = -24						; size = 8
$T80 = -24						; size = 8
$T81 = -24						; size = 8
$T82 = -24						; size = 8
$T83 = -24						; size = 8
$T84 = -24						; size = 8
$T85 = -24						; size = 8
$T86 = -24						; size = 8
$T87 = -24						; size = 8
$T88 = -24						; size = 8
$T89 = -24						; size = 8
$T90 = -24						; size = 8
$T91 = -24						; size = 8
$T92 = -24						; size = 8
$T93 = -24						; size = 8
$T94 = -24						; size = 8
$T95 = -24						; size = 8
$T96 = -24						; size = 8
$T97 = -24						; size = 8
$T98 = -24						; size = 8
$T99 = -24						; size = 8
$T100 = -24						; size = 8
$T101 = -24						; size = 8
$T102 = -24						; size = 8
$T103 = -24						; size = 8
$T104 = -24						; size = 8
$T105 = -24						; size = 8
$T106 = -24						; size = 8
$T107 = -24						; size = 8
$T108 = -24						; size = 8
$T109 = -24						; size = 8
$T110 = -24						; size = 8
$T111 = -24						; size = 8
$T112 = -24						; size = 8
$T113 = -24						; size = 8
$T114 = -24						; size = 8
$T115 = -24						; size = 8
$T116 = -24						; size = 8
$T117 = -24						; size = 8
$T118 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CMainPacketHeaderMap@@QAE@XZ PROC			; CMainPacketHeaderMap::CMainPacketHeaderMap, COMDAT
; _this$dead$ = ecx

; 29   : 		CMainPacketHeaderMap()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CMainPacketHeaderMap@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  0002a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _this$[ebp], OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  00031	e8 00 00 00 00	 call	 ??0CNetworkPacketHeaderMap@@QAE@XZ ; CNetworkPacketHeaderMap::CNetworkPacketHeaderMap

; 31   : 			Set(HEADER_GC_EMPIRE,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCEmpire), STATIC_SIZE_PACKET));

  00036	8d 45 e8	 lea	 eax, DWORD PTR $T118[ebp]
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	50		 push	 eax
  00041	6a 5a		 push	 90			; 0000005aH
  00043	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  00048	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A, OFFSET ??_7CMainPacketHeaderMap@@6B@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00052	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T118[ebp], 2

; 13   : 				isDynamicSizePacket = bFlag;

  00059	c6 45 ec 00	 mov	 BYTE PTR $T118[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 31   : 			Set(HEADER_GC_EMPIRE,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCEmpire), STATIC_SIZE_PACKET));

  0005d	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 32   : 			Set(HEADER_GC_WARP,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCWarp), STATIC_SIZE_PACKET));

  00062	8d 45 e8	 lea	 eax, DWORD PTR $T117[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00065	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T117[ebp], 15 ; 0000000fH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 32   : 			Set(HEADER_GC_WARP,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCWarp), STATIC_SIZE_PACKET));

  0006c	50		 push	 eax
  0006d	6a 41		 push	 65			; 00000041H
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00074	c6 45 ec 00	 mov	 BYTE PTR $T117[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 32   : 			Set(HEADER_GC_WARP,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCWarp), STATIC_SIZE_PACKET));

  00078	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 33   : 			Set(HEADER_GC_SKILL_COOLTIME_END,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSkillCoolTimeEnd), STATIC_SIZE_PACKET));

  0007d	8d 45 e8	 lea	 eax, DWORD PTR $T116[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00080	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T116[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 33   : 			Set(HEADER_GC_SKILL_COOLTIME_END,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSkillCoolTimeEnd), STATIC_SIZE_PACKET));

  00087	50		 push	 eax
  00088	6a 49		 push	 73			; 00000049H
  0008a	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0008f	c6 45 ec 00	 mov	 BYTE PTR $T116[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 33   : 			Set(HEADER_GC_SKILL_COOLTIME_END,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSkillCoolTimeEnd), STATIC_SIZE_PACKET));

  00093	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 34   : 			Set(HEADER_GC_QUEST_INFO,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuestInfo), DYNAMIC_SIZE_PACKET));

  00098	8d 45 e8	 lea	 eax, DWORD PTR $T115[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0009b	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR $T115[ebp], 6
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 34   : 			Set(HEADER_GC_QUEST_INFO,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuestInfo), DYNAMIC_SIZE_PACKET));

  000a2	50		 push	 eax
  000a3	6a 51		 push	 81			; 00000051H
  000a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  000aa	c6 45 ec 01	 mov	 BYTE PTR $T115[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 34   : 			Set(HEADER_GC_QUEST_INFO,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuestInfo), DYNAMIC_SIZE_PACKET));

  000ae	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 35   : 			Set(HEADER_GC_REQUEST_MAKE_GUILD,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBlank), STATIC_SIZE_PACKET));

  000b3	8d 45 e8	 lea	 eax, DWORD PTR $T114[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  000b6	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T114[ebp], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 35   : 			Set(HEADER_GC_REQUEST_MAKE_GUILD,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBlank), STATIC_SIZE_PACKET));

  000bd	50		 push	 eax
  000be	6a 52		 push	 82			; 00000052H
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  000c5	c6 45 ec 00	 mov	 BYTE PTR $T114[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 35   : 			Set(HEADER_GC_REQUEST_MAKE_GUILD,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBlank), STATIC_SIZE_PACKET));

  000c9	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 36   : 			Set(HEADER_GC_PVP,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPVP), STATIC_SIZE_PACKET));

  000ce	8d 45 e8	 lea	 eax, DWORD PTR $T113[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  000d1	c7 45 e8 0a 00
	00 00		 mov	 DWORD PTR $T113[ebp], 10 ; 0000000aH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 36   : 			Set(HEADER_GC_PVP,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPVP), STATIC_SIZE_PACKET));

  000d8	50		 push	 eax
  000d9	6a 29		 push	 41			; 00000029H
  000db	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  000e0	c6 45 ec 00	 mov	 BYTE PTR $T113[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 36   : 			Set(HEADER_GC_PVP,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPVP), STATIC_SIZE_PACKET));

  000e4	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 37   : 			Set(HEADER_GC_DUEL_START,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDuelStart), DYNAMIC_SIZE_PACKET));

  000e9	8d 45 e8	 lea	 eax, DWORD PTR $T112[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  000ec	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR $T112[ebp], 3
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 37   : 			Set(HEADER_GC_DUEL_START,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDuelStart), DYNAMIC_SIZE_PACKET));

  000f3	50		 push	 eax
  000f4	6a 28		 push	 40			; 00000028H
  000f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  000fb	c6 45 ec 01	 mov	 BYTE PTR $T112[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 37   : 			Set(HEADER_GC_DUEL_START,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDuelStart), DYNAMIC_SIZE_PACKET));

  000ff	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 38   : 			Set(HEADER_GC_CHARACTER_ADD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterAdd), STATIC_SIZE_PACKET));

  00104	8d 45 e8	 lea	 eax, DWORD PTR $T111[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00107	c7 45 e8 23 00
	00 00		 mov	 DWORD PTR $T111[ebp], 35 ; 00000023H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 38   : 			Set(HEADER_GC_CHARACTER_ADD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterAdd), STATIC_SIZE_PACKET));

  0010e	50		 push	 eax
  0010f	6a 01		 push	 1
  00111	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00116	c6 45 ec 00	 mov	 BYTE PTR $T111[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 38   : 			Set(HEADER_GC_CHARACTER_ADD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterAdd), STATIC_SIZE_PACKET));

  0011a	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 39   : 			Set(HEADER_GC_CHAR_ADDITIONAL_INFO,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterAdditionalInfo), STATIC_SIZE_PACKET));

  0011f	8d 45 e8	 lea	 eax, DWORD PTR $T110[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00122	c7 45 e8 36 00
	00 00		 mov	 DWORD PTR $T110[ebp], 54 ; 00000036H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 39   : 			Set(HEADER_GC_CHAR_ADDITIONAL_INFO,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterAdditionalInfo), STATIC_SIZE_PACKET));

  00129	50		 push	 eax
  0012a	68 88 00 00 00	 push	 136			; 00000088H
  0012f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00134	c6 45 ec 00	 mov	 BYTE PTR $T110[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 39   : 			Set(HEADER_GC_CHAR_ADDITIONAL_INFO,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterAdditionalInfo), STATIC_SIZE_PACKET));

  00138	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 40   : 			Set(HEADER_GC_CHARACTER_ADD2,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterAdd2), STATIC_SIZE_PACKET));

  0013d	8d 45 e8	 lea	 eax, DWORD PTR $T109[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00140	c7 45 e8 50 00
	00 00		 mov	 DWORD PTR $T109[ebp], 80 ; 00000050H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 40   : 			Set(HEADER_GC_CHARACTER_ADD2,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterAdd2), STATIC_SIZE_PACKET));

  00147	50		 push	 eax
  00148	6a 78		 push	 120			; 00000078H
  0014a	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0014f	c6 45 ec 00	 mov	 BYTE PTR $T109[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 40   : 			Set(HEADER_GC_CHARACTER_ADD2,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterAdd2), STATIC_SIZE_PACKET));

  00153	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 41   : 			Set(HEADER_GC_CHARACTER_UPDATE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterUpdate), STATIC_SIZE_PACKET));

  00158	8d 45 e8	 lea	 eax, DWORD PTR $T108[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0015b	c7 45 e8 23 00
	00 00		 mov	 DWORD PTR $T108[ebp], 35 ; 00000023H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 41   : 			Set(HEADER_GC_CHARACTER_UPDATE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterUpdate), STATIC_SIZE_PACKET));

  00162	50		 push	 eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00163	c6 45 ec 00	 mov	 BYTE PTR $T108[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 41   : 			Set(HEADER_GC_CHARACTER_UPDATE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterUpdate), STATIC_SIZE_PACKET));

  00167	6a 13		 push	 19			; 00000013H
  00169	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  0016e	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 42   : 			Set(HEADER_GC_CHARACTER_UPDATE2,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterUpdate2), STATIC_SIZE_PACKET));

  00173	8d 45 e8	 lea	 eax, DWORD PTR $T107[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00176	c7 45 e8 23 00
	00 00		 mov	 DWORD PTR $T107[ebp], 35 ; 00000023H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 42   : 			Set(HEADER_GC_CHARACTER_UPDATE2,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterUpdate2), STATIC_SIZE_PACKET));

  0017d	50		 push	 eax
  0017e	6a 75		 push	 117			; 00000075H
  00180	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00185	c6 45 ec 00	 mov	 BYTE PTR $T107[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 42   : 			Set(HEADER_GC_CHARACTER_UPDATE2,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterUpdate2), STATIC_SIZE_PACKET));

  00189	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 43   : 			Set(HEADER_GC_CHARACTER_DEL,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterDelete), STATIC_SIZE_PACKET));

  0018e	8d 45 e8	 lea	 eax, DWORD PTR $T106[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00191	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T106[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 43   : 			Set(HEADER_GC_CHARACTER_DEL,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterDelete), STATIC_SIZE_PACKET));

  00198	50		 push	 eax
  00199	6a 02		 push	 2
  0019b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  001a0	c6 45 ec 00	 mov	 BYTE PTR $T106[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 43   : 			Set(HEADER_GC_CHARACTER_DEL,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCharacterDelete), STATIC_SIZE_PACKET));

  001a4	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 44   : 			Set(HEADER_GC_CHARACTER_MOVE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMove), STATIC_SIZE_PACKET));

  001a9	8d 45 e8	 lea	 eax, DWORD PTR $T105[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  001ac	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR $T105[ebp], 24 ; 00000018H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 44   : 			Set(HEADER_GC_CHARACTER_MOVE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMove), STATIC_SIZE_PACKET));

  001b3	50		 push	 eax
  001b4	6a 03		 push	 3
  001b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  001bb	c6 45 ec 00	 mov	 BYTE PTR $T105[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 44   : 			Set(HEADER_GC_CHARACTER_MOVE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMove), STATIC_SIZE_PACKET));

  001bf	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 45   : 			Set(HEADER_GC_CHAT,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChat), DYNAMIC_SIZE_PACKET));

  001c4	8d 45 e8	 lea	 eax, DWORD PTR $T104[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  001c7	c7 45 e8 09 00
	00 00		 mov	 DWORD PTR $T104[ebp], 9
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 45   : 			Set(HEADER_GC_CHAT,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChat), DYNAMIC_SIZE_PACKET));

  001ce	50		 push	 eax
  001cf	6a 04		 push	 4
  001d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  001d6	c6 45 ec 01	 mov	 BYTE PTR $T104[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 45   : 			Set(HEADER_GC_CHAT,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChat), DYNAMIC_SIZE_PACKET));

  001da	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 47   : 			Set(HEADER_GC_SYNC_POSITION,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCC2C), DYNAMIC_SIZE_PACKET));

  001df	8d 45 e8	 lea	 eax, DWORD PTR $T103[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  001e2	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR $T103[ebp], 3
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 47   : 			Set(HEADER_GC_SYNC_POSITION,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCC2C), DYNAMIC_SIZE_PACKET));

  001e9	50		 push	 eax
  001ea	6a 05		 push	 5
  001ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  001f1	c6 45 ec 01	 mov	 BYTE PTR $T103[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 47   : 			Set(HEADER_GC_SYNC_POSITION,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCC2C), DYNAMIC_SIZE_PACKET));

  001f5	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 49   : 			Set(HEADER_GC_LOGIN_SUCCESS3,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginSuccess3), STATIC_SIZE_PACKET));

  001fa	8d 45 e8	 lea	 eax, DWORD PTR $T102[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  001fd	c7 45 e8 f9 00
	00 00		 mov	 DWORD PTR $T102[ebp], 249 ; 000000f9H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 49   : 			Set(HEADER_GC_LOGIN_SUCCESS3,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginSuccess3), STATIC_SIZE_PACKET));

  00204	50		 push	 eax
  00205	6a 06		 push	 6
  00207	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0020c	c6 45 ec 00	 mov	 BYTE PTR $T102[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 49   : 			Set(HEADER_GC_LOGIN_SUCCESS3,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginSuccess3), STATIC_SIZE_PACKET));

  00210	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 50   : 			Set(HEADER_GC_LOGIN_SUCCESS4,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginSuccess4), STATIC_SIZE_PACKET));

  00215	8d 45 e8	 lea	 eax, DWORD PTR $T101[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00218	c7 45 e8 49 01
	00 00		 mov	 DWORD PTR $T101[ebp], 329 ; 00000149H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 50   : 			Set(HEADER_GC_LOGIN_SUCCESS4,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginSuccess4), STATIC_SIZE_PACKET));

  0021f	50		 push	 eax
  00220	6a 20		 push	 32			; 00000020H
  00222	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00227	c6 45 ec 00	 mov	 BYTE PTR $T101[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 50   : 			Set(HEADER_GC_LOGIN_SUCCESS4,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginSuccess4), STATIC_SIZE_PACKET));

  0022b	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 51   : 			Set(HEADER_GC_LOGIN_FAILURE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginFailure), STATIC_SIZE_PACKET));

  00230	8d 45 e8	 lea	 eax, DWORD PTR $T100[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00233	c7 45 e8 0a 00
	00 00		 mov	 DWORD PTR $T100[ebp], 10 ; 0000000aH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 51   : 			Set(HEADER_GC_LOGIN_FAILURE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginFailure), STATIC_SIZE_PACKET));

  0023a	50		 push	 eax
  0023b	6a 07		 push	 7
  0023d	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00242	c6 45 ec 00	 mov	 BYTE PTR $T100[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 51   : 			Set(HEADER_GC_LOGIN_FAILURE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginFailure), STATIC_SIZE_PACKET));

  00246	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 53   : 			Set(HEADER_GC_PLAYER_CREATE_SUCCESS,		 CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPlayerCreateSuccess), STATIC_SIZE_PACKET));

  0024b	8d 45 e8	 lea	 eax, DWORD PTR $T99[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0024e	c7 45 e8 41 00
	00 00		 mov	 DWORD PTR $T99[ebp], 65	; 00000041H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 53   : 			Set(HEADER_GC_PLAYER_CREATE_SUCCESS,		 CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPlayerCreateSuccess), STATIC_SIZE_PACKET));

  00255	50		 push	 eax
  00256	6a 08		 push	 8
  00258	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0025d	c6 45 ec 00	 mov	 BYTE PTR $T99[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 53   : 			Set(HEADER_GC_PLAYER_CREATE_SUCCESS,		 CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPlayerCreateSuccess), STATIC_SIZE_PACKET));

  00261	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 54   : 			Set(HEADER_GC_PLAYER_CREATE_FAILURE,		 CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCreateFailure), STATIC_SIZE_PACKET));

  00266	8d 45 e8	 lea	 eax, DWORD PTR $T98[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00269	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T98[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 54   : 			Set(HEADER_GC_PLAYER_CREATE_FAILURE,		 CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCreateFailure), STATIC_SIZE_PACKET));

  00270	50		 push	 eax
  00271	6a 09		 push	 9
  00273	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00278	c6 45 ec 00	 mov	 BYTE PTR $T98[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 54   : 			Set(HEADER_GC_PLAYER_CREATE_FAILURE,		 CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCreateFailure), STATIC_SIZE_PACKET));

  0027c	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 55   : 			Set(HEADER_GC_PLAYER_DELETE_SUCCESS,		 CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBlank), STATIC_SIZE_PACKET));

  00281	8d 45 e8	 lea	 eax, DWORD PTR $T97[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00284	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T97[ebp], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 55   : 			Set(HEADER_GC_PLAYER_DELETE_SUCCESS,		 CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBlank), STATIC_SIZE_PACKET));

  0028b	50		 push	 eax
  0028c	6a 0a		 push	 10			; 0000000aH
  0028e	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00293	c6 45 ec 00	 mov	 BYTE PTR $T97[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 55   : 			Set(HEADER_GC_PLAYER_DELETE_SUCCESS,		 CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBlank), STATIC_SIZE_PACKET));

  00297	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0029c	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T96[ebp], 1

; 13   : 				isDynamicSizePacket = bFlag;

  002a3	c6 45 ec 00	 mov	 BYTE PTR $T96[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 56   : 			Set(HEADER_GC_PLAYER_DELETE_WRONG_SOCIAL_ID, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBlank), STATIC_SIZE_PACKET));

  002a7	8d 45 e8	 lea	 eax, DWORD PTR $T96[ebp]
  002aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  002af	50		 push	 eax
  002b0	6a 0b		 push	 11			; 0000000bH
  002b2	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 58   : 			Set(HEADER_GC_STUN,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCStun), STATIC_SIZE_PACKET));

  002b7	8d 45 e8	 lea	 eax, DWORD PTR $T95[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  002ba	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T95[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 58   : 			Set(HEADER_GC_STUN,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCStun), STATIC_SIZE_PACKET));

  002c1	50		 push	 eax
  002c2	6a 0d		 push	 13			; 0000000dH
  002c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  002c9	c6 45 ec 00	 mov	 BYTE PTR $T95[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 58   : 			Set(HEADER_GC_STUN,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCStun), STATIC_SIZE_PACKET));

  002cd	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 59   : 			Set(HEADER_GC_DEAD,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDead), STATIC_SIZE_PACKET));

  002d2	8d 45 e8	 lea	 eax, DWORD PTR $T94[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  002d5	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T94[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 59   : 			Set(HEADER_GC_DEAD,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDead), STATIC_SIZE_PACKET));

  002dc	50		 push	 eax
  002dd	6a 0e		 push	 14			; 0000000eH
  002df	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  002e4	c6 45 ec 00	 mov	 BYTE PTR $T94[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 59   : 			Set(HEADER_GC_DEAD,					CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDead), STATIC_SIZE_PACKET));

  002e8	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 61   : 			Set(HEADER_GC_MAIN_CHARACTER,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter), STATIC_SIZE_PACKET));

  002ed	8d 45 e8	 lea	 eax, DWORD PTR $T93[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  002f0	c7 45 e8 2d 00
	00 00		 mov	 DWORD PTR $T93[ebp], 45	; 0000002dH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 61   : 			Set(HEADER_GC_MAIN_CHARACTER,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter), STATIC_SIZE_PACKET));

  002f7	50		 push	 eax
  002f8	6a 0f		 push	 15			; 0000000fH
  002fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  002ff	c6 45 ec 00	 mov	 BYTE PTR $T93[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 61   : 			Set(HEADER_GC_MAIN_CHARACTER,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter), STATIC_SIZE_PACKET));

  00303	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 64   : 			Set(HEADER_GC_MAIN_CHARACTER2_EMPIRE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter2_EMPIRE), STATIC_SIZE_PACKET));

  00308	8d 45 e8	 lea	 eax, DWORD PTR $T92[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0030b	c7 45 e8 2e 00
	00 00		 mov	 DWORD PTR $T92[ebp], 46	; 0000002eH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 64   : 			Set(HEADER_GC_MAIN_CHARACTER2_EMPIRE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter2_EMPIRE), STATIC_SIZE_PACKET));

  00312	50		 push	 eax
  00313	6a 71		 push	 113			; 00000071H
  00315	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0031a	c6 45 ec 00	 mov	 BYTE PTR $T92[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 64   : 			Set(HEADER_GC_MAIN_CHARACTER2_EMPIRE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter2_EMPIRE), STATIC_SIZE_PACKET));

  0031e	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 65   : 			Set(HEADER_GC_MAIN_CHARACTER3_BGM,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter3_BGM), STATIC_SIZE_PACKET));

  00323	8d 45 e8	 lea	 eax, DWORD PTR $T91[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00326	c7 45 e8 47 00
	00 00		 mov	 DWORD PTR $T91[ebp], 71	; 00000047H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 65   : 			Set(HEADER_GC_MAIN_CHARACTER3_BGM,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter3_BGM), STATIC_SIZE_PACKET));

  0032d	50		 push	 eax
  0032e	68 89 00 00 00	 push	 137			; 00000089H
  00333	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00338	c6 45 ec 00	 mov	 BYTE PTR $T91[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 65   : 			Set(HEADER_GC_MAIN_CHARACTER3_BGM,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter3_BGM), STATIC_SIZE_PACKET));

  0033c	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 66   : 			Set(HEADER_GC_MAIN_CHARACTER4_BGM_VOL,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter4_BGM_VOL), STATIC_SIZE_PACKET));

  00341	8d 45 e8	 lea	 eax, DWORD PTR $T90[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00344	c7 45 e8 4b 00
	00 00		 mov	 DWORD PTR $T90[ebp], 75	; 0000004bH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 66   : 			Set(HEADER_GC_MAIN_CHARACTER4_BGM_VOL,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter4_BGM_VOL), STATIC_SIZE_PACKET));

  0034b	50		 push	 eax
  0034c	68 8a 00 00 00	 push	 138			; 0000008aH
  00351	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00356	c6 45 ec 00	 mov	 BYTE PTR $T90[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 66   : 			Set(HEADER_GC_MAIN_CHARACTER4_BGM_VOL,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMainCharacter4_BGM_VOL), STATIC_SIZE_PACKET));

  0035a	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 69   : 			Set(HEADER_GC_PLAYER_POINTS,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPoints), STATIC_SIZE_PACKET));

  0035f	8d 45 e8	 lea	 eax, DWORD PTR $T89[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00362	c7 45 e8 fd 03
	00 00		 mov	 DWORD PTR $T89[ebp], 1021 ; 000003fdH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 69   : 			Set(HEADER_GC_PLAYER_POINTS,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPoints), STATIC_SIZE_PACKET));

  00369	50		 push	 eax
  0036a	6a 10		 push	 16			; 00000010H
  0036c	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00371	c6 45 ec 00	 mov	 BYTE PTR $T89[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 69   : 			Set(HEADER_GC_PLAYER_POINTS,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPoints), STATIC_SIZE_PACKET));

  00375	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 70   : 			Set(HEADER_GC_PLAYER_POINT_CHANGE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPointChange), STATIC_SIZE_PACKET));

  0037a	8d 45 e8	 lea	 eax, DWORD PTR $T88[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0037d	c7 45 e8 11 00
	00 00		 mov	 DWORD PTR $T88[ebp], 17	; 00000011H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 70   : 			Set(HEADER_GC_PLAYER_POINT_CHANGE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPointChange), STATIC_SIZE_PACKET));

  00384	50		 push	 eax
  00385	6a 11		 push	 17			; 00000011H
  00387	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0038c	c6 45 ec 00	 mov	 BYTE PTR $T88[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 70   : 			Set(HEADER_GC_PLAYER_POINT_CHANGE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPointChange), STATIC_SIZE_PACKET));

  00390	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 72   : 			Set(HEADER_GC_ITEM_SET,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet), STATIC_SIZE_PACKET));

  00395	8d 45 e8	 lea	 eax, DWORD PTR $T87[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00398	c7 45 e8 2a 00
	00 00		 mov	 DWORD PTR $T87[ebp], 42	; 0000002aH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 72   : 			Set(HEADER_GC_ITEM_SET,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet), STATIC_SIZE_PACKET));

  0039f	50		 push	 eax
  003a0	6a 14		 push	 20			; 00000014H
  003a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  003a7	c6 45 ec 00	 mov	 BYTE PTR $T87[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 72   : 			Set(HEADER_GC_ITEM_SET,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet), STATIC_SIZE_PACKET));

  003ab	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 73   : 			Set(HEADER_GC_ITEM_SET2,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet2), STATIC_SIZE_PACKET));

  003b0	8d 45 e8	 lea	 eax, DWORD PTR $T86[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  003b3	c7 45 e8 33 00
	00 00		 mov	 DWORD PTR $T86[ebp], 51	; 00000033H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 73   : 			Set(HEADER_GC_ITEM_SET2,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet2), STATIC_SIZE_PACKET));

  003ba	50		 push	 eax
  003bb	6a 15		 push	 21			; 00000015H
  003bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  003c2	c6 45 ec 00	 mov	 BYTE PTR $T86[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 73   : 			Set(HEADER_GC_ITEM_SET2,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet2), STATIC_SIZE_PACKET));

  003c6	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 75   : 			Set(HEADER_GC_ITEM_USE,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemUse), STATIC_SIZE_PACKET));

  003cb	8d 45 e8	 lea	 eax, DWORD PTR $T85[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  003ce	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR $T85[ebp], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 75   : 			Set(HEADER_GC_ITEM_USE,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemUse), STATIC_SIZE_PACKET));

  003d5	50		 push	 eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  003d6	c6 45 ec 00	 mov	 BYTE PTR $T85[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 75   : 			Set(HEADER_GC_ITEM_USE,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemUse), STATIC_SIZE_PACKET));

  003da	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  003df	6a 16		 push	 22			; 00000016H
  003e1	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 76   : 			Set(HEADER_GC_ITEM_UPDATE,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemUpdate), STATIC_SIZE_PACKET));

  003e6	8d 45 e8	 lea	 eax, DWORD PTR $T84[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  003e9	c7 45 e8 26 00
	00 00		 mov	 DWORD PTR $T84[ebp], 38	; 00000026H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 76   : 			Set(HEADER_GC_ITEM_UPDATE,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemUpdate), STATIC_SIZE_PACKET));

  003f0	50		 push	 eax
  003f1	6a 19		 push	 25			; 00000019H
  003f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  003f8	c6 45 ec 00	 mov	 BYTE PTR $T84[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 76   : 			Set(HEADER_GC_ITEM_UPDATE,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemUpdate), STATIC_SIZE_PACKET));

  003fc	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 78   : 			Set(HEADER_GC_ITEM_GROUND_ADD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemGroundAdd), STATIC_SIZE_PACKET));

  00401	8d 45 e8	 lea	 eax, DWORD PTR $T83[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00404	c7 45 e8 15 00
	00 00		 mov	 DWORD PTR $T83[ebp], 21	; 00000015H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 78   : 			Set(HEADER_GC_ITEM_GROUND_ADD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemGroundAdd), STATIC_SIZE_PACKET));

  0040b	50		 push	 eax
  0040c	6a 1a		 push	 26			; 0000001aH
  0040e	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00413	c6 45 ec 00	 mov	 BYTE PTR $T83[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 78   : 			Set(HEADER_GC_ITEM_GROUND_ADD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemGroundAdd), STATIC_SIZE_PACKET));

  00417	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 79   : 			Set(HEADER_GC_ITEM_GROUND_DEL,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemGroundDel), STATIC_SIZE_PACKET));

  0041c	8d 45 e8	 lea	 eax, DWORD PTR $T82[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0041f	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T82[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 79   : 			Set(HEADER_GC_ITEM_GROUND_DEL,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemGroundDel), STATIC_SIZE_PACKET));

  00426	50		 push	 eax
  00427	6a 1b		 push	 27			; 0000001bH
  00429	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0042e	c6 45 ec 00	 mov	 BYTE PTR $T82[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 79   : 			Set(HEADER_GC_ITEM_GROUND_DEL,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemGroundDel), STATIC_SIZE_PACKET));

  00432	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 80   : 			Set(HEADER_GC_ITEM_OWNERSHIP,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemOwnership), STATIC_SIZE_PACKET));

  00437	8d 45 e8	 lea	 eax, DWORD PTR $T81[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0043a	c7 45 e8 1e 00
	00 00		 mov	 DWORD PTR $T81[ebp], 30	; 0000001eH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 80   : 			Set(HEADER_GC_ITEM_OWNERSHIP,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemOwnership), STATIC_SIZE_PACKET));

  00441	50		 push	 eax
  00442	6a 1f		 push	 31			; 0000001fH
  00444	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00449	c6 45 ec 00	 mov	 BYTE PTR $T81[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 80   : 			Set(HEADER_GC_ITEM_OWNERSHIP,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemOwnership), STATIC_SIZE_PACKET));

  0044d	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 82   : 			Set(HEADER_GC_QUICKSLOT_ADD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuickSlotAdd), STATIC_SIZE_PACKET));

  00452	8d 45 e8	 lea	 eax, DWORD PTR $T80[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00455	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR $T80[ebp], 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 82   : 			Set(HEADER_GC_QUICKSLOT_ADD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuickSlotAdd), STATIC_SIZE_PACKET));

  0045c	50		 push	 eax
  0045d	6a 1c		 push	 28			; 0000001cH
  0045f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00464	c6 45 ec 00	 mov	 BYTE PTR $T80[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 82   : 			Set(HEADER_GC_QUICKSLOT_ADD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuickSlotAdd), STATIC_SIZE_PACKET));

  00468	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 83   : 			Set(HEADER_GC_QUICKSLOT_DEL,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuickSlotDel), STATIC_SIZE_PACKET));

  0046d	8d 45 e8	 lea	 eax, DWORD PTR $T79[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00470	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T79[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 83   : 			Set(HEADER_GC_QUICKSLOT_DEL,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuickSlotDel), STATIC_SIZE_PACKET));

  00477	50		 push	 eax
  00478	6a 1d		 push	 29			; 0000001dH
  0047a	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0047f	c6 45 ec 00	 mov	 BYTE PTR $T79[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 83   : 			Set(HEADER_GC_QUICKSLOT_DEL,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuickSlotDel), STATIC_SIZE_PACKET));

  00483	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 84   : 			Set(HEADER_GC_QUICKSLOT_SWAP,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuickSlotSwap), STATIC_SIZE_PACKET));

  00488	8d 45 e8	 lea	 eax, DWORD PTR $T78[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0048b	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR $T78[ebp], 3
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 84   : 			Set(HEADER_GC_QUICKSLOT_SWAP,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuickSlotSwap), STATIC_SIZE_PACKET));

  00492	50		 push	 eax
  00493	6a 1e		 push	 30			; 0000001eH
  00495	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0049a	c6 45 ec 00	 mov	 BYTE PTR $T78[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 84   : 			Set(HEADER_GC_QUICKSLOT_SWAP,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuickSlotSwap), STATIC_SIZE_PACKET));

  0049e	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 86   : 			Set(HEADER_GC_WHISPER,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCWhisper), STATIC_SIZE_PACKET));

  004a3	8d 45 e8	 lea	 eax, DWORD PTR $T77[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  004a6	c7 45 e8 1d 00
	00 00		 mov	 DWORD PTR $T77[ebp], 29	; 0000001dH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 86   : 			Set(HEADER_GC_WHISPER,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCWhisper), STATIC_SIZE_PACKET));

  004ad	50		 push	 eax
  004ae	6a 22		 push	 34			; 00000022H
  004b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  004b5	c6 45 ec 00	 mov	 BYTE PTR $T77[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 86   : 			Set(HEADER_GC_WHISPER,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCWhisper), STATIC_SIZE_PACKET));

  004b9	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 88   : 			Set(HEADER_GC_CHARACTER_POSITION,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPosition), STATIC_SIZE_PACKET));

  004be	8d 45 e8	 lea	 eax, DWORD PTR $T76[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  004c1	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR $T76[ebp], 6
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 88   : 			Set(HEADER_GC_CHARACTER_POSITION,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPosition), STATIC_SIZE_PACKET));

  004c8	50		 push	 eax
  004c9	6a 2b		 push	 43			; 0000002bH
  004cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  004d0	c6 45 ec 00	 mov	 BYTE PTR $T76[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 88   : 			Set(HEADER_GC_CHARACTER_POSITION,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPosition), STATIC_SIZE_PACKET));

  004d4	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 89   : 			Set(HEADER_GC_MOTION,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMotion), STATIC_SIZE_PACKET));

  004d9	8d 45 e8	 lea	 eax, DWORD PTR $T75[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  004dc	c7 45 e8 0b 00
	00 00		 mov	 DWORD PTR $T75[ebp], 11	; 0000000bH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 89   : 			Set(HEADER_GC_MOTION,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMotion), STATIC_SIZE_PACKET));

  004e3	50		 push	 eax
  004e4	6a 24		 push	 36			; 00000024H
  004e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  004eb	c6 45 ec 00	 mov	 BYTE PTR $T75[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 89   : 			Set(HEADER_GC_MOTION,				CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMotion), STATIC_SIZE_PACKET));

  004ef	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 91   : 			Set(HEADER_GC_SHOP,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCShop), DYNAMIC_SIZE_PACKET));

  004f4	8d 45 e8	 lea	 eax, DWORD PTR $T74[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  004f7	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR $T74[ebp], 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 91   : 			Set(HEADER_GC_SHOP,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCShop), DYNAMIC_SIZE_PACKET));

  004fe	50		 push	 eax
  004ff	6a 26		 push	 38			; 00000026H
  00501	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00506	c6 45 ec 01	 mov	 BYTE PTR $T74[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 91   : 			Set(HEADER_GC_SHOP,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCShop), DYNAMIC_SIZE_PACKET));

  0050a	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0050f	c7 45 e8 26 00
	00 00		 mov	 DWORD PTR $T73[ebp], 38	; 00000026H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 92   : 			Set(HEADER_GC_SHOP_SIGN,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCShopSign), STATIC_SIZE_PACKET));

  00516	8d 45 e8	 lea	 eax, DWORD PTR $T73[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00519	c6 45 ec 00	 mov	 BYTE PTR $T73[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 92   : 			Set(HEADER_GC_SHOP_SIGN,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCShopSign), STATIC_SIZE_PACKET));

  0051d	50		 push	 eax
  0051e	6a 27		 push	 39			; 00000027H
  00520	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  00525	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 93   : 			Set(HEADER_GC_EXCHANGE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCExchange), STATIC_SIZE_PACKET));

  0052a	8d 45 e8	 lea	 eax, DWORD PTR $T72[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0052d	c7 45 e8 2f 00
	00 00		 mov	 DWORD PTR $T72[ebp], 47	; 0000002fH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 93   : 			Set(HEADER_GC_EXCHANGE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCExchange), STATIC_SIZE_PACKET));

  00534	50		 push	 eax
  00535	6a 2a		 push	 42			; 0000002aH
  00537	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0053c	c6 45 ec 00	 mov	 BYTE PTR $T72[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 93   : 			Set(HEADER_GC_EXCHANGE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCExchange), STATIC_SIZE_PACKET));

  00540	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 95   : 			Set(HEADER_GC_PING,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPing), STATIC_SIZE_PACKET));

  00545	8d 45 e8	 lea	 eax, DWORD PTR $T71[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00548	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T71[ebp], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 95   : 			Set(HEADER_GC_PING,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPing), STATIC_SIZE_PACKET));

  0054f	50		 push	 eax
  00550	6a 2c		 push	 44			; 0000002cH
  00552	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00557	c6 45 ec 00	 mov	 BYTE PTR $T71[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 95   : 			Set(HEADER_GC_PING,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPing), STATIC_SIZE_PACKET));

  0055b	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 97   : 			Set(HEADER_GC_SCRIPT,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCScript), DYNAMIC_SIZE_PACKET));

  00560	8d 45 e8	 lea	 eax, DWORD PTR $T70[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00563	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR $T70[ebp], 6
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 97   : 			Set(HEADER_GC_SCRIPT,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCScript), DYNAMIC_SIZE_PACKET));

  0056a	50		 push	 eax
  0056b	6a 2d		 push	 45			; 0000002dH
  0056d	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00572	c6 45 ec 01	 mov	 BYTE PTR $T70[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 97   : 			Set(HEADER_GC_SCRIPT,			CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCScript), DYNAMIC_SIZE_PACKET));

  00576	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 98   : 			Set(HEADER_GC_QUEST_CONFIRM,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuestConfirm), STATIC_SIZE_PACKET));

  0057b	8d 45 e8	 lea	 eax, DWORD PTR $T69[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0057e	c7 45 e8 4a 00
	00 00		 mov	 DWORD PTR $T69[ebp], 74	; 0000004aH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 98   : 			Set(HEADER_GC_QUEST_CONFIRM,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuestConfirm), STATIC_SIZE_PACKET));

  00585	50		 push	 eax
  00586	6a 2e		 push	 46			; 0000002eH
  00588	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0058d	c6 45 ec 00	 mov	 BYTE PTR $T69[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 98   : 			Set(HEADER_GC_QUEST_CONFIRM,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCQuestConfirm), STATIC_SIZE_PACKET));

  00591	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 100  : 			Set(HEADER_GC_TARGET,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTarget), STATIC_SIZE_PACKET));

  00596	8d 45 e8	 lea	 eax, DWORD PTR $T68[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00599	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR $T68[ebp], 6
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 100  : 			Set(HEADER_GC_TARGET,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTarget), STATIC_SIZE_PACKET));

  005a0	50		 push	 eax
  005a1	6a 3f		 push	 63			; 0000003fH
  005a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  005a8	c6 45 ec 00	 mov	 BYTE PTR $T68[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 100  : 			Set(HEADER_GC_TARGET,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTarget), STATIC_SIZE_PACKET));

  005ac	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 101  : 			Set(HEADER_GC_MOUNT,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMount), STATIC_SIZE_PACKET));

  005b1	8d 45 e8	 lea	 eax, DWORD PTR $T67[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  005b4	c7 45 e8 12 00
	00 00		 mov	 DWORD PTR $T67[ebp], 18	; 00000012H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 101  : 			Set(HEADER_GC_MOUNT,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMount), STATIC_SIZE_PACKET));

  005bb	50		 push	 eax
  005bc	6a 3d		 push	 61			; 0000003dH
  005be	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  005c3	c6 45 ec 00	 mov	 BYTE PTR $T67[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 101  : 			Set(HEADER_GC_MOUNT,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMount), STATIC_SIZE_PACKET));

  005c7	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 103  : 			Set(HEADER_GC_CHANGE_SPEED,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChangeSpeed), STATIC_SIZE_PACKET));

  005cc	8d 45 e8	 lea	 eax, DWORD PTR $T66[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  005cf	c7 45 e8 07 00
	00 00		 mov	 DWORD PTR $T66[ebp], 7
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 103  : 			Set(HEADER_GC_CHANGE_SPEED,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChangeSpeed), STATIC_SIZE_PACKET));

  005d6	50		 push	 eax
  005d7	6a 12		 push	 18			; 00000012H
  005d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  005de	c6 45 ec 00	 mov	 BYTE PTR $T66[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 103  : 			Set(HEADER_GC_CHANGE_SPEED,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChangeSpeed), STATIC_SIZE_PACKET));

  005e2	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 105  : 			Set(HEADER_GC_HANDSHAKE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCHandshake), STATIC_SIZE_PACKET));

  005e7	8d 45 e8	 lea	 eax, DWORD PTR $T65[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  005ea	c7 45 e8 0d 00
	00 00		 mov	 DWORD PTR $T65[ebp], 13	; 0000000dH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 105  : 			Set(HEADER_GC_HANDSHAKE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCHandshake), STATIC_SIZE_PACKET));

  005f1	50		 push	 eax
  005f2	68 ff 00 00 00	 push	 255			; 000000ffH
  005f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  005fc	c6 45 ec 00	 mov	 BYTE PTR $T65[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 105  : 			Set(HEADER_GC_HANDSHAKE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCHandshake), STATIC_SIZE_PACKET));

  00600	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 106  : 			Set(HEADER_GC_HANDSHAKE_OK,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBlank), STATIC_SIZE_PACKET));

  00605	8d 45 e8	 lea	 eax, DWORD PTR $T64[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00608	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T64[ebp], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 106  : 			Set(HEADER_GC_HANDSHAKE_OK,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBlank), STATIC_SIZE_PACKET));

  0060f	50		 push	 eax
  00610	68 fc 00 00 00	 push	 252			; 000000fcH
  00615	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0061a	c6 45 ec 00	 mov	 BYTE PTR $T64[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 106  : 			Set(HEADER_GC_HANDSHAKE_OK,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBlank), STATIC_SIZE_PACKET));

  0061e	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 107  : 			Set(HEADER_GC_BINDUDP,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBindUDP), STATIC_SIZE_PACKET));

  00623	8d 45 e8	 lea	 eax, DWORD PTR $T63[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00626	c7 45 e8 07 00
	00 00		 mov	 DWORD PTR $T63[ebp], 7
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 107  : 			Set(HEADER_GC_BINDUDP,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBindUDP), STATIC_SIZE_PACKET));

  0062d	50		 push	 eax
  0062e	68 fe 00 00 00	 push	 254			; 000000feH
  00633	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00638	c6 45 ec 00	 mov	 BYTE PTR $T63[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 107  : 			Set(HEADER_GC_BINDUDP,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCBindUDP), STATIC_SIZE_PACKET));

  0063c	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 108  : 			Set(HEADER_GC_OWNERSHIP,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCOwnership), STATIC_SIZE_PACKET));

  00641	8d 45 e8	 lea	 eax, DWORD PTR $T62[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00644	c7 45 e8 09 00
	00 00		 mov	 DWORD PTR $T62[ebp], 9
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 108  : 			Set(HEADER_GC_OWNERSHIP,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCOwnership), STATIC_SIZE_PACKET));

  0064b	50		 push	 eax
  0064c	6a 3e		 push	 62			; 0000003eH
  0064e	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00653	c6 45 ec 00	 mov	 BYTE PTR $T62[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 108  : 			Set(HEADER_GC_OWNERSHIP,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCOwnership), STATIC_SIZE_PACKET));

  00657	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 109  : 			Set(HEADER_GC_CREATE_FLY,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCreateFly), STATIC_SIZE_PACKET));

  0065c	8d 45 e8	 lea	 eax, DWORD PTR $T61[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0065f	c7 45 e8 0a 00
	00 00		 mov	 DWORD PTR $T61[ebp], 10	; 0000000aH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 109  : 			Set(HEADER_GC_CREATE_FLY,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCreateFly), STATIC_SIZE_PACKET));

  00666	50		 push	 eax
  00667	6a 46		 push	 70			; 00000046H
  00669	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0066e	c6 45 ec 00	 mov	 BYTE PTR $T61[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 109  : 			Set(HEADER_GC_CREATE_FLY,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCCreateFly), STATIC_SIZE_PACKET));

  00672	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 111  : 			Set(HEADER_GC_KEY_AGREEMENT, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketKeyAgreement), STATIC_SIZE_PACKET));

  00677	8d 45 e8	 lea	 eax, DWORD PTR $T60[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0067a	c7 45 e8 05 01
	00 00		 mov	 DWORD PTR $T60[ebp], 261 ; 00000105H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 111  : 			Set(HEADER_GC_KEY_AGREEMENT, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketKeyAgreement), STATIC_SIZE_PACKET));

  00681	50		 push	 eax
  00682	68 fb 00 00 00	 push	 251			; 000000fbH
  00687	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0068c	c6 45 ec 00	 mov	 BYTE PTR $T60[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 111  : 			Set(HEADER_GC_KEY_AGREEMENT, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketKeyAgreement), STATIC_SIZE_PACKET));

  00690	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 112  : 			Set(HEADER_GC_KEY_AGREEMENT_COMPLETED, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketKeyAgreementCompleted), STATIC_SIZE_PACKET));

  00695	8d 45 e8	 lea	 eax, DWORD PTR $T59[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00698	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR $T59[ebp], 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 112  : 			Set(HEADER_GC_KEY_AGREEMENT_COMPLETED, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketKeyAgreementCompleted), STATIC_SIZE_PACKET));

  0069f	50		 push	 eax
  006a0	68 fa 00 00 00	 push	 250			; 000000faH
  006a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  006aa	c6 45 ec 00	 mov	 BYTE PTR $T59[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 112  : 			Set(HEADER_GC_KEY_AGREEMENT_COMPLETED, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketKeyAgreementCompleted), STATIC_SIZE_PACKET));

  006ae	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 114  : 			Set(HEADER_GC_ADD_FLY_TARGETING, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCFlyTargeting), STATIC_SIZE_PACKET));

  006b3	8d 45 e8	 lea	 eax, DWORD PTR $T58[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  006b6	c7 45 e8 11 00
	00 00		 mov	 DWORD PTR $T58[ebp], 17	; 00000011H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 114  : 			Set(HEADER_GC_ADD_FLY_TARGETING, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCFlyTargeting), STATIC_SIZE_PACKET));

  006bd	50		 push	 eax
  006be	6a 45		 push	 69			; 00000045H
  006c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  006c5	c6 45 ec 00	 mov	 BYTE PTR $T58[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 114  : 			Set(HEADER_GC_ADD_FLY_TARGETING, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCFlyTargeting), STATIC_SIZE_PACKET));

  006c9	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 115  : 			Set(HEADER_GC_FLY_TARGETING, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCFlyTargeting), STATIC_SIZE_PACKET));

  006ce	8d 45 e8	 lea	 eax, DWORD PTR $T57[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  006d1	c7 45 e8 11 00
	00 00		 mov	 DWORD PTR $T57[ebp], 17	; 00000011H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 115  : 			Set(HEADER_GC_FLY_TARGETING, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCFlyTargeting), STATIC_SIZE_PACKET));

  006d8	50		 push	 eax
  006d9	6a 47		 push	 71			; 00000047H
  006db	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  006e0	c6 45 ec 00	 mov	 BYTE PTR $T57[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 115  : 			Set(HEADER_GC_FLY_TARGETING, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCFlyTargeting), STATIC_SIZE_PACKET));

  006e4	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 117  : 			Set(HEADER_GC_PHASE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPhase), STATIC_SIZE_PACKET));

  006e9	8d 45 e8	 lea	 eax, DWORD PTR $T56[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  006ec	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T56[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 117  : 			Set(HEADER_GC_PHASE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPhase), STATIC_SIZE_PACKET));

  006f3	50		 push	 eax
  006f4	68 fd 00 00 00	 push	 253			; 000000fdH
  006f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  006fe	c6 45 ec 00	 mov	 BYTE PTR $T56[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 117  : 			Set(HEADER_GC_PHASE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPhase), STATIC_SIZE_PACKET));

  00702	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 118  : 			Set(HEADER_GC_SKILL_LEVEL,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSkillLevel), STATIC_SIZE_PACKET));

  00707	8d 45 e8	 lea	 eax, DWORD PTR $T55[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0070a	c7 45 e8 00 01
	00 00		 mov	 DWORD PTR $T55[ebp], 256 ; 00000100H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 118  : 			Set(HEADER_GC_SKILL_LEVEL,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSkillLevel), STATIC_SIZE_PACKET));

  00711	50		 push	 eax
  00712	6a 48		 push	 72			; 00000048H
  00714	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00719	c6 45 ec 00	 mov	 BYTE PTR $T55[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 118  : 			Set(HEADER_GC_SKILL_LEVEL,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSkillLevel), STATIC_SIZE_PACKET));

  0071d	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 119  : 			Set(HEADER_GC_SKILL_LEVEL_NEW,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSkillLevelNew), STATIC_SIZE_PACKET));

  00722	8d 45 e8	 lea	 eax, DWORD PTR $T54[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00725	c7 45 e8 fb 05
	00 00		 mov	 DWORD PTR $T54[ebp], 1531 ; 000005fbH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 119  : 			Set(HEADER_GC_SKILL_LEVEL_NEW,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSkillLevelNew), STATIC_SIZE_PACKET));

  0072c	50		 push	 eax
  0072d	6a 4c		 push	 76			; 0000004cH
  0072f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00734	c6 45 ec 00	 mov	 BYTE PTR $T54[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 119  : 			Set(HEADER_GC_SKILL_LEVEL_NEW,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSkillLevelNew), STATIC_SIZE_PACKET));

  00738	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 121  : 			Set(HEADER_GC_MESSENGER,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMessenger), DYNAMIC_SIZE_PACKET));

  0073d	8d 45 e8	 lea	 eax, DWORD PTR $T53[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00740	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR $T53[ebp], 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 121  : 			Set(HEADER_GC_MESSENGER,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMessenger), DYNAMIC_SIZE_PACKET));

  00747	50		 push	 eax
  00748	6a 4a		 push	 74			; 0000004aH
  0074a	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0074f	c6 45 ec 01	 mov	 BYTE PTR $T53[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 121  : 			Set(HEADER_GC_MESSENGER,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMessenger), DYNAMIC_SIZE_PACKET));

  00753	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 122  : 			Set(HEADER_GC_GUILD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCGuild), DYNAMIC_SIZE_PACKET));

  00758	8d 45 e8	 lea	 eax, DWORD PTR $T52[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0075b	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR $T52[ebp], 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 122  : 			Set(HEADER_GC_GUILD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCGuild), DYNAMIC_SIZE_PACKET));

  00762	50		 push	 eax
  00763	6a 4b		 push	 75			; 0000004bH
  00765	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0076a	c6 45 ec 01	 mov	 BYTE PTR $T52[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 122  : 			Set(HEADER_GC_GUILD,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCGuild), DYNAMIC_SIZE_PACKET));

  0076e	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 124  : 			Set(HEADER_GC_PARTY_INVITE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyInvite), STATIC_SIZE_PACKET));

  00773	8d 45 e8	 lea	 eax, DWORD PTR $T51[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00776	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T51[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 124  : 			Set(HEADER_GC_PARTY_INVITE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyInvite), STATIC_SIZE_PACKET));

  0077d	50		 push	 eax
  0077e	6a 4d		 push	 77			; 0000004dH
  00780	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00785	c6 45 ec 00	 mov	 BYTE PTR $T51[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 124  : 			Set(HEADER_GC_PARTY_INVITE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyInvite), STATIC_SIZE_PACKET));

  00789	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 125  : 			Set(HEADER_GC_PARTY_ADD,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyAdd), STATIC_SIZE_PACKET));

  0078e	8d 45 e8	 lea	 eax, DWORD PTR $T50[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00791	c7 45 e8 1e 00
	00 00		 mov	 DWORD PTR $T50[ebp], 30	; 0000001eH

; 13   : 				isDynamicSizePacket = bFlag;

  00798	c6 45 ec 00	 mov	 BYTE PTR $T50[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 125  : 			Set(HEADER_GC_PARTY_ADD,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyAdd), STATIC_SIZE_PACKET));

  0079c	50		 push	 eax
  0079d	6a 4e		 push	 78			; 0000004eH
  0079f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  007a4	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 126  : 			Set(HEADER_GC_PARTY_UPDATE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyUpdate), STATIC_SIZE_PACKET));

  007a9	8d 45 e8	 lea	 eax, DWORD PTR $T49[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  007ac	c7 45 e8 15 00
	00 00		 mov	 DWORD PTR $T49[ebp], 21	; 00000015H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 126  : 			Set(HEADER_GC_PARTY_UPDATE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyUpdate), STATIC_SIZE_PACKET));

  007b3	50		 push	 eax
  007b4	6a 4f		 push	 79			; 0000004fH
  007b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  007bb	c6 45 ec 00	 mov	 BYTE PTR $T49[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 126  : 			Set(HEADER_GC_PARTY_UPDATE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyUpdate), STATIC_SIZE_PACKET));

  007bf	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 127  : 			Set(HEADER_GC_PARTY_REMOVE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyRemove), STATIC_SIZE_PACKET));

  007c4	8d 45 e8	 lea	 eax, DWORD PTR $T48[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  007c7	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T48[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 127  : 			Set(HEADER_GC_PARTY_REMOVE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyRemove), STATIC_SIZE_PACKET));

  007ce	50		 push	 eax
  007cf	6a 50		 push	 80			; 00000050H
  007d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  007d6	c6 45 ec 00	 mov	 BYTE PTR $T48[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 127  : 			Set(HEADER_GC_PARTY_REMOVE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyRemove), STATIC_SIZE_PACKET));

  007da	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 128  : 			Set(HEADER_GC_PARTY_LINK,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyLink), STATIC_SIZE_PACKET));

  007df	8d 45 e8	 lea	 eax, DWORD PTR $T47[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  007e2	c7 45 e8 09 00
	00 00		 mov	 DWORD PTR $T47[ebp], 9
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 128  : 			Set(HEADER_GC_PARTY_LINK,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyLink), STATIC_SIZE_PACKET));

  007e9	50		 push	 eax
  007ea	6a 5b		 push	 91			; 0000005bH
  007ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  007f1	c6 45 ec 00	 mov	 BYTE PTR $T47[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 128  : 			Set(HEADER_GC_PARTY_LINK,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyLink), STATIC_SIZE_PACKET));

  007f5	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 129  : 			Set(HEADER_GC_PARTY_UNLINK,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyUnlink), STATIC_SIZE_PACKET));

  007fa	8d 45 e8	 lea	 eax, DWORD PTR $T46[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  007fd	c7 45 e8 09 00
	00 00		 mov	 DWORD PTR $T46[ebp], 9
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 129  : 			Set(HEADER_GC_PARTY_UNLINK,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyUnlink), STATIC_SIZE_PACKET));

  00804	50		 push	 eax
  00805	6a 5c		 push	 92			; 0000005cH
  00807	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0080c	c6 45 ec 00	 mov	 BYTE PTR $T46[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 129  : 			Set(HEADER_GC_PARTY_UNLINK,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyUnlink), STATIC_SIZE_PACKET));

  00810	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 130  : 			Set(HEADER_GC_PARTY_PARAMETER,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyParameter), STATIC_SIZE_PACKET));

  00815	8d 45 e8	 lea	 eax, DWORD PTR $T45[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00818	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T45[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 130  : 			Set(HEADER_GC_PARTY_PARAMETER,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyParameter), STATIC_SIZE_PACKET));

  0081f	50		 push	 eax
  00820	6a 53		 push	 83			; 00000053H
  00822	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00827	c6 45 ec 00	 mov	 BYTE PTR $T45[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 130  : 			Set(HEADER_GC_PARTY_PARAMETER,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCPartyParameter), STATIC_SIZE_PACKET));

  0082b	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 132  : 			Set(HEADER_GC_SAFEBOX_SET,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet), STATIC_SIZE_PACKET));

  00830	8d 45 e8	 lea	 eax, DWORD PTR $T44[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00833	c7 45 e8 2a 00
	00 00		 mov	 DWORD PTR $T44[ebp], 42	; 0000002aH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 132  : 			Set(HEADER_GC_SAFEBOX_SET,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet), STATIC_SIZE_PACKET));

  0083a	50		 push	 eax
  0083b	6a 55		 push	 85			; 00000055H
  0083d	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00842	c6 45 ec 00	 mov	 BYTE PTR $T44[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 132  : 			Set(HEADER_GC_SAFEBOX_SET,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet), STATIC_SIZE_PACKET));

  00846	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 133  : 			Set(HEADER_GC_SAFEBOX_DEL,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemDel), STATIC_SIZE_PACKET));

  0084b	8d 45 e8	 lea	 eax, DWORD PTR $T43[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0084e	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T43[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 133  : 			Set(HEADER_GC_SAFEBOX_DEL,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemDel), STATIC_SIZE_PACKET));

  00855	50		 push	 eax
  00856	6a 56		 push	 86			; 00000056H
  00858	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0085d	c6 45 ec 00	 mov	 BYTE PTR $T43[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 133  : 			Set(HEADER_GC_SAFEBOX_DEL,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemDel), STATIC_SIZE_PACKET));

  00861	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 134  : 			Set(HEADER_GC_SAFEBOX_WRONG_PASSWORD,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSafeboxWrongPassword), STATIC_SIZE_PACKET));

  00866	8d 45 e8	 lea	 eax, DWORD PTR $T42[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00869	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T42[ebp], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 134  : 			Set(HEADER_GC_SAFEBOX_WRONG_PASSWORD,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSafeboxWrongPassword), STATIC_SIZE_PACKET));

  00870	50		 push	 eax
  00871	6a 57		 push	 87			; 00000057H
  00873	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00878	c6 45 ec 00	 mov	 BYTE PTR $T42[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 134  : 			Set(HEADER_GC_SAFEBOX_WRONG_PASSWORD,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSafeboxWrongPassword), STATIC_SIZE_PACKET));

  0087c	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 135  : 			Set(HEADER_GC_SAFEBOX_SIZE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSafeboxSize), STATIC_SIZE_PACKET));

  00881	8d 45 e8	 lea	 eax, DWORD PTR $T41[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00884	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T41[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 135  : 			Set(HEADER_GC_SAFEBOX_SIZE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSafeboxSize), STATIC_SIZE_PACKET));

  0088b	50		 push	 eax
  0088c	6a 58		 push	 88			; 00000058H
  0088e	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00893	c6 45 ec 00	 mov	 BYTE PTR $T41[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 135  : 			Set(HEADER_GC_SAFEBOX_SIZE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSafeboxSize), STATIC_SIZE_PACKET));

  00897	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 136  : 			Set(HEADER_GC_SAFEBOX_MONEY_CHANGE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSafeboxMoneyChange), STATIC_SIZE_PACKET));

  0089c	8d 45 e8	 lea	 eax, DWORD PTR $T40[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0089f	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T40[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 136  : 			Set(HEADER_GC_SAFEBOX_MONEY_CHANGE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSafeboxMoneyChange), STATIC_SIZE_PACKET));

  008a6	50		 push	 eax
  008a7	6a 54		 push	 84			; 00000054H
  008a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  008ae	c6 45 ec 00	 mov	 BYTE PTR $T40[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 136  : 			Set(HEADER_GC_SAFEBOX_MONEY_CHANGE,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSafeboxMoneyChange), STATIC_SIZE_PACKET));

  008b2	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 138  : 			Set(HEADER_GC_FISHING,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCFishing), STATIC_SIZE_PACKET));

  008b7	8d 45 e8	 lea	 eax, DWORD PTR $T39[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  008ba	c7 45 e8 07 00
	00 00		 mov	 DWORD PTR $T39[ebp], 7
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 138  : 			Set(HEADER_GC_FISHING,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCFishing), STATIC_SIZE_PACKET));

  008c1	50		 push	 eax
  008c2	6a 59		 push	 89			; 00000059H
  008c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  008c9	c6 45 ec 00	 mov	 BYTE PTR $T39[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 138  : 			Set(HEADER_GC_FISHING,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCFishing), STATIC_SIZE_PACKET));

  008cd	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  008d2	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR $T38[ebp], 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 139  : 			Set(HEADER_GC_DUNGEON, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDungeon), DYNAMIC_SIZE_PACKET));

  008d9	8d 45 e8	 lea	 eax, DWORD PTR $T38[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  008dc	c6 45 ec 01	 mov	 BYTE PTR $T38[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 139  : 			Set(HEADER_GC_DUNGEON, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDungeon), DYNAMIC_SIZE_PACKET));

  008e0	50		 push	 eax
  008e1	6a 6e		 push	 110			; 0000006eH
  008e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  008e8	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 141  : 			Set(HEADER_GC_TIME, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTime), STATIC_SIZE_PACKET));

  008ed	8d 45 e8	 lea	 eax, DWORD PTR $T37[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  008f0	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T37[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 141  : 			Set(HEADER_GC_TIME, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTime), STATIC_SIZE_PACKET));

  008f7	50		 push	 eax
  008f8	6a 6a		 push	 106			; 0000006aH
  008fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  008ff	c6 45 ec 00	 mov	 BYTE PTR $T37[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 141  : 			Set(HEADER_GC_TIME, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTime), STATIC_SIZE_PACKET));

  00903	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 142  : 			Set(HEADER_GC_WALK_MODE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCWalkMode), STATIC_SIZE_PACKET));

  00908	8d 45 e8	 lea	 eax, DWORD PTR $T36[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0090b	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR $T36[ebp], 6
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 142  : 			Set(HEADER_GC_WALK_MODE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCWalkMode), STATIC_SIZE_PACKET));

  00912	50		 push	 eax
  00913	6a 6f		 push	 111			; 0000006fH
  00915	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0091a	c6 45 ec 00	 mov	 BYTE PTR $T36[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 142  : 			Set(HEADER_GC_WALK_MODE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCWalkMode), STATIC_SIZE_PACKET));

  0091e	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 143  : 			Set(HEADER_GC_CHANGE_SKILL_GROUP, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChangeSkillGroup), STATIC_SIZE_PACKET));

  00923	8d 45 e8	 lea	 eax, DWORD PTR $T35[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00926	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T35[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 143  : 			Set(HEADER_GC_CHANGE_SKILL_GROUP, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChangeSkillGroup), STATIC_SIZE_PACKET));

  0092d	50		 push	 eax
  0092e	6a 70		 push	 112			; 00000070H
  00930	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00935	c6 45 ec 00	 mov	 BYTE PTR $T35[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 143  : 			Set(HEADER_GC_CHANGE_SKILL_GROUP, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChangeSkillGroup), STATIC_SIZE_PACKET));

  00939	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 144  : 			Set(HEADER_GC_REFINE_INFORMATION, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCRefineInformation), STATIC_SIZE_PACKET));

  0093e	8d 45 e8	 lea	 eax, DWORD PTR $T34[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00941	c7 45 e8 3b 00
	00 00		 mov	 DWORD PTR $T34[ebp], 59	; 0000003bH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 144  : 			Set(HEADER_GC_REFINE_INFORMATION, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCRefineInformation), STATIC_SIZE_PACKET));

  00948	50		 push	 eax
  00949	6a 5f		 push	 95			; 0000005fH
  0094b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00950	c6 45 ec 00	 mov	 BYTE PTR $T34[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 144  : 			Set(HEADER_GC_REFINE_INFORMATION, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCRefineInformation), STATIC_SIZE_PACKET));

  00954	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 145  : 			Set(HEADER_GC_REFINE_INFORMATION_NEW, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCRefineInformationNew), STATIC_SIZE_PACKET));

  00959	8d 45 e8	 lea	 eax, DWORD PTR $T33[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  0095c	c7 45 e8 3c 00
	00 00		 mov	 DWORD PTR $T33[ebp], 60	; 0000003cH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 145  : 			Set(HEADER_GC_REFINE_INFORMATION_NEW, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCRefineInformationNew), STATIC_SIZE_PACKET));

  00963	50		 push	 eax
  00964	6a 77		 push	 119			; 00000077H
  00966	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  0096b	c6 45 ec 00	 mov	 BYTE PTR $T33[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 145  : 			Set(HEADER_GC_REFINE_INFORMATION_NEW, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCRefineInformationNew), STATIC_SIZE_PACKET));

  0096f	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 146  : 			Set(HEADER_GC_SEPCIAL_EFFECT, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSpecialEffect), STATIC_SIZE_PACKET));

  00974	8d 45 e8	 lea	 eax, DWORD PTR $T32[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00977	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR $T32[ebp], 6
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 146  : 			Set(HEADER_GC_SEPCIAL_EFFECT, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSpecialEffect), STATIC_SIZE_PACKET));

  0097e	50		 push	 eax
  0097f	6a 72		 push	 114			; 00000072H
  00981	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00986	c6 45 ec 00	 mov	 BYTE PTR $T32[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 146  : 			Set(HEADER_GC_SEPCIAL_EFFECT, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSpecialEffect), STATIC_SIZE_PACKET));

  0098a	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 147  : 			Set(HEADER_GC_NPC_POSITION, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCNPCPosition), DYNAMIC_SIZE_PACKET));

  0098f	8d 45 e8	 lea	 eax, DWORD PTR $T31[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00992	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T31[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 147  : 			Set(HEADER_GC_NPC_POSITION, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCNPCPosition), DYNAMIC_SIZE_PACKET));

  00999	50		 push	 eax
  0099a	6a 73		 push	 115			; 00000073H
  0099c	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  009a1	c6 45 ec 01	 mov	 BYTE PTR $T31[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 147  : 			Set(HEADER_GC_NPC_POSITION, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCNPCPosition), DYNAMIC_SIZE_PACKET));

  009a5	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 148  : 			Set(HEADER_GC_CHANGE_NAME, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChangeName), STATIC_SIZE_PACKET));

  009aa	8d 45 e8	 lea	 eax, DWORD PTR $T30[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  009ad	c7 45 e8 1e 00
	00 00		 mov	 DWORD PTR $T30[ebp], 30	; 0000001eH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 148  : 			Set(HEADER_GC_CHANGE_NAME, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChangeName), STATIC_SIZE_PACKET));

  009b4	50		 push	 eax
  009b5	6a 6b		 push	 107			; 0000006bH
  009b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  009bc	c6 45 ec 00	 mov	 BYTE PTR $T30[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 148  : 			Set(HEADER_GC_CHANGE_NAME, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChangeName), STATIC_SIZE_PACKET));

  009c0	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 150  : 			Set(HEADER_GC_CHINA_MATRIX_CARD, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChinaMatrixCard), STATIC_SIZE_PACKET));

  009c5	8d 45 e8	 lea	 eax, DWORD PTR $T29[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  009c8	c7 45 e8 09 00
	00 00		 mov	 DWORD PTR $T29[ebp], 9
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 150  : 			Set(HEADER_GC_CHINA_MATRIX_CARD, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChinaMatrixCard), STATIC_SIZE_PACKET));

  009cf	50		 push	 eax
  009d0	6a 74		 push	 116			; 00000074H
  009d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  009d7	c6 45 ec 00	 mov	 BYTE PTR $T29[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 150  : 			Set(HEADER_GC_CHINA_MATRIX_CARD, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChinaMatrixCard), STATIC_SIZE_PACKET));

  009db	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 151  : 			Set(HEADER_GC_RUNUP_MATRIX_QUIZ, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCRunupMatrixQuiz), STATIC_SIZE_PACKET));

  009e0	8d 45 e8	 lea	 eax, DWORD PTR $T28[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  009e3	c7 45 e8 0a 00
	00 00		 mov	 DWORD PTR $T28[ebp], 10	; 0000000aH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 151  : 			Set(HEADER_GC_RUNUP_MATRIX_QUIZ, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCRunupMatrixQuiz), STATIC_SIZE_PACKET));

  009ea	50		 push	 eax
  009eb	68 c9 00 00 00	 push	 201			; 000000c9H
  009f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  009f5	c6 45 ec 00	 mov	 BYTE PTR $T28[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 151  : 			Set(HEADER_GC_RUNUP_MATRIX_QUIZ, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCRunupMatrixQuiz), STATIC_SIZE_PACKET));

  009f9	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 152  : 			Set(HEADER_GC_NEWCIBN_PASSPOD_REQUEST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCNEWCIBNPasspodRequest), STATIC_SIZE_PACKET));

  009fe	8d 45 e8	 lea	 eax, DWORD PTR $T27[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00a01	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T27[ebp], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 152  : 			Set(HEADER_GC_NEWCIBN_PASSPOD_REQUEST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCNEWCIBNPasspodRequest), STATIC_SIZE_PACKET));

  00a08	50		 push	 eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00a09	c6 45 ec 00	 mov	 BYTE PTR $T27[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 152  : 			Set(HEADER_GC_NEWCIBN_PASSPOD_REQUEST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCNEWCIBNPasspodRequest), STATIC_SIZE_PACKET));

  00a0d	68 ca 00 00 00	 push	 202			; 000000caH
  00a12	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  00a17	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 153  : 			Set(HEADER_GC_NEWCIBN_PASSPOD_FAILURE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCNEWCIBNPasspodFailure), STATIC_SIZE_PACKET));

  00a1c	8d 45 e8	 lea	 eax, DWORD PTR $T26[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00a1f	c7 45 e8 82 00
	00 00		 mov	 DWORD PTR $T26[ebp], 130 ; 00000082H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 153  : 			Set(HEADER_GC_NEWCIBN_PASSPOD_FAILURE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCNEWCIBNPasspodFailure), STATIC_SIZE_PACKET));

  00a26	50		 push	 eax
  00a27	68 cb 00 00 00	 push	 203			; 000000cbH
  00a2c	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00a31	c6 45 ec 00	 mov	 BYTE PTR $T26[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 153  : 			Set(HEADER_GC_NEWCIBN_PASSPOD_FAILURE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCNEWCIBNPasspodFailure), STATIC_SIZE_PACKET));

  00a35	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 154  : 			Set(HEADER_GC_LOGIN_KEY, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginKey), STATIC_SIZE_PACKET));

  00a3a	8d 45 e8	 lea	 eax, DWORD PTR $T25[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00a3d	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T25[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 154  : 			Set(HEADER_GC_LOGIN_KEY, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginKey), STATIC_SIZE_PACKET));

  00a44	50		 push	 eax
  00a45	6a 76		 push	 118			; 00000076H
  00a47	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00a4c	c6 45 ec 00	 mov	 BYTE PTR $T25[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 154  : 			Set(HEADER_GC_LOGIN_KEY, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoginKey), STATIC_SIZE_PACKET));

  00a50	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 156  : 			Set(HEADER_GC_AUTH_SUCCESS, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCAuthSuccess), STATIC_SIZE_PACKET));

  00a55	8d 45 e8	 lea	 eax, DWORD PTR $T24[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00a58	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR $T24[ebp], 6
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 156  : 			Set(HEADER_GC_AUTH_SUCCESS, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCAuthSuccess), STATIC_SIZE_PACKET));

  00a5f	50		 push	 eax
  00a60	68 96 00 00 00	 push	 150			; 00000096H
  00a65	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00a6a	c6 45 ec 00	 mov	 BYTE PTR $T24[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 156  : 			Set(HEADER_GC_AUTH_SUCCESS, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCAuthSuccess), STATIC_SIZE_PACKET));

  00a6e	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 157  : 			Set(HEADER_GC_AUTH_SUCCESS_OPENID, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCAuthSuccessOpenID), STATIC_SIZE_PACKET));

  00a73	8d 45 e8	 lea	 eax, DWORD PTR $T23[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00a76	c7 45 e8 25 00
	00 00		 mov	 DWORD PTR $T23[ebp], 37	; 00000025H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 157  : 			Set(HEADER_GC_AUTH_SUCCESS_OPENID, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCAuthSuccessOpenID), STATIC_SIZE_PACKET));

  00a7d	50		 push	 eax
  00a7e	68 9a 00 00 00	 push	 154			; 0000009aH
  00a83	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00a88	c6 45 ec 00	 mov	 BYTE PTR $T23[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 157  : 			Set(HEADER_GC_AUTH_SUCCESS_OPENID, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCAuthSuccessOpenID), STATIC_SIZE_PACKET));

  00a8c	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 158  : 			Set(HEADER_GC_CHANNEL, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChannel), STATIC_SIZE_PACKET));

  00a91	8d 45 e8	 lea	 eax, DWORD PTR $T22[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00a94	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T22[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 158  : 			Set(HEADER_GC_CHANNEL, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChannel), STATIC_SIZE_PACKET));

  00a9b	50		 push	 eax
  00a9c	6a 79		 push	 121			; 00000079H
  00a9e	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00aa3	c6 45 ec 00	 mov	 BYTE PTR $T22[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 158  : 			Set(HEADER_GC_CHANNEL, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCChannel), STATIC_SIZE_PACKET));

  00aa7	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 159  : 			Set(HEADER_GC_VIEW_EQUIP, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCViewEquip), STATIC_SIZE_PACKET));

  00aac	8d 45 e8	 lea	 eax, DWORD PTR $T21[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00aaf	c7 45 e8 a7 01
	00 00		 mov	 DWORD PTR $T21[ebp], 423 ; 000001a7H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 159  : 			Set(HEADER_GC_VIEW_EQUIP, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCViewEquip), STATIC_SIZE_PACKET));

  00ab6	50		 push	 eax
  00ab7	6a 63		 push	 99			; 00000063H
  00ab9	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00abe	c6 45 ec 00	 mov	 BYTE PTR $T21[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 159  : 			Set(HEADER_GC_VIEW_EQUIP, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCViewEquip), STATIC_SIZE_PACKET));

  00ac2	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 160  : 			Set(HEADER_GC_LAND_LIST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLandList), DYNAMIC_SIZE_PACKET));

  00ac7	8d 45 e8	 lea	 eax, DWORD PTR $T20[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00aca	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR $T20[ebp], 3
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 160  : 			Set(HEADER_GC_LAND_LIST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLandList), DYNAMIC_SIZE_PACKET));

  00ad1	50		 push	 eax
  00ad2	68 82 00 00 00	 push	 130			; 00000082H
  00ad7	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00adc	c6 45 ec 01	 mov	 BYTE PTR $T20[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 160  : 			Set(HEADER_GC_LAND_LIST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLandList), DYNAMIC_SIZE_PACKET));

  00ae0	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 163  : 			Set(HEADER_GC_TARGET_UPDATE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTargetUpdate), STATIC_SIZE_PACKET));

  00ae5	8d 45 e8	 lea	 eax, DWORD PTR $T19[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00ae8	c7 45 e8 0d 00
	00 00		 mov	 DWORD PTR $T19[ebp], 13	; 0000000dH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 163  : 			Set(HEADER_GC_TARGET_UPDATE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTargetUpdate), STATIC_SIZE_PACKET));

  00aef	50		 push	 eax
  00af0	6a 7b		 push	 123			; 0000007bH
  00af2	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00af7	c6 45 ec 00	 mov	 BYTE PTR $T19[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 163  : 			Set(HEADER_GC_TARGET_UPDATE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTargetUpdate), STATIC_SIZE_PACKET));

  00afb	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 164  : 			Set(HEADER_GC_TARGET_DELETE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTargetDelete), STATIC_SIZE_PACKET));

  00b00	8d 45 e8	 lea	 eax, DWORD PTR $T18[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00b03	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T18[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 164  : 			Set(HEADER_GC_TARGET_DELETE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTargetDelete), STATIC_SIZE_PACKET));

  00b0a	50		 push	 eax
  00b0b	6a 7c		 push	 124			; 0000007cH
  00b0d	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00b12	c6 45 ec 00	 mov	 BYTE PTR $T18[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 164  : 			Set(HEADER_GC_TARGET_DELETE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTargetDelete), STATIC_SIZE_PACKET));

  00b16	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 165  : 			Set(HEADER_GC_TARGET_CREATE_NEW, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTargetCreateNew), STATIC_SIZE_PACKET));

  00b1b	8d 45 e8	 lea	 eax, DWORD PTR $T17[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00b1e	c7 45 e8 2b 00
	00 00		 mov	 DWORD PTR $T17[ebp], 43	; 0000002bH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 165  : 			Set(HEADER_GC_TARGET_CREATE_NEW, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTargetCreateNew), STATIC_SIZE_PACKET));

  00b25	50		 push	 eax
  00b26	6a 7d		 push	 125			; 0000007dH
  00b28	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00b2d	c6 45 ec 00	 mov	 BYTE PTR $T17[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 165  : 			Set(HEADER_GC_TARGET_CREATE_NEW, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCTargetCreateNew), STATIC_SIZE_PACKET));

  00b31	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 167  : 			Set(HEADER_GC_AFFECT_ADD, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCAffectAdd), STATIC_SIZE_PACKET));

  00b36	8d 45 e8	 lea	 eax, DWORD PTR $T16[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00b39	c7 45 e8 16 00
	00 00		 mov	 DWORD PTR $T16[ebp], 22	; 00000016H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 167  : 			Set(HEADER_GC_AFFECT_ADD, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCAffectAdd), STATIC_SIZE_PACKET));

  00b40	50		 push	 eax
  00b41	6a 7e		 push	 126			; 0000007eH
  00b43	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00b48	c6 45 ec 00	 mov	 BYTE PTR $T16[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 167  : 			Set(HEADER_GC_AFFECT_ADD, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCAffectAdd), STATIC_SIZE_PACKET));

  00b4c	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00b51	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR $T15[ebp], 6

; 13   : 				isDynamicSizePacket = bFlag;

  00b58	c6 45 ec 00	 mov	 BYTE PTR $T15[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 168  : 			Set(HEADER_GC_AFFECT_REMOVE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCAffectRemove), STATIC_SIZE_PACKET));

  00b5c	8d 45 e8	 lea	 eax, DWORD PTR $T15[ebp]
  00b5f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  00b64	50		 push	 eax
  00b65	6a 7f		 push	 127			; 0000007fH
  00b67	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 170  : 			Set(HEADER_GC_MALL_OPEN, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMallOpen), STATIC_SIZE_PACKET));

  00b6c	8d 45 e8	 lea	 eax, DWORD PTR $T14[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00b6f	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T14[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 170  : 			Set(HEADER_GC_MALL_OPEN, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMallOpen), STATIC_SIZE_PACKET));

  00b76	50		 push	 eax
  00b77	6a 7a		 push	 122			; 0000007aH
  00b79	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00b7e	c6 45 ec 00	 mov	 BYTE PTR $T14[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 170  : 			Set(HEADER_GC_MALL_OPEN, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCMallOpen), STATIC_SIZE_PACKET));

  00b82	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 171  : 			Set(HEADER_GC_MALL_SET, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet), STATIC_SIZE_PACKET));

  00b87	8d 45 e8	 lea	 eax, DWORD PTR $T13[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00b8a	c7 45 e8 2a 00
	00 00		 mov	 DWORD PTR $T13[ebp], 42	; 0000002aH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 171  : 			Set(HEADER_GC_MALL_SET, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet), STATIC_SIZE_PACKET));

  00b91	50		 push	 eax
  00b92	68 80 00 00 00	 push	 128			; 00000080H
  00b97	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00b9c	c6 45 ec 00	 mov	 BYTE PTR $T13[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 171  : 			Set(HEADER_GC_MALL_SET, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemSet), STATIC_SIZE_PACKET));

  00ba0	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 172  : 			Set(HEADER_GC_MALL_DEL, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemDel), STATIC_SIZE_PACKET));

  00ba5	8d 45 e8	 lea	 eax, DWORD PTR $T12[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00ba8	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T12[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 172  : 			Set(HEADER_GC_MALL_DEL, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemDel), STATIC_SIZE_PACKET));

  00baf	50		 push	 eax
  00bb0	68 81 00 00 00	 push	 129			; 00000081H
  00bb5	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00bba	c6 45 ec 00	 mov	 BYTE PTR $T12[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 172  : 			Set(HEADER_GC_MALL_DEL, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCItemDel), STATIC_SIZE_PACKET));

  00bbe	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 174  : 			Set(HEADER_GC_LOVER_INFO, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoverInfo), STATIC_SIZE_PACKET));

  00bc3	8d 45 e8	 lea	 eax, DWORD PTR $T11[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00bc6	c7 45 e8 1b 00
	00 00		 mov	 DWORD PTR $T11[ebp], 27	; 0000001bH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 174  : 			Set(HEADER_GC_LOVER_INFO, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoverInfo), STATIC_SIZE_PACKET));

  00bcd	50		 push	 eax
  00bce	68 83 00 00 00	 push	 131			; 00000083H
  00bd3	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00bd8	c6 45 ec 00	 mov	 BYTE PTR $T11[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 174  : 			Set(HEADER_GC_LOVER_INFO, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLoverInfo), STATIC_SIZE_PACKET));

  00bdc	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 175  : 			Set(HEADER_GC_LOVE_POINT_UPDATE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLovePointUpdate), STATIC_SIZE_PACKET));

  00be1	8d 45 e8	 lea	 eax, DWORD PTR $T10[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00be4	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T10[ebp], 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 175  : 			Set(HEADER_GC_LOVE_POINT_UPDATE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLovePointUpdate), STATIC_SIZE_PACKET));

  00beb	50		 push	 eax
  00bec	68 84 00 00 00	 push	 132			; 00000084H
  00bf1	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00bf6	c6 45 ec 00	 mov	 BYTE PTR $T10[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 175  : 			Set(HEADER_GC_LOVE_POINT_UPDATE, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCLovePointUpdate), STATIC_SIZE_PACKET));

  00bfa	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 177  : 			Set(HEADER_GC_DIG_MOTION, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDigMotion), STATIC_SIZE_PACKET));

  00bff	8d 45 e8	 lea	 eax, DWORD PTR $T9[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00c02	c7 45 e8 0a 00
	00 00		 mov	 DWORD PTR $T9[ebp], 10	; 0000000aH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 177  : 			Set(HEADER_GC_DIG_MOTION, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDigMotion), STATIC_SIZE_PACKET));

  00c09	50		 push	 eax
  00c0a	68 86 00 00 00	 push	 134			; 00000086H
  00c0f	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00c14	c6 45 ec 00	 mov	 BYTE PTR $T9[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 177  : 			Set(HEADER_GC_DIG_MOTION, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDigMotion), STATIC_SIZE_PACKET));

  00c18	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 178  : 			Set(HEADER_GC_DAMAGE_INFO, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDamageInfo), STATIC_SIZE_PACKET));

  00c1d	8d 45 e8	 lea	 eax, DWORD PTR $T8[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00c20	c7 45 e8 0a 00
	00 00		 mov	 DWORD PTR $T8[ebp], 10	; 0000000aH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 178  : 			Set(HEADER_GC_DAMAGE_INFO, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDamageInfo), STATIC_SIZE_PACKET));

  00c27	50		 push	 eax
  00c28	68 87 00 00 00	 push	 135			; 00000087H
  00c2d	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00c32	c6 45 ec 00	 mov	 BYTE PTR $T8[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 178  : 			Set(HEADER_GC_DAMAGE_INFO, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDamageInfo), STATIC_SIZE_PACKET));

  00c36	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 180  : 			Set(HEADER_GC_HS_REQUEST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketHSCheck), STATIC_SIZE_PACKET));

  00c3b	8d 45 e8	 lea	 eax, DWORD PTR $T7[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00c3e	c7 45 e8 93 01
	00 00		 mov	 DWORD PTR $T7[ebp], 403	; 00000193H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 180  : 			Set(HEADER_GC_HS_REQUEST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketHSCheck), STATIC_SIZE_PACKET));

  00c45	50		 push	 eax
  00c46	68 cc 00 00 00	 push	 204			; 000000ccH
  00c4b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00c50	c6 45 ec 00	 mov	 BYTE PTR $T7[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 180  : 			Set(HEADER_GC_HS_REQUEST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketHSCheck), STATIC_SIZE_PACKET));

  00c54	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 181  : 			Set(HEADER_GC_XTRAP_CS1_REQUEST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketXTrapCSVerify), STATIC_SIZE_PACKET));

  00c59	8d 45 e8	 lea	 eax, DWORD PTR $T6[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00c5c	c7 45 e8 81 00
	00 00		 mov	 DWORD PTR $T6[ebp], 129	; 00000081H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 181  : 			Set(HEADER_GC_XTRAP_CS1_REQUEST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketXTrapCSVerify), STATIC_SIZE_PACKET));

  00c63	50		 push	 eax
  00c64	68 cd 00 00 00	 push	 205			; 000000cdH
  00c69	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00c6e	c6 45 ec 00	 mov	 BYTE PTR $T6[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 181  : 			Set(HEADER_GC_XTRAP_CS1_REQUEST, CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketXTrapCSVerify), STATIC_SIZE_PACKET));

  00c72	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 183  : 			Set(HEADER_GC_HYBRIDCRYPT_KEYS,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCHybridCryptKeys), DYNAMIC_SIZE_PACKET));

  00c77	8d 45 e8	 lea	 eax, DWORD PTR $T5[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00c7a	c7 45 e8 0b 00
	00 00		 mov	 DWORD PTR $T5[ebp], 11	; 0000000bH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 183  : 			Set(HEADER_GC_HYBRIDCRYPT_KEYS,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCHybridCryptKeys), DYNAMIC_SIZE_PACKET));

  00c81	50		 push	 eax
  00c82	68 98 00 00 00	 push	 152			; 00000098H
  00c87	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00c8c	c6 45 ec 01	 mov	 BYTE PTR $T5[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 183  : 			Set(HEADER_GC_HYBRIDCRYPT_KEYS,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCHybridCryptKeys), DYNAMIC_SIZE_PACKET));

  00c90	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 184  : 			Set(HEADER_GC_HYBRIDCRYPT_SDB,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCHybridSDB), DYNAMIC_SIZE_PACKET));

  00c95	8d 45 e8	 lea	 eax, DWORD PTR $T4[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00c98	c7 45 e8 0b 00
	00 00		 mov	 DWORD PTR $T4[ebp], 11	; 0000000bH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 184  : 			Set(HEADER_GC_HYBRIDCRYPT_SDB,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCHybridSDB), DYNAMIC_SIZE_PACKET));

  00c9f	50		 push	 eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00ca0	c6 45 ec 01	 mov	 BYTE PTR $T4[ebp+4], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 184  : 			Set(HEADER_GC_HYBRIDCRYPT_SDB,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCHybridSDB), DYNAMIC_SIZE_PACKET));

  00ca4	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  00ca9	68 99 00 00 00	 push	 153			; 00000099H
  00cae	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 185  : 			Set(HEADER_GC_SPECIFIC_EFFECT,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSpecificEffect), STATIC_SIZE_PACKET));

  00cb3	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00cb6	c7 45 e8 85 00
	00 00		 mov	 DWORD PTR $T3[ebp], 133	; 00000085H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 185  : 			Set(HEADER_GC_SPECIFIC_EFFECT,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSpecificEffect), STATIC_SIZE_PACKET));

  00cbd	50		 push	 eax
  00cbe	68 d0 00 00 00	 push	 208			; 000000d0H
  00cc3	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00cc8	c6 45 ec 00	 mov	 BYTE PTR $T3[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 185  : 			Set(HEADER_GC_SPECIFIC_EFFECT,	CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCSpecificEffect), STATIC_SIZE_PACKET));

  00ccc	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 186  : 			Set(HEADER_GC_DRAGON_SOUL_REFINE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDragonSoulRefine), STATIC_SIZE_PACKET));

  00cd1	8d 4d e8	 lea	 ecx, DWORD PTR $T2[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  00cd4	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR $T2[ebp], 5
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 186  : 			Set(HEADER_GC_DRAGON_SOUL_REFINE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDragonSoulRefine), STATIC_SIZE_PACKET));

  00cdb	51		 push	 ecx
  00cdc	68 d1 00 00 00	 push	 209			; 000000d1H
  00ce1	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 13   : 				isDynamicSizePacket = bFlag;

  00ce6	c6 45 ec 00	 mov	 BYTE PTR $T2[ebp+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 186  : 			Set(HEADER_GC_DRAGON_SOUL_REFINE,		CNetworkPacketHeaderMap::TPacketType(sizeof(TPacketGCDragonSoulRefine), STATIC_SIZE_PACKET));

  00cea	e8 00 00 00 00	 call	 ?Set@CNetworkPacketHeaderMap@@QAEXHAAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Set

; 187  : 			
; 188  : 		}

  00cef	b8 00 00 00 00	 mov	 eax, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  00cf4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00cf7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00cfe	59		 pop	 ecx
  00cff	8b e5		 mov	 esp, ebp
  00d01	5d		 pop	 ebp
  00d02	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CMainPacketHeaderMap@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CNetworkPacketHeaderMap@@UAE@XZ ; CNetworkPacketHeaderMap::~CNetworkPacketHeaderMap
__ehhandler$??0CMainPacketHeaderMap@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CMainPacketHeaderMap@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CMainPacketHeaderMap@@QAE@XZ ENDP			; CMainPacketHeaderMap::CMainPacketHeaderMap
; Function compile flags: /Ogtp
;	COMDAT ??_GCMainPacketHeaderMap@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMainPacketHeaderMap@@UAEPAXI@Z PROC		; CMainPacketHeaderMap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CNetworkPacketHeaderMap@@UAE@XZ ; CNetworkPacketHeaderMap::~CNetworkPacketHeaderMap
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN7@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN7@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCMainPacketHeaderMap@@UAEPAXI@Z ENDP		; CMainPacketHeaderMap::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1CMainPacketHeaderMap@@UAE@XZ
_TEXT	SEGMENT
??1CMainPacketHeaderMap@@UAE@XZ PROC			; CMainPacketHeaderMap::~CMainPacketHeaderMap, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1CNetworkPacketHeaderMap@@UAE@XZ ; CNetworkPacketHeaderMap::~CNetworkPacketHeaderMap
??1CMainPacketHeaderMap@@UAE@XZ ENDP			; CMainPacketHeaderMap::~CMainPacketHeaderMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?ExitApplication@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?ExitApplication@CPythonNetworkStream@@QAEXXZ PROC	; CPythonNetworkStream::ExitApplication, COMDAT
; _this$ = ecx

; 195  : 	if (__IsNotPing())

  00000	e8 00 00 00 00	 call	 ?__IsNotPing@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__IsNotPing
  00005	84 c0		 test	 al, al
  00007	0f 85 00 00 00
	00		 jne	 ?AbsoluteExitApplication@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::AbsoluteExitApplication

; 196  : 	{
; 197  : 		AbsoluteExitApplication();
; 198  : 	}
; 199  : 	else
; 200  : 	{
; 201  : 		SendChatPacket("/quit");

  0000d	6a 00		 push	 0
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_05CMMBDMDD@?1quit?$AA@
  00014	e8 00 00 00 00	 call	 ?SendChatPacket@CPythonNetworkStream@@QAE_NPBDE@Z ; CPythonNetworkStream::SendChatPacket

; 202  : 	}
; 203  : }

  00019	c3		 ret	 0
?ExitApplication@CPythonNetworkStream@@QAEXXZ ENDP	; CPythonNetworkStream::ExitApplication
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?ExitGame@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?ExitGame@CPythonNetworkStream@@QAEXXZ PROC		; CPythonNetworkStream::ExitGame, COMDAT
; _this$ = ecx

; 207  : 	if (__IsNotPing())

  00000	e8 00 00 00 00	 call	 ?__IsNotPing@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__IsNotPing
  00005	84 c0		 test	 al, al
  00007	0f 85 00 00 00
	00		 jne	 ?LogOutGame@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::LogOutGame

; 208  : 	{
; 209  : 		LogOutGame();
; 210  : 	}
; 211  : 	else
; 212  : 	{
; 213  : 		SendChatPacket("/phase_select");

  0000d	6a 00		 push	 0
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@ODIJHOCP@?1phase_select?$AA@
  00014	e8 00 00 00 00	 call	 ?SendChatPacket@CPythonNetworkStream@@QAE_NPBDE@Z ; CPythonNetworkStream::SendChatPacket

; 214  : 	}
; 215  : }

  00019	c3		 ret	 0
?ExitGame@CPythonNetworkStream@@QAEXXZ ENDP		; CPythonNetworkStream::ExitGame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?LogOutGame@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?LogOutGame@CPythonNetworkStream@@QAEXXZ PROC		; CPythonNetworkStream::LogOutGame, COMDAT
; _this$ = ecx

; 220  : 	if (__IsNotPing())

  00000	e8 00 00 00 00	 call	 ?__IsNotPing@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__IsNotPing
  00005	84 c0		 test	 al, al
  00007	0f 85 00 00 00
	00		 jne	 ?AbsoluteExitGame@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::AbsoluteExitGame

; 221  : 	{		
; 222  : 		AbsoluteExitGame();
; 223  : 	}	
; 224  : 	else
; 225  : 	{
; 226  : 		SendChatPacket("/logout");

  0000d	6a 00		 push	 0
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_07FOABJBDD@?1logout?$AA@
  00014	e8 00 00 00 00	 call	 ?SendChatPacket@CPythonNetworkStream@@QAE_NPBDE@Z ; CPythonNetworkStream::SendChatPacket

; 227  : 	}
; 228  : }

  00019	c3		 ret	 0
?LogOutGame@CPythonNetworkStream@@QAEXXZ ENDP		; CPythonNetworkStream::LogOutGame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?AbsoluteExitGame@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?AbsoluteExitGame@CPythonNetworkStream@@QAEXXZ PROC	; CPythonNetworkStream::AbsoluteExitGame, COMDAT
; _this$ = ecx

; 231  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 232  : 	if (!IsOnline())

  00003	e8 00 00 00 00	 call	 ?IsOnline@CNetworkStream@@QAE_NXZ ; CNetworkStream::IsOnline
  00008	84 c0		 test	 al, al
  0000a	74 0f		 je	 SHORT $LN2@AbsoluteEx

; 233  : 		return;
; 234  : 
; 235  : 	OnRemoteDisconnect();		

  0000c	8b 06		 mov	 eax, DWORD PTR [esi]
  0000e	8b ce		 mov	 ecx, esi
  00010	ff 50 0c	 call	 DWORD PTR [eax+12]

; 236  : 	Disconnect();

  00013	8b ce		 mov	 ecx, esi
  00015	5e		 pop	 esi
  00016	e9 00 00 00 00	 jmp	 ?Disconnect@CNetworkStream@@QAEXXZ ; CNetworkStream::Disconnect
$LN2@AbsoluteEx:
  0001b	5e		 pop	 esi

; 237  : }

  0001c	c3		 ret	 0
?AbsoluteExitGame@CPythonNetworkStream@@QAEXXZ ENDP	; CPythonNetworkStream::AbsoluteExitGame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?AbsoluteExitApplication@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?AbsoluteExitApplication@CPythonNetworkStream@@QAEXXZ PROC ; CPythonNetworkStream::AbsoluteExitApplication, COMDAT
; _this$dead$ = ecx

; 241  : 	PostQuitMessage(0);

  00000	6a 00		 push	 0
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 242  : }

  00008	c3		 ret	 0
?AbsoluteExitApplication@CPythonNetworkStream@@QAEXXZ ENDP ; CPythonNetworkStream::AbsoluteExitApplication
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?__IsNotPing@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
?__IsNotPing@CPythonNetworkStream@@IAE_NXZ PROC		; CPythonNetworkStream::__IsNotPing, COMDAT
; _this$dead$ = ecx

; 246  : 	//        .
; 247  : 	return false;

  00000	32 c0		 xor	 al, al

; 248  : }

  00002	c3		 ret	 0
?__IsNotPing@CPythonNetworkStream@@IAE_NXZ ENDP		; CPythonNetworkStream::__IsNotPing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?GetGuildID@CPythonNetworkStream@@QAEKXZ
_TEXT	SEGMENT
?GetGuildID@CPythonNetworkStream@@QAEKXZ PROC		; CPythonNetworkStream::GetGuildID, COMDAT
; _this$ = ecx

; 252  : 	return m_dwGuildID;

  00000	8b 81 b0 00 00
	00		 mov	 eax, DWORD PTR [ecx+176]

; 253  : }

  00006	c3		 ret	 0
?GetGuildID@CPythonNetworkStream@@QAEKXZ ENDP		; CPythonNetworkStream::GetGuildID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?UploadMark@CPythonNetworkStream@@QAEIPBD@Z
_TEXT	SEGMENT
_uError$ = -4						; size = 4
_c_szImageFileName$ = 8					; size = 4
?UploadMark@CPythonNetworkStream@@QAEIPBD@Z PROC	; CPythonNetworkStream::UploadMark, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 257  : 	// MARK_BUG_FIX
; 258  : 	//      0.
; 259  : 	if (0 == m_dwGuildID)

  00007	8b 86 b0 00 00
	00		 mov	 eax, DWORD PTR [esi+176]
  0000d	85 c0		 test	 eax, eax
  0000f	75 0c		 jne	 SHORT $LN10@UploadMark

; 260  : 		return ERROR_MARK_UPLOAD_NEED_RECONNECT;

  00011	b8 06 00 00 00	 mov	 eax, 6
  00016	5e		 pop	 esi

; 293  : 		return ERROR_MARK_CHECK_NEED_RECONNECT;
; 294  : 
; 295  : 	return ERROR_NONE;
; 296  : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN10@UploadMark:

; 261  : 
; 262  : 	gs_nextDownloadMarkTime = 0;
; 263  : 	// END_OF_MARK_BUG_FIX
; 264  : 
; 265  : 	UINT uError=ERROR_UNKNOWN;
; 266  : 	CGuildMarkUploader& rkGuildMarkUploader=CGuildMarkUploader::Instance();
; 267  : 	if (!rkGuildMarkUploader.Connect(m_kMarkAuth.m_kNetAddr, m_kMarkAuth.m_dwHandle, m_kMarkAuth.m_dwRandomKey, m_dwGuildID, c_szImageFileName, &uError))

  0001d	8d 4d fc	 lea	 ecx, DWORD PTR _uError$[ebp]
  00020	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gs_nextDownloadMarkTime, 0
  0002a	51		 push	 ecx
  0002b	ff 75 08	 push	 DWORD PTR _c_szImageFileName$[ebp]
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCGuildMarkUploader@@@@0PAVCGuildMarkUploader@@A ; CSingleton<CGuildMarkUploader>::ms_singleton
  00034	50		 push	 eax
  00035	ff b6 0c 79 00
	00		 push	 DWORD PTR [esi+30988]
  0003b	8d 86 f8 78 00
	00		 lea	 eax, DWORD PTR [esi+30968]
  00041	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _uError$[ebp], 1
  00048	ff b6 08 79 00
	00		 push	 DWORD PTR [esi+30984]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?Connect@CGuildMarkUploader@@QAE_NABVCNetworkAddress@@KKKPBDPAI@Z ; CGuildMarkUploader::Connect
  00054	84 c0		 test	 al, al
  00056	75 4c		 jne	 SHORT $LN7@UploadMark

; 268  : 	{
; 269  : 		switch (uError)

  00058	8b 45 fc	 mov	 eax, DWORD PTR _uError$[ebp]
  0005b	48		 dec	 eax
  0005c	83 f8 03	 cmp	 eax, 3
  0005f	77 37		 ja	 SHORT $LN2@UploadMark
  00061	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@UploadMark[eax*4]
$LN6@UploadMark:

; 270  : 		{
; 271  : 			case CGuildMarkUploader::ERROR_CONNECT:
; 272  : 				return ERROR_CONNECT_MARK_SERVER;

  00068	b8 02 00 00 00	 mov	 eax, 2
  0006d	5e		 pop	 esi

; 293  : 		return ERROR_MARK_CHECK_NEED_RECONNECT;
; 294  : 
; 295  : 	return ERROR_NONE;
; 296  : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN5@UploadMark:

; 273  : 				break;
; 274  : 			case CGuildMarkUploader::ERROR_LOAD:
; 275  : 				return ERROR_LOAD_MARK;

  00074	b8 03 00 00 00	 mov	 eax, 3
  00079	5e		 pop	 esi

; 293  : 		return ERROR_MARK_CHECK_NEED_RECONNECT;
; 294  : 
; 295  : 	return ERROR_NONE;
; 296  : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
$LN4@UploadMark:

; 276  : 				break;
; 277  : 			case CGuildMarkUploader::ERROR_WIDTH:
; 278  : 				return ERROR_MARK_WIDTH;

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	5e		 pop	 esi

; 293  : 		return ERROR_MARK_CHECK_NEED_RECONNECT;
; 294  : 
; 295  : 	return ERROR_NONE;
; 296  : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
$LN3@UploadMark:

; 279  : 				break;
; 280  : 			case CGuildMarkUploader::ERROR_HEIGHT:
; 281  : 				return ERROR_MARK_HEIGHT;

  0008c	b8 05 00 00 00	 mov	 eax, 5
  00091	5e		 pop	 esi

; 293  : 		return ERROR_MARK_CHECK_NEED_RECONNECT;
; 294  : 
; 295  : 	return ERROR_NONE;
; 296  : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
$LN2@UploadMark:

; 282  : 				break;
; 283  : 			default:
; 284  : 				return ERROR_UNKNOWN;

  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	5e		 pop	 esi

; 293  : 		return ERROR_MARK_CHECK_NEED_RECONNECT;
; 294  : 
; 295  : 	return ERROR_NONE;
; 296  : }

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
$LN7@UploadMark:

; 285  : 		}
; 286  : 	}
; 287  : 
; 288  : 	// MARK_BUG_FIX	
; 289  : 	__DownloadMark();

  000a4	8b ce		 mov	 ecx, esi
  000a6	e8 00 00 00 00	 call	 ?__DownloadMark@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__DownloadMark

; 290  : 	// END_OF_MARK_BUG_FIX
; 291  : 	
; 292  : 	if (CGuildMarkManager::INVALID_MARK_ID == CGuildMarkManager::Instance().GetMarkID(m_dwGuildID))

  000ab	ff b6 b0 00 00
	00		 push	 DWORD PTR [esi+176]
  000b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$singleton@VCGuildMarkManager@@@@0PAVCGuildMarkManager@@A ; singleton<CGuildMarkManager>::ms_singleton
  000b7	e8 00 00 00 00	 call	 ?GetMarkID@CGuildMarkManager@@QAEKK@Z ; CGuildMarkManager::GetMarkID
  000bc	33 c9		 xor	 ecx, ecx
  000be	ba 07 00 00 00	 mov	 edx, 7
  000c3	83 f8 ff	 cmp	 eax, -1
  000c6	5e		 pop	 esi
  000c7	0f 44 ca	 cmove	 ecx, edx
  000ca	8b c1		 mov	 eax, ecx

; 293  : 		return ERROR_MARK_CHECK_NEED_RECONNECT;
; 294  : 
; 295  : 	return ERROR_NONE;
; 296  : }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 04 00	 ret	 4
  000d2	8b ff		 npad	 2
$LN18@UploadMark:
  000d4	00 00 00 00	 DD	 $LN6@UploadMark
  000d8	00 00 00 00	 DD	 $LN5@UploadMark
  000dc	00 00 00 00	 DD	 $LN4@UploadMark
  000e0	00 00 00 00	 DD	 $LN3@UploadMark
?UploadMark@CPythonNetworkStream@@QAEIPBD@Z ENDP	; CPythonNetworkStream::UploadMark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?UploadSymbol@CPythonNetworkStream@@QAEIPBD@Z
_TEXT	SEGMENT
_uError$ = -4						; size = 4
_c_szImageFileName$ = 8					; size = 4
?UploadSymbol@CPythonNetworkStream@@QAEIPBD@Z PROC	; CPythonNetworkStream::UploadSymbol, COMDAT
; _this$ = ecx

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 300  : 	UINT uError=ERROR_UNKNOWN;
; 301  : 	CGuildMarkUploader& rkGuildMarkUploader=CGuildMarkUploader::Instance();
; 302  : 	if (!rkGuildMarkUploader.ConnectToSendSymbol(m_kMarkAuth.m_kNetAddr, m_kMarkAuth.m_dwHandle, m_kMarkAuth.m_dwRandomKey, m_dwGuildID, c_szImageFileName, &uError))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _uError$[ebp]
  00007	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _uError$[ebp], 1
  0000e	50		 push	 eax
  0000f	ff 75 08	 push	 DWORD PTR _c_szImageFileName$[ebp]
  00012	8d 81 f8 78 00
	00		 lea	 eax, DWORD PTR [ecx+30968]
  00018	ff b1 b0 00 00
	00		 push	 DWORD PTR [ecx+176]
  0001e	ff b1 0c 79 00
	00		 push	 DWORD PTR [ecx+30988]
  00024	ff b1 08 79 00
	00		 push	 DWORD PTR [ecx+30984]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCGuildMarkUploader@@@@0PAVCGuildMarkUploader@@A ; CSingleton<CGuildMarkUploader>::ms_singleton
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?ConnectToSendSymbol@CGuildMarkUploader@@QAE_NABVCNetworkAddress@@KKKPBDPAI@Z ; CGuildMarkUploader::ConnectToSendSymbol
  00036	84 c0		 test	 al, al
  00038	75 47		 jne	 SHORT $LN6@UploadSymb

; 303  : 	{
; 304  : 		switch (uError)

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _uError$[ebp]
  0003d	48		 dec	 eax
  0003e	83 f8 03	 cmp	 eax, 3
  00041	77 33		 ja	 SHORT $LN1@UploadSymb
  00043	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@UploadSymb[eax*4]
$LN5@UploadSymb:

; 305  : 		{
; 306  : 			case CGuildMarkUploader::ERROR_CONNECT:
; 307  : 				return ERROR_CONNECT_MARK_SERVER;

  0004a	b8 02 00 00 00	 mov	 eax, 2

; 324  : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN4@UploadSymb:

; 308  : 				break;
; 309  : 			case CGuildMarkUploader::ERROR_LOAD:
; 310  : 				return ERROR_LOAD_MARK;

  00055	b8 03 00 00 00	 mov	 eax, 3

; 324  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
$LN3@UploadSymb:

; 311  : 				break;
; 312  : 			case CGuildMarkUploader::ERROR_WIDTH:
; 313  : 				return ERROR_MARK_WIDTH;

  00060	b8 04 00 00 00	 mov	 eax, 4

; 324  : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
$LN2@UploadSymb:

; 314  : 				break;
; 315  : 			case CGuildMarkUploader::ERROR_HEIGHT:
; 316  : 				return ERROR_MARK_HEIGHT;

  0006b	b8 05 00 00 00	 mov	 eax, 5

; 324  : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN1@UploadSymb:

; 317  : 				break;
; 318  : 			default:
; 319  : 				return ERROR_UNKNOWN;

  00076	b8 01 00 00 00	 mov	 eax, 1

; 324  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
$LN6@UploadSymb:

; 320  : 		}
; 321  : 	}
; 322  : 
; 323  : 	return ERROR_NONE;

  00081	33 c0		 xor	 eax, eax

; 324  : }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
  00089	8d 49 00	 npad	 3
$LN14@UploadSymb:
  0008c	00 00 00 00	 DD	 $LN5@UploadSymb
  00090	00 00 00 00	 DD	 $LN4@UploadSymb
  00094	00 00 00 00	 DD	 $LN3@UploadSymb
  00098	00 00 00 00	 DD	 $LN2@UploadSymb
?UploadSymbol@CPythonNetworkStream@@QAEIPBD@Z ENDP	; CPythonNetworkStream::UploadSymbol
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?__DownloadMark@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__DownloadMark@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::__DownloadMark, COMDAT
; _this$ = ecx

; 327  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 328  : 	// 3    .
; 329  : 	DWORD curTime = ELTimer_GetMSec();

  00003	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 330  : 
; 331  : 	if (curTime < gs_nextDownloadMarkTime)

  00008	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _gs_nextDownloadMarkTime
  0000e	72 28		 jb	 SHORT $LN2@DownloadMa

; 332  : 		return;
; 333  : 
; 334  : 	gs_nextDownloadMarkTime = curTime + 60000 * 3; // 3
; 335  : 
; 336  : 	CGuildMarkDownloader& rkGuildMarkDownloader = CGuildMarkDownloader::Instance();
; 337  : 	rkGuildMarkDownloader.Connect(m_kMarkAuth.m_kNetAddr, m_kMarkAuth.m_dwHandle, m_kMarkAuth.m_dwRandomKey);

  00010	ff b6 0c 79 00
	00		 push	 DWORD PTR [esi+30988]
  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCGuildMarkDownloader@@@@0PAVCGuildMarkDownloader@@A ; CSingleton<CGuildMarkDownloader>::ms_singleton
  0001c	05 20 bf 02 00	 add	 eax, 180000		; 0002bf20H
  00021	ff b6 08 79 00
	00		 push	 DWORD PTR [esi+30984]
  00027	a3 00 00 00 00	 mov	 DWORD PTR _gs_nextDownloadMarkTime, eax
  0002c	8d 86 f8 78 00
	00		 lea	 eax, DWORD PTR [esi+30968]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?Connect@CGuildMarkDownloader@@QAE_NABVCNetworkAddress@@KK@Z ; CGuildMarkDownloader::Connect
$LN2@DownloadMa:
  00038	5e		 pop	 esi

; 338  : }

  00039	c3		 ret	 0
?__DownloadMark@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::__DownloadMark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?__DownloadSymbol@CPythonNetworkStream@@IAEXABV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
_c_rkVec_dwGuildID$ = 8					; size = 4
?__DownloadSymbol@CPythonNetworkStream@@IAEXABV?$vector@KV?$allocator@K@std@@@std@@@Z PROC ; CPythonNetworkStream::__DownloadSymbol, COMDAT
; _this$ = ecx

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 342  : 	CGuildMarkDownloader& rkGuildMarkDownloader=CGuildMarkDownloader::Instance();
; 343  : 	rkGuildMarkDownloader.ConnectToRecvSymbol(m_kMarkAuth.m_kNetAddr, m_kMarkAuth.m_dwHandle, m_kMarkAuth.m_dwRandomKey, c_rkVec_dwGuildID);

  00003	ff 75 08	 push	 DWORD PTR _c_rkVec_dwGuildID$[ebp]
  00006	8d 81 f8 78 00
	00		 lea	 eax, DWORD PTR [ecx+30968]
  0000c	ff b1 0c 79 00
	00		 push	 DWORD PTR [ecx+30988]
  00012	ff b1 08 79 00
	00		 push	 DWORD PTR [ecx+30984]
  00018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCGuildMarkDownloader@@@@0PAVCGuildMarkDownloader@@A ; CSingleton<CGuildMarkDownloader>::ms_singleton
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?ConnectToRecvSymbol@CGuildMarkDownloader@@QAE_NABVCNetworkAddress@@KKABV?$vector@KV?$allocator@K@std@@@std@@@Z ; CGuildMarkDownloader::ConnectToRecvSymbol

; 344  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?__DownloadSymbol@CPythonNetworkStream@@IAEXABV?$vector@KV?$allocator@K@std@@@std@@@Z ENDP ; CPythonNetworkStream::__DownloadSymbol
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SetPhaseWindow@CPythonNetworkStream@@QAEXIPAU_object@@@Z
_TEXT	SEGMENT
_ePhaseWnd$ = 8						; size = 4
_poPhaseWnd$ = 12					; size = 4
?SetPhaseWindow@CPythonNetworkStream@@QAEXIPAU_object@@@Z PROC ; CPythonNetworkStream::SetPhaseWindow, COMDAT
; _this$ = ecx

; 347  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 348  : 	if (ePhaseWnd>=PHASE_WINDOW_NUM)

  00003	8b 55 08	 mov	 edx, DWORD PTR _ePhaseWnd$[ebp]
  00006	83 fa 07	 cmp	 edx, 7
  00009	73 0a		 jae	 SHORT $LN2@SetPhaseWi

; 349  : 		return;
; 350  : 
; 351  : 	m_apoPhaseWnd[ePhaseWnd]=poPhaseWnd;

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _poPhaseWnd$[ebp]
  0000e	89 84 91 7c 01
	00 00		 mov	 DWORD PTR [ecx+edx*4+380], eax
$LN2@SetPhaseWi:

; 352  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?SetPhaseWindow@CPythonNetworkStream@@QAEXIPAU_object@@@Z ENDP ; CPythonNetworkStream::SetPhaseWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?ClearPhaseWindow@CPythonNetworkStream@@QAEXIPAU_object@@@Z
_TEXT	SEGMENT
_ePhaseWnd$ = 8						; size = 4
_poPhaseWnd$ = 12					; size = 4
?ClearPhaseWindow@CPythonNetworkStream@@QAEXIPAU_object@@@Z PROC ; CPythonNetworkStream::ClearPhaseWindow, COMDAT
; _this$ = ecx

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  : 	if (ePhaseWnd>=PHASE_WINDOW_NUM)

  00003	8b 55 08	 mov	 edx, DWORD PTR _ePhaseWnd$[ebp]
  00006	83 fa 07	 cmp	 edx, 7
  00009	73 17		 jae	 SHORT $LN3@ClearPhase

; 357  : 		return;
; 358  : 
; 359  : 	if (poPhaseWnd != m_apoPhaseWnd[ePhaseWnd])

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _poPhaseWnd$[ebp]
  0000e	3b 84 91 7c 01
	00 00		 cmp	 eax, DWORD PTR [ecx+edx*4+380]
  00015	75 0b		 jne	 SHORT $LN3@ClearPhase

; 360  : 		return;
; 361  : 
; 362  : 	m_apoPhaseWnd[ePhaseWnd]=0;

  00017	c7 84 91 7c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+edx*4+380], 0
$LN3@ClearPhase:

; 363  : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?ClearPhaseWindow@CPythonNetworkStream@@QAEXIPAU_object@@@Z ENDP ; CPythonNetworkStream::ClearPhaseWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SetServerCommandParserWindow@CPythonNetworkStream@@QAEXPAU_object@@@Z
_TEXT	SEGMENT
_poWnd$ = 8						; size = 4
?SetServerCommandParserWindow@CPythonNetworkStream@@QAEXPAU_object@@@Z PROC ; CPythonNetworkStream::SetServerCommandParserWindow, COMDAT
; _this$ = ecx

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 367  : 	m_poSerCommandParserWnd = poWnd;

  00003	8b 45 08	 mov	 eax, DWORD PTR _poWnd$[ebp]
  00006	89 81 98 01 00
	00		 mov	 DWORD PTR [ecx+408], eax

; 368  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetServerCommandParserWindow@CPythonNetworkStream@@QAEXPAU_object@@@Z ENDP ; CPythonNetworkStream::SetServerCommandParserWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?IsSelectedEmpire@CPythonNetworkStream@@QAE_NXZ
_TEXT	SEGMENT
?IsSelectedEmpire@CPythonNetworkStream@@QAE_NXZ PROC	; CPythonNetworkStream::IsSelectedEmpire, COMDAT
; _this$ = ecx

; 372  : 	if (m_dwEmpireID)

  00000	83 b9 b4 00 00
	00 00		 cmp	 DWORD PTR [ecx+180], 0
  00007	0f 95 c0	 setne	 al

; 373  : 		return true;
; 374  : 	
; 375  : 	return false;
; 376  : }

  0000a	c3		 ret	 0
?IsSelectedEmpire@CPythonNetworkStream@@QAE_NXZ ENDP	; CPythonNetworkStream::IsSelectedEmpire
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?GetAccountCharacterSlotDatau@CPythonNetworkStream@@QAEIII@Z
_TEXT	SEGMENT
_iSlot$ = 8						; size = 4
_eType$ = 12						; size = 4
?GetAccountCharacterSlotDatau@CPythonNetworkStream@@QAEIII@Z PROC ; CPythonNetworkStream::GetAccountCharacterSlotDatau, COMDAT
; _this$ = ecx

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 380  : 	if (iSlot >= PLAYER_PER_ACCOUNT4)

  00003	8b 55 08	 mov	 edx, DWORD PTR _iSlot$[ebp]
  00006	83 fa 04	 cmp	 edx, 4
  00009	72 06		 jb	 SHORT $LN16@GetAccount

; 381  : 		return 0;

  0000b	33 c0		 xor	 eax, eax

; 419  : }

  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
$LN16@GetAccount:

; 382  : 		
; 383  : 	TSimplePlayerInformation&	rkSimplePlayerInfo=m_akSimplePlayerInfo[iSlot];

  00011	8b c2		 mov	 eax, edx
  00013	c1 e0 06	 shl	 eax, 6
  00016	2b c2		 sub	 eax, edx
  00018	05 9c 01 00 00	 add	 eax, 412		; 0000019cH
  0001d	56		 push	 esi

; 384  : 	
; 385  : 	switch (eType)

  0001e	8b 75 0c	 mov	 esi, DWORD PTR _eType$[ebp]
  00021	03 c1		 add	 eax, ecx
  00023	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00026	77 7c		 ja	 SHORT $LN14@GetAccount
  00028	ff 24 b5 00 00
	00 00		 jmp	 DWORD PTR $LN21@GetAccount[esi*4]
$LN13@GetAccount:

; 386  : 	{
; 387  : 		case ACCOUNT_CHARACTER_SLOT_ID:
; 388  : 			return rkSimplePlayerInfo.dwID;

  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	5e		 pop	 esi

; 419  : }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
$LN12@GetAccount:

; 389  : 		case ACCOUNT_CHARACTER_SLOT_RACE:
; 390  : 			return rkSimplePlayerInfo.byJob;

  00036	0f b6 40 1d	 movzx	 eax, BYTE PTR [eax+29]
  0003a	5e		 pop	 esi

; 419  : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN11@GetAccount:

; 391  : 		case ACCOUNT_CHARACTER_SLOT_LEVEL:
; 392  : 			return rkSimplePlayerInfo.byLevel;

  0003f	0f b6 40 1e	 movzx	 eax, BYTE PTR [eax+30]
  00043	5e		 pop	 esi

; 419  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
$LN10@GetAccount:

; 393  : 		case ACCOUNT_CHARACTER_SLOT_STR:
; 394  : 			return rkSimplePlayerInfo.byST;

  00048	0f b6 40 23	 movzx	 eax, BYTE PTR [eax+35]
  0004c	5e		 pop	 esi

; 419  : }

  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
$LN9@GetAccount:

; 395  : 		case ACCOUNT_CHARACTER_SLOT_DEX:
; 396  : 			return rkSimplePlayerInfo.byDX;

  00051	0f b6 40 25	 movzx	 eax, BYTE PTR [eax+37]
  00055	5e		 pop	 esi

; 419  : }

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
$LN8@GetAccount:

; 397  : 		case ACCOUNT_CHARACTER_SLOT_HTH:
; 398  : 			return rkSimplePlayerInfo.byHT;

  0005a	0f b6 40 24	 movzx	 eax, BYTE PTR [eax+36]
  0005e	5e		 pop	 esi

; 419  : }

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
$LN7@GetAccount:

; 399  : 		case ACCOUNT_CHARACTER_SLOT_INT:			
; 400  : 			return rkSimplePlayerInfo.byIQ;

  00063	0f b6 40 26	 movzx	 eax, BYTE PTR [eax+38]
  00067	5e		 pop	 esi

; 419  : }

  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
$LN6@GetAccount:

; 401  : 		case ACCOUNT_CHARACTER_SLOT_PLAYTIME:
; 402  : 			return rkSimplePlayerInfo.dwPlayMinutes;

  0006c	8b 40 1f	 mov	 eax, DWORD PTR [eax+31]
  0006f	5e		 pop	 esi

; 419  : }

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
$LN5@GetAccount:

; 403  : 		case ACCOUNT_CHARACTER_SLOT_FORM:
; 404  : //			return rkSimplePlayerInfo.wParts[CRaceData::PART_MAIN];
; 405  : 			return rkSimplePlayerInfo.wMainPart;

  00074	0f b7 40 27	 movzx	 eax, WORD PTR [eax+39]
  00078	5e		 pop	 esi

; 419  : }

  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
$LN4@GetAccount:

; 406  : 		case ACCOUNT_CHARACTER_SLOT_PORT:
; 407  : 			return rkSimplePlayerInfo.wPort;

  0007d	0f b7 40 3c	 movzx	 eax, WORD PTR [eax+60]
  00081	5e		 pop	 esi

; 419  : }

  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
$LN3@GetAccount:

; 408  : 		case ACCOUNT_CHARACTER_SLOT_GUILD_ID:
; 409  : 			return m_adwGuildID[iSlot];

  00086	8b 84 91 98 02
	00 00		 mov	 eax, DWORD PTR [ecx+edx*4+664]
  0008d	5e		 pop	 esi

; 419  : }

  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
$LN2@GetAccount:

; 410  : 			break;
; 411  : 		case ACCOUNT_CHARACTER_SLOT_CHANGE_NAME_FLAG:
; 412  : 			return rkSimplePlayerInfo.bChangeName;

  00092	0f b6 40 29	 movzx	 eax, BYTE PTR [eax+41]
  00096	5e		 pop	 esi

; 419  : }

  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
$LN1@GetAccount:

; 413  : 			break;
; 414  : 		case ACCOUNT_CHARACTER_SLOT_HAIR:
; 415  : 			return rkSimplePlayerInfo.wHairPart;

  0009b	0f b7 40 2a	 movzx	 eax, WORD PTR [eax+42]
  0009f	5e		 pop	 esi

; 419  : }

  000a0	5d		 pop	 ebp
  000a1	c2 08 00	 ret	 8
$LN14@GetAccount:

; 416  : 			break;
; 417  : 	}
; 418  : 	return 0;

  000a4	33 c0		 xor	 eax, eax
  000a6	5e		 pop	 esi

; 419  : }

  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
  000ab	90		 npad	 1
$LN21@GetAccount:
  000ac	00 00 00 00	 DD	 $LN13@GetAccount
  000b0	00 00 00 00	 DD	 $LN14@GetAccount
  000b4	00 00 00 00	 DD	 $LN12@GetAccount
  000b8	00 00 00 00	 DD	 $LN11@GetAccount
  000bc	00 00 00 00	 DD	 $LN10@GetAccount
  000c0	00 00 00 00	 DD	 $LN9@GetAccount
  000c4	00 00 00 00	 DD	 $LN8@GetAccount
  000c8	00 00 00 00	 DD	 $LN7@GetAccount
  000cc	00 00 00 00	 DD	 $LN6@GetAccount
  000d0	00 00 00 00	 DD	 $LN5@GetAccount
  000d4	00 00 00 00	 DD	 $LN14@GetAccount
  000d8	00 00 00 00	 DD	 $LN4@GetAccount
  000dc	00 00 00 00	 DD	 $LN3@GetAccount
  000e0	00 00 00 00	 DD	 $LN14@GetAccount
  000e4	00 00 00 00	 DD	 $LN2@GetAccount
  000e8	00 00 00 00	 DD	 $LN1@GetAccount
?GetAccountCharacterSlotDatau@CPythonNetworkStream@@QAEIII@Z ENDP ; CPythonNetworkStream::GetAccountCharacterSlotDatau
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?GetAccountCharacterSlotDataz@CPythonNetworkStream@@QAEPBDII@Z
_TEXT	SEGMENT
_iSlot$ = 8						; size = 4
_eType$ = 12						; size = 4
?GetAccountCharacterSlotDataz@CPythonNetworkStream@@QAEPBDII@Z PROC ; CPythonNetworkStream::GetAccountCharacterSlotDataz, COMDAT
; _this$ = ecx

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 423  : 	static const char* sc_szEmpty="";
; 424  : 
; 425  : 	if (iSlot >= PLAYER_PER_ACCOUNT4)

  00003	8b 55 08	 mov	 edx, DWORD PTR _iSlot$[ebp]
  00006	83 fa 04	 cmp	 edx, 4
  00009	72 09		 jb	 SHORT $LN9@GetAccount

; 426  : 		return sc_szEmpty;

  0000b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 457  : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
$LN9@GetAccount:

; 427  : 		
; 428  : 	TSimplePlayerInformation&	rkSimplePlayerInfo=m_akSimplePlayerInfo[iSlot];

  00014	8b c2		 mov	 eax, edx
  00016	c1 e0 06	 shl	 eax, 6
  00019	56		 push	 esi
  0001a	2b c2		 sub	 eax, edx
  0001c	8d b1 9c 01 00
	00		 lea	 esi, DWORD PTR [ecx+412]
  00022	03 f0		 add	 esi, eax

; 429  : 	
; 430  : 	switch (eType)

  00024	8b 45 0c	 mov	 eax, DWORD PTR _eType$[ebp]
  00027	48		 dec	 eax
  00028	74 78		 je	 SHORT $LN2@GetAccount
  0002a	83 e8 09	 sub	 eax, 9
  0002d	74 29		 je	 SHORT $LN6@GetAccount
  0002f	83 e8 03	 sub	 eax, 3
  00032	74 0a		 je	 SHORT $LN1@GetAccount

; 454  : 			break;
; 455  : 	}
; 456  : 	return sc_szEmpty;

  00034	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00039	5e		 pop	 esi

; 457  : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN1@GetAccount:

; 453  : 			return m_astrGuildName[iSlot].c_str();

  0003e	8d 04 55 55 00
	00 00		 lea	 eax, DWORD PTR [edx*2+85]
  00045	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00047	83 7c c1 14 10	 cmp	 DWORD PTR [ecx+eax*8+20], 16 ; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 453  : 			return m_astrGuildName[iSlot].c_str();

  0004c	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0004f	72 54		 jb	 SHORT $LN28@GetAccount
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 457  : }

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
$LN6@GetAccount:

; 431  : 	{
; 432  : 		case ACCOUNT_CHARACTER_SLOT_ADDR:
; 433  : 			{				
; 434  : 				BYTE ip[4];
; 435  : 
; 436  : 				const int LEN = 4;
; 437  : 				for (int i = 0; i < LEN; i++)
; 438  : 				{
; 439  : 					ip[i] = BYTE(rkSimplePlayerInfo.lAddr&0xff);

  00058	8a 6e 38	 mov	 ch, BYTE PTR [esi+56]

; 440  : 					rkSimplePlayerInfo.lAddr>>=8;

  0005b	c1 7e 38 08	 sar	 DWORD PTR [esi+56], 8
  0005f	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00062	53		 push	 ebx
  00063	8a da		 mov	 bl, dl
  00065	c1 fa 08	 sar	 edx, 8
  00068	8a ca		 mov	 cl, dl
  0006a	c1 fa 08	 sar	 edx, 8
  0006d	8a c2		 mov	 al, dl
  0006f	c1 fa 08	 sar	 edx, 8

; 441  : 				}
; 442  : 
; 443  : 
; 444  : 				static char s_szAddr[256];
; 445  : 				sprintf(s_szAddr, "%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3]);

  00072	0f b6 c0	 movzx	 eax, al
  00075	50		 push	 eax
  00076	0f b6 c1	 movzx	 eax, cl
  00079	50		 push	 eax
  0007a	0f b6 c3	 movzx	 eax, bl
  0007d	50		 push	 eax
  0007e	0f b6 c5	 movzx	 eax, ch
  00081	50		 push	 eax
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
  00087	68 00 00 00 00	 push	 OFFSET ?s_szAddr@?8??GetAccountCharacterSlotDataz@CPythonNetworkStream@@QAEPBDII@Z@4PADA
  0008c	89 56 38	 mov	 DWORD PTR [esi+56], edx
  0008f	e8 00 00 00 00	 call	 _sprintf
  00094	83 c4 18	 add	 esp, 24			; 00000018H

; 446  : 				return s_szAddr;

  00097	b8 00 00 00 00	 mov	 eax, OFFSET ?s_szAddr@?8??GetAccountCharacterSlotDataz@CPythonNetworkStream@@QAEPBDII@Z@4PADA
  0009c	5b		 pop	 ebx
  0009d	5e		 pop	 esi

; 457  : }

  0009e	5d		 pop	 ebp
  0009f	c2 08 00	 ret	 8
$LN2@GetAccount:

; 447  : 			}
; 448  : 			break;
; 449  : 		case ACCOUNT_CHARACTER_SLOT_NAME:
; 450  : 			return rkSimplePlayerInfo.szName;

  000a2	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$LN28@GetAccount:
  000a5	5e		 pop	 esi

; 457  : }

  000a6	5d		 pop	 ebp
  000a7	c2 08 00	 ret	 8
?GetAccountCharacterSlotDataz@CPythonNetworkStream@@QAEPBDII@Z ENDP ; CPythonNetworkStream::GetAccountCharacterSlotDataz
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?ConnectLoginServer@CPythonNetworkStream@@QAEXPBDI@Z
_TEXT	SEGMENT
_c_szAddr$ = 8						; size = 4
_uPort$ = 12						; size = 4
?ConnectLoginServer@CPythonNetworkStream@@QAEXPBDI@Z PROC ; CPythonNetworkStream::ConnectLoginServer, COMDAT
; _this$ = ecx

; 460  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 461  : 	CNetworkStream::Connect(c_szAddr, uPort);		

  00003	6a 03		 push	 3
  00005	ff 75 0c	 push	 DWORD PTR _uPort$[ebp]
  00008	ff 75 08	 push	 DWORD PTR _c_szAddr$[ebp]
  0000b	e8 00 00 00 00	 call	 ?Connect@CNetworkStream@@QAE_NPBDHH@Z ; CNetworkStream::Connect

; 462  : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?ConnectLoginServer@CPythonNetworkStream@@QAEXPBDI@Z ENDP ; CPythonNetworkStream::ConnectLoginServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SetMarkServer@CPythonNetworkStream@@QAEXPBDI@Z
_TEXT	SEGMENT
_c_szAddr$ = 8						; size = 4
_uPort$ = 12						; size = 4
?SetMarkServer@CPythonNetworkStream@@QAEXPBDI@Z PROC	; CPythonNetworkStream::SetMarkServer, COMDAT
; _this$ = ecx

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 466  : 	m_kMarkAuth.m_kNetAddr.Set(c_szAddr, uPort);

  00003	81 c1 f8 78 00
	00		 add	 ecx, 30968		; 000078f8H

; 467  : }

  00009	5d		 pop	 ebp

; 466  : 	m_kMarkAuth.m_kNetAddr.Set(c_szAddr, uPort);

  0000a	e9 00 00 00 00	 jmp	 ?Set@CNetworkAddress@@QAE_NPBDH@Z ; CNetworkAddress::Set
?SetMarkServer@CPythonNetworkStream@@QAEXPBDI@Z ENDP	; CPythonNetworkStream::SetMarkServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?ConnectGameServer@CPythonNetworkStream@@QAEXI@Z
_TEXT	SEGMENT
_iChrSlot$ = 8						; size = 4
?ConnectGameServer@CPythonNetworkStream@@QAEXI@Z PROC	; CPythonNetworkStream::ConnectGameServer, COMDAT
; _this$ = ecx

; 470  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 471  : 	if (iChrSlot >= PLAYER_PER_ACCOUNT4)

  00003	8b 55 08	 mov	 edx, DWORD PTR _iChrSlot$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	83 fa 04	 cmp	 edx, 4
  0000c	73 2c		 jae	 SHORT $LN2@ConnectGam

; 472  : 		return;
; 473  : 
; 474  : 	m_dwSelectedCharacterIndex = iChrSlot;
; 475  : 
; 476  : 	__DirectEnterMode_Set(iChrSlot);

  0000e	52		 push	 edx
  0000f	89 96 10 79 00
	00		 mov	 DWORD PTR [esi+30992], edx
  00015	e8 00 00 00 00	 call	 ?__DirectEnterMode_Set@CPythonNetworkStream@@AAEXI@Z ; CPythonNetworkStream::__DirectEnterMode_Set

; 477  : 
; 478  : 	TSimplePlayerInformation&	rkSimplePlayerInfo=m_akSimplePlayerInfo[iChrSlot];	

  0001a	8b ca		 mov	 ecx, edx
  0001c	c1 e1 06	 shl	 ecx, 6
  0001f	2b ca		 sub	 ecx, edx

; 479  : 	CNetworkStream::Connect((DWORD)rkSimplePlayerInfo.lAddr, rkSimplePlayerInfo.wPort);

  00021	6a 03		 push	 3
  00023	0f b7 84 31 d8
	01 00 00	 movzx	 eax, WORD PTR [ecx+esi+472]
  0002b	50		 push	 eax
  0002c	ff b4 31 d4 01
	00 00		 push	 DWORD PTR [ecx+esi+468]
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?Connect@CNetworkStream@@QAE_NKHH@Z ; CNetworkStream::Connect
$LN2@ConnectGam:
  0003a	5e		 pop	 esi

; 480  : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?ConnectGameServer@CPythonNetworkStream@@QAEXI@Z ENDP	; CPythonNetworkStream::ConnectGameServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SetLoginInfo@CPythonNetworkStream@@QAEXPBD0@Z
_TEXT	SEGMENT
_c_szID$ = 8						; size = 4
_c_szPassword$ = 12					; size = 4
?SetLoginInfo@CPythonNetworkStream@@QAEXPBD0@Z PROC	; CPythonNetworkStream::SetLoginInfo, COMDAT
; _this$ = ecx

; 483  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00004	8b 75 08	 mov	 esi, DWORD PTR _c_szID$[ebp]
  00007	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 483  : {

  00008	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0000a	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000d	75 04		 jne	 SHORT $LN9@SetLoginIn
  0000f	33 d2		 xor	 edx, edx
  00011	eb 0e		 jmp	 SHORT $LN10@SetLoginIn
$LN9@SetLoginIn:
  00013	8b d6		 mov	 edx, esi
  00015	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL19@SetLoginIn:
  00018	8a 02		 mov	 al, BYTE PTR [edx]
  0001a	42		 inc	 edx
  0001b	84 c0		 test	 al, al
  0001d	75 f9		 jne	 SHORT $LL19@SetLoginIn
  0001f	2b d1		 sub	 edx, ecx
$LN10@SetLoginIn:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00021	52		 push	 edx
  00022	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 484  : 	m_stID=c_szID;

  00023	8d 8f c4 00 00
	00		 lea	 ecx, DWORD PTR [edi+196]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0002e	8b 55 0c	 mov	 edx, DWORD PTR _c_szPassword$[ebp]
  00031	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00034	75 15		 jne	 SHORT $LN17@SetLoginIn
  00036	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00038	51		 push	 ecx
  00039	52		 push	 edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 485  : 	m_stPassword=c_szPassword;

  0003a	8d 8f dc 00 00
	00		 lea	 ecx, DWORD PTR [edi+220]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00040	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 486  : }

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
$LN17@SetLoginIn:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0004b	8b ca		 mov	 ecx, edx
  0004d	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL20@SetLoginIn:
  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL20@SetLoginIn
  00057	2b ce		 sub	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00059	51		 push	 ecx
  0005a	52		 push	 edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 485  : 	m_stPassword=c_szPassword;

  0005b	8d 8f dc 00 00
	00		 lea	 ecx, DWORD PTR [edi+220]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00061	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 486  : }

  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?SetLoginInfo@CPythonNetworkStream@@QAEXPBD0@Z ENDP	; CPythonNetworkStream::SetLoginInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z
_TEXT	SEGMENT
_header$ = -29						; size = 1
_DynamicSizePacketHeader$2 = -28			; size = 3
_PacketType$ = -24					; size = 8
__$EHRec$ = -12						; size = 12
_pRetHeader$ = 8					; size = 4
?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z PROC	; CPythonNetworkStream::CheckPacket, COMDAT
; _this$ = ecx

; 499  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 14	 sub	 esp, 20			; 00000014H
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c4		 xor	 eax, esp
  00020	50		 push	 eax
  00021	8d 44 24 20	 lea	 eax, DWORD PTR __$EHRec$[esp+44]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx

; 500  : 	*pRetHeader = 0;

  0002d	8b 7d 08	 mov	 edi, DWORD PTR _pRetHeader$[ebp]

; 501  : 
; 502  : 	static CMainPacketHeaderMap s_packetHeaderMap;

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4IA
  00035	c6 07 00	 mov	 BYTE PTR [edi], 0
  00038	a8 01		 test	 al, 1
  0003a	75 2a		 jne	 SHORT $LN17@CheckPacke
  0003c	83 c8 01	 or	 eax, 1
  0003f	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4IA, eax
  00044	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+52], 0
  0004c	e8 00 00 00 00	 call	 ??0CMainPacketHeaderMap@@QAE@XZ ; CMainPacketHeaderMap::CMainPacketHeaderMap
  00051	68 00 00 00 00	 push	 OFFSET ??__Fs_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@YAXXZ ; `CPythonNetworkStream::CheckPacket'::`2'::`dynamic atexit destructor for 's_packetHeaderMap''
  00056	e8 00 00 00 00	 call	 _atexit
  0005b	83 c4 04	 add	 esp, 4
  0005e	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+52], -1
$LN17@CheckPacke:

; 503  : 
; 504  : 	TPacketHeader header;
; 505  : 
; 506  : 	if (!Peek(sizeof(TPacketHeader), &header))

  00066	8d 44 24 0f	 lea	 eax, DWORD PTR _header$[esp+44]
  0006a	8b ce		 mov	 ecx, esi
  0006c	50		 push	 eax
  0006d	6a 01		 push	 1
  0006f	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  00074	84 c0		 test	 al, al
  00076	0f 84 ba 00 00
	00		 je	 $LN28@CheckPacke

; 507  : 		return false;
; 508  : 
; 509  : 	if (0 == header)

  0007c	8a 44 24 0f	 mov	 al, BYTE PTR _header$[esp+44]
  00080	84 c0		 test	 al, al
  00082	75 60		 jne	 SHORT $LN8@CheckPacke

; 510  : 	{
; 511  : 		if (!Recv(sizeof(TPacketHeader), &header))

  00084	8d 44 24 0f	 lea	 eax, DWORD PTR _header$[esp+44]
  00088	8b ce		 mov	 ecx, esi
  0008a	50		 push	 eax
  0008b	6a 01		 push	 1
  0008d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00092	84 c0		 test	 al, al
  00094	0f 84 9c 00 00
	00		 je	 $LN28@CheckPacke

; 512  : 			return false;
; 513  : 		
; 514  : 		while (Peek(sizeof(TPacketHeader), &header))

  0009a	8d 44 24 0f	 lea	 eax, DWORD PTR _header$[esp+44]
  0009e	8b ce		 mov	 ecx, esi
  000a0	50		 push	 eax
  000a1	6a 01		 push	 1
  000a3	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  000a8	84 c0		 test	 al, al
  000aa	74 30		 je	 SHORT $LN11@CheckPacke
  000ac	8d 64 24 00	 npad	 4
$LL13@CheckPacke:

; 515  : 		{
; 516  : 			if (0 == header)

  000b0	8a 44 24 0f	 mov	 al, BYTE PTR _header$[esp+44]
  000b4	84 c0		 test	 al, al
  000b6	75 2c		 jne	 SHORT $LN8@CheckPacke

; 517  : 			{
; 518  : 				if (!Recv(sizeof(TPacketHeader), &header))

  000b8	8d 44 24 0f	 lea	 eax, DWORD PTR _header$[esp+44]
  000bc	8b ce		 mov	 ecx, esi
  000be	50		 push	 eax
  000bf	6a 01		 push	 1
  000c1	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  000c6	84 c0		 test	 al, al
  000c8	74 6c		 je	 SHORT $LN28@CheckPacke

; 512  : 			return false;
; 513  : 		
; 514  : 		while (Peek(sizeof(TPacketHeader), &header))

  000ca	8d 44 24 0f	 lea	 eax, DWORD PTR _header$[esp+44]
  000ce	8b ce		 mov	 ecx, esi
  000d0	50		 push	 eax
  000d1	6a 01		 push	 1
  000d3	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  000d8	84 c0		 test	 al, al
  000da	75 d4		 jne	 SHORT $LL13@CheckPacke
$LN11@CheckPacke:

; 519  : 					return false;
; 520  : 			}
; 521  : 			else
; 522  : 			{
; 523  : 				break;
; 524  : 			}
; 525  : 		}
; 526  : 
; 527  : 		if (0 == header)

  000dc	8a 44 24 0f	 mov	 al, BYTE PTR _header$[esp+44]
  000e0	84 c0		 test	 al, al
  000e2	74 52		 je	 SHORT $LN28@CheckPacke
$LN8@CheckPacke:

; 533  : 	if (!s_packetHeaderMap.Get(header, &PacketType))

  000e4	8d 4c 24 14	 lea	 ecx, DWORD PTR _PacketType$[esp+44]
  000e8	0f b6 c0	 movzx	 eax, al
  000eb	51		 push	 ecx
  000ec	50		 push	 eax
  000ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\netpacketheadermap.h

; 12   : 				iPacketSize = iSize;

  000f2	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _PacketType$[esp+52], 0

; 13   : 				isDynamicSizePacket = bFlag;

  000fa	c6 44 24 20 00	 mov	 BYTE PTR _PacketType$[esp+56], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 533  : 	if (!s_packetHeaderMap.Get(header, &PacketType))

  000ff	e8 00 00 00 00	 call	 ?Get@CNetworkPacketHeaderMap@@QAE_NHPAUSPacketType@1@@Z ; CNetworkPacketHeaderMap::Get
  00104	84 c0		 test	 al, al
  00106	75 44		 jne	 SHORT $LN7@CheckPacke

; 534  : 	{
; 535  : 		TraceError("Unknown packet header: %d, last: %d %d", header, g_iLastPacket[0], g_iLastPacket[1]);

  00108	ff 35 04 00 00
	00		 push	 DWORD PTR ?g_iLastPacket@@3PAHA+4
  0010e	0f b6 44 24 13	 movzx	 eax, BYTE PTR _header$[esp+48]
  00113	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_iLastPacket@@3PAHA
  00119	50		 push	 eax
  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@LALGPME@Unknown?5packet?5header?3?5?$CFd?0?5last?3@
  0011f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00124	83 c4 10	 add	 esp, 16			; 00000010H

; 536  : 		ClearRecvBuffer();

  00127	8b ce		 mov	 ecx, esi
  00129	e8 00 00 00 00	 call	 ?ClearRecvBuffer@CNetworkStream@@QAEXXZ ; CNetworkStream::ClearRecvBuffer

; 537  : 
; 538  : 		PostQuitMessage(0);

  0012e	6a 00		 push	 0
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4
$LN28@CheckPacke:

; 539  : 		return false;

  00136	32 c0		 xor	 al, al

; 580  : }

  00138	8b 4c 24 20	 mov	 ecx, DWORD PTR __$EHRec$[esp+44]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c2 04 00	 ret	 4
$LN7@CheckPacke:

; 540  : 	}
; 541  : 
; 542  : 	// Code for dynamic size packet
; 543  : 	if (PacketType.isDynamicSizePacket)

  0014c	80 7c 24 18 00	 cmp	 BYTE PTR _PacketType$[esp+48], 0

; 544  : 	{
; 545  : 		TDynamicSizePacketHeader DynamicSizePacketHeader;
; 546  : 
; 547  : 		if (!Peek(sizeof(TDynamicSizePacketHeader), &DynamicSizePacketHeader))

  00151	8b ce		 mov	 ecx, esi
  00153	74 50		 je	 SHORT $LN6@CheckPacke
  00155	8d 44 24 10	 lea	 eax, DWORD PTR _DynamicSizePacketHeader$2[esp+44]
  00159	50		 push	 eax
  0015a	6a 03		 push	 3
  0015c	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  00161	84 c0		 test	 al, al
  00163	74 d1		 je	 SHORT $LN28@CheckPacke

; 548  : 			return false;
; 549  : 
; 550  : 		if (!Peek(DynamicSizePacketHeader.size))

  00165	0f b7 44 24 11	 movzx	 eax, WORD PTR _DynamicSizePacketHeader$2[esp+45]
  0016a	8b ce		 mov	 ecx, esi
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NH@Z ; CNetworkStream::Peek
  00172	84 c0		 test	 al, al
  00174	75 3c		 jne	 SHORT $LN2@CheckPacke

; 551  : 		{
; 552  : 			Tracef("CPythonNetworkStream::CheckPacket - Not enough dynamic packet size: header %d packet size: %d\n", 
; 553  : 				DynamicSizePacketHeader.header,
; 554  : 				DynamicSizePacketHeader.size);

  00176	0f b7 44 24 11	 movzx	 eax, WORD PTR _DynamicSizePacketHeader$2[esp+45]
  0017b	50		 push	 eax
  0017c	0f b6 44 24 14	 movzx	 eax, BYTE PTR _DynamicSizePacketHeader$2[esp+48]
  00181	50		 push	 eax
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0FP@JGOINIOH@CPythonNetworkStream?3?3CheckPacke@
  00187	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 555  : 			return false;

  0018f	32 c0		 xor	 al, al

; 580  : }

  00191	8b 4c 24 20	 mov	 ecx, DWORD PTR __$EHRec$[esp+44]
  00195	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019c	59		 pop	 ecx
  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	c2 04 00	 ret	 4
$LN6@CheckPacke:

; 556  : 		}
; 557  : 	}
; 558  : 	else
; 559  : 	{
; 560  : 		if (!Peek(PacketType.iPacketSize))

  001a5	ff 74 24 14	 push	 DWORD PTR _PacketType$[esp+44]
  001a9	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NH@Z ; CNetworkStream::Peek
  001ae	84 c0		 test	 al, al
  001b0	74 84		 je	 SHORT $LN28@CheckPacke
$LN2@CheckPacke:

; 561  : 		{
; 562  : 			//Tracef("Not enough packet size: header %d packet size: %d, recv buffer size: %d",
; 563  : 			//	header,
; 564  : 			//	PacketType.iPacketSize,
; 565  : 			//	GetRecvBufferSize());
; 566  : 			return false;
; 567  : 		}
; 568  : 	}
; 569  : 
; 570  : 	if (!header)

  001b2	8a 4c 24 0f	 mov	 cl, BYTE PTR _header$[esp+44]
  001b6	84 c9		 test	 cl, cl
  001b8	0f 84 78 ff ff
	ff		 je	 $LN28@CheckPacke

; 571  : 		return false;
; 572  : 
; 573  : 	*pRetHeader = header;	
; 574  : 
; 575  : 	g_iLastPacket[0] = g_iLastPacket[1];

  001be	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_iLastPacket@@3PAHA+4
  001c3	a3 00 00 00 00	 mov	 DWORD PTR ?g_iLastPacket@@3PAHA, eax

; 576  : 	g_iLastPacket[1] = header;

  001c8	0f b6 c1	 movzx	 eax, cl
  001cb	a3 04 00 00 00	 mov	 DWORD PTR ?g_iLastPacket@@3PAHA+4, eax

; 577  : 	//Tracenf("header %d size %d", header, PacketType.iPacketSize);
; 578  : 	//Tracenf("header %d size %d outputpos[%d] security %u", header, PacketType.iPacketSize, m_recvBufOutputPos, IsSecurityMode());
; 579  : 	return true;

  001d0	b0 01		 mov	 al, 1
  001d2	88 0f		 mov	 BYTE PTR [edi], cl

; 580  : }

  001d4	8b 4c 24 20	 mov	 ecx, DWORD PTR __$EHRec$[esp+44]
  001d8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001df	59		 pop	 ecx
  001e0	5f		 pop	 edi
  001e1	5e		 pop	 esi
  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4IA, eax
  0000d	c3		 ret	 0
__ehhandler$?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 e4	 lea	 eax, DWORD PTR [edx-28]
  00015	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z ENDP	; CPythonNetworkStream::CheckPacket
; Function compile flags: /Ogtp
;	COMDAT ??__Fs_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@YAXXZ
text$yd	SEGMENT
??__Fs_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@YAXXZ PROC ; `CPythonNetworkStream::CheckPacket'::`2'::`dynamic atexit destructor for 's_packetHeaderMap'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@4VCMainPacketHeaderMap@@A
  00005	e9 00 00 00 00	 jmp	 ??1CNetworkPacketHeaderMap@@UAE@XZ ; CNetworkPacketHeaderMap::~CNetworkPacketHeaderMap
??__Fs_packetHeaderMap@?1??CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z@YAXXZ ENDP ; `CPythonNetworkStream::CheckPacket'::`2'::`dynamic atexit destructor for 's_packetHeaderMap''
text$yd	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?RecvErrorPacket@CPythonNetworkStream@@IAE_NH@Z
_TEXT	SEGMENT
_header$ = 8						; size = 4
?RecvErrorPacket@CPythonNetworkStream@@IAE_NH@Z PROC	; CPythonNetworkStream::RecvErrorPacket, COMDAT
; _this$ = ecx

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00006	83 be 20 01 00
	00 10		 cmp	 DWORD PTR [esi+288], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 585  : 		m_strPhase.c_str(), header, g_iLastPacket[0], g_iLastPacket[1]);

  0000d	8d 86 0c 01 00
	00		 lea	 eax, DWORD PTR [esi+268]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00013	72 02		 jb	 SHORT $LN7@RecvErrorP
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00015	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@RecvErrorP:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 585  : 		m_strPhase.c_str(), header, g_iLastPacket[0], g_iLastPacket[1]);

  00017	ff 35 04 00 00
	00		 push	 DWORD PTR ?g_iLastPacket@@3PAHA+4
  0001d	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_iLastPacket@@3PAHA
  00023	ff 75 08	 push	 DWORD PTR _header$[ebp]
  00026	50		 push	 eax
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@JMANDMEJ@Phase?5?$CFs?5does?5not?5handle?5this?5he@
  0002c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00031	83 c4 14	 add	 esp, 20			; 00000014H

; 586  : 
; 587  : 	ClearRecvBuffer();

  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ?ClearRecvBuffer@CNetworkStream@@QAEXXZ ; CNetworkStream::ClearRecvBuffer

; 588  : 	return true;

  0003b	b0 01		 mov	 al, 1
  0003d	5e		 pop	 esi

; 589  : }

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?RecvErrorPacket@CPythonNetworkStream@@IAE_NH@Z ENDP	; CPythonNetworkStream::RecvErrorPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?RecvPhasePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_packet_phase$ = -4					; size = 2
?RecvPhasePacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvPhasePacket, COMDAT
; _this$ = ecx

; 592  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi

; 593  : 	TPacketGCPhase packet_phase;
; 594  : 
; 595  : 	if (!Recv(sizeof(TPacketGCPhase), &packet_phase))

  00008	8d 44 24 04	 lea	 eax, DWORD PTR _packet_phase$[esp+8]
  0000c	8b f1		 mov	 esi, ecx
  0000e	50		 push	 eax
  0000f	6a 02		 push	 2
  00011	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00016	84 c0		 test	 al, al
  00018	75 05		 jne	 SHORT $LN10@RecvPhaseP

; 635  : }

  0001a	5e		 pop	 esi
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN10@RecvPhaseP:

; 596  : 		return false;
; 597  : 
; 598  : 	switch (packet_phase.phase)

  0001f	0f b6 44 24 05	 movzx	 eax, BYTE PTR _packet_phase$[esp+9]
  00024	83 f8 05	 cmp	 eax, 5
  00027	77 60		 ja	 SHORT $LN8@RecvPhaseP
  00029	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@RecvPhaseP[eax*4]
$LN7@RecvPhaseP:

; 599  : 	{
; 600  : 		case PHASE_CLOSE:				//   (   )
; 601  : 			ClosePhase();

  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?ClosePhase@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::ClosePhase

; 628  : 			break;
; 629  : 
; 630  : 		case PHASE_DEAD:				//  .. (    ..)
; 631  : 			break;
; 632  : 	}
; 633  : 
; 634  : 	return true;

  00037	b0 01		 mov	 al, 1

; 635  : }

  00039	5e		 pop	 esi
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN6@RecvPhaseP:

; 602  : 			break;
; 603  : 
; 604  : 		case PHASE_HANDSHAKE:			// ..;;
; 605  : 			SetHandShakePhase();

  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?SetHandShakePhase@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::SetHandShakePhase

; 628  : 			break;
; 629  : 
; 630  : 		case PHASE_DEAD:				//  .. (    ..)
; 631  : 			break;
; 632  : 	}
; 633  : 
; 634  : 	return true;

  00045	b0 01		 mov	 al, 1

; 635  : }

  00047	5e		 pop	 esi
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN5@RecvPhaseP:

; 606  : 			break;
; 607  : 
; 608  : 		case PHASE_LOGIN:				//  
; 609  : 			SetLoginPhase();

  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?SetLoginPhase@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::SetLoginPhase

; 628  : 			break;
; 629  : 
; 630  : 		case PHASE_DEAD:				//  .. (    ..)
; 631  : 			break;
; 632  : 	}
; 633  : 
; 634  : 	return true;

  00053	b0 01		 mov	 al, 1

; 635  : }

  00055	5e		 pop	 esi
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
$LN4@RecvPhaseP:

; 610  : 			break;
; 611  : 
; 612  : 		case PHASE_SELECT:				//   
; 613  : 			SetSelectPhase();

  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?SetSelectPhase@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::SetSelectPhase

; 614  : 
; 615  : 			BuildProcessCRC();

  00061	e8 00 00 00 00	 call	 ?BuildProcessCRC@@YAXXZ	; BuildProcessCRC

; 616  : 	
; 617  : 			// MARK_BUG_FIX
; 618  : 			__DownloadMark();

  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?__DownloadMark@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__DownloadMark

; 628  : 			break;
; 629  : 
; 630  : 		case PHASE_DEAD:				//  .. (    ..)
; 631  : 			break;
; 632  : 	}
; 633  : 
; 634  : 	return true;

  0006d	b0 01		 mov	 al, 1

; 635  : }

  0006f	5e		 pop	 esi
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN3@RecvPhaseP:

; 619  : 			// END_OF_MARK_BUG_FIX
; 620  : 			break;
; 621  : 
; 622  : 		case PHASE_LOADING:				//    
; 623  : 			SetLoadingPhase();

  00074	8b ce		 mov	 ecx, esi
  00076	e8 00 00 00 00	 call	 ?SetLoadingPhase@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::SetLoadingPhase

; 628  : 			break;
; 629  : 
; 630  : 		case PHASE_DEAD:				//  .. (    ..)
; 631  : 			break;
; 632  : 	}
; 633  : 
; 634  : 	return true;

  0007b	b0 01		 mov	 al, 1

; 635  : }

  0007d	5e		 pop	 esi
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
$LN2@RecvPhaseP:

; 624  : 			break;
; 625  : 
; 626  : 		case PHASE_GAME:				//  
; 627  : 			SetGamePhase();

  00082	8b ce		 mov	 ecx, esi
  00084	e8 00 00 00 00	 call	 ?SetGamePhase@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::SetGamePhase
$LN8@RecvPhaseP:

; 628  : 			break;
; 629  : 
; 630  : 		case PHASE_DEAD:				//  .. (    ..)
; 631  : 			break;
; 632  : 	}
; 633  : 
; 634  : 	return true;

  00089	b0 01		 mov	 al, 1

; 635  : }

  0008b	5e		 pop	 esi
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
$LN14@RecvPhaseP:
  00090	00 00 00 00	 DD	 $LN7@RecvPhaseP
  00094	00 00 00 00	 DD	 $LN6@RecvPhaseP
  00098	00 00 00 00	 DD	 $LN5@RecvPhaseP
  0009c	00 00 00 00	 DD	 $LN4@RecvPhaseP
  000a0	00 00 00 00	 DD	 $LN3@RecvPhaseP
  000a4	00 00 00 00	 DD	 $LN2@RecvPhaseP
?RecvPhasePacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvPhasePacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?RecvPingPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kPacketPing$ = -2					; size = 1
_kPacketPong$ = -1					; size = 1
?RecvPingPacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::RecvPingPacket, COMDAT
; _this$ = ecx

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 639  : 	Tracef("recv ping packet. (securitymode %u)\n", IsSecurityMode());

  00007	e8 00 00 00 00	 call	 ?IsSecurityMode@CNetworkStream@@QAE_NXZ ; CNetworkStream::IsSecurityMode
  0000c	0f b6 c0	 movzx	 eax, al
  0000f	50		 push	 eax
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JLNGLGD@recv?5ping?5packet?4?5?$CIsecuritymode?5@
  00015	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0001a	83 c4 08	 add	 esp, 8

; 640  : 
; 641  : 	TPacketGCPing kPacketPing;
; 642  : 
; 643  : 	if (!Recv(sizeof(TPacketGCPing), &kPacketPing))

  0001d	8d 45 fe	 lea	 eax, DWORD PTR _kPacketPing$[ebp]
  00020	8b ce		 mov	 ecx, esi
  00022	50		 push	 eax
  00023	6a 01		 push	 1
  00025	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0002a	84 c0		 test	 al, al
  0002c	75 07		 jne	 SHORT $LN4@RecvPingPa
$LN7@RecvPingPa:

; 644  : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	5e		 pop	 esi

; 658  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN4@RecvPingPa:

; 645  : 
; 646  : 	m_dwLastGamePingTime = ELTimer_GetMSec();

  00035	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0003a	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax

; 647  : 
; 648  : 	TPacketCGPong kPacketPong;
; 649  : 	kPacketPong.bHeader = HEADER_CG_PONG;
; 650  : 
; 651  : 	if (!Send(sizeof(TPacketCGPong), &kPacketPong))

  00040	8b ce		 mov	 ecx, esi
  00042	8d 45 ff	 lea	 eax, DWORD PTR _kPacketPong$[ebp]
  00045	c6 45 ff fe	 mov	 BYTE PTR _kPacketPong$[ebp], 254 ; 000000feH
  00049	50		 push	 eax
  0004a	6a 01		 push	 1
  0004c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00051	84 c0		 test	 al, al
  00053	74 d9		 je	 SHORT $LN7@RecvPingPa

; 652  : 		return false;
; 653  : 
; 654  : 	if (IsSecurityMode())

  00055	8b ce		 mov	 ecx, esi
  00057	e8 00 00 00 00	 call	 ?IsSecurityMode@CNetworkStream@@QAE_NXZ ; CNetworkStream::IsSecurityMode
  0005c	84 c0		 test	 al, al
  0005e	74 0c		 je	 SHORT $LN2@RecvPingPa

; 655  : 		return SendSequence();

  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00067	5e		 pop	 esi

; 658  : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
$LN2@RecvPingPa:

; 656  : 	else
; 657  : 		return true;

  0006c	b0 01		 mov	 al, 1
  0006e	5e		 pop	 esi

; 658  : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?RecvPingPacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::RecvPingPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?RecvDefaultPacket@CPythonNetworkStream@@IAE_NH@Z
_TEXT	SEGMENT
_header$ = 8						; size = 4
?RecvDefaultPacket@CPythonNetworkStream@@IAE_NH@Z PROC	; CPythonNetworkStream::RecvDefaultPacket, COMDAT
; _this$ = ecx

; 661  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 662  : 	if (!header)

  00003	8b 55 08	 mov	 edx, DWORD PTR _header$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	74 27		 je	 SHORT $LN12@RecvDefaul
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0000d	83 be 20 01 00
	00 10		 cmp	 DWORD PTR [esi+288], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 665  : 	TraceError("    %d, state %s\n", header, m_strPhase.c_str());

  00014	8d 86 0c 01 00
	00		 lea	 eax, DWORD PTR [esi+268]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0001a	72 02		 jb	 SHORT $LN8@RecvDefaul
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN8@RecvDefaul:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 665  : 	TraceError("    %d, state %s\n", header, m_strPhase.c_str());

  0001e	50		 push	 eax
  0001f	52		 push	 edx
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IOPHKJBJ@?C?$LD?$LI?$KO?$LF?G?A?v?5?$LO?J?$MA?$LK?5?F?P?E?$LG?5?G?l?$LE?u?5?$CFd?0?5stat@
  00025	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 666  : 	ClearRecvBuffer();

  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?ClearRecvBuffer@CNetworkStream@@QAEXXZ ; CNetworkStream::ClearRecvBuffer
$LN12@RecvDefaul:

; 667  : 	return true;

  00034	b0 01		 mov	 al, 1
  00036	5e		 pop	 esi

; 668  : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?RecvDefaultPacket@CPythonNetworkStream@@IAE_NH@Z ENDP	; CPythonNetworkStream::RecvDefaultPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?OnProcess@CPythonNetworkStream@@MAE_NXZ
_TEXT	SEGMENT
?OnProcess@CPythonNetworkStream@@MAE_NXZ PROC		; CPythonNetworkStream::OnProcess, COMDAT
; _this$ = ecx

; 671  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 672  : 	if (m_isStartGame)

  00003	83 be ac 00 00
	00 00		 cmp	 DWORD PTR [esi+172], 0
  0000a	74 29		 je	 SHORT $LN2@OnProcess

; 673  : 	{
; 674  : 		m_isStartGame = FALSE;
; 675  : 
; 676  : 		PyCallClassMemberFunc(m_poHandler, "SetGamePhase", Py_BuildValue("()"));

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00011	c7 86 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+172], 0
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HHLEGKEL@SetGamePhase?$AA@
  00027	ff b6 78 01 00
	00		 push	 DWORD PTR [esi+376]
  0002d	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00032	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@OnProcess:

; 677  : //		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "StartGame", Py_BuildValue("()"));
; 678  : 	}
; 679  : 	
; 680  : 	m_rokNetActorMgr->Update();

  00035	8b 8e 0c 03 00
	00		 mov	 ecx, DWORD PTR [esi+780]
  0003b	e8 00 00 00 00	 call	 ?Update@CNetworkActorManager@@QAEXXZ ; CNetworkActorManager::Update
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 30   : 			if (m_pSelfObject != NULL)

  00040	83 be 50 01 00
	00 00		 cmp	 DWORD PTR [esi+336], 0
  00047	75 09		 jne	 SHORT $LN1@OnProcess

; 31   : 				return false;
; 32   : 
; 33   : 			if (m_pFuncObject != NULL)

  00049	83 be 58 01 00
	00 00		 cmp	 DWORD PTR [esi+344], 0
  00050	74 1e		 je	 SHORT $LN14@OnProcess
$LN1@OnProcess:

; 34   : 				return false;
; 35   : 
; 36   : 			return true;
; 37   : 		}
; 38   : 
; 39   : 		void Run()
; 40   : 		{
; 41   : 			if (m_pSelfObject)

  00052	8b 96 50 01 00
	00		 mov	 edx, DWORD PTR [esi+336]
  00058	85 d2		 test	 edx, edx
  0005a	74 14		 je	 SHORT $LN14@OnProcess

; 42   : 				if (m_pFuncObject)

  0005c	8b 86 58 01 00
	00		 mov	 eax, DWORD PTR [esi+344]
  00062	85 c0		 test	 eax, eax
  00064	74 0a		 je	 SHORT $LN14@OnProcess

; 43   : 					(m_pSelfObject->*m_pFuncObject)();

  00066	8b 8e 5c 01 00
	00		 mov	 ecx, DWORD PTR [esi+348]
  0006c	03 ca		 add	 ecx, edx
  0006e	ff d0		 call	 eax
$LN14@OnProcess:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 691  : 	return true;

  00070	b0 01		 mov	 al, 1
  00072	5e		 pop	 esi

; 692  : }

  00073	c3		 ret	 0
?OnProcess@CPythonNetworkStream@@MAE_NXZ ENDP		; CPythonNetworkStream::OnProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SetOffLinePhase@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?SetOffLinePhase@CPythonNetworkStream@@QAEXXZ PROC	; CPythonNetworkStream::SetOffLinePhase, COMDAT
; _this$ = ecx

; 697  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  0000a	6a 07		 push	 7
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_07NNEFBBEG@OffLine?$AA@
  00011	ff b6 1c 01 00
	00		 push	 DWORD PTR [esi+284]
  00017	8d 8e 0c 01 00
	00		 lea	 ecx, DWORD PTR [esi+268]
  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);

  00024	85 c0		 test	 eax, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 698  : 	if ("OffLine" != m_strPhase)

  00026	74 1e		 je	 SHORT $LN27@SetOffLine
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 41   : 			if (m_pSelfObject)

  00028	8b 96 68 01 00
	00		 mov	 edx, DWORD PTR [esi+360]
  0002e	85 d2		 test	 edx, edx
  00030	74 14		 je	 SHORT $LN27@SetOffLine

; 42   : 				if (m_pFuncObject)

  00032	8b 86 70 01 00
	00		 mov	 eax, DWORD PTR [esi+368]
  00038	85 c0		 test	 eax, eax
  0003a	74 0a		 je	 SHORT $LN27@SetOffLine

; 43   : 					(m_pSelfObject->*m_pFuncObject)();

  0003c	8b 8e 74 01 00
	00		 mov	 ecx, DWORD PTR [esi+372]
  00042	03 ca		 add	 ecx, edx
  00044	ff d0		 call	 eax
$LN27@SetOffLine:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00046	6a 07		 push	 7
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_07NNEFBBEG@OffLine?$AA@
  0004d	8d 8e 0c 01 00
	00		 lea	 ecx, DWORD PTR [esi+268]
  00053	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 703  : 	Tracen("");

  00058	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00062	83 c4 04	 add	 esp, 4

; 704  : 	Tracen("## Network - OffLine Phase ##");	

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NMFMGDDG@?$CD?$CD?5Network?5?9?5OffLine?5Phase?5?$CD?$CD?$AA@
  0006a	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0006f	83 c4 04	 add	 esp, 4

; 705  : 	Tracen("");

  00072	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00077	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0007c	83 c4 04	 add	 esp, 4

; 706  : 
; 707  : 	m_dwChangingPhaseTime = ELTimer_GetMSec();

  0007f	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00084	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax

; 711  : 	SetGameOffline();

  0008a	8b ce		 mov	 ecx, esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h

; 24   : 			m_pSelfObject = pSelfObject;

  0008c	89 b6 50 01 00
	00		 mov	 DWORD PTR [esi+336], esi

; 25   : 			m_pFuncObject = pFuncObject;

  00092	c7 86 58 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+344], OFFSET ?OffLinePhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::OffLinePhase
  0009c	c7 86 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+348], 0

; 24   : 			m_pSelfObject = pSelfObject;

  000a6	89 b6 68 01 00
	00		 mov	 DWORD PTR [esi+360], esi

; 25   : 			m_pFuncObject = pFuncObject;

  000ac	c7 86 70 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+368], OFFSET ?__LeaveOfflinePhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__LeaveOfflinePhase
  000b6	c7 86 74 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+372], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 711  : 	SetGameOffline();

  000c0	e8 00 00 00 00	 call	 ?SetGameOffline@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::SetGameOffline

; 712  : 
; 713  : 	m_dwSelectedCharacterIndex = 0;

  000c5	c7 86 10 79 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+30992], 0

; 714  : 
; 715  : 	__DirectEnterMode_Initialize();

  000cf	e8 00 00 00 00	 call	 ?__DirectEnterMode_Initialize@CPythonNetworkStream@@AAEXXZ ; CPythonNetworkStream::__DirectEnterMode_Initialize

; 716  : 	__BettingGuildWar_Initialize();

  000d4	e8 00 00 00 00	 call	 ?__BettingGuildWar_Initialize@CPythonNetworkStream@@AAEXXZ ; CPythonNetworkStream::__BettingGuildWar_Initialize

; 717  : }

  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
?SetOffLinePhase@CPythonNetworkStream@@QAEXXZ ENDP	; CPythonNetworkStream::SetOffLinePhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?ClosePhase@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
?ClosePhase@CPythonNetworkStream@@QAEXXZ PROC		; CPythonNetworkStream::ClosePhase, COMDAT
; _this$ = ecx

; 721  : {

  00000	56		 push	 esi

; 722  : 	PyCallClassMemberFunc(m_poHandler, "SetLoginPhase", Py_BuildValue("()"));

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00006	8b f1		 mov	 esi, ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PJEEOCNO@SetLoginPhase?$AA@
  00014	ff b6 78 01 00
	00		 push	 DWORD PTR [esi+376]
  0001a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
  00022	5e		 pop	 esi

; 723  : }

  00023	c3		 ret	 0
?ClosePhase@CPythonNetworkStream@@QAEXXZ ENDP		; CPythonNetworkStream::ClosePhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SetGameOnline@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?SetGameOnline@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::SetGameOnline, COMDAT
; _this$ = ecx

; 728  : 	m_isGameOnline = TRUE;

  00000	c7 81 a8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+168], 1

; 729  : }

  0000a	c3		 ret	 0
?SetGameOnline@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::SetGameOnline
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SetGameOffline@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?SetGameOffline@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::SetGameOffline, COMDAT
; _this$ = ecx

; 733  : 	m_isGameOnline = FALSE;

  00000	c7 81 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+168], 0

; 734  : }

  0000a	c3		 ret	 0
?SetGameOffline@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::SetGameOffline
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SetHandler@CPythonNetworkStream@@QAEXPAU_object@@@Z
_TEXT	SEGMENT
_poHandler$ = 8						; size = 4
?SetHandler@CPythonNetworkStream@@QAEXPAU_object@@@Z PROC ; CPythonNetworkStream::SetHandler, COMDAT
; _this$ = ecx

; 743  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 744  : 	m_poHandler = poHandler;

  00003	8b 45 08	 mov	 eax, DWORD PTR _poHandler$[ebp]
  00006	89 81 78 01 00
	00		 mov	 DWORD PTR [ecx+376], eax

; 745  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetHandler@CPythonNetworkStream@@QAEXPAU_object@@@Z ENDP ; CPythonNetworkStream::SetHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?GetMainActorVID@CPythonNetworkStream@@QAEKXZ
_TEXT	SEGMENT
?GetMainActorVID@CPythonNetworkStream@@QAEKXZ PROC	; CPythonNetworkStream::GetMainActorVID, COMDAT
; _this$ = ecx

; 750  : 	return m_dwMainActorVID;

  00000	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]

; 751  : }

  00006	c3		 ret	 0
?GetMainActorVID@CPythonNetworkStream@@QAEKXZ ENDP	; CPythonNetworkStream::GetMainActorVID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?GetMainActorRace@CPythonNetworkStream@@QAEKXZ
_TEXT	SEGMENT
?GetMainActorRace@CPythonNetworkStream@@QAEKXZ PROC	; CPythonNetworkStream::GetMainActorRace, COMDAT
; _this$ = ecx

; 755  : 	return m_dwMainActorRace;

  00000	8b 81 9c 00 00
	00		 mov	 eax, DWORD PTR [ecx+156]

; 756  : }

  00006	c3		 ret	 0
?GetMainActorRace@CPythonNetworkStream@@QAEKXZ ENDP	; CPythonNetworkStream::GetMainActorRace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?GetMainActorEmpire@CPythonNetworkStream@@QAEKXZ
_TEXT	SEGMENT
?GetMainActorEmpire@CPythonNetworkStream@@QAEKXZ PROC	; CPythonNetworkStream::GetMainActorEmpire, COMDAT
; _this$ = ecx

; 760  : 	return m_dwMainActorEmpire;

  00000	8b 81 a0 00 00
	00		 mov	 eax, DWORD PTR [ecx+160]

; 761  : }

  00006	c3		 ret	 0
?GetMainActorEmpire@CPythonNetworkStream@@QAEKXZ ENDP	; CPythonNetworkStream::GetMainActorEmpire
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?GetMainActorSkillGroup@CPythonNetworkStream@@QAEKXZ
_TEXT	SEGMENT
?GetMainActorSkillGroup@CPythonNetworkStream@@QAEKXZ PROC ; CPythonNetworkStream::GetMainActorSkillGroup, COMDAT
; _this$ = ecx

; 765  : 	return m_dwMainActorSkillGroup;

  00000	8b 81 a4 00 00
	00		 mov	 eax, DWORD PTR [ecx+164]

; 766  : }

  00006	c3		 ret	 0
?GetMainActorSkillGroup@CPythonNetworkStream@@QAEKXZ ENDP ; CPythonNetworkStream::GetMainActorSkillGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SetEmpireID@CPythonNetworkStream@@QAEXK@Z
_TEXT	SEGMENT
_dwEmpireID$ = 8					; size = 4
?SetEmpireID@CPythonNetworkStream@@QAEXK@Z PROC		; CPythonNetworkStream::SetEmpireID, COMDAT
; _this$ = ecx

; 769  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 770  : 	m_dwEmpireID = dwEmpireID;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwEmpireID$[ebp]
  00006	89 81 b4 00 00
	00		 mov	 DWORD PTR [ecx+180], eax

; 771  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetEmpireID@CPythonNetworkStream@@QAEXK@Z ENDP		; CPythonNetworkStream::SetEmpireID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?GetEmpireID@CPythonNetworkStream@@QAEKXZ
_TEXT	SEGMENT
?GetEmpireID@CPythonNetworkStream@@QAEKXZ PROC		; CPythonNetworkStream::GetEmpireID, COMDAT
; _this$ = ecx

; 775  : 	return m_dwEmpireID;

  00000	8b 81 b4 00 00
	00		 mov	 eax, DWORD PTR [ecx+180]

; 776  : }

  00006	c3		 ret	 0
?GetEmpireID@CPythonNetworkStream@@QAEKXZ ENDP		; CPythonNetworkStream::GetEmpireID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?__ClearSelectCharacterData@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__ClearSelectCharacterData@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__ClearSelectCharacterData, COMDAT
; _this$ = ecx

; 779  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f1		 mov	 esi, ecx

; 780  : 	NANOBEGIN

  00005	eb		 DB	 -21			; ffffffebH
  00006	03		 DB	 3
  00007	d6		 DB	 -42			; ffffffd6H
  00008	d7		 DB	 -41			; ffffffd7H
  00009	01		 DB	 1

; 781  : 	memset(&m_akSimplePlayerInfo, 0, sizeof(m_akSimplePlayerInfo));

  0000a	68 fc 00 00 00	 push	 252			; 000000fcH
  0000f	8d 86 9c 01 00
	00		 lea	 eax, DWORD PTR [esi+412]
  00015	6a 00		 push	 0
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	8d be a8 02 00
	00		 lea	 edi, DWORD PTR [esi+680]
  00026	81 c6 98 02 00
	00		 add	 esi, 664		; 00000298H
  0002c	bb 04 00 00 00	 mov	 ebx, 4
$LL3@ClearSelec:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00031	6a 00		 push	 0
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00038	8b cf		 mov	 ecx, edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 785  : 		m_adwGuildID[i] = 0;

  0003a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00040	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 783  : 	for (int i = 0; i < PLAYER_PER_ACCOUNT4; ++i)

  00045	83 c7 18	 add	 edi, 24			; 00000018H
  00048	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0004b	4b		 dec	 ebx
  0004c	75 e3		 jne	 SHORT $LL3@ClearSelec

; 786  : 		m_astrGuildName[i] = "";
; 787  : 	}
; 788  : 	NANOEND

  0004e	eb		 DB	 -21			; ffffffebH
  0004f	03		 DB	 3
  00050	d6		 DB	 -42			; ffffffd6H
  00051	d7		 DB	 -41			; ffffffd7H
  00052	00		 DB	 0
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 789  : }

  00056	c3		 ret	 0
?__ClearSelectCharacterData@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__ClearSelectCharacterData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?__DirectEnterMode_Initialize@CPythonNetworkStream@@AAEXXZ
_TEXT	SEGMENT
?__DirectEnterMode_Initialize@CPythonNetworkStream@@AAEXXZ PROC ; CPythonNetworkStream::__DirectEnterMode_Initialize, COMDAT
; _this$ = ecx

; 793  : 	m_kDirectEnterMode.m_isSet=false;

  00000	c6 81 38 79 00
	00 00		 mov	 BYTE PTR [ecx+31032], 0

; 794  : 	m_kDirectEnterMode.m_dwChrSlotIndex=0;	

  00007	c7 81 3c 79 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+31036], 0

; 795  : }

  00011	c3		 ret	 0
?__DirectEnterMode_Initialize@CPythonNetworkStream@@AAEXXZ ENDP ; CPythonNetworkStream::__DirectEnterMode_Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?__DirectEnterMode_Set@CPythonNetworkStream@@AAEXI@Z
_TEXT	SEGMENT
_uChrSlotIndex$ = 8					; size = 4
?__DirectEnterMode_Set@CPythonNetworkStream@@AAEXI@Z PROC ; CPythonNetworkStream::__DirectEnterMode_Set, COMDAT
; _this$ = ecx

; 798  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 799  : 	m_kDirectEnterMode.m_isSet=true;
; 800  : 	m_kDirectEnterMode.m_dwChrSlotIndex=uChrSlotIndex;

  00003	8b 45 08	 mov	 eax, DWORD PTR _uChrSlotIndex$[ebp]
  00006	c6 81 38 79 00
	00 01		 mov	 BYTE PTR [ecx+31032], 1
  0000d	89 81 3c 79 00
	00		 mov	 DWORD PTR [ecx+31036], eax

; 801  : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__DirectEnterMode_Set@CPythonNetworkStream@@AAEXI@Z ENDP ; CPythonNetworkStream::__DirectEnterMode_Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?__DirectEnterMode_IsSet@CPythonNetworkStream@@AAE_NXZ
_TEXT	SEGMENT
?__DirectEnterMode_IsSet@CPythonNetworkStream@@AAE_NXZ PROC ; CPythonNetworkStream::__DirectEnterMode_IsSet, COMDAT
; _this$ = ecx

; 805  : 	return m_kDirectEnterMode.m_isSet;

  00000	8a 81 38 79 00
	00		 mov	 al, BYTE PTR [ecx+31032]

; 806  : }

  00006	c3		 ret	 0
?__DirectEnterMode_IsSet@CPythonNetworkStream@@AAE_NXZ ENDP ; CPythonNetworkStream::__DirectEnterMode_IsSet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?__InitializeMarkAuth@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__InitializeMarkAuth@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::__InitializeMarkAuth, COMDAT
; _this$ = ecx

; 810  : 	m_kMarkAuth.m_dwHandle=0;

  00000	c7 81 08 79 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+30984], 0

; 811  : 	m_kMarkAuth.m_dwRandomKey=0;

  0000a	c7 81 0c 79 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+30988], 0

; 812  : }

  00014	c3		 ret	 0
?__InitializeMarkAuth@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::__InitializeMarkAuth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?__BettingGuildWar_Initialize@CPythonNetworkStream@@AAEXXZ
_TEXT	SEGMENT
?__BettingGuildWar_Initialize@CPythonNetworkStream@@AAEXXZ PROC ; CPythonNetworkStream::__BettingGuildWar_Initialize, COMDAT
; _this$ = ecx

; 816  : 	m_kBettingGuildWar.m_dwBettingMoney=0;

  00000	c7 81 40 79 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+31040], 0

; 817  : 	m_kBettingGuildWar.m_dwObserverCount=0;

  0000a	c7 81 44 79 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+31044], 0

; 818  : }

  00014	c3		 ret	 0
?__BettingGuildWar_Initialize@CPythonNetworkStream@@AAEXXZ ENDP ; CPythonNetworkStream::__BettingGuildWar_Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?EXPORT_GetBettingGuildWarValue@CPythonNetworkStream@@QAEKPBD@Z
_TEXT	SEGMENT
_c_szValueName$ = 8					; size = 4
?EXPORT_GetBettingGuildWarValue@CPythonNetworkStream@@QAEKPBD@Z PROC ; CPythonNetworkStream::EXPORT_GetBettingGuildWarValue, COMDAT
; _this$ = ecx

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 832  : 	if (stricmp(c_szValueName, "OBSERVER_COUNT") == 0)

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MDCECFOM@OBSERVER_COUNT?$AA@
  00009	ff 75 08	 push	 DWORD PTR _c_szValueName$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	e8 00 00 00 00	 call	 __stricmp
  00013	83 c4 08	 add	 esp, 8
  00016	85 c0		 test	 eax, eax
  00018	75 0b		 jne	 SHORT $LN2@EXPORT_Get

; 833  : 		return m_kBettingGuildWar.m_dwObserverCount;

  0001a	8b 86 44 79 00
	00		 mov	 eax, DWORD PTR [esi+31044]
  00020	5e		 pop	 esi

; 839  : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@EXPORT_Get:

; 834  : 
; 835  : 	if (stricmp(c_szValueName, "BETTING_MONEY") == 0)

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FEJHKOEO@BETTING_MONEY?$AA@
  0002a	ff 75 08	 push	 DWORD PTR _c_szValueName$[ebp]
  0002d	e8 00 00 00 00	 call	 __stricmp
  00032	83 c4 08	 add	 esp, 8
  00035	85 c0		 test	 eax, eax
  00037	75 0b		 jne	 SHORT $LN1@EXPORT_Get

; 836  : 		return m_kBettingGuildWar.m_dwBettingMoney;

  00039	8b 86 40 79 00
	00		 mov	 eax, DWORD PTR [esi+31040]
  0003f	5e		 pop	 esi

; 839  : }

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
$LN1@EXPORT_Get:

; 837  : 
; 838  : 	return 0;

  00044	33 c0		 xor	 eax, eax
  00046	5e		 pop	 esi

; 839  : }

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?EXPORT_GetBettingGuildWarValue@CPythonNetworkStream@@QAEKPBD@Z ENDP ; CPythonNetworkStream::EXPORT_GetBettingGuildWarValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?__ServerTimeSync_Initialize@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
?__ServerTimeSync_Initialize@CPythonNetworkStream@@IAEXXZ PROC ; CPythonNetworkStream::__ServerTimeSync_Initialize, COMDAT
; _this$ = ecx

; 843  : 	m_kServerTimeSync.m_dwChangeClientTime=0;

  00000	c7 81 bc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+188], 0

; 844  : 	m_kServerTimeSync.m_dwChangeServerTime=0;

  0000a	c7 81 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+184], 0

; 845  : }

  00014	c3		 ret	 0
?__ServerTimeSync_Initialize@CPythonNetworkStream@@IAEXXZ ENDP ; CPythonNetworkStream::__ServerTimeSync_Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp
;	COMDAT ?SendEmoticon@CPythonNetworkStream@@QAEXI@Z
_TEXT	SEGMENT
_eEmoticon$ = 8						; size = 4
?SendEmoticon@CPythonNetworkStream@@QAEXI@Z PROC	; CPythonNetworkStream::SendEmoticon, COMDAT
; _this$ = ecx

; 853  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 854  : 	if(eEmoticon < m_EmoticonStringVector.size())

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _eEmoticon$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0000e	8b 96 24 03 00
	00		 mov	 edx, DWORD PTR [esi+804]
  00014	2b 96 20 03 00
	00		 sub	 edx, DWORD PTR [esi+800]
  0001a	f7 ea		 imul	 edx
  0001c	c1 fa 02	 sar	 edx, 2
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00024	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 854  : 	if(eEmoticon < m_EmoticonStringVector.size())

  00026	3b c8		 cmp	 ecx, eax
  00028	73 1f		 jae	 SHORT $LN2@SendEmotic
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  0002a	8b 86 20 03 00
	00		 mov	 eax, DWORD PTR [esi+800]
  00030	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00033	83 7c c8 14 10	 cmp	 DWORD PTR [eax+ecx*8+20], 16 ; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00038	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0003b	72 02		 jb	 SHORT $LN13@SendEmotic
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0003d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN13@SendEmotic:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstream.cpp

; 855  : 		SendChatPacket(m_EmoticonStringVector[eEmoticon].c_str());

  0003f	6a 00		 push	 0
  00041	50		 push	 eax
  00042	8b ce		 mov	 ecx, esi
  00044	e8 00 00 00 00	 call	 ?SendChatPacket@CPythonNetworkStream@@QAE_NPBDE@Z ; CPythonNetworkStream::SendChatPacket
$LN2@SendEmotic:
  00049	5e		 pop	 esi

; 856  : 	else
; 857  : 		assert(false && "SendEmoticon Error");
; 858  : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?SendEmoticon@CPythonNetworkStream@@QAEXI@Z ENDP	; CPythonNetworkStream::SendEmoticon
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCPythonNetworkStream@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPythonNetworkStream@@UAEPAXI@Z PROC		; CPythonNetworkStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPythonNetworkStream@@UAE@XZ ; CPythonNetworkStream::~CPythonNetworkStream
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCPythonNetworkStream@@UAEPAXI@Z ENDP		; CPythonNetworkStream::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SMarkAuth@CPythonNetworkStream@@QAE@XZ
_TEXT	SEGMENT
??0SMarkAuth@CPythonNetworkStream@@QAE@XZ PROC		; CPythonNetworkStream::SMarkAuth::SMarkAuth, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??0CNetworkAddress@@QAE@XZ ; CNetworkAddress::CNetworkAddress
  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0SMarkAuth@CPythonNetworkStream@@QAE@XZ ENDP		; CPythonNetworkStream::SMarkAuth::SMarkAuth
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1SMarkAuth@CPythonNetworkStream@@QAE@XZ
_TEXT	SEGMENT
??1SMarkAuth@CPythonNetworkStream@@QAE@XZ PROC		; CPythonNetworkStream::SMarkAuth::~SMarkAuth, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1CNetworkAddress@@QAE@XZ ; CNetworkAddress::~CNetworkAddress
??1SMarkAuth@CPythonNetworkStream@@QAE@XZ ENDP		; CPythonNetworkStream::SMarkAuth::~SMarkAuth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??0?$CSingleton@VCPythonNetworkStream@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CSingleton@VCPythonNetworkStream@@@@QAE@XZ PROC	; CSingleton<CPythonNetworkStream>::CSingleton<CPythonNetworkStream>, COMDAT
; _this$ = ecx

; 12   : 	{ 
; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 
; 15   : 		ms_singleton = (T*) ((int) this + offset);

  00000	8d 41 84	 lea	 eax, DWORD PTR [ecx-124]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCPythonNetworkStream@@@@6B@
  00009	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A, eax ; CSingleton<CPythonNetworkStream>::ms_singleton

; 16   : 	} 

  0000e	8b c1		 mov	 eax, ecx
  00010	c3		 ret	 0
??0?$CSingleton@VCPythonNetworkStream@@@@QAE@XZ ENDP	; CSingleton<CPythonNetworkStream>::CSingleton<CPythonNetworkStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??1?$CSingleton@VCPythonNetworkStream@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CSingleton@VCPythonNetworkStream@@@@UAE@XZ PROC	; CSingleton<CPythonNetworkStream>::~CSingleton<CPythonNetworkStream>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCPythonNetworkStream@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A, 0 ; CSingleton<CPythonNetworkStream>::ms_singleton

; 22   : 	}

  00010	c3		 ret	 0
??1?$CSingleton@VCPythonNetworkStream@@@@UAE@XZ ENDP	; CSingleton<CPythonNetworkStream>::~CSingleton<CPythonNetworkStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
;	COMDAT ??0?$CFuncObject@VCPythonNetworkStream@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CFuncObject@VCPythonNetworkStream@@@@QAE@XZ PROC	; CFuncObject<CPythonNetworkStream>::CFuncObject<CPythonNetworkStream>, COMDAT
; _this$ = ecx

; 7    : 		CFuncObject()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CFuncObject@VCPythonNetworkStream@@@@6B@

; 8    : 		{
; 9    : 			Clear();
; 10   : 		}

  00006	8b c1		 mov	 eax, ecx

; 11   : 
; 12   : 		virtual ~CFuncObject()
; 13   : 		{
; 14   : 		}
; 15   : 
; 16   : 		void Clear()
; 17   : 		{
; 18   : 			m_pSelfObject = NULL;

  00008	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 19   : 			m_pFuncObject = NULL;

  0000f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00016	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 8    : 		{
; 9    : 			Clear();
; 10   : 		}

  0001d	c3		 ret	 0
??0?$CFuncObject@VCPythonNetworkStream@@@@QAE@XZ ENDP	; CFuncObject<CPythonNetworkStream>::CFuncObject<CPythonNetworkStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
;	COMDAT ??1?$CFuncObject@VCPythonNetworkStream@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CFuncObject@VCPythonNetworkStream@@@@UAE@XZ PROC	; CFuncObject<CPythonNetworkStream>::~CFuncObject<CPythonNetworkStream>, COMDAT
; _this$ = ecx

; 13   : 		{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CFuncObject@VCPythonNetworkStream@@@@6B@

; 14   : 		}

  00006	c3		 ret	 0
??1?$CFuncObject@VCPythonNetworkStream@@@@UAE@XZ ENDP	; CFuncObject<CPythonNetworkStream>::~CFuncObject<CPythonNetworkStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
;	COMDAT ?Clear@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ
_TEXT	SEGMENT
?Clear@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ PROC ; CFuncObject<CPythonNetworkStream>::Clear, COMDAT
; _this$ = ecx

; 18   : 			m_pSelfObject = NULL;

  00000	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 19   : 			m_pFuncObject = NULL;

  00007	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0000e	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 20   : 		}

  00015	c3		 ret	 0
?Clear@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ ENDP ; CFuncObject<CPythonNetworkStream>::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
;	COMDAT ?Set@?$CFuncObject@VCPythonNetworkStream@@@@QAEXPAVCPythonNetworkStream@@P82@AEXXZ@Z
_TEXT	SEGMENT
_pSelfObject$ = 8					; size = 4
_pFuncObject$ = 12					; size = 8
?Set@?$CFuncObject@VCPythonNetworkStream@@@@QAEXPAVCPythonNetworkStream@@P82@AEXXZ@Z PROC ; CFuncObject<CPythonNetworkStream>::Set, COMDAT
; _this$ = ecx

; 23   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   : 			m_pSelfObject = pSelfObject;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pSelfObject$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 25   : 			m_pFuncObject = pFuncObject;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pFuncObject$[ebp]
  0000c	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000f	8b 45 10	 mov	 eax, DWORD PTR _pFuncObject$[ebp+4]
  00012	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 26   : 		}

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?Set@?$CFuncObject@VCPythonNetworkStream@@@@QAEXPAVCPythonNetworkStream@@P82@AEXXZ@Z ENDP ; CFuncObject<CPythonNetworkStream>::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
;	COMDAT ?IsEmpty@?$CFuncObject@VCPythonNetworkStream@@@@QAE_NXZ
_TEXT	SEGMENT
?IsEmpty@?$CFuncObject@VCPythonNetworkStream@@@@QAE_NXZ PROC ; CFuncObject<CPythonNetworkStream>::IsEmpty, COMDAT
; _this$ = ecx

; 30   : 			if (m_pSelfObject != NULL)

  00000	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00004	74 03		 je	 SHORT $LN2@IsEmpty

; 31   : 				return false;

  00006	32 c0		 xor	 al, al

; 34   : 				return false;
; 35   : 
; 36   : 			return true;
; 37   : 		}

  00008	c3		 ret	 0
$LN2@IsEmpty:

; 32   : 
; 33   : 			if (m_pFuncObject != NULL)

  00009	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0000d	0f 94 c0	 sete	 al

; 34   : 				return false;
; 35   : 
; 36   : 			return true;
; 37   : 		}

  00010	c3		 ret	 0
?IsEmpty@?$CFuncObject@VCPythonNetworkStream@@@@QAE_NXZ ENDP ; CFuncObject<CPythonNetworkStream>::IsEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
;	COMDAT ?Run@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ
_TEXT	SEGMENT
?Run@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ PROC	; CFuncObject<CPythonNetworkStream>::Run, COMDAT
; _this$ = ecx

; 41   : 			if (m_pSelfObject)

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	85 d2		 test	 edx, edx
  00005	74 0e		 je	 SHORT $LN1@Run

; 42   : 				if (m_pFuncObject)

  00007	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000a	85 c0		 test	 eax, eax
  0000c	74 07		 je	 SHORT $LN1@Run

; 43   : 					(m_pSelfObject->*m_pFuncObject)();

  0000e	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00011	03 ca		 add	 ecx, edx
  00013	ff e0		 jmp	 eax
$LN1@Run:

; 44   : 		}

  00015	c3		 ret	 0
?Run@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ ENDP	; CFuncObject<CPythonNetworkStream>::Run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h
;	COMDAT ??0?$CRef@VCNetworkActorManager@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CRef@VCNetworkActorManager@@@@QAE@XZ PROC		; CRef<CNetworkActorManager>::CRef<CNetworkActorManager>, COMDAT
; _this$ = ecx

; 21   : 		{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 22   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CRef@VCNetworkActorManager@@@@QAE@XZ ENDP		; CRef<CNetworkActorManager>::CRef<CNetworkActorManager>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h
;	COMDAT ??1?$CRef@VCNetworkActorManager@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CRef@VCNetworkActorManager@@@@QAE@XZ PROC		; CRef<CNetworkActorManager>::~CRef<CNetworkActorManager>, COMDAT
; _this$ = ecx

; 37   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 40   : 		
; 41   : 		void operator = (CReferenceObject* pObject)
; 42   : 		{
; 43   : 			SetPointer(pObject);
; 44   : 		}
; 45   : 
; 46   : 		void operator = (const CRef& c_rRef)
; 47   : 		{
; 48   : 			SetPointer(c_rRef.m_pObject);			
; 49   : 		}
; 50   : 
; 51   : 		void Clear()
; 52   : 		{
; 53   : 			if (m_pObject)

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 0b		 je	 SHORT $LN3@CRef

; 54   : 			{
; 55   : 				m_pObject->Release();

  00009	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@CRef:
  00014	5e		 pop	 esi

; 38   : 			Clear();
; 39   : 		}

  00015	c3		 ret	 0
??1?$CRef@VCNetworkActorManager@@@@QAE@XZ ENDP		; CRef<CNetworkActorManager>::~CRef<CNetworkActorManager>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h
;	COMDAT ??4?$CRef@VCNetworkActorManager@@@@QAEXPAVCReferenceObject@@@Z
_TEXT	SEGMENT
_pObject$ = 8						; size = 4
??4?$CRef@VCNetworkActorManager@@@@QAEXPAVCReferenceObject@@@Z PROC ; CRef<CNetworkActorManager>::operator=, COMDAT
; _this$ = ecx

; 42   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 
; 69   : 			m_pObject = pObject;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pObject$[ebp]
  00006	56		 push	 esi

; 45   : 
; 46   : 		void operator = (const CRef& c_rRef)
; 47   : 		{
; 48   : 			SetPointer(c_rRef.m_pObject);			
; 49   : 		}
; 50   : 
; 51   : 		void Clear()
; 52   : 		{
; 53   : 			if (m_pObject)
; 54   : 			{
; 55   : 				m_pObject->Release();
; 56   : 				m_pObject = NULL;
; 57   : 			}
; 58   : 		}
; 59   : 
; 60   : 		bool IsNull() const
; 61   : 		{
; 62   : 			return m_pObject == NULL ? true : false;
; 63   : 		}
; 64   : 
; 65   : 		void SetPointer(CReferenceObject* pObject)
; 66   : 		{
; 67   : 			CReferenceObject* pOldObject = m_pObject;

  00007	8b 31		 mov	 esi, DWORD PTR [ecx]

; 68   : 
; 69   : 			m_pObject = pObject;

  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 70   : 
; 71   : 			if (m_pObject)

  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN4@operator

; 72   : 				m_pObject->AddReference();

  0000f	8b c8		 mov	 ecx, eax
  00011	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN4@operator:

; 73   : 
; 74   : 			if (pOldObject)

  00016	85 f6		 test	 esi, esi
  00018	74 07		 je	 SHORT $LN3@operator

; 75   : 				pOldObject->Release();

  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN3@operator:
  00021	5e		 pop	 esi

; 43   : 			SetPointer(pObject);
; 44   : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??4?$CRef@VCNetworkActorManager@@@@QAEXPAVCReferenceObject@@@Z ENDP ; CRef<CNetworkActorManager>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h
;	COMDAT ??C?$CRef@VCNetworkActorManager@@@@QBEPAVCNetworkActorManager@@XZ
_TEXT	SEGMENT
??C?$CRef@VCNetworkActorManager@@@@QBEPAVCNetworkActorManager@@XZ PROC ; CRef<CNetworkActorManager>::operator->, COMDAT
; _this$ = ecx

; 85   : 			assert(m_pObject != NULL);
; 86   : 			return static_cast<T*>(m_pObject);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??C?$CRef@VCNetworkActorManager@@@@QBEPAVCNetworkActorManager@@XZ ENDP ; CRef<CNetworkActorManager>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 951  : 		{	// construct empty deque

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00003	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 774  : 		_Mapsize = 0;

  00012	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 775  : 		_Myoff = 0;

  00019	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 776  : 		_Mysize = 0;

  00020	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	74 17		 je	 SHORT $LN48@deque
  00033	89 06		 mov	 DWORD PTR [esi], eax

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0003b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

  00042	8b 06		 mov	 eax, DWORD PTR [esi]
  00044	89 30		 mov	 DWORD PTR [eax], esi

; 952  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi
  00049	c3		 ret	 0
$LN48@deque:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  0004a	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN50@deque:
$LN47@deque:
  0004f	cc		 int	 3
??0?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 1214 : 		{	// destroy the deque

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1215 : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 907  : 		this->_Myproxy = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 1216 : 		}

  00019	c3		 ret	 0
??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCGuildMarkDownloader@@@@SAAAVCGuildMarkDownloader@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCGuildMarkDownloader@@@@SAAAVCGuildMarkDownloader@@XZ PROC ; CSingleton<CGuildMarkDownloader>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCGuildMarkDownloader@@@@0PAVCGuildMarkDownloader@@A ; CSingleton<CGuildMarkDownloader>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCGuildMarkDownloader@@@@SAAAVCGuildMarkDownloader@@XZ ENDP ; CSingleton<CGuildMarkDownloader>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCGuildMarkUploader@@@@SAAAVCGuildMarkUploader@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCGuildMarkUploader@@@@SAAAVCGuildMarkUploader@@XZ PROC ; CSingleton<CGuildMarkUploader>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCGuildMarkUploader@@@@0PAVCGuildMarkUploader@@A ; CSingleton<CGuildMarkUploader>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCGuildMarkUploader@@@@SAAAVCGuildMarkUploader@@XZ ENDP ; CSingleton<CGuildMarkUploader>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??_G?$CSingleton@VCPythonNetworkStream@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CSingleton@VCPythonNetworkStream@@@@UAEPAXI@Z PROC ; CSingleton<CPythonNetworkStream>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 21   : 		ms_singleton = 0; 

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A, 0 ; CSingleton<CPythonNetworkStream>::ms_singleton
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCPythonNetworkStream@@@@6B@
  0001a	74 09		 je	 SHORT $LN6@scalar
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_G?$CSingleton@VCPythonNetworkStream@@@@UAEPAXI@Z ENDP ; CSingleton<CPythonNetworkStream>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\funcobject.h
;	COMDAT ??_G?$CFuncObject@VCPythonNetworkStream@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CFuncObject@VCPythonNetworkStream@@@@UAEPAXI@Z PROC ; CFuncObject<CPythonNetworkStream>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 13   : 		{

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CFuncObject@VCPythonNetworkStream@@@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$CFuncObject@VCPythonNetworkStream@@@@UAEPAXI@Z ENDP ; CFuncObject<CPythonNetworkStream>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h
;	COMDAT ?Clear@?$CRef@VCNetworkActorManager@@@@QAEXXZ
_TEXT	SEGMENT
?Clear@?$CRef@VCNetworkActorManager@@@@QAEXXZ PROC	; CRef<CNetworkActorManager>::Clear, COMDAT
; _this$ = ecx

; 52   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 53   : 			if (m_pObject)

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 0b		 je	 SHORT $LN1@Clear

; 54   : 			{
; 55   : 				m_pObject->Release();

  00009	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Clear:
  00014	5e		 pop	 esi

; 57   : 			}
; 58   : 		}

  00015	c3		 ret	 0
?Clear@?$CRef@VCNetworkActorManager@@@@QAEXXZ ENDP	; CRef<CNetworkActorManager>::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\ref.h
;	COMDAT ?SetPointer@?$CRef@VCNetworkActorManager@@@@QAEXPAVCReferenceObject@@@Z
_TEXT	SEGMENT
_pObject$ = 8						; size = 4
?SetPointer@?$CRef@VCNetworkActorManager@@@@QAEXPAVCReferenceObject@@@Z PROC ; CRef<CNetworkActorManager>::SetPointer, COMDAT
; _this$ = ecx

; 66   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 			CReferenceObject* pOldObject = m_pObject;
; 68   : 
; 69   : 			m_pObject = pObject;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pObject$[ebp]
  00006	56		 push	 esi
  00007	8b 31		 mov	 esi, DWORD PTR [ecx]
  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 70   : 
; 71   : 			if (m_pObject)

  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@SetPointer

; 72   : 				m_pObject->AddReference();

  0000f	8b c8		 mov	 ecx, eax
  00011	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN2@SetPointer:

; 73   : 
; 74   : 			if (pOldObject)

  00016	85 f6		 test	 esi, esi
  00018	74 07		 je	 SHORT $LN1@SetPointer

; 75   : 				pOldObject->Release();

  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN1@SetPointer:
  00021	5e		 pop	 esi

; 76   : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetPointer@?$CRef@VCNetworkActorManager@@@@QAEXPAVCReferenceObject@@@Z ENDP ; CRef<CNetworkActorManager>::SetPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1827 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 783  : 		}
; 784  : 
; 785  : 	_Mapptr _Map;		// pointer to array of pointers to blocks
; 786  : 	size_type _Mapsize;	// size of map array, zero or 2^N
; 787  : 	size_type _Myoff;	// offset of initial element
; 788  : 	size_type _Mysize;	// current length of sequence
; 789  : 	};
; 790  : 
; 791  : 		// TEMPLATE CLASS _Deque_alloc
; 792  : template<bool _Al_has_storage,
; 793  : 	class _Alloc_types>
; 794  : 	class _Deque_alloc
; 795  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 796  : 	{	// base class for deque to hold allocator with storage
; 797  : public:
; 798  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 799  : 
; 800  : 	typedef _Deque_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 801  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 802  : 	typedef typename _Alloc_types::_Alty _Alty;
; 803  : 
; 804  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 805  : 
; 806  : 	_Deque_alloc(const _Alloc& _Al = _Alloc())
; 807  : 		: _Alval(_Al)
; 808  : 		{	// construct allocators from _Al
; 809  : 		_Alloc_proxy();
; 810  : 		}
; 811  : 
; 812  : 	~_Deque_alloc() _NOEXCEPT
; 813  : 		{	// destroy proxy
; 814  : 		_Free_proxy();
; 815  : 		}
; 816  : 
; 817  : 	void _Change_alloc(const _Alty& _Al)
; 818  : 		{	// replace old allocator
; 819  : 		_Free_proxy();
; 820  : 		this->_Alval = _Al;
; 821  : 		_Alloc_proxy();
; 822  : 		}
; 823  : 
; 824  : 	void _Swap_alloc(_Myt& _Right)
; 825  : 		{	// swap allocators
; 826  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 827  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 828  : 		}
; 829  : 
; 830  : 	void _Alloc_proxy()
; 831  : 		{	// construct proxy from _Alval
; 832  : 		typename _Alty::template rebind<_Container_proxy>::other
; 833  : 			_Alproxy(this->_Alval);
; 834  : 		this->_Myproxy = _Alproxy.allocate(1);
; 835  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 836  : 		this->_Myproxy->_Mycont = this;
; 837  : 		}
; 838  : 
; 839  : 	void _Free_proxy()
; 840  : 		{	// destroy proxy
; 841  : 		typename _Alty::template rebind<_Container_proxy>::other
; 842  : 			_Alproxy(this->_Alval);
; 843  : 		this->_Orphan_all();
; 844  : 		_Alproxy.destroy(this->_Myproxy);
; 845  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 846  : 		this->_Myproxy = 0;
; 847  : 		}
; 848  : 
; 849  : 	_Alty& _Getal()
; 850  : 		{	// get reference to allocator
; 851  : 		return (this->_Alval);
; 852  : 		}
; 853  : 
; 854  : 	const _Alty& _Getal() const
; 855  : 		{	// get reference to allocator
; 856  : 		return (this->_Alval);
; 857  : 		}
; 858  : 	};
; 859  : 
; 860  : template<class _Alloc_types>
; 861  : 	class _Deque_alloc<false, _Alloc_types>
; 862  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 863  : 	{	// base class for deque to hold allocator with no storage
; 864  : public:
; 865  : 	typedef _Deque_alloc<false, _Alloc_types> _Myt;
; 866  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 867  : 
; 868  : 	typedef typename _Alloc_types::_Alty _Alty;
; 869  : 
; 870  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 871  : 
; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())
; 873  : 		{	// construct allocators from _Al
; 874  : 		_Alloc_proxy();
; 875  : 		}
; 876  : 
; 877  : 	~_Deque_alloc() _NOEXCEPT
; 878  : 		{	// destroy proxy
; 879  : 		_Free_proxy();
; 880  : 		}
; 881  : 
; 882  : 	void _Change_alloc(const _Alty&)
; 883  : 		{	// replace old allocator
; 884  : 		}
; 885  : 
; 886  : 	void _Swap_alloc(_Myt& _Right)
; 887  : 		{	// swap allocators
; 888  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 889  : 		}
; 890  : 
; 891  : 	void _Alloc_proxy()
; 892  : 		{	// construct proxy from _Alval
; 893  : 		typename _Alty::template rebind<_Container_proxy>::other
; 894  : 			_Alproxy;
; 895  : 		this->_Myproxy = _Alproxy.allocate(1);
; 896  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 897  : 		this->_Myproxy->_Mycont = this;
; 898  : 		}
; 899  : 
; 900  : 	void _Free_proxy()
; 901  : 		{	// destroy proxy
; 902  : 		typename _Alty::template rebind<_Container_proxy>::other
; 903  : 			_Alproxy;
; 904  : 		this->_Orphan_all();
; 905  : 		_Alproxy.destroy(this->_Myproxy);
; 906  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 907  : 		this->_Myproxy = 0;
; 908  : 		}
; 909  : 
; 910  : 	_Alty _Getal() const
; 911  : 		{	// get reference to allocator
; 912  : 		return (_Alty());
; 913  : 		}
; 914  : 	};
; 915  : 
; 916  : 		// TEMPLATE CLASS deque
; 917  : template<class _Ty,
; 918  : 	class _Alloc = allocator<_Ty> >
; 919  : 	class deque
; 920  : 		: public _Deque_alloc<!is_empty<_Alloc>::value,
; 921  : 			_Deque_base_types<_Ty, _Alloc> >
; 922  : 	{	// circular queue of pointers to blocks
; 923  : public:
; 924  : 	typedef deque<_Ty, _Alloc> _Myt;
; 925  : 	typedef _Deque_alloc<!is_empty<_Alloc>::value,
; 926  : 		_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 927  : 	typedef _Alloc allocator_type;
; 928  : 
; 929  : 	typedef typename _Mybase::_Alty _Alty;
; 930  : 	typedef typename _Mybase::_Alpty _Alpty;
; 931  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 932  : 
; 933  : 	typedef typename _Mybase::value_type value_type;
; 934  : 	typedef typename _Mybase::size_type size_type;
; 935  : 	typedef typename _Mybase::difference_type difference_type;
; 936  : 	typedef typename _Mybase::pointer pointer;
; 937  : 	typedef typename _Mybase::const_pointer const_pointer;
; 938  : 	typedef typename _Mybase::reference reference;
; 939  : 	typedef typename _Mybase::const_reference const_reference;
; 940  : 
; 941  : 	typedef typename _Mybase::iterator iterator;
; 942  : 	typedef typename _Mybase::const_iterator const_iterator;
; 943  : 
; 944  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 945  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 946  : 
; 947  : 	static const int _EEM_DS = _DEQUESIZ;
; 948  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 949  : 	deque()
; 950  : 		: _Mybase()
; 951  : 		{	// construct empty deque
; 952  : 		}
; 953  : 
; 954  : 	explicit deque(const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct empty deque with allocator
; 957  : 		}
; 958  : 
; 959  : 	explicit deque(size_type _Count)
; 960  : 		: _Mybase()
; 961  : 		{	// construct from _Count * value_type()
; 962  : 		resize(_Count);
; 963  : 		}
; 964  : 
; 965  : 	deque(size_type _Count, const value_type& _Val)
; 966  : 		: _Mybase()
; 967  : 		{	// construct from _Count * _Val
; 968  : 		_Construct_n(_Count, _Val);
; 969  : 		}
; 970  : 
; 971  : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 972  : 		: _Mybase(_Al)
; 973  : 		{	// construct from _Count * _Val with allocator
; 974  : 		_Construct_n(_Count, _Val);
; 975  : 		}
; 976  : 
; 977  : 	deque(const _Myt& _Right)
; 978  : 
; 979  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 980  : 
; 981  : 
; 982  : 		{	// construct by copying _Right
; 983  : 		_Construct(_Right.begin(), _Right.end());
; 984  : 		}
; 985  : 
; 986  : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 987  : 		: _Mybase(_Al)
; 988  : 		{	// construct by copying _Right
; 989  : 		_Construct(_Right.begin(), _Right.end());
; 990  : 		}
; 991  : 
; 992  : 	template<class _Iter,
; 993  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 994  : 			void>::type>
; 995  : 		deque(_Iter _First, _Iter _Last)
; 996  : 		: _Mybase()
; 997  : 		{	// construct from [_First, _Last)
; 998  : 		_Construct(_First, _Last);
; 999  : 		}
; 1000 : 
; 1001 : 	template<class _Iter,
; 1002 : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 1003 : 			void>::type>
; 1004 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 1005 : 		: _Mybase(_Al)
; 1006 : 		{	// construct from [_First, _Last) with allocator
; 1007 : 		_Construct(_First, _Last);
; 1008 : 		}
; 1009 : 
; 1010 : 	template<class _Iter>
; 1011 : 		void _Construct(_Iter _First, _Iter _Last)
; 1012 : 		{	// initialize from [_First, _Last), input iterators
; 1013 : 		_TRY_BEGIN
; 1014 : 
; 1015 : 		for (; _First != _Last; ++_First)
; 1016 : 			emplace_back(*_First);
; 1017 : 
; 1018 : 		_CATCH_ALL
; 1019 : 		_Tidy();
; 1020 : 		_RERAISE;
; 1021 : 		_CATCH_END
; 1022 : 		}
; 1023 : 
; 1024 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1025 : 		{	// construct from _Count * _Val
; 1026 : 		_TRY_BEGIN
; 1027 : 		for (; 0 < _Count; --_Count)
; 1028 : 			push_back(_Val);
; 1029 : 		_CATCH_ALL
; 1030 : 		_Tidy();
; 1031 : 		_RERAISE;
; 1032 : 		_CATCH_END
; 1033 : 		}
; 1034 : 
; 1035 : #define _PUSH_FRONT_BEGIN \
; 1036 : 	if (this->_Myoff % _DEQUESIZ == 0 \
; 1037 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1038 : 		_Growmap(1); \
; 1039 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1040 : 	size_type _Newoff = this->_Myoff != 0 ? this->_Myoff \
; 1041 : 		: this->_Mapsize * _DEQUESIZ; \
; 1042 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1043 : 	if (this->_Map[_Block] == pointer()) \
; 1044 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1045 : 
; 1046 : #define _PUSH_FRONT_END \
; 1047 : 	this->_Myoff = _Newoff; \
; 1048 : 	++this->_Mysize
; 1049 : 
; 1050 : #define _PUSH_BACK_BEGIN \
; 1051 : 	if ((this->_Myoff + this->_Mysize) % _DEQUESIZ == 0 \
; 1052 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1053 : 		_Growmap(1); \
; 1054 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1055 : 	size_type _Newoff = this->_Myoff + this->_Mysize; \
; 1056 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1057 : 	if (this->_Map[_Block] == pointer()) \
; 1058 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1059 : 
; 1060 : #define _PUSH_BACK_END \
; 1061 : 	++this->_Mysize
; 1062 : 
; 1063 : 	deque(_Myt&& _Right)
; 1064 : 		: _Mybase(_Right._Getal())
; 1065 : 		{	// construct by moving _Right
; 1066 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1067 : 		}
; 1068 : 
; 1069 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1070 : 		: _Mybase(_Al)
; 1071 : 		{	// construct by moving _Right
; 1072 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1073 : 		}
; 1074 : 
; 1075 : 	_Myt& operator=(_Myt&& _Right)
; 1076 : 		{	// assign by moving _Right
; 1077 : 		if (this != &_Right)
; 1078 : 			{	// different, assign it
; 1079 : 			_Tidy();
; 1080 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1081 : 				&& this->_Getal() != _Right._Getal())
; 1082 : 				this->_Change_alloc(_Right._Getal());
; 1083 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1084 : 			}
; 1085 : 		return (*this);
; 1086 : 		}
; 1087 : 
; 1088 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1089 : 		{	// move from _Right, stealing its contents
; 1090 : 		this->_Swap_all((_Myt&)_Right);
; 1091 : 		this->_Map = _Right._Map;
; 1092 : 		this->_Mapsize = _Right._Mapsize;
; 1093 : 		this->_Myoff = _Right._Myoff;
; 1094 : 		this->_Mysize = _Right._Mysize;
; 1095 : 
; 1096 : 		_Right._Map = _Mapptr();
; 1097 : 		_Right._Mapsize = 0;
; 1098 : 		_Right._Myoff = 0;
; 1099 : 		_Right._Mysize = 0;
; 1100 : 		}
; 1101 : 
; 1102 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1103 : 		{	// move from _Right, possibly moving its contents
; 1104 : 		if (get_allocator() == _Right.get_allocator())
; 1105 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1106 : 		else
; 1107 : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 1108 : 				_STD make_move_iterator(_Right.end()));
; 1109 : 		}
; 1110 : 
; 1111 : 	void _Assign_rv(_Myt&& _Right)
; 1112 : 		{	// assign by moving _Right
; 1113 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1114 : 			typename _Alty::propagate_on_container_move_assignment());
; 1115 : 		}
; 1116 : 
; 1117 : 
; 1118 : 	void push_front(value_type&& _Val)
; 1119 : 		{	// insert element at beginning
; 1120 : 		this->_Orphan_all();
; 1121 : 		_PUSH_FRONT_BEGIN;
; 1122 : 		this->_Getal().construct(
; 1123 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1124 : 			_STD forward<value_type>(_Val));
; 1125 : 		_PUSH_FRONT_END;
; 1126 : 		}
; 1127 : 
; 1128 : 	void push_back(value_type&& _Val)
; 1129 : 		{	// insert element at end
; 1130 : 		this->_Orphan_all();
; 1131 : 		_PUSH_BACK_BEGIN;
; 1132 : 		this->_Getal().construct(
; 1133 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 			_STD forward<value_type>(_Val));
; 1135 : 		_PUSH_BACK_END;
; 1136 : 		}
; 1137 : 
; 1138 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1139 : 		{	// insert _Val at _Where
; 1140 : 		return (emplace(_Where, _STD move(_Val)));
; 1141 : 		}
; 1142 : 
; 1143 : 	template<class... _Valty>
; 1144 : 		void emplace_front(_Valty&&... _Val)
; 1145 : 		{	// insert element at beginning
; 1146 : 		this->_Orphan_all();
; 1147 : 		_PUSH_FRONT_BEGIN;
; 1148 : 		this->_Getal().construct(
; 1149 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1150 : 			_STD forward<_Valty>(_Val)...);
; 1151 : 		_PUSH_FRONT_END;
; 1152 : 		}
; 1153 : 
; 1154 : 	template<class... _Valty>
; 1155 : 		void emplace_back(_Valty&&... _Val)
; 1156 : 		{	// insert element at end
; 1157 : 		this->_Orphan_all();
; 1158 : 		_PUSH_BACK_BEGIN;
; 1159 : 		this->_Getal().construct(
; 1160 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1161 : 			_STD forward<_Valty>(_Val)...);
; 1162 : 		_PUSH_BACK_END;
; 1163 : 		}
; 1164 : 
; 1165 : 	template<class... _Valty>
; 1166 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1167 : 		{	// insert element at _Where
; 1168 : 		size_type _Off = _Where - begin();
; 1169 : 
; 1170 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1171 : 		if (this->_Mysize < _Off)
; 1172 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1173 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1174 : 
; 1175 : 		if (_Off <= this->_Mysize / 2)
; 1176 : 			{	// closer to front, push to front then rotate
; 1177 : 			emplace_front(_STD forward<_Valty>(_Val)...);
; 1178 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off);
; 1179 : 			}
; 1180 : 		else
; 1181 : 			{	// closer to back, push to back then rotate
; 1182 : 			emplace_back(_STD forward<_Valty>(_Val)...);
; 1183 : 			_STD rotate(begin() + _Off, end() - 1, end());
; 1184 : 			}
; 1185 : 		return (begin() + _Off);
; 1186 : 		}
; 1187 : 
; 1188 : 
; 1189 : 	deque(_XSTD initializer_list<value_type> _Ilist,
; 1190 : 		const _Alloc& _Al = allocator_type())
; 1191 : 		: _Mybase(_Al)
; 1192 : 		{	// construct from initializer_list
; 1193 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1194 : 		}
; 1195 : 
; 1196 : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 1197 : 		{	// assign initializer_list
; 1198 : 		assign(_Ilist.begin(), _Ilist.end());
; 1199 : 		return (*this);
; 1200 : 		}
; 1201 : 
; 1202 : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 1203 : 		{	// assign initializer_list
; 1204 : 		assign(_Ilist.begin(), _Ilist.end());
; 1205 : 		}
; 1206 : 
; 1207 : 	iterator insert(const_iterator _Where,
; 1208 : 		_XSTD initializer_list<value_type> _Ilist)
; 1209 : 		{	// insert initializer_list
; 1210 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1211 : 		}
; 1212 : 
; 1213 : 	~deque() _NOEXCEPT
; 1214 : 		{	// destroy the deque
; 1215 : 		_Tidy();
; 1216 : 		}
; 1217 : 
; 1218 : 	_Myt& operator=(const _Myt& _Right)
; 1219 : 		{	// assign _Right
; 1220 : 		if (this != &_Right)
; 1221 : 			{	// different, assign it
; 1222 : 			if (this->_Getal() != _Right._Getal()
; 1223 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1224 : 				{	// change allocator before copying
; 1225 : 				_Tidy();
; 1226 : 				this->_Change_alloc(_Right._Getal());
; 1227 : 				}
; 1228 : 
; 1229 : 			this->_Orphan_all();
; 1230 : 
; 1231 : 			if (_Right._Mysize == 0)
; 1232 : 				clear();
; 1233 : 			else if (_Right._Mysize <= this->_Mysize)
; 1234 : 				{	// enough elements, copy new and destroy old
; 1235 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1236 : 					begin());
; 1237 : 				erase(_Mid, end());
; 1238 : 				}
; 1239 : 			else
; 1240 : 				{	// new sequence longer, copy and construct new
; 1241 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;
; 1242 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1243 : 				insert(end(), _Mid, _Right.end());
; 1244 : 				}
; 1245 : 			}
; 1246 : 		return (*this);
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator begin() _NOEXCEPT
; 1250 : 		{	// return iterator for beginning of mutable sequence
; 1251 : 		return (iterator(this->_Myoff, this));
; 1252 : 		}
; 1253 : 
; 1254 : 	const_iterator begin() const _NOEXCEPT
; 1255 : 		{	// return iterator for beginning of nonmutable sequence
; 1256 : 		return (const_iterator(this->_Myoff, this));
; 1257 : 		}
; 1258 : 
; 1259 : 	iterator end() _NOEXCEPT
; 1260 : 		{	// return iterator for end of mutable sequence
; 1261 : 		return (iterator(this->_Myoff + this->_Mysize, this));
; 1262 : 		}
; 1263 : 
; 1264 : 	const_iterator end() const _NOEXCEPT
; 1265 : 		{	// return iterator for end of nonmutable sequence
; 1266 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));
; 1267 : 		}
; 1268 : 
; 1269 : 	iterator _Make_iter(const_iterator _Where) const
; 1270 : 		{	// make iterator from const_iterator
; 1271 : 		return (iterator(_Where._Myoff, this));
; 1272 : 		}
; 1273 : 
; 1274 : 	reverse_iterator rbegin() _NOEXCEPT
; 1275 : 		{	// return iterator for beginning of reversed mutable sequence
; 1276 : 		return (reverse_iterator(end()));
; 1277 : 		}
; 1278 : 
; 1279 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1280 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1281 : 		return (const_reverse_iterator(end()));
; 1282 : 		}
; 1283 : 
; 1284 : 	reverse_iterator rend() _NOEXCEPT
; 1285 : 		{	// return iterator for end of reversed mutable sequence
; 1286 : 		return (reverse_iterator(begin()));
; 1287 : 		}
; 1288 : 
; 1289 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1290 : 		{	// return iterator for end of reversed nonmutable sequence
; 1291 : 		return (const_reverse_iterator(begin()));
; 1292 : 		}
; 1293 : 
; 1294 : 	const_iterator cbegin() const _NOEXCEPT
; 1295 : 		{	// return iterator for beginning of nonmutable sequence
; 1296 : 		return (((const _Myt *)this)->begin());
; 1297 : 		}
; 1298 : 
; 1299 : 	const_iterator cend() const _NOEXCEPT
; 1300 : 		{	// return iterator for end of nonmutable sequence
; 1301 : 		return (((const _Myt *)this)->end());
; 1302 : 		}
; 1303 : 
; 1304 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1306 : 		return (((const _Myt *)this)->rbegin());
; 1307 : 		}
; 1308 : 
; 1309 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1310 : 		{	// return iterator for end of reversed nonmutable sequence
; 1311 : 		return (((const _Myt *)this)->rend());
; 1312 : 		}
; 1313 : 
; 1314 : 	void shrink_to_fit()
; 1315 : 		{	// reduce capacity
; 1316 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize;
; 1317 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1318 : 
; 1319 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1320 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1321 : 
; 1322 : 		if ((empty() && 0 < this->_Mapsize)
; 1323 : 			|| (!empty()
; 1324 : 				&& size() <= _Newcapacity
; 1325 : 				&& _Newcapacity < _Oldcapacity))
; 1326 : 			{	// worth shrinking, do it
; 1327 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1328 : 				_STD make_move_iterator(end()));
; 1329 : 			swap(_Tmp);
; 1330 : 			}
; 1331 : 		}
; 1332 : 
; 1333 : 	void resize(size_type _Newsize)
; 1334 : 		{	// determine new length, padding as needed
; 1335 : 		while (this->_Mysize < _Newsize)
; 1336 : 			emplace_back();
; 1337 : 
; 1338 : 		while (_Newsize < this->_Mysize)
; 1339 : 			pop_back();
; 1340 : 		}
; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);

  00004	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0

; 1828 : 		_Alpty _Almap(this->_Getal());
; 1829 : 		while (!empty())

  00008	74 4e		 je	 SHORT $LN5@Tidy
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL6@Tidy:

; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

  00010	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00013	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00016	48		 dec	 eax
  00017	03 c8		 add	 ecx, eax

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00019	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001c	48		 dec	 eax
  0001d	23 c8		 and	 ecx, eax

; 1363 : 		}
; 1364 : 
; 1365 : 	allocator_type get_allocator() const _NOEXCEPT
; 1366 : 		{	// return allocator object for values
; 1367 : 		return (this->_Getal());
; 1368 : 		}
; 1369 : 
; 1370 : 	const_reference at(size_type _Pos) const
; 1371 : 		{	// subscript nonmutable sequence with checking
; 1372 : 		if (this->_Mysize <= _Pos)
; 1373 : 			_Xran();
; 1374 : 		return (*(begin() + _Pos));
; 1375 : 		}
; 1376 : 
; 1377 : 	reference at(size_type _Pos)
; 1378 : 		{	// subscript mutable sequence with checking
; 1379 : 		if (this->_Mysize <= _Pos)
; 1380 : 			_Xran();
; 1381 : 		return (*(begin() + _Pos));
; 1382 : 		}
; 1383 : 
; 1384 : 	const_reference operator[](size_type _Pos) const
; 1385 : 		{	// subscript nonmutable sequence
; 1386 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 		if (this->_Mysize <= _Pos)
; 1388 : 			_DEBUG_ERROR("deque subscript out of range");
; 1389 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1390 : 
; 1391 : 		return (*(begin() + _Pos));
; 1392 : 		}
; 1393 : 
; 1394 : 	reference operator[](size_type _Pos)
; 1395 : 		{	// subscript mutable sequence
; 1396 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1397 : 		if (this->_Mysize <= _Pos)
; 1398 : 			_DEBUG_ERROR("deque subscript out of range");
; 1399 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1400 : 
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	reference front()
; 1405 : 		{	// return first element of mutable sequence
; 1406 : 		return (*begin());
; 1407 : 		}
; 1408 : 
; 1409 : 	const_reference front() const
; 1410 : 		{	// return first element of nonmutable sequence
; 1411 : 		return (*begin());
; 1412 : 		}
; 1413 : 
; 1414 : 	reference back()
; 1415 : 		{	// return last element of mutable sequence
; 1416 : 		return (*(end() - 1));
; 1417 : 		}
; 1418 : 
; 1419 : 	const_reference back() const
; 1420 : 		{	// return last element of nonmutable sequence
; 1421 : 		return (*(end() - 1));
; 1422 : 		}
; 1423 : 
; 1424 : 	void push_front(const value_type& _Val)
; 1425 : 		{	// insert element at beginning
; 1426 : 		this->_Orphan_all();
; 1427 : 		_PUSH_FRONT_BEGIN;
; 1428 : 		this->_Getal().construct(
; 1429 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1430 : 		_PUSH_FRONT_END;
; 1431 : 		}
; 1432 : 
; 1433 : 	void pop_front()
; 1434 : 		{	// erase element at beginning
; 1435 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1436 : 		if (empty())
; 1437 : 			_DEBUG_ERROR("deque empty before pop");
; 1438 : 		else
; 1439 : 			{	// something to erase, do it
; 1440 : 			_Orphan_off(this->_Myoff);
; 1441 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1442 : 			this->_Getal().destroy(
; 1443 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1444 : 			if (--this->_Mysize == 0)
; 1445 : 				this->_Myoff = 0;
; 1446 : 			else
; 1447 : 				++this->_Myoff;
; 1448 : 			}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 		size_type _Block = this->_Getblock(this->_Myoff);
; 1452 : 		this->_Getal().destroy(
; 1453 : 			this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1454 : 		if (--this->_Mysize == 0)
; 1455 : 			this->_Myoff = 0;
; 1456 : 		else
; 1457 : 			++this->_Myoff;
; 1458 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1459 : 		}
; 1460 : 
; 1461 : 	void push_back(const value_type& _Val)
; 1462 : 		{	// insert element at end
; 1463 : 		this->_Orphan_all();
; 1464 : 		_PUSH_BACK_BEGIN;
; 1465 : 		this->_Getal().construct(
; 1466 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1467 : 		_PUSH_BACK_END;
; 1468 : 		}
; 1469 : 
; 1470 : 	void pop_back()
; 1471 : 		{	// erase element at end
; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

  0001f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00022	8b 3c 88	 mov	 edi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00025	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00029	72 0a		 jb	 SHORT $LN49@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0002b	ff 37		 push	 DWORD PTR [edi]
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00032	83 c4 04	 add	 esp, 4
$LN49@Tidy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00035	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0003c	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00043	c6 07 00	 mov	 BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1491 : 		if (--this->_Mysize == 0)

  00046	ff 4e 10	 dec	 DWORD PTR [esi+16]
  00049	75 07		 jne	 SHORT $LN13@Tidy

; 1492 : 			this->_Myoff = 0;

  0004b	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN13@Tidy:

; 783  : 		}
; 784  : 
; 785  : 	_Mapptr _Map;		// pointer to array of pointers to blocks
; 786  : 	size_type _Mapsize;	// size of map array, zero or 2^N
; 787  : 	size_type _Myoff;	// offset of initial element
; 788  : 	size_type _Mysize;	// current length of sequence
; 789  : 	};
; 790  : 
; 791  : 		// TEMPLATE CLASS _Deque_alloc
; 792  : template<bool _Al_has_storage,
; 793  : 	class _Alloc_types>
; 794  : 	class _Deque_alloc
; 795  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 796  : 	{	// base class for deque to hold allocator with storage
; 797  : public:
; 798  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 799  : 
; 800  : 	typedef _Deque_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 801  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 802  : 	typedef typename _Alloc_types::_Alty _Alty;
; 803  : 
; 804  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 805  : 
; 806  : 	_Deque_alloc(const _Alloc& _Al = _Alloc())
; 807  : 		: _Alval(_Al)
; 808  : 		{	// construct allocators from _Al
; 809  : 		_Alloc_proxy();
; 810  : 		}
; 811  : 
; 812  : 	~_Deque_alloc() _NOEXCEPT
; 813  : 		{	// destroy proxy
; 814  : 		_Free_proxy();
; 815  : 		}
; 816  : 
; 817  : 	void _Change_alloc(const _Alty& _Al)
; 818  : 		{	// replace old allocator
; 819  : 		_Free_proxy();
; 820  : 		this->_Alval = _Al;
; 821  : 		_Alloc_proxy();
; 822  : 		}
; 823  : 
; 824  : 	void _Swap_alloc(_Myt& _Right)
; 825  : 		{	// swap allocators
; 826  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 827  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 828  : 		}
; 829  : 
; 830  : 	void _Alloc_proxy()
; 831  : 		{	// construct proxy from _Alval
; 832  : 		typename _Alty::template rebind<_Container_proxy>::other
; 833  : 			_Alproxy(this->_Alval);
; 834  : 		this->_Myproxy = _Alproxy.allocate(1);
; 835  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 836  : 		this->_Myproxy->_Mycont = this;
; 837  : 		}
; 838  : 
; 839  : 	void _Free_proxy()
; 840  : 		{	// destroy proxy
; 841  : 		typename _Alty::template rebind<_Container_proxy>::other
; 842  : 			_Alproxy(this->_Alval);
; 843  : 		this->_Orphan_all();
; 844  : 		_Alproxy.destroy(this->_Myproxy);
; 845  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 846  : 		this->_Myproxy = 0;
; 847  : 		}
; 848  : 
; 849  : 	_Alty& _Getal()
; 850  : 		{	// get reference to allocator
; 851  : 		return (this->_Alval);
; 852  : 		}
; 853  : 
; 854  : 	const _Alty& _Getal() const
; 855  : 		{	// get reference to allocator
; 856  : 		return (this->_Alval);
; 857  : 		}
; 858  : 	};
; 859  : 
; 860  : template<class _Alloc_types>
; 861  : 	class _Deque_alloc<false, _Alloc_types>
; 862  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 863  : 	{	// base class for deque to hold allocator with no storage
; 864  : public:
; 865  : 	typedef _Deque_alloc<false, _Alloc_types> _Myt;
; 866  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 867  : 
; 868  : 	typedef typename _Alloc_types::_Alty _Alty;
; 869  : 
; 870  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 871  : 
; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())
; 873  : 		{	// construct allocators from _Al
; 874  : 		_Alloc_proxy();
; 875  : 		}
; 876  : 
; 877  : 	~_Deque_alloc() _NOEXCEPT
; 878  : 		{	// destroy proxy
; 879  : 		_Free_proxy();
; 880  : 		}
; 881  : 
; 882  : 	void _Change_alloc(const _Alty&)
; 883  : 		{	// replace old allocator
; 884  : 		}
; 885  : 
; 886  : 	void _Swap_alloc(_Myt& _Right)
; 887  : 		{	// swap allocators
; 888  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 889  : 		}
; 890  : 
; 891  : 	void _Alloc_proxy()
; 892  : 		{	// construct proxy from _Alval
; 893  : 		typename _Alty::template rebind<_Container_proxy>::other
; 894  : 			_Alproxy;
; 895  : 		this->_Myproxy = _Alproxy.allocate(1);
; 896  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 897  : 		this->_Myproxy->_Mycont = this;
; 898  : 		}
; 899  : 
; 900  : 	void _Free_proxy()
; 901  : 		{	// destroy proxy
; 902  : 		typename _Alty::template rebind<_Container_proxy>::other
; 903  : 			_Alproxy;
; 904  : 		this->_Orphan_all();
; 905  : 		_Alproxy.destroy(this->_Myproxy);
; 906  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 907  : 		this->_Myproxy = 0;
; 908  : 		}
; 909  : 
; 910  : 	_Alty _Getal() const
; 911  : 		{	// get reference to allocator
; 912  : 		return (_Alty());
; 913  : 		}
; 914  : 	};
; 915  : 
; 916  : 		// TEMPLATE CLASS deque
; 917  : template<class _Ty,
; 918  : 	class _Alloc = allocator<_Ty> >
; 919  : 	class deque
; 920  : 		: public _Deque_alloc<!is_empty<_Alloc>::value,
; 921  : 			_Deque_base_types<_Ty, _Alloc> >
; 922  : 	{	// circular queue of pointers to blocks
; 923  : public:
; 924  : 	typedef deque<_Ty, _Alloc> _Myt;
; 925  : 	typedef _Deque_alloc<!is_empty<_Alloc>::value,
; 926  : 		_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 927  : 	typedef _Alloc allocator_type;
; 928  : 
; 929  : 	typedef typename _Mybase::_Alty _Alty;
; 930  : 	typedef typename _Mybase::_Alpty _Alpty;
; 931  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 932  : 
; 933  : 	typedef typename _Mybase::value_type value_type;
; 934  : 	typedef typename _Mybase::size_type size_type;
; 935  : 	typedef typename _Mybase::difference_type difference_type;
; 936  : 	typedef typename _Mybase::pointer pointer;
; 937  : 	typedef typename _Mybase::const_pointer const_pointer;
; 938  : 	typedef typename _Mybase::reference reference;
; 939  : 	typedef typename _Mybase::const_reference const_reference;
; 940  : 
; 941  : 	typedef typename _Mybase::iterator iterator;
; 942  : 	typedef typename _Mybase::const_iterator const_iterator;
; 943  : 
; 944  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 945  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 946  : 
; 947  : 	static const int _EEM_DS = _DEQUESIZ;
; 948  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 949  : 	deque()
; 950  : 		: _Mybase()
; 951  : 		{	// construct empty deque
; 952  : 		}
; 953  : 
; 954  : 	explicit deque(const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct empty deque with allocator
; 957  : 		}
; 958  : 
; 959  : 	explicit deque(size_type _Count)
; 960  : 		: _Mybase()
; 961  : 		{	// construct from _Count * value_type()
; 962  : 		resize(_Count);
; 963  : 		}
; 964  : 
; 965  : 	deque(size_type _Count, const value_type& _Val)
; 966  : 		: _Mybase()
; 967  : 		{	// construct from _Count * _Val
; 968  : 		_Construct_n(_Count, _Val);
; 969  : 		}
; 970  : 
; 971  : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 972  : 		: _Mybase(_Al)
; 973  : 		{	// construct from _Count * _Val with allocator
; 974  : 		_Construct_n(_Count, _Val);
; 975  : 		}
; 976  : 
; 977  : 	deque(const _Myt& _Right)
; 978  : 
; 979  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 980  : 
; 981  : 
; 982  : 		{	// construct by copying _Right
; 983  : 		_Construct(_Right.begin(), _Right.end());
; 984  : 		}
; 985  : 
; 986  : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 987  : 		: _Mybase(_Al)
; 988  : 		{	// construct by copying _Right
; 989  : 		_Construct(_Right.begin(), _Right.end());
; 990  : 		}
; 991  : 
; 992  : 	template<class _Iter,
; 993  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 994  : 			void>::type>
; 995  : 		deque(_Iter _First, _Iter _Last)
; 996  : 		: _Mybase()
; 997  : 		{	// construct from [_First, _Last)
; 998  : 		_Construct(_First, _Last);
; 999  : 		}
; 1000 : 
; 1001 : 	template<class _Iter,
; 1002 : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 1003 : 			void>::type>
; 1004 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 1005 : 		: _Mybase(_Al)
; 1006 : 		{	// construct from [_First, _Last) with allocator
; 1007 : 		_Construct(_First, _Last);
; 1008 : 		}
; 1009 : 
; 1010 : 	template<class _Iter>
; 1011 : 		void _Construct(_Iter _First, _Iter _Last)
; 1012 : 		{	// initialize from [_First, _Last), input iterators
; 1013 : 		_TRY_BEGIN
; 1014 : 
; 1015 : 		for (; _First != _Last; ++_First)
; 1016 : 			emplace_back(*_First);
; 1017 : 
; 1018 : 		_CATCH_ALL
; 1019 : 		_Tidy();
; 1020 : 		_RERAISE;
; 1021 : 		_CATCH_END
; 1022 : 		}
; 1023 : 
; 1024 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1025 : 		{	// construct from _Count * _Val
; 1026 : 		_TRY_BEGIN
; 1027 : 		for (; 0 < _Count; --_Count)
; 1028 : 			push_back(_Val);
; 1029 : 		_CATCH_ALL
; 1030 : 		_Tidy();
; 1031 : 		_RERAISE;
; 1032 : 		_CATCH_END
; 1033 : 		}
; 1034 : 
; 1035 : #define _PUSH_FRONT_BEGIN \
; 1036 : 	if (this->_Myoff % _DEQUESIZ == 0 \
; 1037 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1038 : 		_Growmap(1); \
; 1039 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1040 : 	size_type _Newoff = this->_Myoff != 0 ? this->_Myoff \
; 1041 : 		: this->_Mapsize * _DEQUESIZ; \
; 1042 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1043 : 	if (this->_Map[_Block] == pointer()) \
; 1044 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1045 : 
; 1046 : #define _PUSH_FRONT_END \
; 1047 : 	this->_Myoff = _Newoff; \
; 1048 : 	++this->_Mysize
; 1049 : 
; 1050 : #define _PUSH_BACK_BEGIN \
; 1051 : 	if ((this->_Myoff + this->_Mysize) % _DEQUESIZ == 0 \
; 1052 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1053 : 		_Growmap(1); \
; 1054 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1055 : 	size_type _Newoff = this->_Myoff + this->_Mysize; \
; 1056 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1057 : 	if (this->_Map[_Block] == pointer()) \
; 1058 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1059 : 
; 1060 : #define _PUSH_BACK_END \
; 1061 : 	++this->_Mysize
; 1062 : 
; 1063 : 	deque(_Myt&& _Right)
; 1064 : 		: _Mybase(_Right._Getal())
; 1065 : 		{	// construct by moving _Right
; 1066 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1067 : 		}
; 1068 : 
; 1069 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1070 : 		: _Mybase(_Al)
; 1071 : 		{	// construct by moving _Right
; 1072 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1073 : 		}
; 1074 : 
; 1075 : 	_Myt& operator=(_Myt&& _Right)
; 1076 : 		{	// assign by moving _Right
; 1077 : 		if (this != &_Right)
; 1078 : 			{	// different, assign it
; 1079 : 			_Tidy();
; 1080 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1081 : 				&& this->_Getal() != _Right._Getal())
; 1082 : 				this->_Change_alloc(_Right._Getal());
; 1083 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1084 : 			}
; 1085 : 		return (*this);
; 1086 : 		}
; 1087 : 
; 1088 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1089 : 		{	// move from _Right, stealing its contents
; 1090 : 		this->_Swap_all((_Myt&)_Right);
; 1091 : 		this->_Map = _Right._Map;
; 1092 : 		this->_Mapsize = _Right._Mapsize;
; 1093 : 		this->_Myoff = _Right._Myoff;
; 1094 : 		this->_Mysize = _Right._Mysize;
; 1095 : 
; 1096 : 		_Right._Map = _Mapptr();
; 1097 : 		_Right._Mapsize = 0;
; 1098 : 		_Right._Myoff = 0;
; 1099 : 		_Right._Mysize = 0;
; 1100 : 		}
; 1101 : 
; 1102 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1103 : 		{	// move from _Right, possibly moving its contents
; 1104 : 		if (get_allocator() == _Right.get_allocator())
; 1105 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1106 : 		else
; 1107 : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 1108 : 				_STD make_move_iterator(_Right.end()));
; 1109 : 		}
; 1110 : 
; 1111 : 	void _Assign_rv(_Myt&& _Right)
; 1112 : 		{	// assign by moving _Right
; 1113 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1114 : 			typename _Alty::propagate_on_container_move_assignment());
; 1115 : 		}
; 1116 : 
; 1117 : 
; 1118 : 	void push_front(value_type&& _Val)
; 1119 : 		{	// insert element at beginning
; 1120 : 		this->_Orphan_all();
; 1121 : 		_PUSH_FRONT_BEGIN;
; 1122 : 		this->_Getal().construct(
; 1123 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1124 : 			_STD forward<value_type>(_Val));
; 1125 : 		_PUSH_FRONT_END;
; 1126 : 		}
; 1127 : 
; 1128 : 	void push_back(value_type&& _Val)
; 1129 : 		{	// insert element at end
; 1130 : 		this->_Orphan_all();
; 1131 : 		_PUSH_BACK_BEGIN;
; 1132 : 		this->_Getal().construct(
; 1133 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1134 : 			_STD forward<value_type>(_Val));
; 1135 : 		_PUSH_BACK_END;
; 1136 : 		}
; 1137 : 
; 1138 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1139 : 		{	// insert _Val at _Where
; 1140 : 		return (emplace(_Where, _STD move(_Val)));
; 1141 : 		}
; 1142 : 
; 1143 : 	template<class... _Valty>
; 1144 : 		void emplace_front(_Valty&&... _Val)
; 1145 : 		{	// insert element at beginning
; 1146 : 		this->_Orphan_all();
; 1147 : 		_PUSH_FRONT_BEGIN;
; 1148 : 		this->_Getal().construct(
; 1149 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1150 : 			_STD forward<_Valty>(_Val)...);
; 1151 : 		_PUSH_FRONT_END;
; 1152 : 		}
; 1153 : 
; 1154 : 	template<class... _Valty>
; 1155 : 		void emplace_back(_Valty&&... _Val)
; 1156 : 		{	// insert element at end
; 1157 : 		this->_Orphan_all();
; 1158 : 		_PUSH_BACK_BEGIN;
; 1159 : 		this->_Getal().construct(
; 1160 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1161 : 			_STD forward<_Valty>(_Val)...);
; 1162 : 		_PUSH_BACK_END;
; 1163 : 		}
; 1164 : 
; 1165 : 	template<class... _Valty>
; 1166 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1167 : 		{	// insert element at _Where
; 1168 : 		size_type _Off = _Where - begin();
; 1169 : 
; 1170 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1171 : 		if (this->_Mysize < _Off)
; 1172 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1173 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1174 : 
; 1175 : 		if (_Off <= this->_Mysize / 2)
; 1176 : 			{	// closer to front, push to front then rotate
; 1177 : 			emplace_front(_STD forward<_Valty>(_Val)...);
; 1178 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off);
; 1179 : 			}
; 1180 : 		else
; 1181 : 			{	// closer to back, push to back then rotate
; 1182 : 			emplace_back(_STD forward<_Valty>(_Val)...);
; 1183 : 			_STD rotate(begin() + _Off, end() - 1, end());
; 1184 : 			}
; 1185 : 		return (begin() + _Off);
; 1186 : 		}
; 1187 : 
; 1188 : 
; 1189 : 	deque(_XSTD initializer_list<value_type> _Ilist,
; 1190 : 		const _Alloc& _Al = allocator_type())
; 1191 : 		: _Mybase(_Al)
; 1192 : 		{	// construct from initializer_list
; 1193 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1194 : 		}
; 1195 : 
; 1196 : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 1197 : 		{	// assign initializer_list
; 1198 : 		assign(_Ilist.begin(), _Ilist.end());
; 1199 : 		return (*this);
; 1200 : 		}
; 1201 : 
; 1202 : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 1203 : 		{	// assign initializer_list
; 1204 : 		assign(_Ilist.begin(), _Ilist.end());
; 1205 : 		}
; 1206 : 
; 1207 : 	iterator insert(const_iterator _Where,
; 1208 : 		_XSTD initializer_list<value_type> _Ilist)
; 1209 : 		{	// insert initializer_list
; 1210 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1211 : 		}
; 1212 : 
; 1213 : 	~deque() _NOEXCEPT
; 1214 : 		{	// destroy the deque
; 1215 : 		_Tidy();
; 1216 : 		}
; 1217 : 
; 1218 : 	_Myt& operator=(const _Myt& _Right)
; 1219 : 		{	// assign _Right
; 1220 : 		if (this != &_Right)
; 1221 : 			{	// different, assign it
; 1222 : 			if (this->_Getal() != _Right._Getal()
; 1223 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1224 : 				{	// change allocator before copying
; 1225 : 				_Tidy();
; 1226 : 				this->_Change_alloc(_Right._Getal());
; 1227 : 				}
; 1228 : 
; 1229 : 			this->_Orphan_all();
; 1230 : 
; 1231 : 			if (_Right._Mysize == 0)
; 1232 : 				clear();
; 1233 : 			else if (_Right._Mysize <= this->_Mysize)
; 1234 : 				{	// enough elements, copy new and destroy old
; 1235 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1236 : 					begin());
; 1237 : 				erase(_Mid, end());
; 1238 : 				}
; 1239 : 			else
; 1240 : 				{	// new sequence longer, copy and construct new
; 1241 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;
; 1242 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1243 : 				insert(end(), _Mid, _Right.end());
; 1244 : 				}
; 1245 : 			}
; 1246 : 		return (*this);
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator begin() _NOEXCEPT
; 1250 : 		{	// return iterator for beginning of mutable sequence
; 1251 : 		return (iterator(this->_Myoff, this));
; 1252 : 		}
; 1253 : 
; 1254 : 	const_iterator begin() const _NOEXCEPT
; 1255 : 		{	// return iterator for beginning of nonmutable sequence
; 1256 : 		return (const_iterator(this->_Myoff, this));
; 1257 : 		}
; 1258 : 
; 1259 : 	iterator end() _NOEXCEPT
; 1260 : 		{	// return iterator for end of mutable sequence
; 1261 : 		return (iterator(this->_Myoff + this->_Mysize, this));
; 1262 : 		}
; 1263 : 
; 1264 : 	const_iterator end() const _NOEXCEPT
; 1265 : 		{	// return iterator for end of nonmutable sequence
; 1266 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));
; 1267 : 		}
; 1268 : 
; 1269 : 	iterator _Make_iter(const_iterator _Where) const
; 1270 : 		{	// make iterator from const_iterator
; 1271 : 		return (iterator(_Where._Myoff, this));
; 1272 : 		}
; 1273 : 
; 1274 : 	reverse_iterator rbegin() _NOEXCEPT
; 1275 : 		{	// return iterator for beginning of reversed mutable sequence
; 1276 : 		return (reverse_iterator(end()));
; 1277 : 		}
; 1278 : 
; 1279 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1280 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1281 : 		return (const_reverse_iterator(end()));
; 1282 : 		}
; 1283 : 
; 1284 : 	reverse_iterator rend() _NOEXCEPT
; 1285 : 		{	// return iterator for end of reversed mutable sequence
; 1286 : 		return (reverse_iterator(begin()));
; 1287 : 		}
; 1288 : 
; 1289 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1290 : 		{	// return iterator for end of reversed nonmutable sequence
; 1291 : 		return (const_reverse_iterator(begin()));
; 1292 : 		}
; 1293 : 
; 1294 : 	const_iterator cbegin() const _NOEXCEPT
; 1295 : 		{	// return iterator for beginning of nonmutable sequence
; 1296 : 		return (((const _Myt *)this)->begin());
; 1297 : 		}
; 1298 : 
; 1299 : 	const_iterator cend() const _NOEXCEPT
; 1300 : 		{	// return iterator for end of nonmutable sequence
; 1301 : 		return (((const _Myt *)this)->end());
; 1302 : 		}
; 1303 : 
; 1304 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1306 : 		return (((const _Myt *)this)->rbegin());
; 1307 : 		}
; 1308 : 
; 1309 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1310 : 		{	// return iterator for end of reversed nonmutable sequence
; 1311 : 		return (((const _Myt *)this)->rend());
; 1312 : 		}
; 1313 : 
; 1314 : 	void shrink_to_fit()
; 1315 : 		{	// reduce capacity
; 1316 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize;
; 1317 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1318 : 
; 1319 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1320 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1321 : 
; 1322 : 		if ((empty() && 0 < this->_Mapsize)
; 1323 : 			|| (!empty()
; 1324 : 				&& size() <= _Newcapacity
; 1325 : 				&& _Newcapacity < _Oldcapacity))
; 1326 : 			{	// worth shrinking, do it
; 1327 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1328 : 				_STD make_move_iterator(end()));
; 1329 : 			swap(_Tmp);
; 1330 : 			}
; 1331 : 		}
; 1332 : 
; 1333 : 	void resize(size_type _Newsize)
; 1334 : 		{	// determine new length, padding as needed
; 1335 : 		while (this->_Mysize < _Newsize)
; 1336 : 			emplace_back();
; 1337 : 
; 1338 : 		while (_Newsize < this->_Mysize)
; 1339 : 			pop_back();
; 1340 : 		}
; 1341 : 
; 1342 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1343 : 		{	// determine new length, padding with _Val elements as needed
; 1344 : 		while (this->_Mysize < _Newsize)
; 1345 : 			push_back(_Val);
; 1346 : 		while (_Newsize < this->_Mysize)
; 1347 : 			pop_back();
; 1348 : 		}
; 1349 : 
; 1350 : 	size_type size() const _NOEXCEPT
; 1351 : 		{	// return length of sequence
; 1352 : 		return (this->_Mysize);
; 1353 : 		}
; 1354 : 
; 1355 : 	size_type max_size() const _NOEXCEPT
; 1356 : 		{	// return maximum possible length of sequence
; 1357 : 		return (this->_Getal().max_size());
; 1358 : 		}
; 1359 : 
; 1360 : 	bool empty() const _NOEXCEPT
; 1361 : 		{	// test if sequence is empty
; 1362 : 		return (this->_Mysize == 0);

  00052	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0

; 1828 : 		_Alpty _Almap(this->_Getal());
; 1829 : 		while (!empty())

  00056	75 b8		 jne	 SHORT $LL6@Tidy
$LN5@Tidy:

; 1831 : 		for (size_type _Block = this->_Mapsize; 0 < _Block; )

  00058	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0005b	85 ff		 test	 edi, edi
  0005d	74 19		 je	 SHORT $LN3@Tidy
  0005f	90		 npad	 1
$LL4@Tidy:

; 1832 : 			{	// free storage for a block and destroy pointer
; 1833 : 			if (this->_Map[--_Block] != pointer())

  00060	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00063	4f		 dec	 edi
  00064	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00067	85 c0		 test	 eax, eax
  00069	74 09		 je	 SHORT $LN2@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00071	83 c4 04	 add	 esp, 4
$LN2@Tidy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1831 : 		for (size_type _Block = this->_Mapsize; 0 < _Block; )

  00074	85 ff		 test	 edi, edi
  00076	75 e8		 jne	 SHORT $LL4@Tidy
$LN3@Tidy:

; 1834 : 				{	// free block and destroy its pointer
; 1835 : 				this->_Getal().deallocate(this->_Map[_Block], _DEQUESIZ);
; 1836 : 				this->_Getal().destroy(&this->_Map[_Block]);
; 1837 : 				}
; 1838 : 			}
; 1839 : 
; 1840 : 		if (this->_Map != _Mapptr())

  00078	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0007b	85 c0		 test	 eax, eax
  0007d	74 09		 je	 SHORT $LN79@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00085	83 c4 04	 add	 esp, 4
$LN79@Tidy:
  00088	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1844 : 		this->_Map = _Mapptr();

  00089	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00090	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00097	5e		 pop	 esi

; 1845 : 		}

  00098	c3		 ret	 0
?_Tidy@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 872  : 	_Deque_alloc(const _Alloc& = _Alloc())

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00003	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 773  : 		_Map = _Mapptr();

  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 774  : 		_Mapsize = 0;

  00012	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 775  : 		_Myoff = 0;

  00019	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 776  : 		_Mysize = 0;

  00020	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	74 19		 je	 SHORT $LN42@Deque_allo
  00033	89 06		 mov	 DWORD PTR [esi], eax

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0003b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

  00042	8b 06		 mov	 eax, DWORD PTR [esi]
  00044	89 30		 mov	 DWORD PTR [eax], esi

; 875  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi
  00049	c2 04 00	 ret	 4
$LN42@Deque_allo:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  0004c	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN44@Deque_allo:
$LN41@Deque_allo:
  00051	cc		 int	 3
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy proxy

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 907  : 		this->_Myproxy = 0;

  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00013	5e		 pop	 esi

; 879  : 		_Free_proxy();
; 880  : 		}

  00014	c3		 ret	 0
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?empty@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty, COMDAT
; _this$ = ecx

; 1362 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00005	0f 94 c0	 sete	 al

; 1363 : 		}

  00008	c3		 ret	 0
?empty@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pop_back, COMDAT
; _this$ = ecx

; 1471 : 		{	// erase element at end

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

  00004	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00007	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0000a	48		 dec	 eax
  0000b	03 d0		 add	 edx, eax

; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00010	48		 dec	 eax
  00011	23 d0		 and	 edx, eax

; 1472 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1473 : 		if (empty())
; 1474 : 			_DEBUG_ERROR("deque empty before pop");
; 1475 : 		else
; 1476 : 			{	// something to erase, do it
; 1477 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1478 : 			_Orphan_off(_Newoff);
; 1479 : 			size_type _Block = this->_Getblock(_Newoff);
; 1480 : 			this->_Getal().destroy(
; 1481 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1482 : 			if (--this->_Mysize == 0)
; 1483 : 				this->_Myoff = 0;
; 1484 : 			}
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1488 : 		size_type _Block = this->_Getblock(_Newoff);
; 1489 : 		this->_Getal().destroy(
; 1490 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ);

  00013	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00016	8b 3c 90	 mov	 edi, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00019	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  0001d	72 0a		 jb	 SHORT $LN37@pop_back
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0001f	ff 37		 push	 DWORD PTR [edi]
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
$LN37@pop_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00029	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00030	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00037	c6 07 00	 mov	 BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 1491 : 		if (--this->_Mysize == 0)

  0003a	ff 4e 10	 dec	 DWORD PTR [esi+16]
  0003d	75 07		 jne	 SHORT $LN1@pop_back

; 1492 : 			this->_Myoff = 0;

  0003f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN1@pop_back:
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi

; 1493 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1494 : 		}

  00048	c3		 ret	 0
?pop_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 892  : 		{	// construct proxy from _Alval

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00001	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 892  : 		{	// construct proxy from _Alval

  00003	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
  0000d	85 c0		 test	 eax, eax
  0000f	74 15		 je	 SHORT $LN35@Alloc_prox
  00011	89 06		 mov	 DWORD PTR [esi], eax

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}
; 33   : 
; 34   : 		// TEMPLATE FUNCTION _Construct
; 35   : template<class _Ty1,
; 36   : 	class _Ty2> inline
; 37   : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 38   : 	{	// construct object at _Ptr with value _Val
; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 41   : 	}
; 42   : 
; 43   : template<class _Ty1> inline
; 44   : 	void _Construct(_Ty1 *_Ptr)
; 45   : 	{	// construct object at _Ptr with default value
; 46   : 	void *_Vptr = _Ptr;
; 47   : 
; 48   : 	::new (_Vptr) _Ty1();
; 49   : 	}
; 50   : 
; 51   : 		// TEMPLATE FUNCTION _Destroy
; 52   : template<class _Ty> inline
; 53   : 	void _Destroy(_Ty *_Ptr)
; 54   : 	{	// destroy object at _Ptr
; 55   : 	_Ptr->~_Ty();
; 56   : 	}
; 57   : 
; 58   : template<> inline
; 59   : 	void _Destroy(char *)
; 60   : 	{	// destroy a char (do nothing)
; 61   : 	}
; 62   : 
; 63   : template<> inline
; 64   : 	void _Destroy(wchar_t *)
; 65   : 	{	// destroy a wchar_t (do nothing)
; 66   : 	}
; 67   : 
; 68   :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 69   : template<> inline
; 70   : 	void _Destroy(unsigned short *)
; 71   : 	{	// destroy a unsigned short (do nothing)
; 72   : 	}
; 73   :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 74   : 
; 75   : 		// TEMPLATE FUNCTION _Destroy_range
; 76   : template<class _Alloc> inline
; 77   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 78   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 79   : 		_Nonscalar_ptr_iterator_tag)
; 80   : 	{	// destroy [_First, _Last), arbitrary type
; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}
; 84   : 
; 85   : template<class _Alloc> inline
; 86   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 87   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 88   : 		_Scalar_ptr_iterator_tag)
; 89   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 95   : 	{	// destroy [_First, _Last)
; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);
; 574  : 		}
; 575  : 
; 576  : 	pointer allocate(size_type _Count)
; 577  : 		{	// allocate array of _Count elements
; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}
; 580  : 
; 581  : 	pointer allocate(size_type _Count, const void *)
; 582  : 		{	// allocate array of _Count elements, ignore hint
; 583  : 		return (allocate(_Count));
; 584  : 		}
; 585  : 
; 586  : 	void construct(_Ty *_Ptr)
; 587  : 		{	// default construct object at _Ptr
; 588  : 		::new ((void *)_Ptr) _Ty();
; 589  : 		}
; 590  : 
; 591  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 592  : 		{	// construct object at _Ptr with value _Val
; 593  : 		::new ((void *)_Ptr) _Ty(_Val);
; 594  : 		}
; 595  : 
; 596  : 	template<class _Objty,
; 597  : 		class... _Types>
; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)
; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00019	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 897  : 		this->_Myproxy->_Mycont = this;

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	89 30		 mov	 DWORD PTR [eax], esi
  00024	5e		 pop	 esi

; 898  : 		}

  00025	c3		 ret	 0
$LN35@Alloc_prox:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00026	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN37@Alloc_prox:
$LN34@Alloc_prox:
  0002b	cc		 int	 3
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Free_proxy, COMDAT
; _this$ = ecx

; 901  : 		{	// destroy proxy

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000a	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 907  : 		this->_Myproxy = 0;

  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00013	5e		 pop	 esi

; 908  : 		}

  00014	c3		 ret	 0
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT
; _this$ = ecx

; 911  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 912  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 913  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 80   : 		{	// construct childless container

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque

; 777  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00024	c3		 ret	 0
??0?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getblock, COMDAT
; _this$ = ecx

; 780  : 		{	// determine block from offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 781  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 782  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	48		 dec	 eax
  00007	23 45 08	 and	 eax, DWORD PTR __Off$[ebp]

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$fill@PAPAU_object@@PAU1@@std@@YAXPAPAU_object@@0ABQAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill@PAPAU_object@@PAU1@@std@@YAXPAPAU_object@@0ABQAU1@@Z PROC ; std::fill<_object * *,_object *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2621 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b fa		 mov	 edi, edx
  00007	33 c0		 xor	 eax, eax
  00009	2b f9		 sub	 edi, ecx
  0000b	33 f6		 xor	 esi, esi
  0000d	83 c7 03	 add	 edi, 3
  00010	c1 ef 02	 shr	 edi, 2
  00013	3b ca		 cmp	 ecx, edx
  00015	0f 47 f8	 cmova	 edi, eax

; 2599 : 	for (; _First != _Last; ++_First)

  00018	85 ff		 test	 edi, edi
  0001a	74 11		 je	 SHORT $LN7@fill
  0001c	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0001f	90		 npad	 1
$LL9@fill:

; 2600 : 		*_First = _Val;

  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]

; 2599 : 	for (; _First != _Last; ++_First)

  00025	46		 inc	 esi

; 2600 : 		*_First = _Val;

  00026	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
  00029	3b f7		 cmp	 esi, edi
  0002b	75 f3		 jne	 SHORT $LL9@fill
$LN7@fill:
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi

; 2622 : 	_DEBUG_RANGE(_First, _Last);
; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2624 : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$fill@PAPAU_object@@PAU1@@std@@YAXPAPAU_object@@0ABQAU1@@Z ENDP ; std::fill<_object * *,_object *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 818  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAU_object@@@std@@YAPAPAU_object@@PAPAU1@@Z
_TEXT	SEGMENT
??$_Unchecked@PAPAU_object@@@std@@YAPAPAU_object@@PAPAU1@@Z PROC ; std::_Unchecked<_object * *>, COMDAT
; __Src$ = ecx

; 281  : 	return (_Src);

  00000	8b c1		 mov	 eax, ecx

; 282  : 	}

  00002	c3		 ret	 0
??$_Unchecked@PAPAU_object@@@std@@YAPAPAU_object@@PAPAU1@@Z ENDP ; std::_Unchecked<_object * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Fill@PAPAU_object@@PAU1@@std@@YAXPAPAU_object@@0ABQAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill@PAPAU_object@@PAU1@@std@@YAXPAPAU_object@@0ABQAU1@@Z PROC ; std::_Fill<_object * *,_object *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2598 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b fa		 mov	 edi, edx
  00007	33 c0		 xor	 eax, eax
  00009	2b f9		 sub	 edi, ecx
  0000b	33 f6		 xor	 esi, esi
  0000d	83 c7 03	 add	 edi, 3
  00010	c1 ef 02	 shr	 edi, 2
  00013	3b ca		 cmp	 ecx, edx
  00015	0f 47 f8	 cmova	 edi, eax

; 2599 : 	for (; _First != _Last; ++_First)

  00018	85 ff		 test	 edi, edi
  0001a	74 11		 je	 SHORT $LN1@Fill
  0001c	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0001f	90		 npad	 1
$LL3@Fill:

; 2600 : 		*_First = _Val;

  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00025	46		 inc	 esi
  00026	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
  00029	3b f7		 cmp	 esi, edi
  0002b	75 f3		 jne	 SHORT $LL3@Fill
$LN1@Fill:
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi

; 2601 : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Fill@PAPAU_object@@PAU1@@std@@YAXPAPAU_object@@0ABQAU1@@Z ENDP ; std::_Fill<_object * *,_object *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_ECPythonNetworkStream@@WHM@AEPAXI@Z
_TEXT	SEGMENT
??_ECPythonNetworkStream@@WHM@AEPAXI@Z PROC		; [thunk]:CPythonNetworkStream::`vector deleting destructor', COMDAT
  00000	83 e9 7c	 sub	 ecx, 124		; 0000007cH
  00003	e9 00 00 00 00	 jmp	 ??_ECPythonNetworkStream@@UAEPAXI@Z
??_ECPythonNetworkStream@@WHM@AEPAXI@Z ENDP		; [thunk]:CPythonNetworkStream::`vector deleting destructor'
_TEXT	ENDS
END
