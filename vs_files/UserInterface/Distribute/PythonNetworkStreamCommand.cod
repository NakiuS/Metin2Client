; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonNetworkStreamCommand.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_0BJ@GKNJMEFC@BINARY_ServerCommand_Run?$AA@ ; `string'
PUBLIC	??_C@_0O@NGPLKLCI@ConsoleEnable?$AA@		; `string'
PUBLIC	??_C@_0N@JEPOMHGB@BettingMoney?$AA@		; `string'
PUBLIC	??_C@_04KNNLNNGO@quit?$AA@			; `string'
PUBLIC	??_C@_04FDOIBAFG@gift?$AA@			; `string'
PUBLIC	??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@ ; `string'
PUBLIC	??_C@_04OIHHNFHN@cube?$AA@			; `string'
PUBLIC	??_C@_09MBHMFCFC@Gift_Show?$AA@			; `string'
PUBLIC	??_C@_0BB@OJMMNJOG@BINARY_Cube_Open?$AA@	; `string'
PUBLIC	??_C@_04PMOCAHAA@open?$AA@			; `string'
PUBLIC	??_C@_0BC@PIJLHOMJ@BINARY_Cube_Close?$AA@	; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
PUBLIC	??_C@_05HEIOBLPG@?$CIiii?$CJ?$AA@		; `string'
PUBLIC	??_C@_04NIDJFNBE@info?$AA@			; `string'
PUBLIC	??_C@_07IPNMCAN@success?$AA@			; `string'
PUBLIC	??_C@_0BH@DMGJNFKF@BINARY_Cube_UpdateInfo?$AA@	; `string'
PUBLIC	??_C@_04CCHLMOGN@fail?$AA@			; `string'
PUBLIC	??_C@_0BE@HLNHNAAA@BINARY_Cube_Succeed?$AA@	; `string'
PUBLIC	??_C@_06ODLEBDJP@r_list?$AA@			; `string'
PUBLIC	??_C@_0BD@IKENMBNJ@BINARY_Cube_Failed?$AA@	; `string'
PUBLIC	??_C@_0BH@JONCIELM@BINARY_Cube_ResultList?$AA@	; `string'
PUBLIC	??_C@_0FD@MDMGNNOD@CPythonNetworkStream?3?3ServerComm@ ; `string'
PUBLIC	??_C@_0BJ@DLFAEHHE@BINARY_Cube_MaterialInfo?$AA@ ; `string'
PUBLIC	??_C@_06JEMOOCHA@m_info?$AA@			; `string'
PUBLIC	??_C@_0CL@MFEDAABM@BINARY_BettingGuildWar_UpdateObs@ ; `string'
PUBLIC	??_C@_0O@HADNNBFL@ObserverCount?$AA@		; `string'
PUBLIC	??_C@_0CH@OENJEHPK@BINARY_BettingGuildWar_SetObserv@ ; `string'
PUBLIC	??_C@_0N@EBGNMPMN@ObserverMode?$AA@		; `string'
PUBLIC	??_C@_0M@EEGHHMDP@StoneDetect?$AA@		; `string'
PUBLIC	??_C@_0BB@MALBLMJA@ObserverTeamInfo?$AA@	; `string'
PUBLIC	??_C@_0EJ@MCLCAHNB@CPythonNetworkStream?3?3ServerComm@ ; `string'
PUBLIC	??_C@_0DD@COMEEBAO@StoneDetect?5?$FLVID?3?$CFd?$FN?5?$FLDistance?3?$CF@ ; `string'
PUBLIC	??_C@_0DB@KDMGCNFI@d?3?1ymir?5work?1effect?1etc?1compass?1@ ; `string'
PUBLIC	??_C@_0DB@CJFLAJFC@d?3?1ymir?5work?1effect?1etc?1firecrac@ ; `string'
PUBLIC	??_C@_0DB@EEGLDHND@d?3?1ymir?5work?1effect?1etc?1compass?1@ ; `string'
PUBLIC	??_C@_0DC@MDCBLGBM@d?3?1ymir?5work?1effect?1etc?1compass?1@ ; `string'
PUBLIC	??_C@_0BE@FMEJBOHN@StartStaminaConsume?$AA@	; `string'
PUBLIC	??_C@_0EH@NKAADCPI@CPythonNetworkStream?3?3ServerComm@ ; `string'
PUBLIC	??_C@_03ODCMFNNH@sms?$AA@			; `string'
PUBLIC	??_C@_0BD@IEDOLMCO@StopStaminaConsume?$AA@	; `string'
PUBLIC	??_C@_0M@HBFEJGNO@mobile_auth?$AA@		; `string'
PUBLIC	??_C@_05FKDGKNNO@nosms?$AA@			; `string'
PUBLIC	??_C@_0P@EGMHBKG@messenger_auth?$AA@		; `string'
PUBLIC	??_C@_0BC@PFMPDKEI@OnMobileAuthority?$AA@	; `string'
PUBLIC	??_C@_05LLEFIEMM@combo?$AA@			; `string'
PUBLIC	??_C@_0BN@HFJFNDOJ@OnMessengerAddFriendQuestion?$AA@ ; `string'
PUBLIC	??_C@_0M@KBLDJFEH@OnBlockMode?$AA@		; `string'
PUBLIC	??_C@_0N@OCOPIGOC@setblockmode?$AA@		; `string'
PUBLIC	??_C@_04MDLEAKAL@kiss?$AA@			; `string'
PUBLIC	??_C@_0M@KHOIJDFJ@french_kiss?$AA@		; `string'
PUBLIC	??_C@_04PAJFJFCF@clap?$AA@			; `string'
PUBLIC	??_C@_04JAHFACKH@slap?$AA@			; `string'
PUBLIC	??_C@_06NLEFOMIN@cheer2?$AA@			; `string'
PUBLIC	??_C@_06PAGILPEO@cheer1?$AA@			; `string'
PUBLIC	??_C@_06HCDPFIPD@dance2?$AA@			; `string'
PUBLIC	??_C@_06FJBCALDA@dance1?$AA@			; `string'
PUBLIC	??_C@_06GLCEGJLC@dance3?$AA@			; `string'
PUBLIC	??_C@_0L@MMJCNAM@dig_motion?$AA@		; `string'
PUBLIC	??_C@_06DNHOMODE@dance5?$AA@			; `string'
PUBLIC	??_C@_06CEGFPPHF@dance4?$AA@			; `string'
PUBLIC	??_C@_0P@KFFKPMLJ@congratulation?$AA@		; `string'
PUBLIC	??_C@_06BGFDJNPH@dance6?$AA@			; `string'
PUBLIC	??_C@_05KEOOPKLE@angry?$AA@			; `string'
PUBLIC	??_C@_07JCIHIBLI@forgive?$AA@			; `string'
PUBLIC	??_C@_03OPLFCACF@sad?$AA@			; `string'
PUBLIC	??_C@_0L@BIJBGJBO@attractive?$AA@		; `string'
PUBLIC	??_C@_07MJDIFIMC@cheerup?$AA@			; `string'
PUBLIC	??_C@_03BPAIHHLG@shy?$AA@			; `string'
PUBLIC	??_C@_03DHFGHJCG@joy?$AA@			; `string'
PUBLIC	??_C@_06CMFIENOK@banter?$AA@			; `string'
PUBLIC	??_C@_0BP@HJIPKFJO@Unknown?5Server?5Command?5?$CFs?5?$HM?5?$CFs?$AA@ ; `string'
EXTRN	?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0PA_N@Z:PROC ; PyCallClassMemberFunc
EXTRN	_isspace:PROC
EXTRN	__strcmpi:PROC
;	COMDAT ?s_isFirst@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4_NA
_DATA	SEGMENT
?s_isFirst@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4_NA DB 01H ; `CPythonNetworkStream::ServerCommand'::`212'::s_isFirst
_DATA	ENDS
;	COMDAT ??_C@_0BP@HJIPKFJO@Unknown?5Server?5Command?5?$CFs?5?$HM?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BP@HJIPKFJO@Unknown?5Server?5Command?5?$CFs?5?$HM?5?$CFs?$AA@ DB 'U'
	DB	'nknown Server Command %s | %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CMFIENOK@banter?$AA@
CONST	SEGMENT
??_C@_06CMFIENOK@banter?$AA@ DB 'banter', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DHFGHJCG@joy?$AA@
CONST	SEGMENT
??_C@_03DHFGHJCG@joy?$AA@ DB 'joy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BPAIHHLG@shy?$AA@
CONST	SEGMENT
??_C@_03BPAIHHLG@shy?$AA@ DB 'shy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MJDIFIMC@cheerup?$AA@
CONST	SEGMENT
??_C@_07MJDIFIMC@cheerup?$AA@ DB 'cheerup', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BIJBGJBO@attractive?$AA@
CONST	SEGMENT
??_C@_0L@BIJBGJBO@attractive?$AA@ DB 'attractive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03OPLFCACF@sad?$AA@
CONST	SEGMENT
??_C@_03OPLFCACF@sad?$AA@ DB 'sad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JCIHIBLI@forgive?$AA@
CONST	SEGMENT
??_C@_07JCIHIBLI@forgive?$AA@ DB 'forgive', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KEOOPKLE@angry?$AA@
CONST	SEGMENT
??_C@_05KEOOPKLE@angry?$AA@ DB 'angry', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BGFDJNPH@dance6?$AA@
CONST	SEGMENT
??_C@_06BGFDJNPH@dance6?$AA@ DB 'dance6', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KFFKPMLJ@congratulation?$AA@
CONST	SEGMENT
??_C@_0P@KFFKPMLJ@congratulation?$AA@ DB 'congratulation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CEGFPPHF@dance4?$AA@
CONST	SEGMENT
??_C@_06CEGFPPHF@dance4?$AA@ DB 'dance4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNHOMODE@dance5?$AA@
CONST	SEGMENT
??_C@_06DNHOMODE@dance5?$AA@ DB 'dance5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MMJCNAM@dig_motion?$AA@
CONST	SEGMENT
??_C@_0L@MMJCNAM@dig_motion?$AA@ DB 'dig_motion', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLCEGJLC@dance3?$AA@
CONST	SEGMENT
??_C@_06GLCEGJLC@dance3?$AA@ DB 'dance3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FJBCALDA@dance1?$AA@
CONST	SEGMENT
??_C@_06FJBCALDA@dance1?$AA@ DB 'dance1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HCDPFIPD@dance2?$AA@
CONST	SEGMENT
??_C@_06HCDPFIPD@dance2?$AA@ DB 'dance2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PAGILPEO@cheer1?$AA@
CONST	SEGMENT
??_C@_06PAGILPEO@cheer1?$AA@ DB 'cheer1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NLEFOMIN@cheer2?$AA@
CONST	SEGMENT
??_C@_06NLEFOMIN@cheer2?$AA@ DB 'cheer2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JAHFACKH@slap?$AA@
CONST	SEGMENT
??_C@_04JAHFACKH@slap?$AA@ DB 'slap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PAJFJFCF@clap?$AA@
CONST	SEGMENT
??_C@_04PAJFJFCF@clap?$AA@ DB 'clap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KHOIJDFJ@french_kiss?$AA@
CONST	SEGMENT
??_C@_0M@KHOIJDFJ@french_kiss?$AA@ DB 'french_kiss', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MDLEAKAL@kiss?$AA@
CONST	SEGMENT
??_C@_04MDLEAKAL@kiss?$AA@ DB 'kiss', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OCOPIGOC@setblockmode?$AA@
CONST	SEGMENT
??_C@_0N@OCOPIGOC@setblockmode?$AA@ DB 'setblockmode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KBLDJFEH@OnBlockMode?$AA@
CONST	SEGMENT
??_C@_0M@KBLDJFEH@OnBlockMode?$AA@ DB 'OnBlockMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HFJFNDOJ@OnMessengerAddFriendQuestion?$AA@
CONST	SEGMENT
??_C@_0BN@HFJFNDOJ@OnMessengerAddFriendQuestion?$AA@ DB 'OnMessengerAddFr'
	DB	'iendQuestion', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05LLEFIEMM@combo?$AA@
CONST	SEGMENT
??_C@_05LLEFIEMM@combo?$AA@ DB 'combo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PFMPDKEI@OnMobileAuthority?$AA@
CONST	SEGMENT
??_C@_0BC@PFMPDKEI@OnMobileAuthority?$AA@ DB 'OnMobileAuthority', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EGMHBKG@messenger_auth?$AA@
CONST	SEGMENT
??_C@_0P@EGMHBKG@messenger_auth?$AA@ DB 'messenger_auth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKDGKNNO@nosms?$AA@
CONST	SEGMENT
??_C@_05FKDGKNNO@nosms?$AA@ DB 'nosms', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBFEJGNO@mobile_auth?$AA@
CONST	SEGMENT
??_C@_0M@HBFEJGNO@mobile_auth?$AA@ DB 'mobile_auth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IEDOLMCO@StopStaminaConsume?$AA@
CONST	SEGMENT
??_C@_0BD@IEDOLMCO@StopStaminaConsume?$AA@ DB 'StopStaminaConsume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03ODCMFNNH@sms?$AA@
CONST	SEGMENT
??_C@_03ODCMFNNH@sms?$AA@ DB 'sms', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@NKAADCPI@CPythonNetworkStream?3?3ServerComm@
CONST	SEGMENT
??_C@_0EH@NKAADCPI@CPythonNetworkStream?3?3ServerComm@ DB 'CPythonNetwork'
	DB	'Stream::ServerCommand(c_szCommand=%s) - Strange Distance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FMEJBOHN@StartStaminaConsume?$AA@
CONST	SEGMENT
??_C@_0BE@FMEJBOHN@StartStaminaConsume?$AA@ DB 'StartStaminaConsume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MDCBLGBM@d?3?1ymir?5work?1effect?1etc?1compass?1@
CONST	SEGMENT
??_C@_0DC@MDCBLGBM@d?3?1ymir?5work?1effect?1etc?1compass?1@ DB 'd:/ymir w'
	DB	'ork/effect/etc/compass/appear_middle.mse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@EEGLDHND@d?3?1ymir?5work?1effect?1etc?1compass?1@
CONST	SEGMENT
??_C@_0DB@EEGLDHND@d?3?1ymir?5work?1effect?1etc?1compass?1@ DB 'd:/ymir w'
	DB	'ork/effect/etc/compass/appear_large.mse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CJFLAJFC@d?3?1ymir?5work?1effect?1etc?1firecrac@
CONST	SEGMENT
??_C@_0DB@CJFLAJFC@d?3?1ymir?5work?1effect?1etc?1firecrac@ DB 'd:/ymir wo'
	DB	'rk/effect/etc/firecracker/find_out.mse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KDMGCNFI@d?3?1ymir?5work?1effect?1etc?1compass?1@
CONST	SEGMENT
??_C@_0DB@KDMGCNFI@d?3?1ymir?5work?1effect?1etc?1compass?1@ DB 'd:/ymir w'
	DB	'ork/effect/etc/compass/appear_small.mse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@COMEEBAO@StoneDetect?5?$FLVID?3?$CFd?$FN?5?$FLDistance?3?$CF@
CONST	SEGMENT
??_C@_0DD@COMEEBAO@StoneDetect?5?$FLVID?3?$CFd?$FN?5?$FLDistance?3?$CF@ DB 'S'
	DB	'toneDetect [VID:%d] [Distance:%d] [Angle:%d->%f]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@MCLCAHNB@CPythonNetworkStream?3?3ServerComm@
CONST	SEGMENT
??_C@_0EJ@MCLCAHNB@CPythonNetworkStream?3?3ServerComm@ DB 'CPythonNetwork'
	DB	'Stream::ServerCommand(c_szCommand=%s) - Not Exist Instance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MALBLMJA@ObserverTeamInfo?$AA@
CONST	SEGMENT
??_C@_0BB@MALBLMJA@ObserverTeamInfo?$AA@ DB 'ObserverTeamInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEGHHMDP@StoneDetect?$AA@
CONST	SEGMENT
??_C@_0M@EEGHHMDP@StoneDetect?$AA@ DB 'StoneDetect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EBGNMPMN@ObserverMode?$AA@
CONST	SEGMENT
??_C@_0N@EBGNMPMN@ObserverMode?$AA@ DB 'ObserverMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OENJEHPK@BINARY_BettingGuildWar_SetObserv@
CONST	SEGMENT
??_C@_0CH@OENJEHPK@BINARY_BettingGuildWar_SetObserv@ DB 'BINARY_BettingGu'
	DB	'ildWar_SetObserverMode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HADNNBFL@ObserverCount?$AA@
CONST	SEGMENT
??_C@_0O@HADNNBFL@ObserverCount?$AA@ DB 'ObserverCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MFEDAABM@BINARY_BettingGuildWar_UpdateObs@
CONST	SEGMENT
??_C@_0CL@MFEDAABM@BINARY_BettingGuildWar_UpdateObs@ DB 'BINARY_BettingGu'
	DB	'ildWar_UpdateObserverCount', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JEMOOCHA@m_info?$AA@
CONST	SEGMENT
??_C@_06JEMOOCHA@m_info?$AA@ DB 'm_info', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DLFAEHHE@BINARY_Cube_MaterialInfo?$AA@
CONST	SEGMENT
??_C@_0BJ@DLFAEHHE@BINARY_Cube_MaterialInfo?$AA@ DB 'BINARY_Cube_Material'
	DB	'Info', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@MDMGNNOD@CPythonNetworkStream?3?3ServerComm@
CONST	SEGMENT
??_C@_0FD@MDMGNNOD@CPythonNetworkStream?3?3ServerComm@ DB 'CPythonNetwork'
	DB	'Stream::ServerCommand(c_szCommand=%s) - Strange Parameter Cou'
	DB	'nt : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JONCIELM@BINARY_Cube_ResultList?$AA@
CONST	SEGMENT
??_C@_0BH@JONCIELM@BINARY_Cube_ResultList?$AA@ DB 'BINARY_Cube_ResultList'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKENMBNJ@BINARY_Cube_Failed?$AA@
CONST	SEGMENT
??_C@_0BD@IKENMBNJ@BINARY_Cube_Failed?$AA@ DB 'BINARY_Cube_Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ODLEBDJP@r_list?$AA@
CONST	SEGMENT
??_C@_06ODLEBDJP@r_list?$AA@ DB 'r_list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HLNHNAAA@BINARY_Cube_Succeed?$AA@
CONST	SEGMENT
??_C@_0BE@HLNHNAAA@BINARY_Cube_Succeed?$AA@ DB 'BINARY_Cube_Succeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CCHLMOGN@fail?$AA@
CONST	SEGMENT
??_C@_04CCHLMOGN@fail?$AA@ DB 'fail', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DMGJNFKF@BINARY_Cube_UpdateInfo?$AA@
CONST	SEGMENT
??_C@_0BH@DMGJNFKF@BINARY_Cube_UpdateInfo?$AA@ DB 'BINARY_Cube_UpdateInfo'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07IPNMCAN@success?$AA@
CONST	SEGMENT
??_C@_07IPNMCAN@success?$AA@ DB 'success', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NIDJFNBE@info?$AA@
CONST	SEGMENT
??_C@_04NIDJFNBE@info?$AA@ DB 'info', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HEIOBLPG@?$CIiii?$CJ?$AA@
CONST	SEGMENT
??_C@_05HEIOBLPG@?$CIiii?$CJ?$AA@ DB '(iii)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PIJLHOMJ@BINARY_Cube_Close?$AA@
CONST	SEGMENT
??_C@_0BC@PIJLHOMJ@BINARY_Cube_Close?$AA@ DB 'BINARY_Cube_Close', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PMOCAHAA@open?$AA@
CONST	SEGMENT
??_C@_04PMOCAHAA@open?$AA@ DB 'open', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OJMMNJOG@BINARY_Cube_Open?$AA@
CONST	SEGMENT
??_C@_0BB@OJMMNJOG@BINARY_Cube_Open?$AA@ DB 'BINARY_Cube_Open', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBHMFCFC@Gift_Show?$AA@
CONST	SEGMENT
??_C@_09MBHMFCFC@Gift_Show?$AA@ DB 'Gift_Show', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OIHHNFHN@cube?$AA@
CONST	SEGMENT
??_C@_04OIHHNFHN@cube?$AA@ DB 'cube', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@
CONST	SEGMENT
??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@ DB 'CPythonNetwork'
	DB	'Stream::ServerCommand(c_szCommand=%s) - Strange Parameter Cou'
	DB	'nt : %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04FDOIBAFG@gift?$AA@
CONST	SEGMENT
??_C@_04FDOIBAFG@gift?$AA@ DB 'gift', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNNLNNGO@quit?$AA@
CONST	SEGMENT
??_C@_04KNNLNNGO@quit?$AA@ DB 'quit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JEPOMHGB@BettingMoney?$AA@
CONST	SEGMENT
??_C@_0N@JEPOMHGB@BettingMoney?$AA@ DB 'BettingMoney', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NGPLKLCI@ConsoleEnable?$AA@
CONST	SEGMENT
??_C@_0O@NGPLKLCI@ConsoleEnable?$AA@ DB 'ConsoleEnable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GKNJMEFC@BINARY_ServerCommand_Run?$AA@
CONST	SEGMENT
??_C@_0BJ@GKNJMEFC@BINARY_ServerCommand_Run?$AA@ DB 'BINARY_ServerCommand'
	DB	'_Run', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
PUBLIC	?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_not_of
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?GetSingleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@SAAAVIAbstractCharacterManager@@XZ ; TAbstractSingleton<IAbstractCharacterManager>::GetSingleton
PUBLIC	?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
PUBLIC	?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_not_of
PUBLIC	?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z	; CPythonNetworkStream::ServerCommand
PUBLIC	?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z ; SplitToken
PUBLIC	?ClientCommand@CPythonNetworkStream@@QAE_NPBD@Z	; CPythonNetworkStream::ClientCommand
;	COMDAT ?$S2@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4IA
_BSS	SEGMENT
?$S2@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4IA DD 01H DUP (?) ; S2<`template-parameter-212',CPythonNetworkStream::verCommand,unsigned char * const,void,char *>
_BSS	ENDS
;	COMDAT ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
_BSS	SEGMENT
?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A DQ 01H DUP (?) ; `CPythonNetworkStream::ServerCommand'::`212'::s_emotionDict
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$15
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
;	COMDAT ?ClientCommand@CPythonNetworkStream@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szCommand$dead$ = 8					; size = 4
?ClientCommand@CPythonNetworkStream@@QAE_NPBD@Z PROC	; CPythonNetworkStream::ClientCommand, COMDAT
; _this$dead$ = ecx

; 85   : 	return false;

  00000	32 c0		 xor	 al, al

; 86   : }

  00002	c2 04 00	 ret	 4
?ClientCommand@CPythonNetworkStream@@QAE_NPBD@Z ENDP	; CPythonNetworkStream::ClientCommand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
;	COMDAT ?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z
_TEXT	SEGMENT
_basePos$1$ = -100					; size = 4
__Cat$2 = -100						; size = 1
__Alval$3 = -93						; size = 1
_stToken$ = -92						; size = 24
$T4 = -68						; size = 24
_strLine$ = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_c_szDelimeter$dead$ = 8				; size = 4
?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z PROC ; SplitToken, COMDAT
; _c_szLine$ = ecx
; _pstTokenVector$ = edx

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b fa		 mov	 edi, edx
  0002d	8b d9		 mov	 ebx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002f	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00032	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00037	2b 37		 sub	 esi, DWORD PTR [edi]
  00039	f7 ee		 imul	 esi
  0003b	c1 fa 02	 sar	 edx, 2
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00043	03 c2		 add	 eax, edx

; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)

  00045	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00048	73 09		 jae	 SHORT $LN17@SplitToken

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

  0004a	6a 0a		 push	 10			; 0000000aH
  0004c	8b cf		 mov	 ecx, edi
  0004e	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN17@SplitToken:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00053	ff 75 9c	 push	 DWORD PTR __Cat$2[ebp]
  00056	8d 45 a3	 lea	 eax, DWORD PTR __Alval$3[ebp]
  00059	50		 push	 eax
  0005a	ff 77 04	 push	 DWORD PTR [edi+4]
  0005d	ff 37		 push	 DWORD PTR [edi]
  0005f	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00064	8b 07		 mov	 eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00066	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00069	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0006c	c7 45 b8 0f 00
	00 00		 mov	 DWORD PTR _stToken$[ebp+20], 15 ; 0000000fH

; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00073	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _stToken$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0007a	c6 45 a4 00	 mov	 BYTE PTR _stToken$[ebp], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 93   : 	std::string stToken;

  0007e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00085	80 3b 00	 cmp	 BYTE PTR [ebx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00088	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _strLine$[ebp+20], 15 ; 0000000fH

; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0008f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _strLine$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00096	c6 45 d4 00	 mov	 BYTE PTR _strLine$[ebp], 0

; 523  : 			: _CSTD strlen(_First));

  0009a	75 04		 jne	 SHORT $LN126@SplitToken
  0009c	33 c9		 xor	 ecx, ecx
  0009e	eb 0e		 jmp	 SHORT $LN127@SplitToken
$LN126@SplitToken:
  000a0	8b cb		 mov	 ecx, ebx
  000a2	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL515@SplitToken:
  000a5	8a 01		 mov	 al, BYTE PTR [ecx]
  000a7	41		 inc	 ecx
  000a8	84 c0		 test	 al, al
  000aa	75 f9		 jne	 SHORT $LL515@SplitToken
  000ac	2b ca		 sub	 ecx, edx
$LN127@SplitToken:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  000ae	51		 push	 ecx
  000af	53		 push	 ebx
  000b0	8d 4d d4	 lea	 ecx, DWORD PTR _strLine$[ebp]
  000b3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 94   : 	std::string strLine = c_szLine;

  000b8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 95   : 
; 96   : 	DWORD basePos = 0;

  000bc	33 db		 xor	 ebx, ebx
  000be	8b ff		 npad	 2
$LL8@SplitToken:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));

  000c0	6a 01		 push	 1
  000c2	53		 push	 ebx
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  000c8	8d 4d d4	 lea	 ecx, DWORD PTR _strLine$[ebp]
  000cb	e8 00 00 00 00	 call	 ?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_not_of
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 100  : 		int beginPos = strLine.find_first_not_of(c_szDelimeter, basePos);

  000d0	8b f0		 mov	 esi, eax

; 101  : 		if (beginPos < 0)

  000d2	85 f6		 test	 esi, esi
  000d4	0f 88 31 01 00
	00		 js	 $LN510@SplitToken
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000da	83 7d e8 10	 cmp	 DWORD PTR _strLine$[ebp+20], 16 ; 00000010H
  000de	8d 4d d4	 lea	 ecx, DWORD PTR _strLine$[ebp]

; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));

  000e1	6a 01		 push	 1

; 513  : 			: this->_Bx._Buf);

  000e3	0f 43 4d d4	 cmovae	 ecx, DWORD PTR _strLine$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 106  : 		if (strLine[beginPos] == '"')

  000e7	80 3c 31 22	 cmp	 BYTE PTR [ecx+esi], 34	; 00000022H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));

  000eb	8d 4d d4	 lea	 ecx, DWORD PTR _strLine$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 106  : 		if (strLine[beginPos] == '"')

  000ee	75 1c		 jne	 SHORT $LN152@SplitToken

; 107  : 		{
; 108  : 			++beginPos;

  000f0	46		 inc	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));

  000f1	56		 push	 esi
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
  000f7	e8 00 00 00 00	 call	 ?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_of
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 111  : 			if (endPos < 0)

  000fc	85 c0		 test	 eax, eax
  000fe	0f 88 07 01 00
	00		 js	 $LN510@SplitToken

; 112  : 				return false;
; 113  : 			
; 114  : 			basePos = endPos + 1;

  00104	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00107	89 4d 9c	 mov	 DWORD PTR _basePos$1$[ebp], ecx

; 115  : 		}
; 116  : 		else

  0010a	eb 0e		 jmp	 SHORT $LN2@SplitToken
$LN152@SplitToken:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));

  0010c	56		 push	 esi
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  00112	e8 00 00 00 00	 call	 ?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_of
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 119  : 			basePos = endPos;

  00117	89 45 9c	 mov	 DWORD PTR _basePos$1$[ebp], eax
$LN2@SplitToken:

; 122  : 		pstTokenVector->push_back(strLine.substr(beginPos, endPos - beginPos));

  0011a	2b c6		 sub	 eax, esi
  0011c	8d 4d d4	 lea	 ecx, DWORD PTR _strLine$[ebp]
  0011f	50		 push	 eax
  00120	56		 push	 esi
  00121	8d 45 bc	 lea	 eax, DWORD PTR $T4[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  0012a	8b f0		 mov	 esi, eax
  0012c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00130	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00133	3b f1		 cmp	 esi, ecx
  00135	73 31		 jae	 SHORT $LN157@SplitToken
  00137	8b 07		 mov	 eax, DWORD PTR [edi]
  00139	3b c6		 cmp	 eax, esi
  0013b	77 2b		 ja	 SHORT $LN157@SplitToken

; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  0013d	2b f0		 sub	 esi, eax
  0013f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00144	f7 ee		 imul	 esi
  00146	c1 fa 02	 sar	 edx, 2
  00149	8b f2		 mov	 esi, edx
  0014b	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0014e	03 f2		 add	 esi, edx

; 869  : 			if (this->_Mylast == this->_Myend)

  00150	3b 4f 08	 cmp	 ecx, DWORD PTR [edi+8]
  00153	75 09		 jne	 SHORT $LN156@SplitToken

; 870  : 				_Reserve(1);

  00155	6a 01		 push	 1
  00157	8b cf		 mov	 ecx, edi
  00159	e8 00 00 00 00	 call	 ?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
$LN156@SplitToken:

; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));

  0015e	8b 07		 mov	 eax, DWORD PTR [edi]
  00160	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00163	8d 34 c8	 lea	 esi, DWORD PTR [eax+ecx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

  00166	eb 0e		 jmp	 SHORT $LN154@SplitToken
$LN157@SplitToken:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 878  : 			if (this->_Mylast == this->_Myend)

  00168	3b 4f 08	 cmp	 ecx, DWORD PTR [edi+8]
  0016b	75 09		 jne	 SHORT $LN154@SplitToken

; 879  : 				_Reserve(1);

  0016d	6a 01		 push	 1
  0016f	8b cf		 mov	 ecx, edi
  00171	e8 00 00 00 00	 call	 ?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
$LN154@SplitToken:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00176	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00179	85 db		 test	 ebx, ebx
  0017b	74 51		 je	 SHORT $LN302@SplitToken
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0017d	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH

; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00184	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0018b	c6 03 00	 mov	 BYTE PTR [ebx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

  0018e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00192	73 13		 jae	 SHORT $LN349@SplitToken

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

  00194	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00197	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00198	74 17		 je	 SHORT $LN348@SplitToken
  0019a	50		 push	 eax
  0019b	56		 push	 esi
  0019c	53		 push	 ebx
  0019d	e8 00 00 00 00	 call	 _memmove
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

  001a5	eb 0a		 jmp	 SHORT $LN348@SplitToken
$LN349@SplitToken:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  001a7	8b 06		 mov	 eax, DWORD PTR [esi]
  001a9	89 03		 mov	 DWORD PTR [ebx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 942  : 			_Right._Bx._Ptr = pointer();

  001ab	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN348@SplitToken:

; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;

  001b1	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001b4	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 945  : 		this->_Myres = _Right._Myres;

  001b7	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001ba	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  001bd	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  001c4	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  001cb	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN302@SplitToken:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 883  : 			++this->_Mylast;

  001ce	83 47 04 18	 add	 DWORD PTR [edi+4], 24	; 00000018H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 122  : 		pstTokenVector->push_back(strLine.substr(beginPos, endPos - beginPos));

  001d2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  001d6	83 7d d0 10	 cmp	 DWORD PTR $T4[ebp+20], 16 ; 00000010H
  001da	72 0b		 jb	 SHORT $LN424@SplitToken
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001dc	ff 75 bc	 push	 DWORD PTR $T4[ebp]
  001df	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001e4	83 c4 04	 add	 esp, 4
$LN424@SplitToken:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));

  001e7	8b 5d 9c	 mov	 ebx, DWORD PTR _basePos$1$[ebp]
  001ea	8d 4d d4	 lea	 ecx, DWORD PTR _strLine$[ebp]
  001ed	6a 01		 push	 1
  001ef	53		 push	 ebx
  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  001f5	e8 00 00 00 00	 call	 ?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_not_of
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 125  : 		if (int(strLine.find_first_not_of(c_szDelimeter, basePos)) < 0)

  001fa	85 c0		 test	 eax, eax
  001fc	78 09		 js	 SHORT $LN6@SplitToken

; 126  : 			break;
; 127  : 	} while (basePos < strLine.length());

  001fe	3b 5d e4	 cmp	 ebx, DWORD PTR _strLine$[ebp+16]
  00201	0f 82 b9 fe ff
	ff		 jb	 $LL8@SplitToken
$LN6@SplitToken:

; 129  : 	return true;

  00207	b3 01		 mov	 bl, 1
  00209	eb 02		 jmp	 SHORT $LN15@SplitToken
$LN510@SplitToken:
  0020b	32 db		 xor	 bl, bl
$LN15@SplitToken:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0020d	83 7d e8 10	 cmp	 DWORD PTR _strLine$[ebp+20], 16 ; 00000010H
  00211	72 0b		 jb	 SHORT $LN516@SplitToken
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00213	ff 75 d4	 push	 DWORD PTR _strLine$[ebp]
  00216	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0021b	83 c4 04	 add	 esp, 4
$LN516@SplitToken:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 129  : 	return true;

  0021e	8a c3		 mov	 al, bl

; 130  : }

  00220	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00223	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0022a	59		 pop	 ecx
  0022b	5f		 pop	 edi
  0022c	5e		 pop	 esi
  0022d	5b		 pop	 ebx
  0022e	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00231	33 cd		 xor	 ecx, ebp
  00233	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00238	8b e5		 mov	 esp, ebp
  0023a	5d		 pop	 ebp
  0023b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z$0:
  00000	8d 4d a4	 lea	 ecx, DWORD PTR _stToken$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z$1:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR _strLine$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z$2:
  00010	8d 4d bc	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z ENDP ; SplitToken
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp
;	COMDAT ?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z
_TEXT	SEGMENT
_byDistance$1$ = -149					; size = 1
__Alval$2 = -149					; size = 1
_isTrue$3 = -149					; size = 1
_isTrue$4 = -149					; size = 1
_TokenVector$ = -148					; size = 12
_pInstance1$1$ = -136					; size = 4
_iVID1$1$ = -136					; size = 4
_pInstance1$1$ = -136					; size = 4
_iVID1$1$ = -136					; size = 4
_pInstance1$1$ = -136					; size = 4
_iVID1$1$ = -136					; size = 4
tv3193 = -136						; size = 4
tv2898 = -136						; size = 4
__Cat$5 = -136						; size = 1
_f$6 = -136						; size = 4
_this$GSCopy$1$ = -132					; size = 4
_dwVID$1$ = -132					; size = 4
tv3185 = -128						; size = 8
$T7 = -116						; size = 24
$T8 = -116						; size = 24
$T9 = -116						; size = 24
$T10 = -116						; size = 24
$T11 = -116						; size = 24
$T12 = -116						; size = 24
$T13 = -116						; size = 24
$T14 = -116						; size = 24
$T15 = -116						; size = 24
$T16 = -116						; size = 24
$T17 = -116						; size = 24
$T18 = -116						; size = 24
$T19 = -116						; size = 24
_$S1$20 = -116						; size = 24
_PixelPosition$21 = -116				; size = 12
$T22 = -92						; size = 24
_v3Rotation$23 = -92					; size = 12
__$ArrayPad$ = -68					; size = 4
__$EHRec$ = -12						; size = 12
_c_szCommand$ = 8					; size = 4
?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z PROC	; CPythonNetworkStream::ServerCommand, COMDAT
; _this$ = ecx

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	89 44 24 70	 mov	 DWORD PTR __$ArrayPad$[esp+180], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c4		 xor	 eax, esp
  0002f	50		 push	 eax
  00030	8d 84 24 b8 00
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+196]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	8b d9		 mov	 ebx, ecx
  0003f	89 5c 24 40	 mov	 DWORD PTR _this$GSCopy$1$[esp+196], ebx
  00043	8b 7d 08	 mov	 edi, DWORD PTR _c_szCommand$[ebp]

; 134  : 	// #0000811: [M2EU]    
; 135  : 	if (strcmpi(c_szCommand, "ConsoleEnable") == 0)

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NGPLKLCI@ConsoleEnable?$AA@
  0004b	57		 push	 edi
  0004c	e8 00 00 00 00	 call	 __strcmpi
  00051	83 c4 08	 add	 esp, 8
  00054	85 c0		 test	 eax, eax
  00056	0f 84 2d 11 00
	00		 je	 $LN672@ServerComm

; 136  : 		return;
; 137  : 
; 138  : 	if (m_apoPhaseWnd[PHASE_WINDOW_GAME])

  0005c	83 bb 90 01 00
	00 00		 cmp	 DWORD PTR [ebx+400], 0
  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  00068	74 1e		 je	 SHORT $LN106@ServerComm

; 139  : 	{
; 140  : 		bool isTrue;
; 141  : 		if (PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 142  : 			"BINARY_ServerCommand_Run", 
; 143  : 			Py_BuildValue("(s)", c_szCommand),
; 144  : 			&isTrue
; 145  : 		))

  0006a	8d 4c 24 2f	 lea	 ecx, DWORD PTR _isTrue$4[esp+196]
  0006e	51		 push	 ecx
  0006f	57		 push	 edi
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  00075	ff d0		 call	 eax
  00077	83 c4 08	 add	 esp, 8
  0007a	50		 push	 eax
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GKNJMEFC@BINARY_ServerCommand_Run?$AA@
  00080	ff b3 90 01 00
	00		 push	 DWORD PTR [ebx+400]

; 146  : 		{
; 147  : 			if (isTrue)
; 148  : 				return;
; 149  : 		}
; 150  : 	}

  00086	eb 25		 jmp	 SHORT $LN708@ServerComm
$LN106@ServerComm:

; 151  : 	else if (m_poSerCommandParserWnd)

  00088	83 bb 98 01 00
	00 00		 cmp	 DWORD PTR [ebx+408], 0
  0008f	74 33		 je	 SHORT $LN100@ServerComm

; 152  : 	{
; 153  : 		bool isTrue;
; 154  : 		if (PyCallClassMemberFunc(m_poSerCommandParserWnd, 
; 155  : 			"BINARY_ServerCommand_Run", 
; 156  : 			Py_BuildValue("(s)", c_szCommand),
; 157  : 			&isTrue
; 158  : 		))

  00091	8d 4c 24 2f	 lea	 ecx, DWORD PTR _isTrue$3[esp+196]
  00095	51		 push	 ecx
  00096	57		 push	 edi
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  0009c	ff d0		 call	 eax
  0009e	83 c4 08	 add	 esp, 8
  000a1	50		 push	 eax
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GKNJMEFC@BINARY_ServerCommand_Run?$AA@
  000a7	ff b3 98 01 00
	00		 push	 DWORD PTR [ebx+408]
$LN708@ServerComm:
  000ad	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0PA_N@Z ; PyCallClassMemberFunc
  000b2	83 c4 10	 add	 esp, 16			; 00000010H
  000b5	84 c0		 test	 al, al
  000b7	74 0b		 je	 SHORT $LN100@ServerComm

; 159  : 		{
; 160  : 			if (isTrue)

  000b9	80 7c 24 2f 00	 cmp	 BYTE PTR _isTrue$3[esp+196], 0
  000be	0f 85 c5 10 00
	00		 jne	 $LN672@ServerComm
$LN100@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  000c4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _TokenVector$[esp+196], 0

; 483  : 		_Mylast = pointer();

  000cc	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _TokenVector$[esp+200], 0

; 484  : 		_Myend = pointer();

  000d4	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR _TokenVector$[esp+204], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 166  : 	if (!SplitToken(c_szCommand, &TokenVector))

  000dc	51		 push	 ecx
  000dd	8d 54 24 34	 lea	 edx, DWORD PTR _TokenVector$[esp+200]
  000e1	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+208], 0
  000ec	8b cf		 mov	 ecx, edi
  000ee	e8 00 00 00 00	 call	 ?SplitToken@@YA_NPBDPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@0@Z ; SplitToken
  000f3	8b 5c 24 34	 mov	 ebx, DWORD PTR _TokenVector$[esp+200]
  000f7	83 c4 04	 add	 esp, 4
  000fa	84 c0		 test	 al, al
  000fc	8b 44 24 34	 mov	 eax, DWORD PTR _TokenVector$[esp+200]
  00100	0f 84 66 10 00
	00		 je	 $LN1@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00106	3b d8		 cmp	 ebx, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 168  : 	if (TokenVector.empty())

  00108	0f 84 5e 10 00
	00		 je	 $LN1@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0010e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00112	72 04		 jb	 SHORT $LN158@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00114	8b 33		 mov	 esi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00116	eb 02		 jmp	 SHORT $LN159@ServerComm
$LN158@ServerComm:
  00118	8b f3		 mov	 esi, ebx
$LN159@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 173  : 	if (!strcmpi(szCmd, "quit"))

  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_04KNNLNNGO@quit?$AA@
  0011f	56		 push	 esi
  00120	e8 00 00 00 00	 call	 __strcmpi
  00125	83 c4 08	 add	 esp, 8
  00128	85 c0		 test	 eax, eax
  0012a	75 0c		 jne	 SHORT $LN97@ServerComm

; 174  : 	{
; 175  : 		PostQuitMessage(0);

  0012c	50		 push	 eax
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4
  00133	e9 30 10 00 00	 jmp	 $LN704@ServerComm
$LN97@ServerComm:

; 176  : 	}
; 177  : 	else if (!strcmpi(szCmd, "BettingMoney"))

  00138	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JEPOMHGB@BettingMoney?$AA@
  0013d	56		 push	 esi
  0013e	e8 00 00 00 00	 call	 __strcmpi
  00143	83 c4 08	 add	 esp, 8
  00146	85 c0		 test	 eax, eax
  00148	75 33		 jne	 SHORT $LN95@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0014a	8b 4c 24 34	 mov	 ecx, DWORD PTR _TokenVector$[esp+200]
  0014e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00153	2b cb		 sub	 ecx, ebx
  00155	f7 e9		 imul	 ecx
  00157	c1 fa 02	 sar	 edx, 2
  0015a	8b c2		 mov	 eax, edx
  0015c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0015f	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 179  : 		if (2 != TokenVector.size())

  00161	83 f8 02	 cmp	 eax, 2
  00164	0f 84 fe 0f 00
	00		 je	 $LN704@ServerComm

; 180  : 		{
; 181  : 			TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %s", c_szCommand);

  0016a	57		 push	 edi
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@
  00170	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00175	83 c4 08	 add	 esp, 8
  00178	e9 eb 0f 00 00	 jmp	 $LN704@ServerComm
$LN95@ServerComm:

; 182  : 			return;
; 183  : 		}
; 184  : 
; 185  : 		//UINT uMoney= atoi(TokenVector[1].c_str());		
; 186  : 		
; 187  : 	}
; 188  : 	// GIFT NOTIFY
; 189  : 	else if (!strcmpi(szCmd, "gift"))

  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_04FDOIBAFG@gift?$AA@
  00182	56		 push	 esi
  00183	e8 00 00 00 00	 call	 __strcmpi
  00188	83 c4 08	 add	 esp, 8
  0018b	85 c0		 test	 eax, eax
  0018d	75 2c		 jne	 SHORT $LN92@ServerComm

; 190  : 	{
; 191  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "Gift_Show", Py_BuildValue("()")); 	

  0018f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  00194	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00199	ff d0		 call	 eax
  0019b	83 c4 04	 add	 esp, 4
  0019e	50		 push	 eax
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_09MBHMFCFC@Gift_Show?$AA@
$LN709@ServerComm:
  001a4	8b 4c 24 48	 mov	 ecx, DWORD PTR _this$GSCopy$1$[esp+204]
  001a8	ff b1 90 01 00
	00		 push	 DWORD PTR [ecx+400]
  001ae	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b6	e9 ad 0f 00 00	 jmp	 $LN704@ServerComm
$LN92@ServerComm:

; 192  : 	}
; 193  : 	// CUBE
; 194  : 	else if (!strcmpi(szCmd, "cube"))

  001bb	68 00 00 00 00	 push	 OFFSET ??_C@_04OIHHNFHN@cube?$AA@
  001c0	56		 push	 esi
  001c1	e8 00 00 00 00	 call	 __strcmpi
  001c6	83 c4 08	 add	 esp, 8
  001c9	85 c0		 test	 eax, eax
  001cb	0f 85 f4 02 00
	00		 jne	 $LN90@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001d1	8b 4c 24 34	 mov	 ecx, DWORD PTR _TokenVector$[esp+200]
  001d5	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  001da	2b cb		 sub	 ecx, ebx
  001dc	f7 e9		 imul	 ecx
  001de	c1 fa 02	 sar	 edx, 2
  001e1	8b f2		 mov	 esi, edx
  001e3	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  001e6	03 f2		 add	 esi, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 196  : 		if (TokenVector.size() < 2)

  001e8	83 fe 02	 cmp	 esi, 2
  001eb	73 13		 jae	 SHORT $LN89@ServerComm

; 197  : 		{
; 198  : 			TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %s", c_szCommand);

  001ed	57		 push	 edi
  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@
  001f3	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001f8	83 c4 08	 add	 esp, 8
  001fb	e9 68 0f 00 00	 jmp	 $LN704@ServerComm
$LN89@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00200	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 202  : 		if ("open" == TokenVector[1])

  00203	50		 push	 eax
  00204	68 00 00 00 00	 push	 OFFSET ??_C@_04PMOCAHAA@open?$AA@
  00209	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0020e	83 c4 08	 add	 esp, 8
  00211	84 c0		 test	 al, al
  00213	74 56		 je	 SHORT $LN88@ServerComm

; 203  : 		{
; 204  : 			if (3 > TokenVector.size())

  00215	83 fe 03	 cmp	 esi, 3
  00218	73 13		 jae	 SHORT $LN87@ServerComm

; 205  : 			{
; 206  : 				TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %s", c_szCommand);

  0021a	57		 push	 edi
  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@
  00220	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00225	83 c4 08	 add	 esp, 8
  00228	e9 3b 0f 00 00	 jmp	 $LN704@ServerComm
$LN87@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0022d	83 7b 44 10	 cmp	 DWORD PTR [ebx+68], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00231	8d 43 30	 lea	 eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00234	72 02		 jb	 SHORT $LN176@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00236	8b 00		 mov	 eax, DWORD PTR [eax]
$LN176@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 210  : 			DWORD npcVNUM = (DWORD)atoi(TokenVector[2].c_str());

  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 __atoi64
  0023e	83 c4 04	 add	 esp, 4

; 211  : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_Open", Py_BuildValue("(i)", npcVNUM));

  00241	50		 push	 eax
  00242	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  00247	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  0024c	ff d0		 call	 eax
  0024e	50		 push	 eax
  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OJMMNJOG@BINARY_Cube_Open?$AA@
$LN711@ServerComm:
  00254	8b 4c 24 50	 mov	 ecx, DWORD PTR _this$GSCopy$1$[esp+212]
  00258	ff b1 90 01 00
	00		 push	 DWORD PTR [ecx+400]
  0025e	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00263	83 c4 14	 add	 esp, 20			; 00000014H

; 212  : 		}
; 213  : 		else if ("close" == TokenVector[1])

  00266	e9 fd 0e 00 00	 jmp	 $LN704@ServerComm
$LN88@ServerComm:
  0026b	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
  0026e	50		 push	 eax
  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_05LBOHBHFK@close?$AA@
  00274	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00279	83 c4 08	 add	 esp, 8
  0027c	84 c0		 test	 al, al
  0027e	74 1a		 je	 SHORT $LN85@ServerComm

; 214  : 		{
; 215  : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_Close", Py_BuildValue("()"));

  00280	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  00285	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0028a	ff d0		 call	 eax
  0028c	83 c4 04	 add	 esp, 4
  0028f	50		 push	 eax
  00290	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PIJLHOMJ@BINARY_Cube_Close?$AA@

; 216  : 		}
; 217  : 		else if ("info" == TokenVector[1])

  00295	e9 0a ff ff ff	 jmp	 $LN709@ServerComm
$LN85@ServerComm:
  0029a	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
  0029d	50		 push	 eax
  0029e	68 00 00 00 00	 push	 OFFSET ??_C@_04NIDJFNBE@info?$AA@
  002a3	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  002a8	83 c4 08	 add	 esp, 8
  002ab	84 c0		 test	 al, al
  002ad	0f 84 84 00 00
	00		 je	 $LN83@ServerComm

; 218  : 		{
; 219  : 			if (5 != TokenVector.size())

  002b3	83 fe 05	 cmp	 esi, 5
  002b6	74 13		 je	 SHORT $LN82@ServerComm

; 220  : 			{
; 221  : 				TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %s", c_szCommand);

  002b8	57		 push	 edi
  002b9	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@
  002be	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  002c3	83 c4 08	 add	 esp, 8
  002c6	e9 9d 0e 00 00	 jmp	 $LN704@ServerComm
$LN82@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  002cb	83 7b 44 10	 cmp	 DWORD PTR [ebx+68], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  002cf	8d 43 30	 lea	 eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  002d2	72 02		 jb	 SHORT $LN192@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  002d4	8b 00		 mov	 eax, DWORD PTR [eax]
$LN192@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 225  : 			UINT gold = atoi(TokenVector[2].c_str());

  002d6	50		 push	 eax
  002d7	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  002dc	8d 4b 48	 lea	 ecx, DWORD PTR [ebx+72]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 225  : 			UINT gold = atoi(TokenVector[2].c_str());

  002df	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  002e2	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 225  : 			UINT gold = atoi(TokenVector[2].c_str());

  002e6	8b f8		 mov	 edi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  002e8	72 02		 jb	 SHORT $LN202@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  002ea	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN202@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 226  : 			UINT itemVnum = atoi(TokenVector[3].c_str());

  002ec	51		 push	 ecx
  002ed	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  002f2	8d 4b 60	 lea	 ecx, DWORD PTR [ebx+96]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 226  : 			UINT itemVnum = atoi(TokenVector[3].c_str());

  002f5	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  002f8	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 226  : 			UINT itemVnum = atoi(TokenVector[3].c_str());

  002fc	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  002fe	72 02		 jb	 SHORT $LN212@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00300	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN212@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 227  : 			UINT count = atoi(TokenVector[4].c_str());

  00302	51		 push	 ecx
  00303	e8 00 00 00 00	 call	 __atoi64
  00308	83 c4 04	 add	 esp, 4

; 228  : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_UpdateInfo", Py_BuildValue("(iii)", gold, itemVnum, count));

  0030b	50		 push	 eax
  0030c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  00311	56		 push	 esi
  00312	57		 push	 edi
  00313	68 00 00 00 00	 push	 OFFSET ??_C@_05HEIOBLPG@?$CIiii?$CJ?$AA@
  00318	ff d0		 call	 eax
  0031a	50		 push	 eax
  0031b	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@DMGJNFKF@BINARY_Cube_UpdateInfo?$AA@
$LN712@ServerComm:
  00320	8b 4c 24 58	 mov	 ecx, DWORD PTR _this$GSCopy$1$[esp+220]
  00324	ff b1 90 01 00
	00		 push	 DWORD PTR [ecx+400]
  0032a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0032f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 229  : 		}
; 230  : 		else if ("success" == TokenVector[1])

  00332	e9 31 0e 00 00	 jmp	 $LN704@ServerComm
$LN83@ServerComm:
  00337	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
  0033a	50		 push	 eax
  0033b	68 00 00 00 00	 push	 OFFSET ??_C@_07IPNMCAN@success?$AA@
  00340	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00345	83 c4 08	 add	 esp, 8
  00348	84 c0		 test	 al, al
  0034a	74 5e		 je	 SHORT $LN80@ServerComm

; 231  : 		{
; 232  : 			if (4 != TokenVector.size())

  0034c	83 fe 04	 cmp	 esi, 4
  0034f	74 13		 je	 SHORT $LN79@ServerComm

; 233  : 			{
; 234  : 				TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %s", c_szCommand);

  00351	57		 push	 edi
  00352	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@
  00357	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0035c	83 c4 08	 add	 esp, 8
  0035f	e9 04 0e 00 00	 jmp	 $LN704@ServerComm
$LN79@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00364	83 7b 44 10	 cmp	 DWORD PTR [ebx+68], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00368	8d 43 30	 lea	 eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0036b	72 02		 jb	 SHORT $LN226@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0036d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN226@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 238  : 			UINT itemVnum = atoi(TokenVector[2].c_str());

  0036f	50		 push	 eax
  00370	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00375	8d 4b 48	 lea	 ecx, DWORD PTR [ebx+72]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 238  : 			UINT itemVnum = atoi(TokenVector[2].c_str());

  00378	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0037b	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 238  : 			UINT itemVnum = atoi(TokenVector[2].c_str());

  0037f	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00381	72 02		 jb	 SHORT $LN236@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00383	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN236@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 239  : 			UINT count = atoi(TokenVector[3].c_str());

  00385	51		 push	 ecx
  00386	e8 00 00 00 00	 call	 __atoi64
  0038b	83 c4 04	 add	 esp, 4

; 240  : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_Succeed", Py_BuildValue("(ii)", itemVnum, count));

  0038e	50		 push	 eax
  0038f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  00394	56		 push	 esi
  00395	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  0039a	ff d0		 call	 eax
  0039c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0039f	50		 push	 eax
  003a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@HLNHNAAA@BINARY_Cube_Succeed?$AA@

; 241  : 		}
; 242  : 		else if ("fail" == TokenVector[1])

  003a5	e9 fa fd ff ff	 jmp	 $LN709@ServerComm
$LN80@ServerComm:
  003aa	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
  003ad	50		 push	 eax
  003ae	68 00 00 00 00	 push	 OFFSET ??_C@_04CCHLMOGN@fail?$AA@
  003b3	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  003b8	83 c4 08	 add	 esp, 8
  003bb	84 c0		 test	 al, al
  003bd	74 1a		 je	 SHORT $LN77@ServerComm

; 243  : 		{
; 244  : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_Failed", Py_BuildValue("()"));

  003bf	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  003c4	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  003c9	ff d0		 call	 eax
  003cb	83 c4 04	 add	 esp, 4
  003ce	50		 push	 eax
  003cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IKENMBNJ@BINARY_Cube_Failed?$AA@

; 245  : 		}
; 246  : 		else if ("r_list" == TokenVector[1])

  003d4	e9 cb fd ff ff	 jmp	 $LN709@ServerComm
$LN77@ServerComm:
  003d9	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
  003dc	50		 push	 eax
  003dd	68 00 00 00 00	 push	 OFFSET ??_C@_06ODLEBDJP@r_list?$AA@
  003e2	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  003e7	83 c4 08	 add	 esp, 8
  003ea	84 c0		 test	 al, al
  003ec	74 55		 je	 SHORT $LN75@ServerComm

; 247  : 		{
; 248  : 			// result list (/cube r_list npcVNUM resultCount resultText)
; 249  : 			// 20383 4 72723,1/72725,1/72730.1/50001,5 <-  "/"    
; 250  : 			if (5 != TokenVector.size())

  003ee	83 fe 05	 cmp	 esi, 5
  003f1	74 15		 je	 SHORT $LN74@ServerComm

; 251  : 			{
; 252  : 				TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %d", c_szCommand, 5);

  003f3	6a 05		 push	 5
  003f5	57		 push	 edi
  003f6	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MDMGNNOD@CPythonNetworkStream?3?3ServerComm@
  003fb	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00400	83 c4 0c	 add	 esp, 12			; 0000000cH
  00403	e9 60 0d 00 00	 jmp	 $LN704@ServerComm
$LN74@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00408	83 7b 44 10	 cmp	 DWORD PTR [ebx+68], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  0040c	8d 43 30	 lea	 eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0040f	72 02		 jb	 SHORT $LN252@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00411	8b 00		 mov	 eax, DWORD PTR [eax]
$LN252@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 256  : 			DWORD npcVNUM = (DWORD)atoi(TokenVector[2].c_str());

  00413	50		 push	 eax
  00414	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00419	8d 4b 60	 lea	 ecx, DWORD PTR [ebx+96]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 256  : 			DWORD npcVNUM = (DWORD)atoi(TokenVector[2].c_str());

  0041c	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0041f	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00423	72 02		 jb	 SHORT $LN262@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00425	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN262@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 258  : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_ResultList", Py_BuildValue("(is)", npcVNUM, TokenVector[4].c_str()));

  00427	51		 push	 ecx
  00428	50		 push	 eax
  00429	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  0042e	68 00 00 00 00	 push	 OFFSET ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
  00433	ff d0		 call	 eax
  00435	83 c4 0c	 add	 esp, 12			; 0000000cH
  00438	50		 push	 eax
  00439	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JONCIELM@BINARY_Cube_ResultList?$AA@

; 259  : 		}
; 260  : 		else if ("m_info" == TokenVector[1])

  0043e	e9 61 fd ff ff	 jmp	 $LN709@ServerComm
$LN75@ServerComm:
  00443	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
  00446	50		 push	 eax
  00447	68 00 00 00 00	 push	 OFFSET ??_C@_06JEMOOCHA@m_info?$AA@
  0044c	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00451	83 c4 08	 add	 esp, 8
  00454	84 c0		 test	 al, al
  00456	0f 84 0c 0d 00
	00		 je	 $LN704@ServerComm

; 261  : 		{
; 262  : 			// material list (/cube m_info requestStartIndex resultCount MaterialText)
; 263  : 			// ex) requestStartIndex: 0, resultCount : 5 -  NPC     0~4        MaterialText 
; 264  : 			//       "@"  
; 265  : 			// 0 5 125,1|126,2|127,2|123,5&555,5&555,4/120000 <-     
; 266  : 
; 267  : 			if (5 != TokenVector.size())

  0045c	83 fe 05	 cmp	 esi, 5
  0045f	74 15		 je	 SHORT $LN71@ServerComm

; 268  : 			{
; 269  : 				TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %d", c_szCommand, 5);

  00461	6a 05		 push	 5
  00463	57		 push	 edi
  00464	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MDMGNNOD@CPythonNetworkStream?3?3ServerComm@
  00469	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0046e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00471	e9 f2 0c 00 00	 jmp	 $LN704@ServerComm
$LN71@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00476	83 7b 44 10	 cmp	 DWORD PTR [ebx+68], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  0047a	8d 43 30	 lea	 eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0047d	72 02		 jb	 SHORT $LN276@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0047f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN276@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 273  : 			UINT requestStartIndex = (UINT)atoi(TokenVector[2].c_str());

  00481	50		 push	 eax
  00482	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00487	8d 4b 48	 lea	 ecx, DWORD PTR [ebx+72]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 273  : 			UINT requestStartIndex = (UINT)atoi(TokenVector[2].c_str());

  0048a	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0048d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 273  : 			UINT requestStartIndex = (UINT)atoi(TokenVector[2].c_str());

  00491	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00493	72 02		 jb	 SHORT $LN286@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00495	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN286@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 274  : 			UINT resultCount = (UINT)atoi(TokenVector[3].c_str());

  00497	51		 push	 ecx
  00498	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  0049d	8d 4b 60	 lea	 ecx, DWORD PTR [ebx+96]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 274  : 			UINT resultCount = (UINT)atoi(TokenVector[3].c_str());

  004a0	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  004a3	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  004a7	72 02		 jb	 SHORT $LN296@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  004a9	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN296@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 276  : 			PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "BINARY_Cube_MaterialInfo", Py_BuildValue("(iis)", requestStartIndex, resultCount, TokenVector[4].c_str()));

  004ab	51		 push	 ecx
  004ac	50		 push	 eax
  004ad	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  004b2	56		 push	 esi
  004b3	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDPDNFA@?$CIiis?$CJ?$AA@
  004b8	ff d0		 call	 eax
  004ba	50		 push	 eax
  004bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DLFAEHHE@BINARY_Cube_MaterialInfo?$AA@

; 277  : 		}
; 278  : 	}

  004c0	e9 5b fe ff ff	 jmp	 $LN712@ServerComm
$LN90@ServerComm:

; 279  : 	// CUEBE_END
; 280  : 	else if (!strcmpi(szCmd, "ObserverCount"))

  004c5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HADNNBFL@ObserverCount?$AA@
  004ca	56		 push	 esi
  004cb	e8 00 00 00 00	 call	 __strcmpi
  004d0	83 c4 08	 add	 esp, 8
  004d3	85 c0		 test	 eax, eax
  004d5	75 5b		 jne	 SHORT $LN69@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  004d7	8b 4c 24 34	 mov	 ecx, DWORD PTR _TokenVector$[esp+200]
  004db	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  004e0	2b cb		 sub	 ecx, ebx
  004e2	f7 e9		 imul	 ecx
  004e4	c1 fa 02	 sar	 edx, 2
  004e7	8b c2		 mov	 eax, edx
  004e9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  004ec	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 282  : 		if (2 != TokenVector.size())

  004ee	83 f8 02	 cmp	 eax, 2
  004f1	74 13		 je	 SHORT $LN68@ServerComm

; 283  : 		{
; 284  : 			TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %s", c_szCommand);

  004f3	57		 push	 edi
  004f4	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@
  004f9	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  004fe	83 c4 08	 add	 esp, 8
  00501	e9 62 0c 00 00	 jmp	 $LN704@ServerComm
$LN68@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00506	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  0050a	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0050d	72 02		 jb	 SHORT $LN308@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0050f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN308@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 288  : 		UINT uObserverCount= atoi(TokenVector[1].c_str());				

  00511	50		 push	 eax
  00512	e8 00 00 00 00	 call	 __atoi64
  00517	83 c4 04	 add	 esp, 4

; 289  : 
; 290  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 291  : 			"BINARY_BettingGuildWar_UpdateObserverCount", 
; 292  : 			Py_BuildValue("(i)", uObserverCount)
; 293  : 		);

  0051a	50		 push	 eax
  0051b	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  00520	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00525	ff d0		 call	 eax
  00527	50		 push	 eax
  00528	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@MFEDAABM@BINARY_BettingGuildWar_UpdateObs@
  0052d	e9 22 fd ff ff	 jmp	 $LN711@ServerComm
$LN69@ServerComm:

; 294  : 	}
; 295  : 	else if (!strcmpi(szCmd, "ObserverMode"))

  00532	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EBGNMPMN@ObserverMode?$AA@
  00537	56		 push	 esi
  00538	e8 00 00 00 00	 call	 __strcmpi
  0053d	83 c4 08	 add	 esp, 8
  00540	85 c0		 test	 eax, eax
  00542	75 71		 jne	 SHORT $LN66@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00544	8b 4c 24 34	 mov	 ecx, DWORD PTR _TokenVector$[esp+200]
  00548	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0054d	2b cb		 sub	 ecx, ebx
  0054f	f7 e9		 imul	 ecx
  00551	c1 fa 02	 sar	 edx, 2
  00554	8b c2		 mov	 eax, edx
  00556	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00559	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 297  : 		if (2 != TokenVector.size())

  0055b	83 f8 02	 cmp	 eax, 2
  0055e	74 13		 je	 SHORT $LN65@ServerComm

; 298  : 		{
; 299  : 			TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %s", c_szCommand);

  00560	57		 push	 edi
  00561	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@
  00566	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0056b	83 c4 08	 add	 esp, 8
  0056e	e9 f5 0b 00 00	 jmp	 $LN704@ServerComm
$LN65@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00573	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00577	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0057a	72 02		 jb	 SHORT $LN320@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0057c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN320@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 303  : 		UINT uMode= atoi(TokenVector[1].c_str());

  0057e	50		 push	 eax
  0057f	e8 00 00 00 00	 call	 __atoi64

; 304  : 		
; 305  : 		IAbstractPlayer& rkPlayer=IAbstractPlayer::GetSingleton();

  00584	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  0058a	83 c4 04	 add	 esp, 4
  0058d	8b f8		 mov	 edi, eax

; 306  : 		rkPlayer.SetObserverMode(uMode ? true : false);

  0058f	85 ff		 test	 edi, edi
  00591	8b 31		 mov	 esi, DWORD PTR [ecx]
  00593	0f 95 c2	 setne	 dl
  00596	0f b6 d2	 movzx	 edx, dl
  00599	52		 push	 edx
  0059a	ff 56 74	 call	 DWORD PTR [esi+116]

; 307  : 
; 308  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], 
; 309  : 			"BINARY_BettingGuildWar_SetObserverMode", 
; 310  : 			Py_BuildValue("(i)", uMode)
; 311  : 		);

  0059d	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  005a2	57		 push	 edi
  005a3	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  005a8	ff d0		 call	 eax
  005aa	50		 push	 eax
  005ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@OENJEHPK@BINARY_BettingGuildWar_SetObserv@
  005b0	e9 9f fc ff ff	 jmp	 $LN711@ServerComm
$LN66@ServerComm:

; 312  : 	}
; 313  : 	else if (!strcmpi(szCmd, "ObserverTeamInfo"))

  005b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MALBLMJA@ObserverTeamInfo?$AA@
  005ba	56		 push	 esi
  005bb	e8 00 00 00 00	 call	 __strcmpi
  005c0	83 c4 08	 add	 esp, 8
  005c3	85 c0		 test	 eax, eax
  005c5	0f 84 9d 0b 00
	00		 je	 $LN704@ServerComm

; 314  : 	{		
; 315  : 	}
; 316  : 	else if (!strcmpi(szCmd, "StoneDetect"))

  005cb	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EEGHHMDP@StoneDetect?$AA@
  005d0	56		 push	 esi
  005d1	e8 00 00 00 00	 call	 __strcmpi
  005d6	83 c4 08	 add	 esp, 8
  005d9	85 c0		 test	 eax, eax
  005db	0f 85 30 02 00
	00		 jne	 $LN61@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  005e1	8b 4c 24 34	 mov	 ecx, DWORD PTR _TokenVector$[esp+200]
  005e5	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  005ea	2b cb		 sub	 ecx, ebx
  005ec	f7 e9		 imul	 ecx
  005ee	c1 fa 02	 sar	 edx, 2
  005f1	8b c2		 mov	 eax, edx
  005f3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  005f6	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 318  : 		if (4 != TokenVector.size())

  005f8	83 f8 04	 cmp	 eax, 4
  005fb	74 13		 je	 SHORT $LN60@ServerComm

; 319  : 		{
; 320  : 			TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %s", c_szCommand);

  005fd	57		 push	 edi
  005fe	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@
  00603	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00608	83 c4 08	 add	 esp, 8
  0060b	e9 58 0b 00 00	 jmp	 $LN704@ServerComm
$LN60@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00610	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00614	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00617	72 02		 jb	 SHORT $LN334@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00619	8b 00		 mov	 eax, DWORD PTR [eax]
$LN334@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 325  : 		DWORD dwVID = atoi(TokenVector[1].c_str());

  0061b	50		 push	 eax
  0061c	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00621	8d 4b 30	 lea	 ecx, DWORD PTR [ebx+48]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 325  : 		DWORD dwVID = atoi(TokenVector[1].c_str());

  00624	89 44 24 44	 mov	 DWORD PTR _dwVID$1$[esp+200], eax
  00628	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0062b	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0062f	72 02		 jb	 SHORT $LN344@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00631	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN344@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 326  : 		BYTE byDistance = atoi(TokenVector[2].c_str());

  00633	51		 push	 ecx
  00634	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00639	8d 73 48	 lea	 esi, DWORD PTR [ebx+72]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 326  : 		BYTE byDistance = atoi(TokenVector[2].c_str());

  0063c	88 44 24 33	 mov	 BYTE PTR _byDistance$1$[esp+200], al
  00640	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00643	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00647	72 04		 jb	 SHORT $LN354@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00649	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0064b	eb 02		 jmp	 SHORT $LN355@ServerComm
$LN354@ServerComm:
  0064d	8b ce		 mov	 ecx, esi
$LN355@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 327  : 		float fAngle = atof(TokenVector[3].c_str());

  0064f	51		 push	 ecx
  00650	e8 00 00 00 00	 call	 _atof
  00655	d9 5c 24 40	 fstp	 DWORD PTR tv3193[esp+200]
  00659	d9 44 24 40	 fld	 DWORD PTR tv3193[esp+200]
  0065d	83 c4 04	 add	 esp, 4

; 328  : 		fAngle = fmod(540.0f - fAngle, 360.0f);

  00660	d8 2d 00 00 00
	00		 fsubr	 DWORD PTR __real@44070000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 706  :     return (float)fmod(_X, _Y);

  00666	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4076800000000000
  0066c	e8 00 00 00 00	 call	 __CIfmod
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00671	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 706  :     return (float)fmod(_X, _Y);

  00675	dd 5c 24 44	 fstp	 QWORD PTR tv3185[esp+196]
  00679	f2 0f 10 44 24
	44		 movsd	 xmm0, QWORD PTR tv3185[esp+196]
  0067f	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00683	72 02		 jb	 SHORT $LN368@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00685	8b 36		 mov	 esi, DWORD PTR [esi]
$LN368@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 329  : 		Tracef("StoneDetect [VID:%d] [Distance:%d] [Angle:%d->%f]\n", dwVID, byDistance, atoi(TokenVector[3].c_str()), fAngle);

  00687	0f b6 44 24 2f	 movzx	 eax, BYTE PTR _byDistance$1$[esp+196]
  0068c	83 ec 08	 sub	 esp, 8
  0068f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00692	89 44 24 44	 mov	 DWORD PTR tv2898[esp+204], eax
  00696	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0069b	56		 push	 esi
  0069c	e8 00 00 00 00	 call	 __atoi64
  006a1	8b 74 24 48	 mov	 esi, DWORD PTR tv2898[esp+208]
  006a5	83 c4 04	 add	 esp, 4
  006a8	52		 push	 edx
  006a9	50		 push	 eax
  006aa	56		 push	 esi
  006ab	ff 74 24 54	 push	 DWORD PTR _dwVID$1$[esp+216]
  006af	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@COMEEBAO@StoneDetect?5?$FLVID?3?$CFd?$FN?5?$FLDistance?3?$CF@
  006b4	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef

; 330  : 
; 331  : 		IAbstractCharacterManager& rkChrMgr=IAbstractCharacterManager::GetSingleton();

  006b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  006bf	83 c4 1c	 add	 esp, 28			; 0000001cH

; 332  : 
; 333  : 		CInstanceBase * pInstance = rkChrMgr.GetInstancePtr(dwVID);

  006c2	8b 01		 mov	 eax, DWORD PTR [ecx]
  006c4	ff 74 24 40	 push	 DWORD PTR _dwVID$1$[esp+196]
  006c8	ff 50 08	 call	 DWORD PTR [eax+8]

; 334  : 		if (!pInstance)

  006cb	85 c0		 test	 eax, eax
  006cd	75 13		 jne	 SHORT $LN59@ServerComm

; 335  : 		{
; 336  : 			TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Not Exist Instance", c_szCommand);

  006cf	57		 push	 edi
  006d0	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@MCLCAHNB@CPythonNetworkStream?3?3ServerComm@
  006d5	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  006da	83 c4 08	 add	 esp, 8
  006dd	e9 86 0a 00 00	 jmp	 $LN704@ServerComm
$LN59@ServerComm:
  006e2	f2 0f 10 44 24
	44		 movsd	 xmm0, QWORD PTR tv3185[esp+196]

; 342  : 		pInstance->NEW_GetPixelPosition(&PixelPosition);

  006e8	8d 4c 24 50	 lea	 ecx, DWORD PTR _PixelPosition$21[esp+196]
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 182  :     z = fz;

  006ec	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 342  : 		pInstance->NEW_GetPixelPosition(&PixelPosition);

  006f0	51		 push	 ecx
  006f1	8b c8		 mov	 ecx, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 180  :     x = fx;

  006f3	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR _v3Rotation$23[esp+200], 0

; 181  :     y = fy;

  006fb	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR _v3Rotation$23[esp+204], 0

; 182  :     z = fz;

  00703	f3 0f 11 44 24
	74		 movss	 DWORD PTR _v3Rotation$23[esp+208], xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 342  : 		pInstance->NEW_GetPixelPosition(&PixelPosition);

  00709	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 343  : 
; 344  : 		PixelPosition.y *= -1.0f;

  0070e	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR _PixelPosition$21[esp+200]
  00714	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@bf800000
  0071c	f3 0f 11 44 24
	54		 movss	 DWORD PTR _PixelPosition$21[esp+200], xmm0

; 345  : 
; 346  : 		switch (byDistance)

  00722	83 fe 03	 cmp	 esi, 3
  00725	0f 87 d3 00 00
	00		 ja	 $LN52@ServerComm
  0072b	ff 24 b5 00 00
	00 00		 jmp	 DWORD PTR $LN714@ServerComm[esi*4]
$LN56@ServerComm:

; 347  : 		{
; 348  : 			case 0:
; 349  : 				CEffectManager::Instance().RegisterEffect("d:/ymir work/effect/etc/firecracker/find_out.mse");

  00732	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  00738	6a 00		 push	 0
  0073a	6a 00		 push	 0
  0073c	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CJFLAJFC@d?3?1ymir?5work?1effect?1etc?1firecrac@
  00741	e8 00 00 00 00	 call	 ?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z ; CEffectManager::RegisterEffect

; 350  : 				CEffectManager::Instance().CreateEffect("d:/ymir work/effect/etc/firecracker/find_out.mse", PixelPosition, v3Rotation);

  00746	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  0074c	8d 44 24 68	 lea	 eax, DWORD PTR _v3Rotation$23[esp+196]
  00750	50		 push	 eax
  00751	8d 44 24 54	 lea	 eax, DWORD PTR _PixelPosition$21[esp+200]
  00755	50		 push	 eax
  00756	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CJFLAJFC@d?3?1ymir?5work?1effect?1etc?1firecrac@
  0075b	e8 00 00 00 00	 call	 ?CreateEffect@CEffectManager@@QAEHPBDABUD3DXVECTOR3@@1@Z ; CEffectManager::CreateEffect

; 351  : 				break;

  00760	e9 03 0a 00 00	 jmp	 $LN704@ServerComm
$LN55@ServerComm:

; 352  : 			case 1:
; 353  : 				CEffectManager::Instance().RegisterEffect("d:/ymir work/effect/etc/compass/appear_small.mse");

  00765	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  0076b	6a 00		 push	 0
  0076d	6a 00		 push	 0
  0076f	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@KDMGCNFI@d?3?1ymir?5work?1effect?1etc?1compass?1@
  00774	e8 00 00 00 00	 call	 ?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z ; CEffectManager::RegisterEffect

; 354  : 				CEffectManager::Instance().CreateEffect("d:/ymir work/effect/etc/compass/appear_small.mse", PixelPosition, v3Rotation);

  00779	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  0077f	8d 44 24 68	 lea	 eax, DWORD PTR _v3Rotation$23[esp+196]
  00783	50		 push	 eax
  00784	8d 44 24 54	 lea	 eax, DWORD PTR _PixelPosition$21[esp+200]
  00788	50		 push	 eax
  00789	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@KDMGCNFI@d?3?1ymir?5work?1effect?1etc?1compass?1@
  0078e	e8 00 00 00 00	 call	 ?CreateEffect@CEffectManager@@QAEHPBDABUD3DXVECTOR3@@1@Z ; CEffectManager::CreateEffect

; 355  : 				break;

  00793	e9 d0 09 00 00	 jmp	 $LN704@ServerComm
$LN54@ServerComm:

; 356  : 			case 2:
; 357  : 				CEffectManager::Instance().RegisterEffect("d:/ymir work/effect/etc/compass/appear_middle.mse");

  00798	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  0079e	6a 00		 push	 0
  007a0	6a 00		 push	 0
  007a2	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@MDCBLGBM@d?3?1ymir?5work?1effect?1etc?1compass?1@
  007a7	e8 00 00 00 00	 call	 ?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z ; CEffectManager::RegisterEffect

; 358  : 				CEffectManager::Instance().CreateEffect("d:/ymir work/effect/etc/compass/appear_middle.mse", PixelPosition, v3Rotation);

  007ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  007b2	8d 44 24 68	 lea	 eax, DWORD PTR _v3Rotation$23[esp+196]
  007b6	50		 push	 eax
  007b7	8d 44 24 54	 lea	 eax, DWORD PTR _PixelPosition$21[esp+200]
  007bb	50		 push	 eax
  007bc	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@MDCBLGBM@d?3?1ymir?5work?1effect?1etc?1compass?1@
  007c1	e8 00 00 00 00	 call	 ?CreateEffect@CEffectManager@@QAEHPBDABUD3DXVECTOR3@@1@Z ; CEffectManager::CreateEffect

; 359  : 				break;

  007c6	e9 9d 09 00 00	 jmp	 $LN704@ServerComm
$LN53@ServerComm:

; 360  : 			case 3:
; 361  : 				CEffectManager::Instance().RegisterEffect("d:/ymir work/effect/etc/compass/appear_large.mse");

  007cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  007d1	6a 00		 push	 0
  007d3	6a 00		 push	 0
  007d5	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@EEGLDHND@d?3?1ymir?5work?1effect?1etc?1compass?1@
  007da	e8 00 00 00 00	 call	 ?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z ; CEffectManager::RegisterEffect

; 362  : 				CEffectManager::Instance().CreateEffect("d:/ymir work/effect/etc/compass/appear_large.mse", PixelPosition, v3Rotation);

  007df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  007e5	8d 44 24 68	 lea	 eax, DWORD PTR _v3Rotation$23[esp+196]
  007e9	50		 push	 eax
  007ea	8d 44 24 54	 lea	 eax, DWORD PTR _PixelPosition$21[esp+200]
  007ee	50		 push	 eax
  007ef	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@EEGLDHND@d?3?1ymir?5work?1effect?1etc?1compass?1@
  007f4	e8 00 00 00 00	 call	 ?CreateEffect@CEffectManager@@QAEHPBDABUD3DXVECTOR3@@1@Z ; CEffectManager::CreateEffect

; 363  : 				break;

  007f9	e9 6a 09 00 00	 jmp	 $LN704@ServerComm
$LN52@ServerComm:

; 364  : 			default:
; 365  : 				TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Distance", c_szCommand);

  007fe	57		 push	 edi
  007ff	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@NKAADCPI@CPythonNetworkStream?3?3ServerComm@
  00804	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00809	83 c4 08	 add	 esp, 8

; 366  : 				break;
; 367  : 		}
; 368  : 
; 369  : #ifdef _DEBUG
; 370  : 		IAbstractChat& rkChat=IAbstractChat::GetSingleton();
; 371  : 		rkChat.AppendChat(CHAT_TYPE_INFO, c_szCommand);
; 372  : #endif
; 373  : 	}
; 374  : 	else if (!strcmpi(szCmd, "StartStaminaConsume"))

  0080c	e9 57 09 00 00	 jmp	 $LN704@ServerComm
$LN61@ServerComm:
  00811	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FMEJBOHN@StartStaminaConsume?$AA@
  00816	56		 push	 esi
  00817	e8 00 00 00 00	 call	 __strcmpi
  0081c	83 c4 08	 add	 esp, 8
  0081f	85 c0		 test	 eax, eax
  00821	75 6b		 jne	 SHORT $LN50@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00823	8b 4c 24 34	 mov	 ecx, DWORD PTR _TokenVector$[esp+200]
  00827	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0082c	2b cb		 sub	 ecx, ebx
  0082e	f7 e9		 imul	 ecx
  00830	c1 fa 02	 sar	 edx, 2
  00833	8b c2		 mov	 eax, edx
  00835	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00838	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 376  : 		if (3 != TokenVector.size())

  0083a	83 f8 03	 cmp	 eax, 3
  0083d	74 13		 je	 SHORT $LN49@ServerComm

; 377  : 		{
; 378  : 			TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %s", c_szCommand);

  0083f	57		 push	 edi
  00840	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MGEFFJHF@CPythonNetworkStream?3?3ServerComm@
  00845	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0084a	83 c4 08	 add	 esp, 8
  0084d	e9 16 09 00 00	 jmp	 $LN704@ServerComm
$LN49@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00852	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00856	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00859	72 02		 jb	 SHORT $LN402@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0085b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN402@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 382  : 		DWORD dwConsumePerSec = atoi(TokenVector[1].c_str());

  0085d	50		 push	 eax
  0085e	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00863	8d 4b 30	 lea	 ecx, DWORD PTR [ebx+48]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 382  : 		DWORD dwConsumePerSec = atoi(TokenVector[1].c_str());

  00866	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00869	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 382  : 		DWORD dwConsumePerSec = atoi(TokenVector[1].c_str());

  0086d	8b f0		 mov	 esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0086f	72 02		 jb	 SHORT $LN412@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00871	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN412@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 383  : 		DWORD dwCurrentStamina = atoi(TokenVector[2].c_str());

  00873	51		 push	 ecx
  00874	e8 00 00 00 00	 call	 __atoi64

; 384  : 
; 385  : 		IAbstractPlayer& rPlayer=IAbstractPlayer::GetSingleton();

  00879	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  0087f	83 c4 04	 add	 esp, 4

; 386  : 		rPlayer.StartStaminaConsume(dwConsumePerSec, dwCurrentStamina);

  00882	8b 11		 mov	 edx, DWORD PTR [ecx]
  00884	50		 push	 eax
  00885	56		 push	 esi
  00886	ff 52 1c	 call	 DWORD PTR [edx+28]
  00889	e9 da 08 00 00	 jmp	 $LN704@ServerComm
$LN50@ServerComm:

; 387  : 	}
; 388  : 	
; 389  : 	else if (!strcmpi(szCmd, "StopStaminaConsume"))

  0088e	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IEDOLMCO@StopStaminaConsume?$AA@
  00893	56		 push	 esi
  00894	e8 00 00 00 00	 call	 __strcmpi
  00899	83 c4 08	 add	 esp, 8
  0089c	85 c0		 test	 eax, eax
  0089e	75 55		 jne	 SHORT $LN47@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  008a0	8b 4c 24 34	 mov	 ecx, DWORD PTR _TokenVector$[esp+200]
  008a4	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  008a9	2b cb		 sub	 ecx, ebx
  008ab	f7 e9		 imul	 ecx
  008ad	c1 fa 02	 sar	 edx, 2
  008b0	8b c2		 mov	 eax, edx
  008b2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  008b5	03 c2		 add	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 391  : 		if (2 != TokenVector.size())

  008b7	83 f8 02	 cmp	 eax, 2
  008ba	74 14		 je	 SHORT $LN46@ServerComm

; 392  : 		{
; 393  : 			TraceError("CPythonNetworkStream::ServerCommand(c_szCommand=%s) - Strange Parameter Count : %d", c_szCommand, TokenVector.size());

  008bc	50		 push	 eax
  008bd	57		 push	 edi
  008be	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MDMGNNOD@CPythonNetworkStream?3?3ServerComm@
  008c3	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  008c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  008cb	e9 98 08 00 00	 jmp	 $LN704@ServerComm
$LN46@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  008d0	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  008d4	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  008d7	72 02		 jb	 SHORT $LN428@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  008d9	8b 00		 mov	 eax, DWORD PTR [eax]
$LN428@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 397  : 		DWORD dwCurrentStamina = atoi(TokenVector[1].c_str());

  008db	50		 push	 eax
  008dc	e8 00 00 00 00	 call	 __atoi64

; 398  : 
; 399  : 		IAbstractPlayer& rPlayer=IAbstractPlayer::GetSingleton();

  008e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  008e7	83 c4 04	 add	 esp, 4

; 400  : 		rPlayer.StopStaminaConsume(dwCurrentStamina);

  008ea	8b 11		 mov	 edx, DWORD PTR [ecx]
  008ec	50		 push	 eax
  008ed	ff 52 20	 call	 DWORD PTR [edx+32]
  008f0	e9 73 08 00 00	 jmp	 $LN704@ServerComm
$LN47@ServerComm:

; 401  : 	}
; 402  : 	else if (!strcmpi(szCmd, "sms"))

  008f5	68 00 00 00 00	 push	 OFFSET ??_C@_03ODCMFNNH@sms?$AA@
  008fa	56		 push	 esi
  008fb	e8 00 00 00 00	 call	 __strcmpi
  00900	83 c4 08	 add	 esp, 8
  00903	85 c0		 test	 eax, eax
  00905	75 12		 jne	 SHORT $LN44@ServerComm

; 403  : 	{
; 404  : 		IAbstractPlayer& rPlayer=IAbstractPlayer::GetSingleton();

  00907	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton

; 405  : 		rPlayer.SetMobileFlag(TRUE);

  0090d	6a 01		 push	 1
  0090f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00911	ff 50 78	 call	 DWORD PTR [eax+120]
  00914	e9 4f 08 00 00	 jmp	 $LN704@ServerComm
$LN44@ServerComm:

; 406  : 	}
; 407  : 	else if (!strcmpi(szCmd, "nosms"))

  00919	68 00 00 00 00	 push	 OFFSET ??_C@_05FKDGKNNO@nosms?$AA@
  0091e	56		 push	 esi
  0091f	e8 00 00 00 00	 call	 __strcmpi
  00924	83 c4 08	 add	 esp, 8
  00927	85 c0		 test	 eax, eax
  00929	75 12		 jne	 SHORT $LN42@ServerComm

; 408  : 	{
; 409  : 		IAbstractPlayer& rPlayer=IAbstractPlayer::GetSingleton();

  0092b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton

; 410  : 		rPlayer.SetMobileFlag(FALSE);

  00931	6a 00		 push	 0
  00933	8b 01		 mov	 eax, DWORD PTR [ecx]
  00935	ff 50 78	 call	 DWORD PTR [eax+120]
  00938	e9 2b 08 00 00	 jmp	 $LN704@ServerComm
$LN42@ServerComm:

; 411  : 	}
; 412  : 	else if (!strcmpi(szCmd, "mobile_auth"))

  0093d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HBFEJGNO@mobile_auth?$AA@
  00942	56		 push	 esi
  00943	e8 00 00 00 00	 call	 __strcmpi
  00948	83 c4 08	 add	 esp, 8
  0094b	85 c0		 test	 eax, eax
  0094d	75 1a		 jne	 SHORT $LN40@ServerComm

; 413  : 	{
; 414  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnMobileAuthority", Py_BuildValue("()"));

  0094f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  00954	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00959	ff d0		 call	 eax
  0095b	83 c4 04	 add	 esp, 4
  0095e	50		 push	 eax
  0095f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PFMPDKEI@OnMobileAuthority?$AA@
  00964	e9 3b f8 ff ff	 jmp	 $LN709@ServerComm
$LN40@ServerComm:

; 415  : 	}
; 416  : 	else if (!strcmpi(szCmd, "messenger_auth"))

  00969	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EGMHBKG@messenger_auth?$AA@
  0096e	56		 push	 esi
  0096f	e8 00 00 00 00	 call	 __strcmpi
  00974	83 c4 08	 add	 esp, 8
  00977	85 c0		 test	 eax, eax
  00979	75 5e		 jne	 SHORT $LN38@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0097b	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  0097f	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00982	72 02		 jb	 SHORT $LN444@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00984	8b 00		 mov	 eax, DWORD PTR [eax]
$LN444@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 418  : 		const std::string & c_rstrName = TokenVector[1].c_str();

  00986	50		 push	 eax
  00987	8d 4c 24 54	 lea	 ecx, DWORD PTR _$S1$20[esp+200]
  0098b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00990	c6 84 24 c0 00
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+204], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00998	8d 44 24 50	 lea	 eax, DWORD PTR _$S1$20[esp+196]
  0099c	83 7c 24 64 10	 cmp	 DWORD PTR _$S1$20[esp+216], 16 ; 00000010H
  009a1	0f 43 44 24 50	 cmovae	 eax, DWORD PTR _$S1$20[esp+196]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 419  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnMessengerAddFriendQuestion", Py_BuildValue("(s)", c_rstrName.c_str()));

  009a6	50		 push	 eax
  009a7	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  009ac	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  009b1	ff d0		 call	 eax
  009b3	8b 4c 24 48	 mov	 ecx, DWORD PTR _this$GSCopy$1$[esp+204]
  009b7	50		 push	 eax
  009b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HFJFNDOJ@OnMessengerAddFriendQuestion?$AA@
  009bd	ff b1 90 01 00
	00		 push	 DWORD PTR [ecx+400]
  009c3	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  009c8	83 c4 14	 add	 esp, 20			; 00000014H

; 420  : 	}

  009cb	8d 4c 24 50	 lea	 ecx, DWORD PTR _$S1$20[esp+196]
  009cf	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  009d4	e9 8f 07 00 00	 jmp	 $LN704@ServerComm
$LN38@ServerComm:

; 421  : 	else if (!strcmpi(szCmd, "combo"))

  009d9	68 00 00 00 00	 push	 OFFSET ??_C@_05LLEFIEMM@combo?$AA@
  009de	56		 push	 esi
  009df	e8 00 00 00 00	 call	 __strcmpi
  009e4	83 c4 08	 add	 esp, 8
  009e7	85 c0		 test	 eax, eax
  009e9	75 36		 jne	 SHORT $LN36@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  009eb	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  009ef	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  009f2	72 02		 jb	 SHORT $LN462@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  009f4	8b 00		 mov	 eax, DWORD PTR [eax]
$LN462@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 423  : 		int iFlag = atoi(TokenVector[1].c_str());

  009f6	50		 push	 eax
  009f7	e8 00 00 00 00	 call	 __atoi64

; 424  : 		IAbstractPlayer& rPlayer=IAbstractPlayer::GetSingleton();

  009fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  00a02	83 c4 04	 add	 esp, 4
  00a05	8b f0		 mov	 esi, eax

; 425  : 		rPlayer.SetComboSkillFlag(iFlag);

  00a07	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a09	56		 push	 esi
  00a0a	ff 52 7c	 call	 DWORD PTR [edx+124]

; 426  : 		m_bComboSkillFlag = iFlag ? true : false;

  00a0d	8b 4c 24 40	 mov	 ecx, DWORD PTR _this$GSCopy$1$[esp+196]
  00a11	85 f6		 test	 esi, esi
  00a13	0f 95 c0	 setne	 al
  00a16	88 81 21 79 00
	00		 mov	 BYTE PTR [ecx+31009], al
  00a1c	e9 47 07 00 00	 jmp	 $LN704@ServerComm
$LN36@ServerComm:

; 427  : 	}
; 428  : 	else if (!strcmpi(szCmd, "setblockmode"))

  00a21	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OCOPIGOC@setblockmode?$AA@
  00a26	56		 push	 esi
  00a27	e8 00 00 00 00	 call	 __strcmpi
  00a2c	83 c4 08	 add	 esp, 8
  00a2f	85 c0		 test	 eax, eax
  00a31	75 2c		 jne	 SHORT $LN34@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00a33	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00a37	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00a3a	72 02		 jb	 SHORT $LN474@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00a3c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN474@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 430  : 		int iFlag = atoi(TokenVector[1].c_str());

  00a3e	50		 push	 eax
  00a3f	e8 00 00 00 00	 call	 __atoi64
  00a44	83 c4 04	 add	 esp, 4

; 431  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_GAME], "OnBlockMode", Py_BuildValue("(i)", iFlag));

  00a47	50		 push	 eax
  00a48	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_BuildValue
  00a4d	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00a52	ff d0		 call	 eax
  00a54	50		 push	 eax
  00a55	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KBLDJFEH@OnBlockMode?$AA@
  00a5a	e9 f5 f7 ff ff	 jmp	 $LN711@ServerComm
$LN34@ServerComm:

; 432  : 	}
; 433  : 	// Emotion Start
; 434  : 	else if (!strcmpi(szCmd, "french_kiss"))

  00a5f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KHOIJDFJ@french_kiss?$AA@
  00a64	56		 push	 esi
  00a65	e8 00 00 00 00	 call	 __strcmpi
  00a6a	83 c4 08	 add	 esp, 8
  00a6d	85 c0		 test	 eax, eax
  00a6f	75 74		 jne	 SHORT $LN32@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00a71	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00a75	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00a78	72 02		 jb	 SHORT $LN484@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00a7a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN484@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 436  : 		int iVID1 = atoi(TokenVector[1].c_str());

  00a7c	50		 push	 eax
  00a7d	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00a82	8d 4b 30	 lea	 ecx, DWORD PTR [ebx+48]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 436  : 		int iVID1 = atoi(TokenVector[1].c_str());

  00a85	89 44 24 40	 mov	 DWORD PTR _iVID1$1$[esp+200], eax
  00a89	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00a8c	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00a90	72 02		 jb	 SHORT $LN494@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00a92	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN494@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 437  : 		int iVID2 = atoi(TokenVector[2].c_str());

  00a94	51		 push	 ecx
  00a95	e8 00 00 00 00	 call	 __atoi64

; 438  : 
; 439  : 		IAbstractCharacterManager & rkChrMgr = IAbstractCharacterManager::GetSingleton();

  00a9a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  00aa0	83 c4 04	 add	 esp, 4

; 440  : 		CInstanceBase * pInstance1 = rkChrMgr.GetInstancePtr(iVID1);

  00aa3	8b cf		 mov	 ecx, edi
  00aa5	8b f0		 mov	 esi, eax
  00aa7	8b 17		 mov	 edx, DWORD PTR [edi]
  00aa9	ff 74 24 3c	 push	 DWORD PTR _iVID1$1$[esp+196]
  00aad	ff 52 08	 call	 DWORD PTR [edx+8]

; 441  : 		CInstanceBase * pInstance2 = rkChrMgr.GetInstancePtr(iVID2);

  00ab0	8b 17		 mov	 edx, DWORD PTR [edi]
  00ab2	8b cf		 mov	 ecx, edi
  00ab4	56		 push	 esi
  00ab5	89 44 24 40	 mov	 DWORD PTR _pInstance1$1$[esp+200], eax
  00ab9	ff 52 08	 call	 DWORD PTR [edx+8]

; 442  : 		if (pInstance1 && pInstance2)

  00abc	8b 4c 24 3c	 mov	 ecx, DWORD PTR _pInstance1$1$[esp+196]
  00ac0	85 c9		 test	 ecx, ecx
  00ac2	0f 84 a0 06 00
	00		 je	 $LN704@ServerComm
  00ac8	85 c0		 test	 eax, eax
  00aca	0f 84 98 06 00
	00		 je	 $LN704@ServerComm

; 443  : 			pInstance1->ActDualEmotion(*pInstance2, CRaceMotionData::NAME_FRENCH_KISS_START, CRaceMotionData::NAME_FRENCH_KISS_START);

  00ad0	68 39 01 00 00	 push	 313			; 00000139H
  00ad5	68 39 01 00 00	 push	 313			; 00000139H
  00ada	50		 push	 eax
  00adb	e8 00 00 00 00	 call	 ?ActDualEmotion@CInstanceBase@@QAEXAAV1@GG@Z ; CInstanceBase::ActDualEmotion

; 444  : 	}

  00ae0	e9 83 06 00 00	 jmp	 $LN704@ServerComm
$LN32@ServerComm:

; 445  : 	else if (!strcmpi(szCmd, "kiss"))

  00ae5	68 00 00 00 00	 push	 OFFSET ??_C@_04MDLEAKAL@kiss?$AA@
  00aea	56		 push	 esi
  00aeb	e8 00 00 00 00	 call	 __strcmpi
  00af0	83 c4 08	 add	 esp, 8
  00af3	85 c0		 test	 eax, eax
  00af5	75 74		 jne	 SHORT $LN29@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00af7	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00afb	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00afe	72 02		 jb	 SHORT $LN506@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00b00	8b 00		 mov	 eax, DWORD PTR [eax]
$LN506@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 447  : 		int iVID1 = atoi(TokenVector[1].c_str());

  00b02	50		 push	 eax
  00b03	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00b08	8d 4b 30	 lea	 ecx, DWORD PTR [ebx+48]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 447  : 		int iVID1 = atoi(TokenVector[1].c_str());

  00b0b	89 44 24 40	 mov	 DWORD PTR _iVID1$1$[esp+200], eax
  00b0f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00b12	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00b16	72 02		 jb	 SHORT $LN516@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00b18	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN516@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 448  : 		int iVID2 = atoi(TokenVector[2].c_str());

  00b1a	51		 push	 ecx
  00b1b	e8 00 00 00 00	 call	 __atoi64

; 449  : 
; 450  : 		IAbstractCharacterManager & rkChrMgr = IAbstractCharacterManager::GetSingleton();

  00b20	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  00b26	83 c4 04	 add	 esp, 4

; 451  : 		CInstanceBase * pInstance1 = rkChrMgr.GetInstancePtr(iVID1);

  00b29	8b cf		 mov	 ecx, edi
  00b2b	8b f0		 mov	 esi, eax
  00b2d	8b 17		 mov	 edx, DWORD PTR [edi]
  00b2f	ff 74 24 3c	 push	 DWORD PTR _iVID1$1$[esp+196]
  00b33	ff 52 08	 call	 DWORD PTR [edx+8]

; 452  : 		CInstanceBase * pInstance2 = rkChrMgr.GetInstancePtr(iVID2);

  00b36	8b 17		 mov	 edx, DWORD PTR [edi]
  00b38	8b cf		 mov	 ecx, edi
  00b3a	56		 push	 esi
  00b3b	89 44 24 40	 mov	 DWORD PTR _pInstance1$1$[esp+200], eax
  00b3f	ff 52 08	 call	 DWORD PTR [edx+8]

; 453  : 		if (pInstance1 && pInstance2)

  00b42	8b 4c 24 3c	 mov	 ecx, DWORD PTR _pInstance1$1$[esp+196]
  00b46	85 c9		 test	 ecx, ecx
  00b48	0f 84 1a 06 00
	00		 je	 $LN704@ServerComm
  00b4e	85 c0		 test	 eax, eax
  00b50	0f 84 12 06 00
	00		 je	 $LN704@ServerComm

; 454  : 			pInstance1->ActDualEmotion(*pInstance2, CRaceMotionData::NAME_KISS_START, CRaceMotionData::NAME_KISS_START);

  00b56	68 35 01 00 00	 push	 309			; 00000135H
  00b5b	68 35 01 00 00	 push	 309			; 00000135H
  00b60	50		 push	 eax
  00b61	e8 00 00 00 00	 call	 ?ActDualEmotion@CInstanceBase@@QAEXAAV1@GG@Z ; CInstanceBase::ActDualEmotion

; 455  : 	}

  00b66	e9 fd 05 00 00	 jmp	 $LN704@ServerComm
$LN29@ServerComm:

; 456  : 	else if (!strcmpi(szCmd, "slap"))

  00b6b	68 00 00 00 00	 push	 OFFSET ??_C@_04JAHFACKH@slap?$AA@
  00b70	56		 push	 esi
  00b71	e8 00 00 00 00	 call	 __strcmpi
  00b76	83 c4 08	 add	 esp, 8
  00b79	85 c0		 test	 eax, eax
  00b7b	75 74		 jne	 SHORT $LN26@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00b7d	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00b81	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00b84	72 02		 jb	 SHORT $LN528@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00b86	8b 00		 mov	 eax, DWORD PTR [eax]
$LN528@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 458  : 		int iVID1 = atoi(TokenVector[1].c_str());

  00b88	50		 push	 eax
  00b89	e8 00 00 00 00	 call	 __atoi64
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00b8e	8d 4b 30	 lea	 ecx, DWORD PTR [ebx+48]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 458  : 		int iVID1 = atoi(TokenVector[1].c_str());

  00b91	89 44 24 40	 mov	 DWORD PTR _iVID1$1$[esp+200], eax
  00b95	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00b98	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00b9c	72 02		 jb	 SHORT $LN538@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00b9e	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN538@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 459  : 		int iVID2 = atoi(TokenVector[2].c_str());

  00ba0	51		 push	 ecx
  00ba1	e8 00 00 00 00	 call	 __atoi64

; 460  : 
; 461  : 		IAbstractCharacterManager & rkChrMgr = IAbstractCharacterManager::GetSingleton();

  00ba6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  00bac	83 c4 04	 add	 esp, 4

; 462  : 		CInstanceBase * pInstance1 = rkChrMgr.GetInstancePtr(iVID1);

  00baf	8b cf		 mov	 ecx, edi
  00bb1	8b f0		 mov	 esi, eax
  00bb3	8b 17		 mov	 edx, DWORD PTR [edi]
  00bb5	ff 74 24 3c	 push	 DWORD PTR _iVID1$1$[esp+196]
  00bb9	ff 52 08	 call	 DWORD PTR [edx+8]

; 463  : 		CInstanceBase * pInstance2 = rkChrMgr.GetInstancePtr(iVID2);

  00bbc	8b 17		 mov	 edx, DWORD PTR [edi]
  00bbe	8b cf		 mov	 ecx, edi
  00bc0	56		 push	 esi
  00bc1	89 44 24 40	 mov	 DWORD PTR _pInstance1$1$[esp+200], eax
  00bc5	ff 52 08	 call	 DWORD PTR [edx+8]

; 464  : 		if (pInstance1 && pInstance2)

  00bc8	8b 4c 24 3c	 mov	 ecx, DWORD PTR _pInstance1$1$[esp+196]
  00bcc	85 c9		 test	 ecx, ecx
  00bce	0f 84 94 05 00
	00		 je	 $LN704@ServerComm
  00bd4	85 c0		 test	 eax, eax
  00bd6	0f 84 8c 05 00
	00		 je	 $LN704@ServerComm

; 465  : 			pInstance1->ActDualEmotion(*pInstance2, CRaceMotionData::NAME_SLAP_HURT_START, CRaceMotionData::NAME_SLAP_HIT_START);

  00bdc	68 3d 01 00 00	 push	 317			; 0000013dH
  00be1	68 41 01 00 00	 push	 321			; 00000141H
  00be6	50		 push	 eax
  00be7	e8 00 00 00 00	 call	 ?ActDualEmotion@CInstanceBase@@QAEXAAV1@GG@Z ; CInstanceBase::ActDualEmotion

; 466  : 	}

  00bec	e9 77 05 00 00	 jmp	 $LN704@ServerComm
$LN26@ServerComm:

; 467  : 	else if (!strcmpi(szCmd, "clap"))

  00bf1	68 00 00 00 00	 push	 OFFSET ??_C@_04PAJFJFCF@clap?$AA@
  00bf6	56		 push	 esi
  00bf7	e8 00 00 00 00	 call	 __strcmpi
  00bfc	83 c4 08	 add	 esp, 8
  00bff	85 c0		 test	 eax, eax
  00c01	75 32		 jne	 SHORT $LN23@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00c03	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00c07	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00c0a	72 02		 jb	 SHORT $LN550@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00c0c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN550@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 469  : 		int iVID = atoi(TokenVector[1].c_str());

  00c0e	50		 push	 eax
  00c0f	e8 00 00 00 00	 call	 __atoi64

; 470  : 		IAbstractCharacterManager & rkChrMgr = IAbstractCharacterManager::GetSingleton();

  00c14	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  00c1a	83 c4 04	 add	 esp, 4

; 471  : 		CInstanceBase * pInstance = rkChrMgr.GetInstancePtr(iVID);

  00c1d	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c1f	50		 push	 eax
  00c20	ff 52 08	 call	 DWORD PTR [edx+8]

; 472  : 		if (pInstance)

  00c23	85 c0		 test	 eax, eax
  00c25	0f 84 3d 05 00
	00		 je	 $LN704@ServerComm

; 473  : 			pInstance->ActEmotion(CRaceMotionData::NAME_CLAP);

  00c2b	68 32 01 00 00	 push	 306			; 00000132H

; 474  : 	}

  00c30	e9 2c 05 00 00	 jmp	 $LN713@ServerComm
$LN23@ServerComm:

; 475  : 	else if (!strcmpi(szCmd, "cheer1"))

  00c35	68 00 00 00 00	 push	 OFFSET ??_C@_06PAGILPEO@cheer1?$AA@
  00c3a	56		 push	 esi
  00c3b	e8 00 00 00 00	 call	 __strcmpi
  00c40	83 c4 08	 add	 esp, 8
  00c43	85 c0		 test	 eax, eax
  00c45	75 32		 jne	 SHORT $LN20@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00c47	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00c4b	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00c4e	72 02		 jb	 SHORT $LN562@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00c50	8b 00		 mov	 eax, DWORD PTR [eax]
$LN562@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 477  : 		int iVID = atoi(TokenVector[1].c_str());

  00c52	50		 push	 eax
  00c53	e8 00 00 00 00	 call	 __atoi64

; 478  : 		IAbstractCharacterManager & rkChrMgr = IAbstractCharacterManager::GetSingleton();

  00c58	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  00c5e	83 c4 04	 add	 esp, 4

; 479  : 		CInstanceBase * pInstance = rkChrMgr.GetInstancePtr(iVID);

  00c61	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c63	50		 push	 eax
  00c64	ff 52 08	 call	 DWORD PTR [edx+8]

; 480  : 		if (pInstance)

  00c67	85 c0		 test	 eax, eax
  00c69	0f 84 f9 04 00
	00		 je	 $LN704@ServerComm

; 481  : 			pInstance->ActEmotion(CRaceMotionData::NAME_CHEERS_1);

  00c6f	68 33 01 00 00	 push	 307			; 00000133H

; 482  : 	}

  00c74	e9 e8 04 00 00	 jmp	 $LN713@ServerComm
$LN20@ServerComm:

; 483  : 	else if (!strcmpi(szCmd, "cheer2"))

  00c79	68 00 00 00 00	 push	 OFFSET ??_C@_06NLEFOMIN@cheer2?$AA@
  00c7e	56		 push	 esi
  00c7f	e8 00 00 00 00	 call	 __strcmpi
  00c84	83 c4 08	 add	 esp, 8
  00c87	85 c0		 test	 eax, eax
  00c89	75 32		 jne	 SHORT $LN17@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00c8b	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00c8f	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00c92	72 02		 jb	 SHORT $LN574@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00c94	8b 00		 mov	 eax, DWORD PTR [eax]
$LN574@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 485  : 		int iVID = atoi(TokenVector[1].c_str());

  00c96	50		 push	 eax
  00c97	e8 00 00 00 00	 call	 __atoi64

; 486  : 		IAbstractCharacterManager & rkChrMgr = IAbstractCharacterManager::GetSingleton();

  00c9c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  00ca2	83 c4 04	 add	 esp, 4

; 487  : 		CInstanceBase * pInstance = rkChrMgr.GetInstancePtr(iVID);

  00ca5	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ca7	50		 push	 eax
  00ca8	ff 52 08	 call	 DWORD PTR [edx+8]

; 488  : 		if (pInstance)

  00cab	85 c0		 test	 eax, eax
  00cad	0f 84 b5 04 00
	00		 je	 $LN704@ServerComm

; 489  : 			pInstance->ActEmotion(CRaceMotionData::NAME_CHEERS_2);

  00cb3	68 34 01 00 00	 push	 308			; 00000134H

; 490  : 	}

  00cb8	e9 a4 04 00 00	 jmp	 $LN713@ServerComm
$LN17@ServerComm:

; 491  : 	else if (!strcmpi(szCmd, "dance1"))

  00cbd	68 00 00 00 00	 push	 OFFSET ??_C@_06FJBCALDA@dance1?$AA@
  00cc2	56		 push	 esi
  00cc3	e8 00 00 00 00	 call	 __strcmpi
  00cc8	83 c4 08	 add	 esp, 8
  00ccb	85 c0		 test	 eax, eax
  00ccd	75 32		 jne	 SHORT $LN14@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00ccf	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00cd3	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00cd6	72 02		 jb	 SHORT $LN586@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00cd8	8b 00		 mov	 eax, DWORD PTR [eax]
$LN586@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 493  : 		int iVID = atoi(TokenVector[1].c_str());

  00cda	50		 push	 eax
  00cdb	e8 00 00 00 00	 call	 __atoi64

; 494  : 		IAbstractCharacterManager & rkChrMgr = IAbstractCharacterManager::GetSingleton();

  00ce0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  00ce6	83 c4 04	 add	 esp, 4

; 495  : 		CInstanceBase * pInstance = rkChrMgr.GetInstancePtr(iVID);

  00ce9	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ceb	50		 push	 eax
  00cec	ff 52 08	 call	 DWORD PTR [edx+8]

; 496  : 		if (pInstance)

  00cef	85 c0		 test	 eax, eax
  00cf1	0f 84 71 04 00
	00		 je	 $LN704@ServerComm

; 497  : 			pInstance->ActEmotion(CRaceMotionData::NAME_DANCE_1);

  00cf7	68 46 01 00 00	 push	 326			; 00000146H

; 498  : 	}

  00cfc	e9 60 04 00 00	 jmp	 $LN713@ServerComm
$LN14@ServerComm:

; 499  : 	else if (!strcmpi(szCmd, "dance2"))

  00d01	68 00 00 00 00	 push	 OFFSET ??_C@_06HCDPFIPD@dance2?$AA@
  00d06	56		 push	 esi
  00d07	e8 00 00 00 00	 call	 __strcmpi
  00d0c	83 c4 08	 add	 esp, 8
  00d0f	85 c0		 test	 eax, eax
  00d11	75 32		 jne	 SHORT $LN11@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00d13	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00d17	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00d1a	72 02		 jb	 SHORT $LN598@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00d1c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN598@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 501  : 		int iVID = atoi(TokenVector[1].c_str());

  00d1e	50		 push	 eax
  00d1f	e8 00 00 00 00	 call	 __atoi64

; 502  : 		IAbstractCharacterManager & rkChrMgr = IAbstractCharacterManager::GetSingleton();

  00d24	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  00d2a	83 c4 04	 add	 esp, 4

; 503  : 		CInstanceBase * pInstance = rkChrMgr.GetInstancePtr(iVID);

  00d2d	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d2f	50		 push	 eax
  00d30	ff 52 08	 call	 DWORD PTR [edx+8]

; 504  : 		if (pInstance)

  00d33	85 c0		 test	 eax, eax
  00d35	0f 84 2d 04 00
	00		 je	 $LN704@ServerComm

; 505  : 			pInstance->ActEmotion(CRaceMotionData::NAME_DANCE_2);

  00d3b	68 47 01 00 00	 push	 327			; 00000147H

; 506  : 	}

  00d40	e9 1c 04 00 00	 jmp	 $LN713@ServerComm
$LN11@ServerComm:

; 507  : 	else if (!strcmpi(szCmd, "dig_motion"))

  00d45	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MMJCNAM@dig_motion?$AA@
  00d4a	56		 push	 esi
  00d4b	e8 00 00 00 00	 call	 __strcmpi
  00d50	83 c4 08	 add	 esp, 8
  00d53	85 c0		 test	 eax, eax
  00d55	75 32		 jne	 SHORT $LN8@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00d57	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00d5b	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00d5e	72 02		 jb	 SHORT $LN610@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00d60	8b 00		 mov	 eax, DWORD PTR [eax]
$LN610@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 509  : 		int iVID = atoi(TokenVector[1].c_str());

  00d62	50		 push	 eax
  00d63	e8 00 00 00 00	 call	 __atoi64

; 510  : 		IAbstractCharacterManager & rkChrMgr = IAbstractCharacterManager::GetSingleton();

  00d68	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  00d6e	83 c4 04	 add	 esp, 4

; 511  : 		CInstanceBase * pInstance = rkChrMgr.GetInstancePtr(iVID);

  00d71	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d73	50		 push	 eax
  00d74	ff 52 08	 call	 DWORD PTR [edx+8]

; 512  : 		if (pInstance)

  00d77	85 c0		 test	 eax, eax
  00d79	0f 84 e9 03 00
	00		 je	 $LN704@ServerComm

; 513  : 			pInstance->ActEmotion(CRaceMotionData::NAME_DIG);

  00d7f	68 45 01 00 00	 push	 325			; 00000145H

; 514  : 	}
; 515  : 	// Emotion End
; 516  : 	else

  00d84	e9 d8 03 00 00	 jmp	 $LN713@ServerComm
$LN8@ServerComm:

; 518  : 		static std::map<std::string, int> s_emotionDict;

  00d89	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S2@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4IA
  00d8e	a8 01		 test	 al, 1
  00d90	75 43		 jne	 SHORT $LN5@ServerComm
  00d92	83 c8 01	 or	 eax, 1
  00d95	a3 00 00 00 00	 mov	 DWORD PTR ?$S2@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4IA, eax
  00d9a	c6 84 24 c0 00
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+204], 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00da2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A, 0

; 570  : 		this->_Mysize = 0;

  00dac	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A+4, 0

; 773  : 		this->_Myhead = _Buyheadnode();

  00db6	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Buyheadnode
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 518  : 		static std::map<std::string, int> s_emotionDict;

  00dbb	68 00 00 00 00	 push	 OFFSET ??__Fs_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@YAXXZ ; `CPythonNetworkStream::ServerCommand'::`212'::`dynamic atexit destructor for 's_emotionDict''
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  00dc0	a3 00 00 00 00	 mov	 DWORD PTR ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 518  : 		static std::map<std::string, int> s_emotionDict;

  00dc5	e8 00 00 00 00	 call	 _atexit
  00dca	83 c4 04	 add	 esp, 4
  00dcd	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
$LN5@ServerComm:

; 519  : 
; 520  : 		static bool s_isFirst = true;
; 521  : 		if (s_isFirst)

  00dd5	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?s_isFirst@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4_NA, 0
  00ddc	0f 84 13 03 00
	00		 je	 $LN4@ServerComm

; 522  : 		{
; 523  : 			s_isFirst = false;
; 524  : 
; 525  : 			s_emotionDict["dance3"] = CRaceMotionData::NAME_DANCE_3;

  00de2	68 00 00 00 00	 push	 OFFSET ??_C@_06GLCEGJLC@dance3?$AA@
  00de7	8d 4c 24 54	 lea	 ecx, DWORD PTR $T19[esp+200]
  00deb	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?s_isFirst@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4_NA, 0
  00df2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00df7	8d 44 24 50	 lea	 eax, DWORD PTR $T19[esp+196]
  00dfb	c6 84 24 c0 00
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+204], 3
  00e03	50		 push	 eax
  00e04	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  00e09	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00e0e	8d 4c 24 50	 lea	 ecx, DWORD PTR $T19[esp+196]
  00e12	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  00e1a	c7 00 48 01 00
	00		 mov	 DWORD PTR [eax], 328	; 00000148H
  00e20	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 526  : 			s_emotionDict["dance4"] = CRaceMotionData::NAME_DANCE_4;

  00e25	68 00 00 00 00	 push	 OFFSET ??_C@_06CEGFPPHF@dance4?$AA@
  00e2a	8d 4c 24 54	 lea	 ecx, DWORD PTR $T18[esp+200]
  00e2e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00e33	8d 44 24 50	 lea	 eax, DWORD PTR $T18[esp+196]
  00e37	c6 84 24 c0 00
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+204], 4
  00e3f	50		 push	 eax
  00e40	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  00e45	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00e4a	8d 4c 24 50	 lea	 ecx, DWORD PTR $T18[esp+196]
  00e4e	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  00e56	c7 00 49 01 00
	00		 mov	 DWORD PTR [eax], 329	; 00000149H
  00e5c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 527  : 			s_emotionDict["dance5"] = CRaceMotionData::NAME_DANCE_5;

  00e61	68 00 00 00 00	 push	 OFFSET ??_C@_06DNHOMODE@dance5?$AA@
  00e66	8d 4c 24 54	 lea	 ecx, DWORD PTR $T17[esp+200]
  00e6a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00e6f	8d 44 24 50	 lea	 eax, DWORD PTR $T17[esp+196]
  00e73	c6 84 24 c0 00
	00 00 05	 mov	 BYTE PTR __$EHRec$[esp+204], 5
  00e7b	50		 push	 eax
  00e7c	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  00e81	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00e86	8d 4c 24 50	 lea	 ecx, DWORD PTR $T17[esp+196]
  00e8a	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  00e92	c7 00 4a 01 00
	00		 mov	 DWORD PTR [eax], 330	; 0000014aH
  00e98	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 528  : 			s_emotionDict["dance6"] = CRaceMotionData::NAME_DANCE_6;

  00e9d	68 00 00 00 00	 push	 OFFSET ??_C@_06BGFDJNPH@dance6?$AA@
  00ea2	8d 4c 24 54	 lea	 ecx, DWORD PTR $T16[esp+200]
  00ea6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00eab	8d 44 24 50	 lea	 eax, DWORD PTR $T16[esp+196]
  00eaf	c6 84 24 c0 00
	00 00 06	 mov	 BYTE PTR __$EHRec$[esp+204], 6
  00eb7	50		 push	 eax
  00eb8	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  00ebd	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00ec2	8d 4c 24 50	 lea	 ecx, DWORD PTR $T16[esp+196]
  00ec6	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  00ece	c7 00 4b 01 00
	00		 mov	 DWORD PTR [eax], 331	; 0000014bH
  00ed4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 529  : 			s_emotionDict["congratulation"] = CRaceMotionData::NAME_CONGRATULATION;

  00ed9	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KFFKPMLJ@congratulation?$AA@
  00ede	8d 4c 24 54	 lea	 ecx, DWORD PTR $T15[esp+200]
  00ee2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ee7	8d 44 24 50	 lea	 eax, DWORD PTR $T15[esp+196]
  00eeb	c6 84 24 c0 00
	00 00 07	 mov	 BYTE PTR __$EHRec$[esp+204], 7
  00ef3	50		 push	 eax
  00ef4	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  00ef9	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00efe	8d 4c 24 50	 lea	 ecx, DWORD PTR $T15[esp+196]
  00f02	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  00f0a	c7 00 57 01 00
	00		 mov	 DWORD PTR [eax], 343	; 00000157H
  00f10	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 530  : 			s_emotionDict["forgive"] = CRaceMotionData::NAME_FORGIVE;

  00f15	68 00 00 00 00	 push	 OFFSET ??_C@_07JCIHIBLI@forgive?$AA@
  00f1a	8d 4c 24 54	 lea	 ecx, DWORD PTR $T14[esp+200]
  00f1e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00f23	8d 44 24 50	 lea	 eax, DWORD PTR $T14[esp+196]
  00f27	c6 84 24 c0 00
	00 00 08	 mov	 BYTE PTR __$EHRec$[esp+204], 8
  00f2f	50		 push	 eax
  00f30	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  00f35	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00f3a	8d 4c 24 50	 lea	 ecx, DWORD PTR $T14[esp+196]
  00f3e	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  00f46	c7 00 58 01 00
	00		 mov	 DWORD PTR [eax], 344	; 00000158H
  00f4c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 531  : 			s_emotionDict["angry"] = CRaceMotionData::NAME_ANGRY;

  00f51	68 00 00 00 00	 push	 OFFSET ??_C@_05KEOOPKLE@angry?$AA@
  00f56	8d 4c 24 54	 lea	 ecx, DWORD PTR $T13[esp+200]
  00f5a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00f5f	8d 44 24 50	 lea	 eax, DWORD PTR $T13[esp+196]
  00f63	c6 84 24 c0 00
	00 00 09	 mov	 BYTE PTR __$EHRec$[esp+204], 9
  00f6b	50		 push	 eax
  00f6c	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  00f71	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00f76	8d 4c 24 50	 lea	 ecx, DWORD PTR $T13[esp+196]
  00f7a	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  00f82	c7 00 59 01 00
	00		 mov	 DWORD PTR [eax], 345	; 00000159H
  00f88	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 532  : 			s_emotionDict["attractive"] = CRaceMotionData::NAME_ATTRACTIVE;

  00f8d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BIJBGJBO@attractive?$AA@
  00f92	8d 4c 24 54	 lea	 ecx, DWORD PTR $T12[esp+200]
  00f96	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00f9b	8d 44 24 50	 lea	 eax, DWORD PTR $T12[esp+196]
  00f9f	c6 84 24 c0 00
	00 00 0a	 mov	 BYTE PTR __$EHRec$[esp+204], 10 ; 0000000aH
  00fa7	50		 push	 eax
  00fa8	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  00fad	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00fb2	8d 4c 24 50	 lea	 ecx, DWORD PTR $T12[esp+196]
  00fb6	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  00fbe	c7 00 5a 01 00
	00		 mov	 DWORD PTR [eax], 346	; 0000015aH
  00fc4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 533  : 			s_emotionDict["sad"] = CRaceMotionData::NAME_SAD;

  00fc9	68 00 00 00 00	 push	 OFFSET ??_C@_03OPLFCACF@sad?$AA@
  00fce	8d 4c 24 54	 lea	 ecx, DWORD PTR $T11[esp+200]
  00fd2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00fd7	8d 44 24 50	 lea	 eax, DWORD PTR $T11[esp+196]
  00fdb	c6 84 24 c0 00
	00 00 0b	 mov	 BYTE PTR __$EHRec$[esp+204], 11 ; 0000000bH
  00fe3	50		 push	 eax
  00fe4	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  00fe9	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00fee	8d 4c 24 50	 lea	 ecx, DWORD PTR $T11[esp+196]
  00ff2	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  00ffa	c7 00 5b 01 00
	00		 mov	 DWORD PTR [eax], 347	; 0000015bH
  01000	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 534  : 			s_emotionDict["shy"] = CRaceMotionData::NAME_SHY;

  01005	68 00 00 00 00	 push	 OFFSET ??_C@_03BPAIHHLG@shy?$AA@
  0100a	8d 4c 24 54	 lea	 ecx, DWORD PTR $T10[esp+200]
  0100e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01013	8d 44 24 50	 lea	 eax, DWORD PTR $T10[esp+196]
  01017	c6 84 24 c0 00
	00 00 0c	 mov	 BYTE PTR __$EHRec$[esp+204], 12 ; 0000000cH
  0101f	50		 push	 eax
  01020	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  01025	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0102a	8d 4c 24 50	 lea	 ecx, DWORD PTR $T10[esp+196]
  0102e	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  01036	c7 00 5c 01 00
	00		 mov	 DWORD PTR [eax], 348	; 0000015cH
  0103c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 535  : 			s_emotionDict["cheerup"] = CRaceMotionData::NAME_CHEERUP;

  01041	68 00 00 00 00	 push	 OFFSET ??_C@_07MJDIFIMC@cheerup?$AA@
  01046	8d 4c 24 54	 lea	 ecx, DWORD PTR $T9[esp+200]
  0104a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0104f	8d 44 24 50	 lea	 eax, DWORD PTR $T9[esp+196]
  01053	c6 84 24 c0 00
	00 00 0d	 mov	 BYTE PTR __$EHRec$[esp+204], 13 ; 0000000dH
  0105b	50		 push	 eax
  0105c	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  01061	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  01066	8d 4c 24 50	 lea	 ecx, DWORD PTR $T9[esp+196]
  0106a	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  01072	c7 00 5d 01 00
	00		 mov	 DWORD PTR [eax], 349	; 0000015dH
  01078	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 536  : 			s_emotionDict["banter"] = CRaceMotionData::NAME_BANTER;

  0107d	68 00 00 00 00	 push	 OFFSET ??_C@_06CMFIENOK@banter?$AA@
  01082	8d 4c 24 54	 lea	 ecx, DWORD PTR $T8[esp+200]
  01086	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0108b	8d 44 24 50	 lea	 eax, DWORD PTR $T8[esp+196]
  0108f	c6 84 24 c0 00
	00 00 0e	 mov	 BYTE PTR __$EHRec$[esp+204], 14 ; 0000000eH
  01097	50		 push	 eax
  01098	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  0109d	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  010a2	8d 4c 24 50	 lea	 ecx, DWORD PTR $T8[esp+196]
  010a6	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  010ae	c7 00 5e 01 00
	00		 mov	 DWORD PTR [eax], 350	; 0000015eH
  010b4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 537  : 			s_emotionDict["joy"] = CRaceMotionData::NAME_JOY;

  010b9	68 00 00 00 00	 push	 OFFSET ??_C@_03DHFGHJCG@joy?$AA@
  010be	8d 4c 24 6c	 lea	 ecx, DWORD PTR $T22[esp+200]
  010c2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  010c7	c6 84 24 c0 00
	00 00 0f	 mov	 BYTE PTR __$EHRec$[esp+204], 15 ; 0000000fH
  010cf	8d 44 24 68	 lea	 eax, DWORD PTR $T22[esp+196]
  010d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  010d8	50		 push	 eax
  010d9	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  010de	8d 4c 24 68	 lea	 ecx, DWORD PTR $T22[esp+196]
  010e2	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+204], 0
  010ea	c7 00 5f 01 00
	00		 mov	 DWORD PTR [eax], 351	; 0000015fH
  010f0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@ServerComm:

; 538  : 		}
; 539  : 
; 540  : 		std::map<std::string, int>::iterator f = s_emotionDict.find(szCmd);

  010f5	56		 push	 esi
  010f6	8d 4c 24 54	 lea	 ecx, DWORD PTR $T7[esp+200]
  010fa	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  010ff	8d 44 24 50	 lea	 eax, DWORD PTR $T7[esp+196]
  01103	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  01108	50		 push	 eax
  01109	8d 44 24 40	 lea	 eax, DWORD PTR _f$6[esp+200]
  0110d	50		 push	 eax
  0110e	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::find
  01113	8d 4c 24 50	 lea	 ecx, DWORD PTR $T7[esp+196]
  01117	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  0111c	8b 44 24 3c	 mov	 eax, DWORD PTR _f$6[esp+196]
  01120	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 541  : 		if (f == s_emotionDict.end())

  01126	75 11		 jne	 SHORT $LN3@ServerComm

; 542  : 		{
; 543  : 			TraceError("Unknown Server Command %s | %s", c_szCommand, szCmd);

  01128	56		 push	 esi
  01129	57		 push	 edi
  0112a	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@HJIPKFJO@Unknown?5Server?5Command?5?$CFs?5?$HM?5?$CFs?$AA@
  0112f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  01134	83 c4 0c	 add	 esp, 12			; 0000000cH
  01137	eb 2f		 jmp	 SHORT $LN704@ServerComm
$LN3@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  01139	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 547  : 			int emotionIndex = f->second;

  0113d	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  01140	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  01143	72 02		 jb	 SHORT $LN664@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  01145	8b 00		 mov	 eax, DWORD PTR [eax]
$LN664@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 549  : 			int iVID = atoi(TokenVector[1].c_str());

  01147	50		 push	 eax
  01148	e8 00 00 00 00	 call	 __atoi64

; 550  : 			IAbstractCharacterManager & rkChrMgr = IAbstractCharacterManager::GetSingleton();

  0114d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton
  01153	83 c4 04	 add	 esp, 4

; 551  : 			CInstanceBase * pInstance = rkChrMgr.GetInstancePtr(iVID);

  01156	8b 11		 mov	 edx, DWORD PTR [ecx]
  01158	50		 push	 eax
  01159	ff 52 08	 call	 DWORD PTR [edx+8]

; 552  : 
; 553  : 			if (pInstance)

  0115c	85 c0		 test	 eax, eax
  0115e	74 08		 je	 SHORT $LN704@ServerComm

; 554  : 				pInstance->ActEmotion(emotionIndex);

  01160	56		 push	 esi
$LN713@ServerComm:
  01161	8b c8		 mov	 ecx, eax
  01163	e8 00 00 00 00	 call	 ?ActEmotion@CInstanceBase@@QAEXK@Z ; CInstanceBase::ActEmotion
$LN704@ServerComm:
  01168	8b 44 24 34	 mov	 eax, DWORD PTR _TokenVector$[esp+200]
$LN1@ServerComm:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0116c	85 db		 test	 ebx, ebx
  0116e	74 19		 je	 SHORT $LN672@ServerComm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  01170	ff 74 24 3c	 push	 DWORD PTR __Cat$5[esp+196]
  01174	8d 4c 24 33	 lea	 ecx, DWORD PTR __Alval$2[esp+200]
  01178	51		 push	 ecx
  01179	50		 push	 eax
  0117a	53		 push	 ebx
  0117b	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);

  01180	53		 push	 ebx
  01181	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  01186	83 c4 14	 add	 esp, 20			; 00000014H
$LN672@ServerComm:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonnetworkstreamcommand.cpp

; 557  : }

  01189	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+196]
  01190	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01197	59		 pop	 ecx
  01198	5f		 pop	 edi
  01199	5e		 pop	 esi
  0119a	5b		 pop	 ebx
  0119b	8b 4c 24 70	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+180]
  0119f	33 cc		 xor	 ecx, esp
  011a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011a6	8b e5		 mov	 esp, ebp
  011a8	5d		 pop	 ebp
  011a9	c2 04 00	 ret	 4
$LN714@ServerComm:
  011ac	00 00 00 00	 DD	 $LN56@ServerComm
  011b0	00 00 00 00	 DD	 $LN55@ServerComm
  011b4	00 00 00 00	 DD	 $LN54@ServerComm
  011b8	00 00 00 00	 DD	 $LN53@ServerComm
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$0:
  00000	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _TokenVector$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$1:
  0000b	8d 4d 8c	 lea	 ecx, DWORD PTR _$S1$20[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$2:
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S2@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4IA
  00018	83 e0 fe	 and	 eax, -2			; fffffffeH
  0001b	a3 00 00 00 00	 mov	 DWORD PTR ?$S2@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4IA, eax
  00020	c3		 ret	 0
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$3:
  00021	8d 4d 8c	 lea	 ecx, DWORD PTR $T19[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$4:
  00029	8d 4d 8c	 lea	 ecx, DWORD PTR $T18[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$5:
  00031	8d 4d 8c	 lea	 ecx, DWORD PTR $T17[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$6:
  00039	8d 4d 8c	 lea	 ecx, DWORD PTR $T16[ebp]
  0003c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$7:
  00041	8d 4d 8c	 lea	 ecx, DWORD PTR $T15[ebp]
  00044	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$8:
  00049	8d 4d 8c	 lea	 ecx, DWORD PTR $T14[ebp]
  0004c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$9:
  00051	8d 4d 8c	 lea	 ecx, DWORD PTR $T13[ebp]
  00054	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$10:
  00059	8d 4d 8c	 lea	 ecx, DWORD PTR $T12[ebp]
  0005c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$11:
  00061	8d 4d 8c	 lea	 ecx, DWORD PTR $T11[ebp]
  00064	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$12:
  00069	8d 4d 8c	 lea	 ecx, DWORD PTR $T10[ebp]
  0006c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$13:
  00071	8d 4d 8c	 lea	 ecx, DWORD PTR $T9[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$14:
  00079	8d 4d 8c	 lea	 ecx, DWORD PTR $T8[ebp]
  0007c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z$15:
  00081	8d 4d a4	 lea	 ecx, DWORD PTR $T22[ebp]
  00084	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z:
  00089	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0008d	8d 82 4c ff ff
	ff		 lea	 eax, DWORD PTR [edx-180]
  00093	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  00099	33 c8		 xor	 ecx, eax
  0009b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a0	83 c0 0c	 add	 eax, 12			; 0000000cH
  000a3	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  000a6	33 c8		 xor	 ecx, eax
  000a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ad	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z
  000b2	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ServerCommand@CPythonNetworkStream@@QAEXPAD@Z ENDP	; CPythonNetworkStream::ServerCommand
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__Fs_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@YAXXZ
text$yd	SEGMENT
$T1 = -8						; size = 4
$T2 = -1						; size = 1
$T3 = -1						; size = 1
$T4 = -1						; size = 1
$T5 = -1						; size = 1
??__Fs_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@YAXXZ PROC ; `CPythonNetworkStream::ServerCommand'::`212'::`dynamic atexit destructor for 's_emotionDict'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  00008	83 ec 08	 sub	 esp, 8
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A
  00010	56		 push	 esi
  00011	50		 push	 eax
  00012	ff 30		 push	 DWORD PTR [eax]
  00014	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase

; 778  : 		_Freeheadnode(this->_Myhead);

  0001d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?s_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@4V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@A

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  00023	8d 4d ff	 lea	 ecx, DWORD PTR $T5[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >

; 779  : 		}
; 780  : 
; 781  : 	void _Change_alloc(const _Alty&)
; 782  : 		{	// replace old allocator
; 783  : 		}
; 784  : 
; 785  : 	void _Swap_alloc(_Myt&)
; 786  : 		{	// swap allocators
; 787  : 		}
; 788  : 
; 789  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 790  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 791  : 		{	// construct allocators from _Al
; 792  : 		this->_Myhead = _Buyheadnode();
; 793  : 		_TRY_BEGIN
; 794  : 		_Alloc_proxy();
; 795  : 		_CATCH_ALL
; 796  : 		_Freeheadnode(this->_Myhead);
; 797  : 		_RERAISE;
; 798  : 		_CATCH_END
; 799  : 		}
; 800  : 
; 801  : 	~_Tree_alloc() _NOEXCEPT
; 802  : 		{	// destroy proxy
; 803  : 		_Freeheadnode(this->_Myhead);
; 804  : 		_Free_proxy();
; 805  : 		}
; 806  : 
; 807  : 	void _Change_alloc(const _Alty&)
; 808  : 		{	// replace old allocator
; 809  : 		}
; 810  : 
; 811  : 	void _Swap_alloc(_Myt&)
; 812  : 		{	// swap allocators
; 813  : 		}
; 814  : 
; 815  : 	void _Alloc_proxy()
; 816  : 		{	// construct proxy from _Alnod
; 817  : 		typename _Alty::template rebind<_Container_proxy>::other
; 818  : 			_Alproxy(_Getal());
; 819  : 		this->_Myproxy = _Alproxy.allocate(1);
; 820  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 821  : 		this->_Myproxy->_Mycont = this;
; 822  : 		}
; 823  : 
; 824  : 	void _Free_proxy()
; 825  : 		{	// destroy proxy
; 826  : 		typename _Alty::template rebind<_Container_proxy>::other
; 827  : 			_Alproxy(_Getal());
; 828  : 		this->_Orphan_all();
; 829  : 		_Alproxy.destroy(this->_Myproxy);
; 830  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 831  : 		this->_Myproxy = 0;
; 832  : 		}
; 833  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 834  : 
; 835  : 	_Nodeptr _Buyheadnode()
; 836  : 		{	// get head node using current allocator
; 837  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 838  : 
; 839  : 		_TRY_BEGIN
; 840  : 		this->_Getal().construct(
; 841  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 842  : 		this->_Getal().construct(
; 843  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 844  : 		this->_Getal().construct(
; 845  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 846  : 		_CATCH_ALL
; 847  : 		this->_Getal().deallocate(_Pnode, 1);
; 848  : 		_RERAISE;
; 849  : 		_CATCH_END
; 850  : 
; 851  : 		this->_Color(_Pnode) = this->_Black;
; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}
; 855  : 
; 856  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 857  : 		{	// free head node using current allocator
; 858  : 		this->_Getal().destroy(
; 859  : 			_STD addressof(this->_Left(_Pnode)));

  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  00031	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00034	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >

; 860  : 		this->_Getal().destroy(
; 861  : 			_STD addressof(this->_Parent(_Pnode)));

  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  0003f	8d 4d ff	 lea	 ecx, DWORD PTR $T4[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >

; 862  : 		this->_Getal().destroy(
; 863  : 			_STD addressof(this->_Right(_Pnode)));

  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

  0004d	8d 4d ff	 lea	 ecx, DWORD PTR $T3[ebp]
  00050	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	56		 push	 esi
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
  0005e	5e		 pop	 esi
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
??__Fs_emotionDict@?NE@??ServerCommand@CPythonNetworkStream@@QAEXPAD@Z@YAXXZ ENDP ; `CPythonNetworkStream::ServerCommand'::`212'::`dynamic atexit destructor for 's_emotionDict''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_not_of, COMDAT
; _this$ = ecx

; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN5@find_first
  0000c	33 d2		 xor	 edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));

  0000e	52		 push	 edx
  0000f	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_not_of
  00018	5e		 pop	 esi

; 2081 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
$LN5@find_first:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@find_first:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL7@find_first
  0002a	2b d7		 sub	 edx, edi
  0002c	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));

  0002d	52		 push	 edx
  0002e	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_not_of
  00037	5e		 pop	 esi

; 2081 : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_not_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 2130 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 761  : 		assign(_Right, _Roff, _Count);

  00005	ff 75 10	 push	 DWORD PTR __Count$[ebp]

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 761  : 		assign(_Right, _Roff, _Count);

  0000b	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00015	51		 push	 ecx

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00016	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 761  : 		assign(_Right, _Roff, _Count);

  0001d	8b ce		 mov	 ecx, esi

; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00026	c6 06 00	 mov	 BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 761  : 		assign(_Right, _Roff, _Count);

  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi

; 2132 : 		}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve, COMDAT
; _this$ = ecx

; 999  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH

; 1000 : 		if (capacity() < _Count)

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00011	2b 16		 sub	 edx, DWORD PTR [esi]
  00013	f7 ea		 imul	 edx
  00015	c1 fa 02	 sar	 edx, 2
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx

; 1000 : 		if (capacity() < _Count)

  0001f	3b c1		 cmp	 eax, ecx
  00021	73 10		 jae	 SHORT $LN2@reserve

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

  00023	81 f9 aa aa aa
	0a		 cmp	 ecx, 178956970		; 0aaaaaaaH
  00029	77 0d		 ja	 SHORT $LN21@reserve

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

  0002b	51		 push	 ecx
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN2@reserve:
  00033	5e		 pop	 esi

; 1005 : 			}
; 1006 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN21@reserve:

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN23@reserve:
$LN20@reserve:
  00042	cc		 int	 3
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
;	COMDAT ?GetSingleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@SAAAVIAbstractCharacterManager@@XZ
_TEXT	SEGMENT
?GetSingleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@SAAAVIAbstractCharacterManager@@XZ PROC ; TAbstractSingleton<IAbstractCharacterManager>::GetSingleton, COMDAT

; 24   : 		assert(ms_singleton!=NULL);
; 25   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@0PAVIAbstractCharacterManager@@A ; TAbstractSingleton<IAbstractCharacterManager>::ms_singleton

; 26   : 	}	

  00005	c3		 ret	 0
?GetSingleton@?$TAbstractSingleton@VIAbstractCharacterManager@@@@SAAAVIAbstractCharacterManager@@XZ ENDP ; TAbstractSingleton<IAbstractCharacterManager>::GetSingleton
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 761  : 		assign(_Right, _Roff, _Count);

  00004	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 0c	 push	 DWORD PTR __Roff$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Right$[ebp]

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0000f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00016	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0001d	c6 06 00	 mov	 BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 761  : 		assign(_Right, _Roff, _Count);

  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 762  : 		}

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 10 00	 ret	 16			; 00000010H
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
tv207 = -4						; size = 4
__Ptr$ = 8						; size = 4
tv211 = 12						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_not_of, COMDAT
; _this$ = ecx

; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0000f	89 45 fc	 mov	 DWORD PTR tv207[ebp], eax
  00012	3b d0		 cmp	 edx, eax
  00014	73 4e		 jae	 SHORT $LN2@find_first

; 520  : 			: this->_Bx._Buf);

  00016	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00019	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0001c	72 07		 jb	 SHORT $LN10@find_first
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0001e	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00020	89 5d 0c	 mov	 DWORD PTR tv211[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00023	eb 05		 jmp	 SHORT $LN11@find_first
$LN10@find_first:
  00025	8b df		 mov	 ebx, edi
  00027	89 7d 0c	 mov	 DWORD PTR tv211[ebp], edi
$LN11@find_first:

; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;

  0002a	03 c3		 add	 eax, ebx

; 520  : 			: this->_Bx._Buf);

  0002c	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002f	72 04		 jb	 SHORT $LN16@find_first
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00031	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00033	eb 02		 jmp	 SHORT $LN17@find_first
$LN16@find_first:
  00035	8b cf		 mov	 ecx, edi
$LN17@find_first:

; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;

  00037	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]

; 2069 : 				_Uptr < _Vptr; ++_Uptr)

  0003a	3b f0		 cmp	 esi, eax
  0003c	73 26		 jae	 SHORT $LN2@find_first
  0003e	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
$LL4@find_first:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 546  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00041	85 db		 test	 ebx, ebx
  00043	74 2b		 je	 SHORT $LN31@find_first
  00045	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00048	53		 push	 ebx
  00049	50		 push	 eax
  0004a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0004d	e8 00 00 00 00	 call	 _memchr
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)

  00055	85 c0		 test	 eax, eax
  00057	74 17		 je	 SHORT $LN31@find_first

; 2069 : 				_Uptr < _Vptr; ++_Uptr)

  00059	8b 45 fc	 mov	 eax, DWORD PTR tv207[ebp]
  0005c	46		 inc	 esi
  0005d	03 45 0c	 add	 eax, DWORD PTR tv211[ebp]
  00060	3b f0		 cmp	 esi, eax
  00062	72 dd		 jb	 SHORT $LL4@find_first
$LN2@find_first:
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi

; 2072 : 			}
; 2073 : 		return (npos);

  00066	83 c8 ff	 or	 eax, -1
  00069	5b		 pop	 ebx

; 2074 : 		}

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 0c 00	 ret	 12			; 0000000cH
$LN31@find_first:

; 520  : 			: this->_Bx._Buf);

  00070	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00074	72 02		 jb	 SHORT $LN26@find_first
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00076	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN26@find_first:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2071 : 					return (_Uptr - this->_Myptr());

  00078	2b f7		 sub	 esi, edi
  0007a	5f		 pop	 edi
  0007b	8b c6		 mov	 eax, esi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx

; 2074 : 		}

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 0c 00	 ret	 12			; 0000000cH
?find_first_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_not_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 2188 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2189 : 		return (this->_Getal());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2190 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
END
