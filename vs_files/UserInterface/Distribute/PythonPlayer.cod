; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonPlayer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@KCGJBOBB@RefreshStamina?$AA@		; `string'
PUBLIC	??_C@_0BL@KCKDPCFN@BINARY_Guild_ExitGuildArea?$AA@ ; `string'
PUBLIC	??_C@_0BM@OMJPBBKE@BINARY_Guild_EnterGuildArea?$AA@ ; `string'
PUBLIC	??_C@_0DC@LHJHEHHP@CPythonPlayer?3?3GetStatus?5?9?5Get?5S@ ; `string'
PUBLIC	??_C@_0DC@HBNJHHEJ@CPythonPlayer?3?3SetStatus?5?9?5Set?5S@ ; `string'
PUBLIC	??_C@_0GC@FMCMFPCN@CPythonPlayer?3?3SetItemData?$CIwindo@ ; `string'
PUBLIC	??_C@_0P@PDEFNCOA@OnChangePKMode?$AA@		; `string'
PUBLIC	??_C@_0FF@PCELILMJ@Failed?5to?5find?5ItemData?5?9?5CPytho@ ; `string'
PUBLIC	??_C@_0BC@GAEKBOHM@BINARY_ActEmotion?$AA@	; `string'
PUBLIC	??_C@_0ED@OIFHNIC@CPythonPlayer?3?3SetSkillCoolTime?$CI@ ; `string'
PUBLIC	??_C@_0DK@OJMDGNKA@CPythonPlayer?3?3SetSkillLevel?$CISlo@ ; `string'
PUBLIC	??_C@_0ED@MHHIIPAM@CPythonPlayer?3?3EndSkillCoolTime?$CI@ ; `string'
PUBLIC	??_C@_0FC@CAEKCLMF@CPythonPlayer?3?3SetSkillCoolTime?$CI@ ; `string'
PUBLIC	??_C@_0EA@BNHLOMGN@CPythonPlayer?3?3ActivavteSkill?$CIdw@ ; `string'
PUBLIC	??_C@_0FC@JLHDIAGN@CPythonPlayer?3?3EndSkillCoolTime?$CI@ ; `string'
PUBLIC	??_C@_0EC@BHLLACII@CPythonPlayer?3?3DeactivavteSkill?$CI@ ; `string'
PUBLIC	??_C@_0BC@GDFCJBCP@ActivateSkillSlot?$AA@	; `string'
PUBLIC	??_C@_0DP@MLLABPNJ@CPythonPlayer?3?3SendClickItemPack@ ; `string'
PUBLIC	??_C@_0BE@HIMJCBBG@DeactivateSkillSlot?$AA@	; `string'
PUBLIC	??_C@_0P@CGBLDLHF@OnCannotMining?$AA@		; `string'
PUBLIC	??_C@_0BB@DNNBDACF@OnCannotPickItem?$AA@	; `string'
PUBLIC	??_C@_0BC@FKINMGLI@OnCannotShotError?$AA@	; `string'
PUBLIC	??_C@_0M@HCIEKIGP@NEED_TARGET?$AA@		; `string'
PUBLIC	??_C@_0FC@JHEGNFED@?5CPythonPlayer?3?3LinkPartyMember?$CI@ ; `string'
PUBLIC	??_C@_08HOHDPHII@?1kiss?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0GK@FIFNELKC@?5CPythonPlayer?3?3UpdatePartyMembe@ ; `string'
PUBLIC	??_C@_0EK@OICEDEOK@?5CPythonPlayer?3?3UnlinkPartyMembe@ ; `string'
PUBLIC	??_C@_0HF@NJGIGGLI@?5CPythonPlayer?3?3UpdatePartyMembe@ ; `string'
PUBLIC	??_C@_0HG@LLGBHOIA@?5CPythonPlayer?3?3UpdatePartyMembe@ ; `string'
PUBLIC	??_C@_0BH@PIKHDMAM@BINARY_CheckGameButton?$AA@	; `string'
PUBLIC	??_C@_0O@EHNHNBIB@RefreshMobile?$AA@		; `string'
PUBLIC	??_R2CPythonPlayer@@8				; CPythonPlayer::`RTTI Base Class Array'
PUBLIC	??_R2?$CSingleton@VCPythonPlayer@@@@8		; CSingleton<CPythonPlayer>::`RTTI Base Class Array'
PUBLIC	??_R2?$TAbstractSingleton@VIAbstractPlayer@@@@8	; TAbstractSingleton<IAbstractPlayer>::`RTTI Base Class Array'
PUBLIC	??_R2IAbstractPlayer@@8				; IAbstractPlayer::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@IAbstractPlayer@@8			; IAbstractPlayer::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R13?0A@EA@?$TAbstractSingleton@VIAbstractPlayer@@@@8 ; TAbstractSingleton<IAbstractPlayer>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCPythonPlayer@@@@8	; CSingleton<CPythonPlayer>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CPythonPlayer@@8			; CPythonPlayer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IAbstractPlayer@@8		; IAbstractPlayer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$TAbstractSingleton@VIAbstractPlayer@@@@8 ; TAbstractSingleton<IAbstractPlayer>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$CSingleton@VCPythonPlayer@@@@@8	; CSingleton<CPythonPlayer> `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VCPythonPlayer@@@@8		; CSingleton<CPythonPlayer>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCPythonPlayer@@@8			; CPythonPlayer `RTTI Type Descriptor'
PUBLIC	??_R3CPythonPlayer@@8				; CPythonPlayer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$TAbstractSingleton@VIAbstractPlayer@@@@@8 ; TAbstractSingleton<IAbstractPlayer> `RTTI Type Descriptor'
PUBLIC	??_R3?$TAbstractSingleton@VIAbstractPlayer@@@@8	; TAbstractSingleton<IAbstractPlayer>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVIAbstractPlayer@@@8			; IAbstractPlayer `RTTI Type Descriptor'
PUBLIC	??_R3IAbstractPlayer@@8				; IAbstractPlayer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$CSingleton@VCPythonPlayer@@@@6B@		; CSingleton<CPythonPlayer>::`RTTI Complete Object Locator'
PUBLIC	??_R4CPythonPlayer@@6BIAbstractPlayer@@@	; CPythonPlayer::`RTTI Complete Object Locator'
PUBLIC	??_R4CPythonPlayer@@6B?$CSingleton@VCPythonPlayer@@@@@ ; CPythonPlayer::`RTTI Complete Object Locator'
PUBLIC	??_R4?$TAbstractSingleton@VIAbstractPlayer@@@@6B@ ; TAbstractSingleton<IAbstractPlayer>::`RTTI Complete Object Locator'
PUBLIC	??_R4IAbstractPlayer@@6B@			; IAbstractPlayer::`RTTI Complete Object Locator'
PUBLIC	??_7?$CSingleton@VCPythonPlayer@@@@6B@		; CSingleton<CPythonPlayer>::`vftable'
PUBLIC	??_7?$TAbstractSingleton@VIAbstractPlayer@@@@6B@ ; TAbstractSingleton<IAbstractPlayer>::`vftable'
PUBLIC	??_7CPythonPlayer@@6B?$CSingleton@VCPythonPlayer@@@@@ ; CPythonPlayer::`vftable'
PUBLIC	??_7CPythonPlayer@@6BIAbstractPlayer@@@		; CPythonPlayer::`vftable'
PUBLIC	??_7IAbstractPlayer@@6B@			; IAbstractPlayer::`vftable'
;	COMDAT ?s_dwNextTCPTime@?L@??__SendClickActorPacket@CPythonPlayer@@IAEXAAVCInstanceBase@@@Z@4KA
_BSS	SEGMENT
?s_dwNextTCPTime@?L@??__SendClickActorPacket@CPythonPlayer@@IAEXAAVCInstanceBase@@@Z@4KA DD 01H DUP (?) ; `CPythonPlayer::__SendClickActorPacket'::`11'::s_dwNextTCPTime
_BSS	ENDS
;	COMDAT ?s_dwNextTCPTime@?3??SendClickItemPacket@CPythonPlayer@@QAEXK@Z@4KA
_BSS	SEGMENT
?s_dwNextTCPTime@?3??SendClickItemPacket@CPythonPlayer@@QAEXK@Z@4KA DD 01H DUP (?) ; `CPythonPlayer::SendClickItemPacket'::`4'::s_dwNextTCPTime
_BSS	ENDS
;	COMDAT ??_7IAbstractPlayer@@6B@
CONST	SEGMENT
??_7IAbstractPlayer@@6B@ DD FLAT:??_R4IAbstractPlayer@@6B@ ; IAbstractPlayer::`vftable'
	DD	FLAT:??_EIAbstractPlayer@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7CPythonPlayer@@6BIAbstractPlayer@@@
CONST	SEGMENT
??_7CPythonPlayer@@6BIAbstractPlayer@@@ DD FLAT:??_R4CPythonPlayer@@6BIAbstractPlayer@@@ ; CPythonPlayer::`vftable'
	DD	FLAT:??_ECPythonPlayer@@W3AEPAXI@Z
	DD	FLAT:?GetMainCharacterIndex@CPythonPlayer@@UAEKXZ
	DD	FLAT:?SetMainCharacterIndex@CPythonPlayer@@UAEXH@Z
	DD	FLAT:?IsMainCharacterIndex@CPythonPlayer@@UAE_NK@Z
	DD	FLAT:?GetStatus@CPythonPlayer@@UAEHK@Z
	DD	FLAT:?GetName@CPythonPlayer@@UAEPBDXZ
	DD	FLAT:?SetRace@CPythonPlayer@@UAEXK@Z
	DD	FLAT:?StartStaminaConsume@CPythonPlayer@@UAEXKK@Z
	DD	FLAT:?StopStaminaConsume@CPythonPlayer@@UAEXK@Z
	DD	FLAT:?IsPartyMemberByVID@CPythonPlayer@@UAE_NK@Z
	DD	FLAT:?PartyMemberVIDToPID@CPythonPlayer@@UAE_NKPAK@Z
	DD	FLAT:?IsSamePartyMember@CPythonPlayer@@UAE_NKK@Z
	DD	FLAT:?SetItemData@CPythonPlayer@@UAEXUSItemPos@@ABUpacket_item@@@Z
	DD	FLAT:?SetItemCount@CPythonPlayer@@UAEXUSItemPos@@E@Z
	DD	FLAT:?SetItemMetinSocket@CPythonPlayer@@UAEXUSItemPos@@KK@Z
	DD	FLAT:?SetItemAttribute@CPythonPlayer@@UAEXUSItemPos@@KEF@Z
	DD	FLAT:?GetItemIndex@CPythonPlayer@@UAEKUSItemPos@@@Z
	DD	FLAT:?GetItemFlags@CPythonPlayer@@UAEKUSItemPos@@@Z
	DD	FLAT:?GetItemCount@CPythonPlayer@@UAEKUSItemPos@@@Z
	DD	FLAT:?IsEquipItemInSlot@CPythonPlayer@@UAE_NUSItemPos@@@Z
	DD	FLAT:?AddQuickSlot@CPythonPlayer@@UAEXHDD@Z
	DD	FLAT:?DeleteQuickSlot@CPythonPlayer@@UAEXH@Z
	DD	FLAT:?MoveQuickSlot@CPythonPlayer@@UAEXHH@Z
	DD	FLAT:?SetWeaponPower@CPythonPlayer@@UAEXKKKKK@Z
	DD	FLAT:?SetTarget@CPythonPlayer@@UAEXKH@Z
	DD	FLAT:?NotifyCharacterUpdate@CPythonPlayer@@UAEXK@Z
	DD	FLAT:?NotifyCharacterDead@CPythonPlayer@@UAEXK@Z
	DD	FLAT:?NotifyDeletingCharacterInstance@CPythonPlayer@@UAEXK@Z
	DD	FLAT:?NotifyChangePKMode@CPythonPlayer@@UAEXXZ
	DD	FLAT:?SetObserverMode@CPythonPlayer@@UAEX_N@Z
	DD	FLAT:?SetMobileFlag@CPythonPlayer@@UAEXH@Z
	DD	FLAT:?SetComboSkillFlag@CPythonPlayer@@UAEXH@Z
	DD	FLAT:?StartEmotionProcess@CPythonPlayer@@UAEXXZ
	DD	FLAT:?EndEmotionProcess@CPythonPlayer@@UAEXXZ
	DD	FLAT:?NEW_GetMainActorPtr@CPythonPlayer@@UAEPAVCInstanceBase@@XZ
CONST	ENDS
;	COMDAT ??_7CPythonPlayer@@6B?$CSingleton@VCPythonPlayer@@@@@
CONST	SEGMENT
??_7CPythonPlayer@@6B?$CSingleton@VCPythonPlayer@@@@@ DD FLAT:??_R4CPythonPlayer@@6B?$CSingleton@VCPythonPlayer@@@@@ ; CPythonPlayer::`vftable'
	DD	FLAT:??_ECPythonPlayer@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$TAbstractSingleton@VIAbstractPlayer@@@@6B@
CONST	SEGMENT
??_7?$TAbstractSingleton@VIAbstractPlayer@@@@6B@ DD FLAT:??_R4?$TAbstractSingleton@VIAbstractPlayer@@@@6B@ ; TAbstractSingleton<IAbstractPlayer>::`vftable'
	DD	FLAT:??_E?$TAbstractSingleton@VIAbstractPlayer@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCPythonPlayer@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCPythonPlayer@@@@6B@ DD FLAT:??_R4?$CSingleton@VCPythonPlayer@@@@6B@ ; CSingleton<CPythonPlayer>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCPythonPlayer@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4IAbstractPlayer@@6B@
rdata$r	SEGMENT
??_R4IAbstractPlayer@@6B@ DD 00H			; IAbstractPlayer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIAbstractPlayer@@@8
	DD	FLAT:??_R3IAbstractPlayer@@8
rdata$r	ENDS
;	COMDAT ??_R4?$TAbstractSingleton@VIAbstractPlayer@@@@6B@
rdata$r	SEGMENT
??_R4?$TAbstractSingleton@VIAbstractPlayer@@@@6B@ DD 00H ; TAbstractSingleton<IAbstractPlayer>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$TAbstractSingleton@VIAbstractPlayer@@@@@8
	DD	FLAT:??_R3?$TAbstractSingleton@VIAbstractPlayer@@@@8
rdata$r	ENDS
;	COMDAT ??_R4CPythonPlayer@@6B?$CSingleton@VCPythonPlayer@@@@@
rdata$r	SEGMENT
??_R4CPythonPlayer@@6B?$CSingleton@VCPythonPlayer@@@@@ DD 00H ; CPythonPlayer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPythonPlayer@@@8
	DD	FLAT:??_R3CPythonPlayer@@8
rdata$r	ENDS
;	COMDAT ??_R4CPythonPlayer@@6BIAbstractPlayer@@@
rdata$r	SEGMENT
??_R4CPythonPlayer@@6BIAbstractPlayer@@@ DD 00H		; CPythonPlayer::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVCPythonPlayer@@@8
	DD	FLAT:??_R3CPythonPlayer@@8
rdata$r	ENDS
;	COMDAT ??_R4?$CSingleton@VCPythonPlayer@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCPythonPlayer@@@@6B@ DD 00H		; CSingleton<CPythonPlayer>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCPythonPlayer@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCPythonPlayer@@@@8
rdata$r	ENDS
;	COMDAT ??_R3IAbstractPlayer@@8
rdata$r	SEGMENT
??_R3IAbstractPlayer@@8 DD 00H				; IAbstractPlayer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IAbstractPlayer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIAbstractPlayer@@@8
data$r	SEGMENT
??_R0?AVIAbstractPlayer@@@8 DD FLAT:??_7type_info@@6B@	; IAbstractPlayer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIAbstractPlayer@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$TAbstractSingleton@VIAbstractPlayer@@@@8
rdata$r	SEGMENT
??_R3?$TAbstractSingleton@VIAbstractPlayer@@@@8 DD 00H	; TAbstractSingleton<IAbstractPlayer>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$TAbstractSingleton@VIAbstractPlayer@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$TAbstractSingleton@VIAbstractPlayer@@@@@8
data$r	SEGMENT
??_R0?AV?$TAbstractSingleton@VIAbstractPlayer@@@@@8 DD FLAT:??_7type_info@@6B@ ; TAbstractSingleton<IAbstractPlayer> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$TAbstractSingleton@VIAbstractPlayer@@@@', 00H
data$r	ENDS
;	COMDAT ??_R3CPythonPlayer@@8
rdata$r	SEGMENT
??_R3CPythonPlayer@@8 DD 00H				; CPythonPlayer::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2CPythonPlayer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPythonPlayer@@@8
data$r	SEGMENT
??_R0?AVCPythonPlayer@@@8 DD FLAT:??_7type_info@@6B@	; CPythonPlayer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPythonPlayer@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCPythonPlayer@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCPythonPlayer@@@@8 DD 00H		; CSingleton<CPythonPlayer>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCPythonPlayer@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCPythonPlayer@@@@@8
data$r	SEGMENT
??_R0?AV?$CSingleton@VCPythonPlayer@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CPythonPlayer> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCPythonPlayer@@@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$TAbstractSingleton@VIAbstractPlayer@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$TAbstractSingleton@VIAbstractPlayer@@@@8 DD FLAT:??_R0?AV?$TAbstractSingleton@VIAbstractPlayer@@@@@8 ; TAbstractSingleton<IAbstractPlayer>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$TAbstractSingleton@VIAbstractPlayer@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IAbstractPlayer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IAbstractPlayer@@8 DD FLAT:??_R0?AVIAbstractPlayer@@@8 ; IAbstractPlayer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IAbstractPlayer@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPythonPlayer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPythonPlayer@@8 DD FLAT:??_R0?AVCPythonPlayer@@@8 ; CPythonPlayer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPythonPlayer@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCPythonPlayer@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCPythonPlayer@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCPythonPlayer@@@@@8 ; CSingleton<CPythonPlayer>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCPythonPlayer@@@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@?$TAbstractSingleton@VIAbstractPlayer@@@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$TAbstractSingleton@VIAbstractPlayer@@@@8 DD FLAT:??_R0?AV?$TAbstractSingleton@VIAbstractPlayer@@@@@8 ; TAbstractSingleton<IAbstractPlayer>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$TAbstractSingleton@VIAbstractPlayer@@@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@IAbstractPlayer@@8
rdata$r	SEGMENT
??_R13?0A@EA@IAbstractPlayer@@8 DD FLAT:??_R0?AVIAbstractPlayer@@@8 ; IAbstractPlayer::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	01H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IAbstractPlayer@@8
rdata$r	ENDS
;	COMDAT ??_R2IAbstractPlayer@@8
rdata$r	SEGMENT
??_R2IAbstractPlayer@@8 DD FLAT:??_R1A@?0A@EA@IAbstractPlayer@@8 ; IAbstractPlayer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$TAbstractSingleton@VIAbstractPlayer@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$TAbstractSingleton@VIAbstractPlayer@@@@8
rdata$r	SEGMENT
??_R2?$TAbstractSingleton@VIAbstractPlayer@@@@8 DD FLAT:??_R1A@?0A@EA@?$TAbstractSingleton@VIAbstractPlayer@@@@8 ; TAbstractSingleton<IAbstractPlayer>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCPythonPlayer@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCPythonPlayer@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonPlayer@@@@8 ; CSingleton<CPythonPlayer>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CPythonPlayer@@8
rdata$r	SEGMENT
??_R2CPythonPlayer@@8 DD FLAT:??_R1A@?0A@EA@CPythonPlayer@@8 ; CPythonPlayer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonPlayer@@@@8
	DD	FLAT:??_R13?0A@EA@IAbstractPlayer@@8
	DD	FLAT:??_R13?0A@EA@?$TAbstractSingleton@VIAbstractPlayer@@@@8
rdata$r	ENDS
;	COMDAT ??_C@_0O@EHNHNBIB@RefreshMobile?$AA@
CONST	SEGMENT
??_C@_0O@EHNHNBIB@RefreshMobile?$AA@ DB 'RefreshMobile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PIKHDMAM@BINARY_CheckGameButton?$AA@
CONST	SEGMENT
??_C@_0BH@PIKHDMAM@BINARY_CheckGameButton?$AA@ DB 'BINARY_CheckGameButton'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@LLGBHOIA@?5CPythonPlayer?3?3UpdatePartyMembe@
CONST	SEGMENT
??_C@_0HG@LLGBHOIA@?5CPythonPlayer?3?3UpdatePartyMembe@ DB ' CPythonPlaye'
	DB	'r::UpdatePartyMemberAffect(dwPID=%d, byAffectSlotIndex=%d, sA'
	DB	'ffectNumber=%d) - Strange affect slot index', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@NJGIGGLI@?5CPythonPlayer?3?3UpdatePartyMembe@
CONST	SEGMENT
??_C@_0HF@NJGIGGLI@?5CPythonPlayer?3?3UpdatePartyMembe@ DB ' CPythonPlaye'
	DB	'r::UpdatePartyMemberAffect(dwPID=%d, byAffectSlotIndex=%d, sA'
	DB	'ffectNumber=%d) - Failed to find character', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@OICEDEOK@?5CPythonPlayer?3?3UnlinkPartyMembe@
CONST	SEGMENT
??_C@_0EK@OICEDEOK@?5CPythonPlayer?3?3UnlinkPartyMembe@ DB ' CPythonPlaye'
	DB	'r::UnlinkPartyMember(dwPID=%d) - Failed to find party member', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@FIFNELKC@?5CPythonPlayer?3?3UpdatePartyMembe@
CONST	SEGMENT
??_C@_0GK@FIFNELKC@?5CPythonPlayer?3?3UpdatePartyMembe@ DB ' CPythonPlaye'
	DB	'r::UpdatePartyMemberInfo(dwPID=%d, byState=%d, byHPPercentage'
	DB	'=%d) - Failed to find character', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HOHDPHII@?1kiss?5?$CFs?$AA@
CONST	SEGMENT
??_C@_08HOHDPHII@?1kiss?5?$CFs?$AA@ DB '/kiss %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@JHEGNFED@?5CPythonPlayer?3?3LinkPartyMember?$CI@
CONST	SEGMENT
??_C@_0FC@JHEGNFED@?5CPythonPlayer?3?3LinkPartyMember?$CI@ DB ' CPythonPl'
	DB	'ayer::LinkPartyMember(dwPID=%d, dwVID=%d) - Failed to find pa'
	DB	'rty member', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HCIEKIGP@NEED_TARGET?$AA@
CONST	SEGMENT
??_C@_0M@HCIEKIGP@NEED_TARGET?$AA@ DB 'NEED_TARGET', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FKINMGLI@OnCannotShotError?$AA@
CONST	SEGMENT
??_C@_0BC@FKINMGLI@OnCannotShotError?$AA@ DB 'OnCannotShotError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DNNBDACF@OnCannotPickItem?$AA@
CONST	SEGMENT
??_C@_0BB@DNNBDACF@OnCannotPickItem?$AA@ DB 'OnCannotPickItem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CGBLDLHF@OnCannotMining?$AA@
CONST	SEGMENT
??_C@_0P@CGBLDLHF@OnCannotMining?$AA@ DB 'OnCannotMining', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HIMJCBBG@DeactivateSkillSlot?$AA@
CONST	SEGMENT
??_C@_0BE@HIMJCBBG@DeactivateSkillSlot?$AA@ DB 'DeactivateSkillSlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@MLLABPNJ@CPythonPlayer?3?3SendClickItemPack@
CONST	SEGMENT
??_C@_0DP@MLLABPNJ@CPythonPlayer?3?3SendClickItemPack@ DB 'CPythonPlayer:'
	DB	':SendClickItemPacket(dwIID=%d) : Non-exist item.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GDFCJBCP@ActivateSkillSlot?$AA@
CONST	SEGMENT
??_C@_0BC@GDFCJBCP@ActivateSkillSlot?$AA@ DB 'ActivateSkillSlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@BHLLACII@CPythonPlayer?3?3DeactivavteSkill?$CI@
CONST	SEGMENT
??_C@_0EC@BHLLACII@CPythonPlayer?3?3DeactivavteSkill?$CI@ DB 'CPythonPlay'
	DB	'er::DeactivavteSkill(dwSlotIndex=%d/%d) - OUT OF RANGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@JLHDIAGN@CPythonPlayer?3?3EndSkillCoolTime?$CI@
CONST	SEGMENT
??_C@_0FC@JLHDIAGN@CPythonPlayer?3?3EndSkillCoolTime?$CI@ DB 'CPythonPlay'
	DB	'er::EndSkillCoolTime(dwSkillIndex=%d) - dwSlotIndex=%d/%d OUT'
	DB	' OF RANGE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@BNHLOMGN@CPythonPlayer?3?3ActivavteSkill?$CIdw@
CONST	SEGMENT
??_C@_0EA@BNHLOMGN@CPythonPlayer?3?3ActivavteSkill?$CIdw@ DB 'CPythonPlay'
	DB	'er::ActivavteSkill(dwSlotIndex=%d/%d) - OUT OF RANGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@CAEKCLMF@CPythonPlayer?3?3SetSkillCoolTime?$CI@
CONST	SEGMENT
??_C@_0FC@CAEKCLMF@CPythonPlayer?3?3SetSkillCoolTime?$CI@ DB 'CPythonPlay'
	DB	'er::SetSkillCoolTime(dwSkillIndex=%d) - dwSlotIndex=%d/%d OUT'
	DB	' OF RANGE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MHHIIPAM@CPythonPlayer?3?3EndSkillCoolTime?$CI@
CONST	SEGMENT
??_C@_0ED@MHHIIPAM@CPythonPlayer?3?3EndSkillCoolTime?$CI@ DB 'CPythonPlay'
	DB	'er::EndSkillCoolTime(dwSkillIndex=%d) - FIND SLOT ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OJMDGNKA@CPythonPlayer?3?3SetSkillLevel?$CISlo@
CONST	SEGMENT
??_C@_0DK@OJMDGNKA@CPythonPlayer?3?3SetSkillLevel?$CISlo@ DB 'CPythonPlay'
	DB	'er::SetSkillLevel(SlotIndex=%d, SkillLevel=%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@OIFHNIC@CPythonPlayer?3?3SetSkillCoolTime?$CI@
CONST	SEGMENT
??_C@_0ED@OIFHNIC@CPythonPlayer?3?3SetSkillCoolTime?$CI@ DB 'CPythonPlaye'
	DB	'r::SetSkillCoolTime(dwSkillIndex=%d) - FIND SLOT ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GAEKBOHM@BINARY_ActEmotion?$AA@
CONST	SEGMENT
??_C@_0BC@GAEKBOHM@BINARY_ActEmotion?$AA@ DB 'BINARY_ActEmotion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@PCELILMJ@Failed?5to?5find?5ItemData?5?9?5CPytho@
CONST	SEGMENT
??_C@_0FF@PCELILMJ@Failed?5to?5find?5ItemData?5?9?5CPytho@ DB 'Failed to '
	DB	'find ItemData - CPythonPlayer::IsEquipItem(window_type=%d, iS'
	DB	'lotindex=%d)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PDEFNCOA@OnChangePKMode?$AA@
CONST	SEGMENT
??_C@_0P@PDEFNCOA@OnChangePKMode?$AA@ DB 'OnChangePKMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@FMCMFPCN@CPythonPlayer?3?3SetItemData?$CIwindo@
CONST	SEGMENT
??_C@_0GC@FMCMFPCN@CPythonPlayer?3?3SetItemData?$CIwindo@ DB 'CPythonPlay'
	DB	'er::SetItemData(window_type : %d, dwSlotIndex=%d, itemIndex=%'
	DB	'd) - Failed to item data', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HBNJHHEJ@CPythonPlayer?3?3SetStatus?5?9?5Set?5S@
CONST	SEGMENT
??_C@_0DC@HBNJHHEJ@CPythonPlayer?3?3SetStatus?5?9?5Set?5S@ DB 'CPythonPla'
	DB	'yer::SetStatus - Set Status Type Error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LHJHEHHP@CPythonPlayer?3?3GetStatus?5?9?5Get?5S@
CONST	SEGMENT
??_C@_0DC@LHJHEHHP@CPythonPlayer?3?3GetStatus?5?9?5Get?5S@ DB 'CPythonPla'
	DB	'yer::GetStatus - Get Status Type Error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OMJPBBKE@BINARY_Guild_EnterGuildArea?$AA@
CONST	SEGMENT
??_C@_0BM@OMJPBBKE@BINARY_Guild_EnterGuildArea?$AA@ DB 'BINARY_Guild_Ente'
	DB	'rGuildArea', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KCKDPCFN@BINARY_Guild_ExitGuildArea?$AA@
CONST	SEGMENT
??_C@_0BL@KCKDPCFN@BINARY_Guild_ExitGuildArea?$AA@ DB 'BINARY_Guild_ExitG'
	DB	'uildArea', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KCGJBOBB@RefreshStamina?$AA@
CONST	SEGMENT
??_C@_0P@KCGJBOBB@RefreshStamina?$AA@ DB 'RefreshStamina', 00H ; `string'
PUBLIC	?IsValidCell@SItemPos@@QAE_NXZ			; SItemPos::IsValidCell
PUBLIC	??_ECPythonPlayer@@W3AEPAXI@Z			; [thunk]:CPythonPlayer::`vector deleting destructor'
PUBLIC	??$?0V?$tuple@ABK@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBKK@std@@QAE@AAV?$tuple@ABK@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z ; std::pair<unsigned long const ,unsigned long>::pair<unsigned long const ,unsigned long><std::tuple<unsigned long const &>,std::tuple<>,0>
PUBLIC	??$?0ABK$$$V@?$pair@$$CBKK@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABK@1@V?$tuple@$$$V@1@@Z ; std::pair<unsigned long const ,unsigned long>::pair<unsigned long const ,unsigned long><unsigned long const &>
PUBLIC	??$?0KUSPartyMemberInfo@CPythonPlayer@@X@?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo><unsigned long,CPythonPlayer::SPartyMemberInfo,void>
PUBLIC	??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
PUBLIC	??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::construct<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
PUBLIC	??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > >
PUBLIC	??$_Buynode_if_nil@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PAU21@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Buynode_if_nil<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &>
PUBLIC	??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::max_size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::max_size
PUBLIC	??1?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@XZ ; std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>::~pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>
PUBLIC	??_G?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAEPAXI@Z ; std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>::`scalar deleting destructor'
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::construct<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::destroy<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
PUBLIC	??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::destroy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >
PUBLIC	??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &,bool,void>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool,void>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Insert_at<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
PUBLIC	??$forward@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YAAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &>
PUBLIC	??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator--
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator--
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator--
PUBLIC	?_Freenode0@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Freenode0
PUBLIC	?_Buynode0@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Buynode0
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Destroy_if_not_nil
PUBLIC	??0SPartyMemberInfo@CPythonPlayer@@QAE@ABU01@@Z	; CPythonPlayer::SPartyMemberInfo::SPartyMemberInfo
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &>
PUBLIC	??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >
PUBLIC	??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,unsigned int>
PUBLIC	??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > >
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_hint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
PUBLIC	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
PUBLIC	??$?0HHX@?$pair@HH@std@@QAE@$$QAH0@Z		; std::pair<int,int>::pair<int,int><int,int,void>
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Insert_nohint<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
PUBLIC	??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Buynode<std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
PUBLIC	??$forward@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YA$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z ; std::forward<std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
PUBLIC	??$?0AAKUSPartyMemberInfo@CPythonPlayer@@X@?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@AAK$$QAUSPartyMemberInfo@CPythonPlayer@@@Z ; std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo>::pair<unsigned long,CPythonPlayer::SPartyMemberInfo><unsigned long &,CPythonPlayer::SPartyMemberInfo,void>
PUBLIC	??$forward@USPartyMemberInfo@CPythonPlayer@@@std@@YA$$QAUSPartyMemberInfo@CPythonPlayer@@AAU12@@Z ; std::forward<CPythonPlayer::SPartyMemberInfo>
PUBLIC	??$_Move@AAUSQuickSlot@@@std@@YA$$QAUSQuickSlot@@AAU1@@Z ; std::_Move<SQuickSlot &>
PUBLIC	??$_Allocate@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
PUBLIC	??$_Kfn@$$CBKUSPartyMemberInfo@CPythonPlayer@@@?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0>::_Kfn<unsigned long const ,CPythonPlayer::SPartyMemberInfo>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@0@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &,void>
PUBLIC	??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >
PUBLIC	??$addressof@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YAPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z ; std::addressof<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >
PUBLIC	??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,unsigned int>
PUBLIC	??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
PUBLIC	??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QAH0@Z	; std::make_pair<int,int>
PUBLIC	??$insert@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::insert<std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
PUBLIC	??$make_pair@AAKUSPartyMemberInfo@CPythonPlayer@@@std@@YA?AU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@0@AAK$$QAUSPartyMemberInfo@CPythonPlayer@@@Z ; std::make_pair<unsigned long &,CPythonPlayer::SPartyMemberInfo>
PUBLIC	??$swap@USQuickSlot@@@std@@YAXAAUSQuickSlot@@0@Z ; std::swap<SQuickSlot>
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::allocate
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >
PUBLIC	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Buyheadnode
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >
PUBLIC	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Min
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Max
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Color
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >
PUBLIC	??0?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lrotate
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator++
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator++
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator*
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Myval
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Right
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Parent
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Left
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Isnil
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::deallocate
PUBLIC	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Getal
PUBLIC	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Freeheadnode
PUBLIC	??0?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEABKABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Kfn
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lbound
PUBLIC	?_Eqrange@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Eqrange
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@SAPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@AAU32@@Z ; std::pointer_traits<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> *>::pointer_to
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator++
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator*
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >
PUBLIC	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >
PUBLIC	??0?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >
PUBLIC	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Getcomp
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEABKPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Key
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Tidy
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Root
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Rmost
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lmost
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Erase
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::equal_range
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::lower_bound
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >
PUBLIC	??1?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAE@XZ ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::~_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >
PUBLIC	??1?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::~_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >
PUBLIC	??_G?$CSingleton@VCPythonPlayer@@@@UAEPAXI@Z	; CSingleton<CPythonPlayer>::`scalar deleting destructor'
PUBLIC	??_G?$TAbstractSingleton@VIAbstractPlayer@@@@UAEPAXI@Z ; TAbstractSingleton<IAbstractPlayer>::`scalar deleting destructor'
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator!=
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator==
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator++
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator->
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::find
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::clear
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAEIABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::end
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::begin
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >
PUBLIC	??0?$map@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >
PUBLIC	??1?$CSingleton@VCPythonPlayer@@@@UAE@XZ	; CSingleton<CPythonPlayer>::~CSingleton<CPythonPlayer>
PUBLIC	??0?$CSingleton@VCPythonPlayer@@@@QAE@XZ	; CSingleton<CPythonPlayer>::CSingleton<CPythonPlayer>
PUBLIC	??1?$TAbstractSingleton@VIAbstractPlayer@@@@UAE@XZ ; TAbstractSingleton<IAbstractPlayer>::~TAbstractSingleton<IAbstractPlayer>
PUBLIC	??0?$TAbstractSingleton@VIAbstractPlayer@@@@QAE@XZ ; TAbstractSingleton<IAbstractPlayer>::TAbstractSingleton<IAbstractPlayer>
PUBLIC	??A?$map@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEAAKABK@Z ; std::map<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::operator[]
PUBLIC	??1?$map@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::~map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >
PUBLIC	??_GCPythonPlayer@@UAEPAXI@Z			; CPythonPlayer::`scalar deleting destructor'
PUBLIC	?ClearSkillDict@CPythonPlayer@@QAEXXZ		; CPythonPlayer::ClearSkillDict
PUBLIC	?SetGameWindow@CPythonPlayer@@QAEXPAU_object@@@Z ; CPythonPlayer::SetGameWindow
PUBLIC	?HasMobilePhoneNumber@CPythonPlayer@@QAEHXZ	; CPythonPlayer::HasMobilePhoneNumber
PUBLIC	?SetMobileFlag@CPythonPlayer@@UAEXH@Z		; CPythonPlayer::SetMobileFlag
PUBLIC	?GetPKMode@CPythonPlayer@@QAEKXZ		; CPythonPlayer::GetPKMode
PUBLIC	?StopStaminaConsume@CPythonPlayer@@UAEXK@Z	; CPythonPlayer::StopStaminaConsume
PUBLIC	?StartStaminaConsume@CPythonPlayer@@UAEXKK@Z	; CPythonPlayer::StartStaminaConsume
PUBLIC	?__ToggleLevelLimit@CPythonPlayer@@QAEHXZ	; CPythonPlayer::__ToggleLevelLimit
PUBLIC	?__ToggleCoolTime@CPythonPlayer@@QAEHXZ		; CPythonPlayer::__ToggleCoolTime
PUBLIC	?SetObserverMode@CPythonPlayer@@UAEX_N@Z	; CPythonPlayer::SetObserverMode
PUBLIC	?IsOpenPrivateShop@CPythonPlayer@@QAE_NXZ	; CPythonPlayer::IsOpenPrivateShop
PUBLIC	?IsCantFightInstance@CPythonPlayer@@QAE_NK@Z	; CPythonPlayer::IsCantFightInstance
PUBLIC	?IsRevengeInstance@CPythonPlayer@@QAE_NK@Z	; CPythonPlayer::IsRevengeInstance
PUBLIC	?IsChallengeInstance@CPythonPlayer@@QAE_NK@Z	; CPythonPlayer::IsChallengeInstance
PUBLIC	?IsSamePartyMember@CPythonPlayer@@UAE_NKK@Z	; CPythonPlayer::IsSamePartyMember
PUBLIC	?PartyMemberVIDToPID@CPythonPlayer@@UAE_NKPAK@Z	; CPythonPlayer::PartyMemberVIDToPID
PUBLIC	?IsPartyMemberByName@CPythonPlayer@@QAE_NPBD@Z	; CPythonPlayer::IsPartyMemberByName
PUBLIC	?IsPartyMemberByVID@CPythonPlayer@@UAE_NK@Z	; CPythonPlayer::IsPartyMemberByVID
PUBLIC	?RemovePartyMember@CPythonPlayer@@QAEXK@Z	; CPythonPlayer::RemovePartyMember
PUBLIC	??1?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@XZ ; std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo>::~pair<unsigned long,CPythonPlayer::SPartyMemberInfo>
PUBLIC	??1SPartyMemberInfo@CPythonPlayer@@QAE@XZ	; CPythonPlayer::SPartyMemberInfo::~SPartyMemberInfo
PUBLIC	?ExitParty@CPythonPlayer@@QAEXXZ		; CPythonPlayer::ExitParty
PUBLIC	?AlarmHaveToGo@CPythonPlayer@@QAEXXZ		; CPythonPlayer::AlarmHaveToGo
PUBLIC	?__IsProcessingEmotion@CPythonPlayer@@IAEHXZ	; CPythonPlayer::__IsProcessingEmotion
PUBLIC	?EndEmotionProcess@CPythonPlayer@@UAEXXZ	; CPythonPlayer::EndEmotionProcess
PUBLIC	?StartEmotionProcess@CPythonPlayer@@UAEXXZ	; CPythonPlayer::StartEmotionProcess
PUBLIC	?ActEmotion@CPythonPlayer@@QAEXK@Z		; CPythonPlayer::ActEmotion
PUBLIC	?__SendClickActorPacket@CPythonPlayer@@IAEXAAVCInstanceBase@@@Z ; CPythonPlayer::__SendClickActorPacket
PUBLIC	?SendClickItemPacket@CPythonPlayer@@QAEXK@Z	; CPythonPlayer::SendClickItemPacket
PUBLIC	?GetPlayTime@CPythonPlayer@@QAEKXZ		; CPythonPlayer::GetPlayTime
PUBLIC	?SetPlayTime@CPythonPlayer@@QAEXK@Z		; CPythonPlayer::SetPlayTime
PUBLIC	?IsSkillActive@CPythonPlayer@@QAEHK@Z		; CPythonPlayer::IsSkillActive
PUBLIC	?IsSkillCoolTime@CPythonPlayer@@QAEHK@Z		; CPythonPlayer::IsSkillCoolTime
PUBLIC	?__DeactivateSkillSlot@CPythonPlayer@@IAEXK@Z	; CPythonPlayer::__DeactivateSkillSlot
PUBLIC	?__ActivateSkillSlot@CPythonPlayer@@IAEXK@Z	; CPythonPlayer::__ActivateSkillSlot
PUBLIC	?GetSkillElapsedCoolTime@CPythonPlayer@@QAEMK@Z	; CPythonPlayer::GetSkillElapsedCoolTime
PUBLIC	?GetSkillCoolTime@CPythonPlayer@@QAEMK@Z	; CPythonPlayer::GetSkillCoolTime
PUBLIC	?GetSkillNextEfficientPercentage@CPythonPlayer@@QAEMK@Z ; CPythonPlayer::GetSkillNextEfficientPercentage
PUBLIC	?GetSkillCurrentEfficientPercentage@CPythonPlayer@@QAEMK@Z ; CPythonPlayer::GetSkillCurrentEfficientPercentage
PUBLIC	?GetSkillLevel@CPythonPlayer@@QAEHK@Z		; CPythonPlayer::GetSkillLevel
PUBLIC	?GetSkillGrade@CPythonPlayer@@QAEHK@Z		; CPythonPlayer::GetSkillGrade
PUBLIC	?GetSkillIndex@CPythonPlayer@@QAEHK@Z		; CPythonPlayer::GetSkillIndex
PUBLIC	?IsEquipItemInSlot@CPythonPlayer@@UAE_NUSItemPos@@@Z ; CPythonPlayer::IsEquipItemInSlot
PUBLIC	?IsEquipmentSlot@CPythonPlayer@@QAE_NUSItemPos@@@Z ; CPythonPlayer::IsEquipmentSlot
PUBLIC	?MoveQuickSlot@CPythonPlayer@@UAEXHH@Z		; CPythonPlayer::MoveQuickSlot
PUBLIC	?DeleteQuickSlot@CPythonPlayer@@UAEXH@Z		; CPythonPlayer::DeleteQuickSlot
PUBLIC	?AddQuickSlot@CPythonPlayer@@UAEXHDD@Z		; CPythonPlayer::AddQuickSlot
PUBLIC	?RequestUseLocalQuickSlot@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::RequestUseLocalQuickSlot
PUBLIC	?RequestDeleteGlobalQuickSlot@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::RequestDeleteGlobalQuickSlot
PUBLIC	?RequestAddToEmptyLocalQuickSlot@CPythonPlayer@@QAEXKK@Z ; CPythonPlayer::RequestAddToEmptyLocalQuickSlot
PUBLIC	?RequestAddLocalQuickSlot@CPythonPlayer@@QAEXKKK@Z ; CPythonPlayer::RequestAddLocalQuickSlot
PUBLIC	?RequestMoveGlobalQuickSlotToLocalQuickSlot@CPythonPlayer@@QAEXKK@Z ; CPythonPlayer::RequestMoveGlobalQuickSlotToLocalQuickSlot
PUBLIC	?IsItem@CPythonPlayer@@QAEDUSItemPos@@@Z	; CPythonPlayer::IsItem
PUBLIC	?RemoveQuickSlotByValue@CPythonPlayer@@QAEXHH@Z	; CPythonPlayer::RemoveQuickSlotByValue
PUBLIC	?__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z ; CPythonPlayer::__RefGlobalQuickSlot
PUBLIC	?__RefLocalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z ; CPythonPlayer::__RefLocalQuickSlot
PUBLIC	?GetLocalQuickSlotData@CPythonPlayer@@QAEXKPAK0@Z ; CPythonPlayer::GetLocalQuickSlotData
PUBLIC	?GetGlobalQuickSlotData@CPythonPlayer@@QAEXKPAK0@Z ; CPythonPlayer::GetGlobalQuickSlotData
PUBLIC	?LocalQuickSlotIndexToGlobalQuickSlotIndex@CPythonPlayer@@QAEKK@Z ; CPythonPlayer::LocalQuickSlotIndexToGlobalQuickSlotIndex
PUBLIC	?SetQuickPage@CPythonPlayer@@QAEXH@Z		; CPythonPlayer::SetQuickPage
PUBLIC	?GetQuickPage@CPythonPlayer@@QAEHXZ		; CPythonPlayer::GetQuickPage
PUBLIC	?SetItemAttribute@CPythonPlayer@@UAEXUSItemPos@@KEF@Z ; CPythonPlayer::SetItemAttribute
PUBLIC	?SetItemMetinSocket@CPythonPlayer@@UAEXUSItemPos@@KK@Z ; CPythonPlayer::SetItemMetinSocket
PUBLIC	?SetItemCount@CPythonPlayer@@UAEXUSItemPos@@E@Z	; CPythonPlayer::SetItemCount
PUBLIC	?GetItemAttribute@CPythonPlayer@@QAEXUSItemPos@@KPAEPAF@Z ; CPythonPlayer::GetItemAttribute
PUBLIC	?GetItemMetinSocket@CPythonPlayer@@QAEKUSItemPos@@K@Z ; CPythonPlayer::GetItemMetinSocket
PUBLIC	?GetItemCountByVnum@CPythonPlayer@@QAEKK@Z	; CPythonPlayer::GetItemCountByVnum
PUBLIC	?GetItemCount@CPythonPlayer@@UAEKUSItemPos@@@Z	; CPythonPlayer::GetItemCount
PUBLIC	?GetItemFlags@CPythonPlayer@@UAEKUSItemPos@@@Z	; CPythonPlayer::GetItemFlags
PUBLIC	?GetItemIndex@CPythonPlayer@@UAEKUSItemPos@@@Z	; CPythonPlayer::GetItemIndex
PUBLIC	?SetItemData@CPythonPlayer@@UAEXUSItemPos@@ABUpacket_item@@@Z ; CPythonPlayer::SetItemData
PUBLIC	?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData
PUBLIC	?MoveItemData@CPythonPlayer@@QAEXUSItemPos@@0@Z	; CPythonPlayer::MoveItemData
PUBLIC	?NotifyChangePKMode@CPythonPlayer@@UAEXXZ	; CPythonPlayer::NotifyChangePKMode
PUBLIC	?NotifyCharacterUpdate@CPythonPlayer@@UAEXK@Z	; CPythonPlayer::NotifyCharacterUpdate
PUBLIC	?NotifyCharacterDead@CPythonPlayer@@UAEXK@Z	; CPythonPlayer::NotifyCharacterDead
PUBLIC	?NotifyDeletingCharacterInstance@CPythonPlayer@@UAEXK@Z ; CPythonPlayer::NotifyDeletingCharacterInstance
PUBLIC	?GetName@CPythonPlayer@@UAEPBDXZ		; CPythonPlayer::GetName
PUBLIC	?GetStatus@CPythonPlayer@@UAEHK@Z		; CPythonPlayer::GetStatus
PUBLIC	?__UpdateBattleStatus@CPythonPlayer@@IAEXXZ	; CPythonPlayer::__UpdateBattleStatus
PUBLIC	?__GetEvadeRate@CPythonPlayer@@IAEKXZ		; CPythonPlayer::__GetEvadeRate
PUBLIC	?__GetHitRate@CPythonPlayer@@IAEKXZ		; CPythonPlayer::__GetHitRate
PUBLIC	?__GetTotalAtk@CPythonPlayer@@IAEKKK@Z		; CPythonPlayer::__GetTotalAtk
PUBLIC	?__GetWeaponAtk@CPythonPlayer@@IAEKK@Z		; CPythonPlayer::__GetWeaponAtk
PUBLIC	?__GetStatAtk@CPythonPlayer@@IAEKXZ		; CPythonPlayer::__GetStatAtk
PUBLIC	?__GetLevelAtk@CPythonPlayer@@IAEKXZ		; CPythonPlayer::__GetLevelAtk
PUBLIC	?__GetRaceStat@CPythonPlayer@@IAEKXZ		; CPythonPlayer::__GetRaceStat
PUBLIC	?GetRace@CPythonPlayer@@QAEKXZ			; CPythonPlayer::GetRace
PUBLIC	?SetRace@CPythonPlayer@@UAEXK@Z			; CPythonPlayer::SetRace
PUBLIC	?SetWeaponPower@CPythonPlayer@@UAEXKKKKK@Z	; CPythonPlayer::SetWeaponPower
PUBLIC	?IsMainCharacterIndex@CPythonPlayer@@UAE_NK@Z	; CPythonPlayer::IsMainCharacterIndex
PUBLIC	?GetMainCharacterIndex@CPythonPlayer@@UAEKXZ	; CPythonPlayer::GetMainCharacterIndex
PUBLIC	?SetMainCharacterIndex@CPythonPlayer@@UAEXH@Z	; CPythonPlayer::SetMainCharacterIndex
PUBLIC	?__Update_NotifyGuildAreaEvent@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__Update_NotifyGuildAreaEvent
PUBLIC	?__Update_AutoAttack@CPythonPlayer@@IAEXXZ	; CPythonPlayer::__Update_AutoAttack
PUBLIC	?__IsUsingChargeSkill@CPythonPlayer@@IAE_NXZ	; CPythonPlayer::__IsUsingChargeSkill
PUBLIC	?NEW_GetMainActorPtr@CPythonPlayer@@UAEPAVCInstanceBase@@XZ ; CPythonPlayer::NEW_GetMainActorPtr
PUBLIC	?NEW_FindActorPtr@CPythonPlayer@@QAEPAVCInstanceBase@@K@Z ; CPythonPlayer::NEW_FindActorPtr
PUBLIC	?NEW_ShowEffect@CPythonPlayer@@IAEXHUD3DXVECTOR3@@@Z ; CPythonPlayer::NEW_ShowEffect
PUBLIC	?RegisterEffect@CPythonPlayer@@QAE_NKPBD_N@Z	; CPythonPlayer::RegisterEffect
PUBLIC	?__GetPickedGroundPos@CPythonPlayer@@IAE_NPAUD3DXVECTOR3@@@Z ; CPythonPlayer::__GetPickedGroundPos
PUBLIC	?__GetPickedItemID@CPythonPlayer@@IAE_NPAK@Z	; CPythonPlayer::__GetPickedItemID
PUBLIC	?__GetPickedActorID@CPythonPlayer@@IAE_NPAK@Z	; CPythonPlayer::__GetPickedActorID
PUBLIC	?__GetPickedActorPtr@CPythonPlayer@@IAE_NPAPAVCInstanceBase@@@Z ; CPythonPlayer::__GetPickedActorPtr
PUBLIC	?AffectIndexToSkillIndex@CPythonPlayer@@QAE_NKPAK@Z ; CPythonPlayer::AffectIndexToSkillIndex
PUBLIC	?GetPoint@SPlayerStatus@CPythonPlayer@@QAEJI@Z	; CPythonPlayer::SPlayerStatus::GetPoint
PUBLIC	?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z	; CPythonPlayer::SPlayerStatus::SetPoint
PUBLIC	??0SAutoPotionInfo@CPythonPlayer@@QAE@XZ	; CPythonPlayer::SAutoPotionInfo::SAutoPotionInfo
PUBLIC	??0SPartyMemberInfo@CPythonPlayer@@QAE@KPBD@Z	; CPythonPlayer::SPartyMemberInfo::SPartyMemberInfo
PUBLIC	??_GIAbstractPlayer@@UAEPAXI@Z			; IAbstractPlayer::`scalar deleting destructor'
PUBLIC	??1IAbstractPlayer@@UAE@XZ			; IAbstractPlayer::~IAbstractPlayer
PUBLIC	??0IAbstractPlayer@@QAE@XZ			; IAbstractPlayer::IAbstractPlayer
PUBLIC	?Clear@CPythonPlayer@@QAEXXZ			; CPythonPlayer::Clear
PUBLIC	?SetName@CPythonPlayer@@QAEXPBD@Z		; CPythonPlayer::SetName
PUBLIC	?RememberChallengeInstance@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::RememberChallengeInstance
PUBLIC	?RememberCantFightInstance@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::RememberCantFightInstance
PUBLIC	?RememberRevengeInstance@CPythonPlayer@@QAEXK@Z	; CPythonPlayer::RememberRevengeInstance
PUBLIC	?ForgetInstance@CPythonPlayer@@QAEXK@Z		; CPythonPlayer::ForgetInstance
PUBLIC	?SetStatus@CPythonPlayer@@QAEXKJ@Z		; CPythonPlayer::SetStatus
PUBLIC	?NotifyDeadMainCharacter@CPythonPlayer@@QAEXXZ	; CPythonPlayer::NotifyDeadMainCharacter
PUBLIC	?GetSkillSlotIndex@CPythonPlayer@@QAE_NKPAK@Z	; CPythonPlayer::GetSkillSlotIndex
PUBLIC	?SetSkillLevel@CPythonPlayer@@QAEXKK@Z		; CPythonPlayer::SetSkillLevel
PUBLIC	?SetSkill@CPythonPlayer@@QAEXKK@Z		; CPythonPlayer::SetSkill
PUBLIC	?SetSkillLevel_@CPythonPlayer@@QAEXKKK@Z	; CPythonPlayer::SetSkillLevel_
PUBLIC	?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z	; CPythonPlayer::AppendPartyMember
PUBLIC	?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
PUBLIC	?UpdatePartyMemberInfo@CPythonPlayer@@QAEXKEE@Z	; CPythonPlayer::UpdatePartyMemberInfo
PUBLIC	?UpdatePartyMemberAffect@CPythonPlayer@@QAEXKEF@Z ; CPythonPlayer::UpdatePartyMemberAffect
PUBLIC	?PartyMemberPIDToVID@CPythonPlayer@@QAE_NKPAK@Z	; CPythonPlayer::PartyMemberPIDToVID
PUBLIC	?LinkPartyMember@CPythonPlayer@@QAEXKK@Z	; CPythonPlayer::LinkPartyMember
PUBLIC	?UnlinkPartyMember@CPythonPlayer@@QAEXK@Z	; CPythonPlayer::UnlinkPartyMember
PUBLIC	?SetDungeonDestinationPosition@CPythonPlayer@@QAEXHH@Z ; CPythonPlayer::SetDungeonDestinationPosition
PUBLIC	?ClosePrivateShop@CPythonPlayer@@QAEXXZ		; CPythonPlayer::ClosePrivateShop
PUBLIC	?OpenPrivateShop@CPythonPlayer@@QAEXXZ		; CPythonPlayer::OpenPrivateShop
PUBLIC	?NEW_ClearSkillData@CPythonPlayer@@QAEX_N@Z	; CPythonPlayer::NEW_ClearSkillData
PUBLIC	??0CPythonPlayer@@QAE@XZ			; CPythonPlayer::CPythonPlayer
PUBLIC	??1CPythonPlayer@@UAE@XZ			; CPythonPlayer::~CPythonPlayer
PUBLIC	?NEW_GetMainActorPosition@CPythonPlayer@@QAEXPAUD3DXVECTOR3@@@Z ; CPythonPlayer::NEW_GetMainActorPosition
PUBLIC	?Update@CPythonPlayer@@QAEXXZ			; CPythonPlayer::Update
PUBLIC	?IsObserverMode@CPythonPlayer@@QAE_NXZ		; CPythonPlayer::IsObserverMode
EXTRN	??_EIAbstractPlayer@@UAEPAXI@Z:PROC		; IAbstractPlayer::`vector deleting destructor'
EXTRN	??_E?$TAbstractSingleton@VIAbstractPlayer@@@@UAEPAXI@Z:PROC ; TAbstractSingleton<IAbstractPlayer>::`vector deleting destructor'
EXTRN	??_ECPythonPlayer@@UAEPAXI@Z:PROC		; CPythonPlayer::`vector deleting destructor'
EXTRN	??_E?$CSingleton@VCPythonPlayer@@@@UAEPAXI@Z:PROC ; CSingleton<CPythonPlayer>::`vector deleting destructor'
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?s_kQuickSlot@?4??__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z@4U3@A
_BSS	SEGMENT
?s_kQuickSlot@?4??__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z@4U3@A DW 01H DUP (?) ; `CPythonPlayer::__RefGlobalQuickSlot'::`5'::s_kQuickSlot
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CPythonPlayer@@QAE@XZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??0CPythonPlayer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0CPythonPlayer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPythonPlayer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CPythonPlayer@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CPythonPlayer@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CPythonPlayer@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CPythonPlayer@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CPythonPlayer@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonPlayer@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CPythonPlayer@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CPythonPlayer@@QAE@XZ$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$2
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$4
__catchsym$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z$2
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z$2
__catchsym$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$0
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsObserverMode@CPythonPlayer@@QAE_NXZ
_TEXT	SEGMENT
?IsObserverMode@CPythonPlayer@@QAE_NXZ PROC		; CPythonPlayer::IsObserverMode, COMDAT
; _this$ = ecx

; 1502 : 	return m_isObserverMode;

  00000	8a 81 cd 09 01
	00		 mov	 al, BYTE PTR [ecx+68045]

; 1503 : }

  00006	c3		 ret	 0
?IsObserverMode@CPythonPlayer@@QAE_NXZ ENDP		; CPythonPlayer::IsObserverMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?Update@CPythonPlayer@@QAEXXZ
_TEXT	SEGMENT
_PixelPosition$1 = -16					; size = 12
_fElapsedTime$2 = -4					; size = 4
?Update@CPythonPlayer@@QAEXXZ PROC			; CPythonPlayer::Update, COMDAT
; _this$ = ecx

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 142  : 	NEW_RefreshMouseWalkingDirection();

  00009	e8 00 00 00 00	 call	 ?NEW_RefreshMouseWalkingDirection@CPythonPlayer@@IAEXXZ ; CPythonPlayer::NEW_RefreshMouseWalkingDirection

; 143  : 
; 144  : 	CPythonPlayerEventHandler& rkPlayerEventHandler=CPythonPlayerEventHandler::GetSingleton();

  0000e	e8 00 00 00 00	 call	 ?GetSingleton@CPythonPlayerEventHandler@@SAAAV1@XZ ; CPythonPlayerEventHandler::GetSingleton

; 145  : 	rkPlayerEventHandler.FlushVictimList();

  00013	8b c8		 mov	 ecx, eax
  00015	e8 00 00 00 00	 call	 ?FlushVictimList@CPythonPlayerEventHandler@@QAEXXZ ; CPythonPlayerEventHandler::FlushVictimList

; 146  : 
; 147  : 	if (m_isDestPosition)

  0001a	83 be 9c 09 01
	00 00		 cmp	 DWORD PTR [esi+67996], 0
  00021	74 72		 je	 SHORT $LN2@Update

; 148  : 	{
; 149  : 		CInstanceBase * pInstance = NEW_GetMainActorPtr();

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00029	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 150  : 		if (pInstance)

  0002f	85 c0		 test	 eax, eax
  00031	74 62		 je	 SHORT $LN2@Update

; 151  : 		{
; 152  : 			TPixelPosition PixelPosition;
; 153  : 			pInstance->NEW_GetPixelPosition(&PixelPosition);

  00033	8d 4d f0	 lea	 ecx, DWORD PTR _PixelPosition$1[ebp]
  00036	51		 push	 ecx
  00037	8b c8		 mov	 ecx, eax
  00039	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 154  : 
; 155  : 			if (abs(int(PixelPosition.x) - m_ixDestPos) + abs(int(PixelPosition.y) - m_iyDestPos) < 10000)

  0003e	f3 0f 2c 45 f4	 cvttss2si eax, DWORD PTR _PixelPosition$1[ebp+4]
  00043	2b 86 a4 09 01
	00		 sub	 eax, DWORD PTR [esi+68004]
  00049	99		 cdq
  0004a	8b c8		 mov	 ecx, eax
  0004c	f3 0f 2c 45 f0	 cvttss2si eax, DWORD PTR _PixelPosition$1[ebp]
  00051	33 ca		 xor	 ecx, edx
  00053	2b ca		 sub	 ecx, edx
  00055	2b 86 a0 09 01
	00		 sub	 eax, DWORD PTR [esi+68000]
  0005b	99		 cdq
  0005c	33 c2		 xor	 eax, edx
  0005e	2b c2		 sub	 eax, edx
  00060	03 c8		 add	 ecx, eax
  00062	81 f9 10 27 00
	00		 cmp	 ecx, 10000		; 00002710H
  00068	7d 0c		 jge	 SHORT $LN4@Update

; 156  : 			{
; 157  : 				m_isDestPosition = FALSE;

  0006a	c7 86 9c 09 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+67996], 0

; 158  : 			}
; 159  : 			else

  00074	eb 1f		 jmp	 SHORT $LN2@Update
$LN4@Update:

; 160  : 			{
; 161  : 				if (CTimer::Instance().GetCurrentMillisecond() - m_iLastAlarmTime > 20000)

  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  0007c	e8 00 00 00 00	 call	 ?GetCurrentMillisecond@CTimer@@QAEKXZ ; CTimer::GetCurrentMillisecond
  00081	2b 86 a8 09 01
	00		 sub	 eax, DWORD PTR [esi+68008]
  00087	3d 20 4e 00 00	 cmp	 eax, 20000		; 00004e20H
  0008c	76 07		 jbe	 SHORT $LN2@Update

; 162  : 				{
; 163  : 					AlarmHaveToGo();

  0008e	8b ce		 mov	 ecx, esi
  00090	e8 00 00 00 00	 call	 ?AlarmHaveToGo@CPythonPlayer@@QAEXXZ ; CPythonPlayer::AlarmHaveToGo
$LN2@Update:

; 164  : 				}
; 165  : 			}
; 166  : 		}
; 167  : 	}
; 168  : 
; 169  : 	if (m_isConsumingStamina)

  00095	83 be d0 09 01
	00 00		 cmp	 DWORD PTR [esi+68048], 0
  0009c	74 5d		 je	 SHORT $LN1@Update

; 170  : 	{
; 171  : 		float fElapsedTime = CTimer::Instance().GetElapsedSecond();

  0009e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  000a4	e8 00 00 00 00	 call	 ?GetElapsedSecond@CTimer@@QAEMXZ ; CTimer::GetElapsedSecond

; 172  : 		m_fCurrentStamina -= (fElapsedTime * m_fConsumeStaminaPerSec);

  000a9	f3 0f 10 8e d8
	09 01 00	 movss	 xmm1, DWORD PTR [esi+68056]
  000b1	f3 0f 10 86 d4
	09 01 00	 movss	 xmm0, DWORD PTR [esi+68052]
  000b9	d9 5d fc	 fstp	 DWORD PTR _fElapsedTime$2[ebp]
  000bc	f3 0f 59 4d fc	 mulss	 xmm1, DWORD PTR _fElapsedTime$2[ebp]
  000c1	f3 0f 5c c1	 subss	 xmm0, xmm1
  000c5	f3 0f 11 86 d4
	09 01 00	 movss	 DWORD PTR [esi+68052], xmm0

; 173  : 
; 174  : 		SetStatus(POINT_STAMINA, DWORD(m_fCurrentStamina));

  000cd	e8 00 00 00 00	 call	 __ftoui3
  000d2	50		 push	 eax
  000d3	6a 09		 push	 9
  000d5	8b ce		 mov	 ecx, esi
  000d7	e8 00 00 00 00	 call	 ?SetStatus@CPythonPlayer@@QAEXKJ@Z ; CPythonPlayer::SetStatus

; 175  : 
; 176  : 		PyCallClassMemberFunc(m_ppyGameWindow, "RefreshStamina", Py_BuildValue("()"));

  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000e7	83 c4 04	 add	 esp, 4
  000ea	50		 push	 eax
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KCGJBOBB@RefreshStamina?$AA@
  000f0	ff 76 08	 push	 DWORD PTR [esi+8]
  000f3	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000f8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Update:

; 177  : 	}
; 178  : 
; 179  : 	__Update_AutoAttack();

  000fb	8b ce		 mov	 ecx, esi
  000fd	e8 00 00 00 00	 call	 ?__Update_AutoAttack@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__Update_AutoAttack

; 180  : 	__Update_NotifyGuildAreaEvent();

  00102	8b ce		 mov	 ecx, esi
  00104	e8 00 00 00 00	 call	 ?__Update_NotifyGuildAreaEvent@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__Update_NotifyGuildAreaEvent

; 181  : }

  00109	5e		 pop	 esi
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
?Update@CPythonPlayer@@QAEXXZ ENDP			; CPythonPlayer::Update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?NEW_GetMainActorPosition@CPythonPlayer@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pkPPosActor$ = 8					; size = 4
?NEW_GetMainActorPosition@CPythonPlayer@@QAEXPAUD3DXVECTOR3@@@Z PROC ; CPythonPlayer::NEW_GetMainActorPosition, COMDAT
; _this$dead$ = ecx

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   : 	TPixelPosition kPPosMainActor;
; 90   : 
; 91   : 	IAbstractPlayer& rkPlayer=IAbstractPlayer::GetSingleton();

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton

; 92   : 	CInstanceBase * pInstance = rkPlayer.NEW_GetMainActorPtr();

  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 93   : 	if (pInstance)

  00011	85 c0		 test	 eax, eax
  00013	74 08		 je	 SHORT $LN2@NEW_GetMai

; 94   : 	{
; 95   : 		pInstance->NEW_GetPixelPosition(pkPPosActor);

  00015	8b c8		 mov	 ecx, eax

; 100  : 	}
; 101  : }

  00017	5d		 pop	 ebp

; 94   : 	{
; 95   : 		pInstance->NEW_GetPixelPosition(pkPPosActor);

  00018	e9 00 00 00 00	 jmp	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition
$LN2@NEW_GetMai:

; 96   : 	}
; 97   : 	else
; 98   : 	{
; 99   : 		CPythonApplication::Instance().GetCenterPosition(pkPPosActor);

  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance

; 100  : 	}
; 101  : }

  00023	5d		 pop	 ebp

; 96   : 	}
; 97   : 	else
; 98   : 	{
; 99   : 		CPythonApplication::Instance().GetCenterPosition(pkPPosActor);

  00024	e9 00 00 00 00	 jmp	 ?GetCenterPosition@CPythonApplication@@QAEXPAUD3DXVECTOR3@@@Z ; CPythonApplication::GetCenterPosition
?NEW_GetMainActorPosition@CPythonPlayer@@QAEXPAUD3DXVECTOR3@@@Z ENDP ; CPythonPlayer::NEW_GetMainActorPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ??1CPythonPlayer@@UAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
$T2 = -4						; size = 4
$T3 = -4						; size = 4
$T4 = -4						; size = 4
$T5 = -4						; size = 4
$T6 = -4						; size = 4
??1CPythonPlayer@@UAE@XZ PROC				; CPythonPlayer::~CPythonPlayer, COMDAT
; _this$ = ecx

; 1726 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CPythonPlayer@@6B?$CSingleton@VCPythonPlayer@@@@@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  0000e	8d 8f 44 0a 01
	00		 lea	 ecx, DWORD PTR [edi+68164]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1726 : {

  00014	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], OFFSET ??_7CPythonPlayer@@6BIAbstractPlayer@@@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  0001b	8b 87 44 0a 01
	00		 mov	 eax, DWORD PTR [edi+68164]
  00021	50		 push	 eax
  00022	ff 30		 push	 DWORD PTR [eax]
  00024	8d 45 fc	 lea	 eax, DWORD PTR $T6[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0002d	ff b7 44 0a 01
	00		 push	 DWORD PTR [edi+68164]
  00033	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

  00038	8b 87 c4 09 01
	00		 mov	 eax, DWORD PTR [edi+68036]

; 2230 : 		erase(begin(), end());

  0003e	8d 8f c4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68036]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00044	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00047	50		 push	 eax
  00048	ff 30		 push	 DWORD PTR [eax]
  0004a	8d 45 fc	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00053	ff b7 c4 09 01
	00		 push	 DWORD PTR [edi+68036]
  00059	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

  0005e	8b 87 bc 09 01
	00		 mov	 eax, DWORD PTR [edi+68028]

; 2230 : 		erase(begin(), end());

  00064	8d 8f bc 09 01
	00		 lea	 ecx, DWORD PTR [edi+68028]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0006a	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  0006d	50		 push	 eax
  0006e	ff 30		 push	 DWORD PTR [eax]
  00070	8d 45 fc	 lea	 eax, DWORD PTR $T4[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00079	ff b7 bc 09 01
	00		 push	 DWORD PTR [edi+68028]
  0007f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

  00084	8b 87 b4 09 01
	00		 mov	 eax, DWORD PTR [edi+68020]

; 2230 : 		erase(begin(), end());

  0008a	8d 8f b4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68020]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00090	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00093	50		 push	 eax
  00094	ff 30		 push	 DWORD PTR [eax]
  00096	8d 45 fc	 lea	 eax, DWORD PTR $T3[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0009f	ff b7 b4 09 01
	00		 push	 DWORD PTR [edi+68020]
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  000aa	8b 87 ac 09 01
	00		 mov	 eax, DWORD PTR [edi+68012]
  000b0	8d 8f ac 09 01
	00		 lea	 ecx, DWORD PTR [edi+68012]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000b6	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  000b9	50		 push	 eax
  000ba	ff 30		 push	 DWORD PTR [eax]
  000bc	8d 45 fc	 lea	 eax, DWORD PTR $T2[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000c5	ff b7 ac 09 01
	00		 push	 DWORD PTR [edi+68012]
  000cb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d0	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000d3	83 7f 28 10	 cmp	 DWORD PTR [edi+40], 16	; 00000010H
  000d7	72 0b		 jb	 SHORT $LN321@CPythonPla
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000d9	ff 77 14	 push	 DWORD PTR [edi+20]
  000dc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e1	83 c4 04	 add	 esp, 4
$LN321@CPythonPla:
  000e4	c7 47 28 0f 00
	00 00		 mov	 DWORD PTR [edi+40], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  000eb	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000ee	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000f5	c6 47 14 00	 mov	 BYTE PTR [edi+20], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  000f9	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000fc	50		 push	 eax
  000fd	ff 30		 push	 DWORD PTR [eax]
  000ff	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00108	ff 77 0c	 push	 DWORD PTR [edi+12]
  0010b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00110	83 c4 04	 add	 esp, 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h

; 17   : 	{ 

  00113	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], OFFSET ??_7?$TAbstractSingleton@VIAbstractPlayer@@@@6B@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 19   : 	{ 

  0011a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CSingleton@VCPythonPlayer@@@@6B@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h

; 19   : 		ms_singleton = 0; 

  00120	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A, 0 ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 21   : 		ms_singleton = 0; 

  0012a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A, 0 ; CSingleton<CPythonPlayer>::ms_singleton
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1727 : }

  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
??1CPythonPlayer@@UAE@XZ ENDP				; CPythonPlayer::~CPythonPlayer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractplayer.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ??0CPythonPlayer@@QAE@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 8
$T3 = -24						; size = 8
$T4 = -24						; size = 8
$T5 = -24						; size = 8
$T6 = -24						; size = 8
$T7 = -24						; size = 8
$T8 = -24						; size = 8
$T9 = -24						; size = 8
$T10 = -24						; size = 8
$T11 = -24						; size = 8
$T12 = -24						; size = 8
$T13 = -24						; size = 8
$T14 = -24						; size = 8
$T15 = -24						; size = 8
$T16 = -24						; size = 8
$T17 = -24						; size = 8
$T18 = -24						; size = 8
$T19 = -24						; size = 8
$T20 = -24						; size = 8
$T21 = -24						; size = 8
$T22 = -24						; size = 8
$T23 = -24						; size = 8
$T24 = -24						; size = 8
$T25 = -24						; size = 8
$T26 = -24						; size = 8
$T27 = -24						; size = 8
$T28 = -24						; size = 8
$T29 = -24						; size = 8
$T30 = -24						; size = 8
$T31 = -24						; size = 8
$T32 = -24						; size = 8
$T33 = -24						; size = 8
$T34 = -24						; size = 8
$T35 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CPythonPlayer@@QAE@XZ PROC				; CPythonPlayer::CPythonPlayer, COMDAT
; _this$ = ecx

; 1682 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CPythonPlayer@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  0002c	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A, edi ; CSingleton<CPythonPlayer>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1682 : {

  00032	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h

; 13   : 		ms_singleton = (T*) ((int) this + offset);

  0003c	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A, eax ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractplayer.h

; 10   : 		IAbstractPlayer() {}

  00041	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IAbstractPlayer@@6B@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1682 : {

  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  0004b	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1682 : {

  0004e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CPythonPlayer@@6B?$CSingleton@VCPythonPlayer@@@@@
  00054	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CPythonPlayer@@6BIAbstractPlayer@@@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  0005a	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 570  : 		this->_Mysize = 0;

  00061	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  00068	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > > >::_Buyheadnode
  0006d	89 47 0c	 mov	 DWORD PTR [edi+12], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00070	c7 47 28 0f 00
	00 00		 mov	 DWORD PTR [edi+40], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00077	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0007e	c6 47 14 00	 mov	 BYTE PTR [edi+20], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1682 : {

  00082	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00086	c7 87 ac 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68012], 0

; 570  : 		this->_Mysize = 0;

  00090	c7 87 b0 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68016], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  0009a	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Buyheadnode
  0009f	89 87 ac 09 01
	00		 mov	 DWORD PTR [edi+68012], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1682 : {

  000a5	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  000a9	8d 8f b4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68020]

; 569  : 		this->_Myhead = 0;

  000af	c7 87 b4 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68020], 0

; 570  : 		this->_Mysize = 0;

  000b9	c7 87 b8 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68024], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  000c3	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_Tree_node@KPAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<unsigned long,std::allocator<unsigned long> > >::_Buyheadnode
  000c8	89 87 b4 09 01
	00		 mov	 DWORD PTR [edi+68020], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1682 : {

  000ce	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  000d2	8d 8f bc 09 01
	00		 lea	 ecx, DWORD PTR [edi+68028]

; 569  : 		this->_Myhead = 0;

  000d8	c7 87 bc 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68028], 0

; 570  : 		this->_Mysize = 0;

  000e2	c7 87 c0 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68032], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  000ec	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_Tree_node@KPAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<unsigned long,std::allocator<unsigned long> > >::_Buyheadnode
  000f1	89 87 bc 09 01
	00		 mov	 DWORD PTR [edi+68028], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1682 : {

  000f7	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  000fb	8d 8f c4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68036]

; 569  : 		this->_Myhead = 0;

  00101	c7 87 c4 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68036], 0

; 570  : 		this->_Mysize = 0;

  0010b	c7 87 c8 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68040], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  00115	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_Tree_node@KPAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<unsigned long,std::allocator<unsigned long> > >::_Buyheadnode
  0011a	89 87 c4 09 01
	00		 mov	 DWORD PTR [edi+68036], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1682 : {

  00120	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00124	8d b7 44 0a 01
	00		 lea	 esi, DWORD PTR [edi+68164]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h

; 167  : 			SAutoPotionInfo() : bActivated(false), totalAmount(0), currentAmount(0) {}

  0012a	c6 87 20 0a 01
	00 00		 mov	 BYTE PTR [edi+68128], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  00131	8b ce		 mov	 ecx, esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h

; 167  : 			SAutoPotionInfo() : bActivated(false), totalAmount(0), currentAmount(0) {}

  00133	c7 87 24 0a 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68132], 0
  0013d	c7 87 28 0a 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68136], 0
  00147	c6 87 30 0a 01
	00 00		 mov	 BYTE PTR [edi+68144], 0
  0014e	c7 87 34 0a 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68148], 0
  00158	c7 87 38 0a 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68152], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00162	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00168	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  0016f	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > > >::_Buyheadnode
  00174	89 06		 mov	 DWORD PTR [esi], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1682 : {

  00176	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8

; 1683 : 	SetMovableGroundDistance(40.0f);

  0017a	8b cf		 mov	 ecx, edi
  0017c	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@42200000
  00184	e8 00 00 00 00	 call	 ?SetMovableGroundDistance@CPythonPlayer@@QAEXM@Z ; CPythonPlayer::SetMovableGroundDistance
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00189	8d 45 e8	 lea	 eax, DWORD PTR $T35[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0018c	c7 45 e8 0e 00
	00 00		 mov	 DWORD PTR $T35[ebp], 14	; 0000000eH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00193	50		 push	 eax
  00194	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00196	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR $T35[ebp+4], 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0019d	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  001a2	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  001a3	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  001a6	50		 push	 eax
  001a7	51		 push	 ecx
  001a8	8d 45 e8	 lea	 eax, DWORD PTR $T34[ebp]
  001ab	8b ce		 mov	 ecx, esi
  001ad	50		 push	 eax
  001ae	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  001b3	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T33[ebp], 15	; 0000000fH
  001ba	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR $T33[ebp+4], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  001c1	8d 45 e8	 lea	 eax, DWORD PTR $T33[ebp]
  001c4	8b ce		 mov	 ecx, esi
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  001cc	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  001cd	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  001d0	50		 push	 eax
  001d1	51		 push	 ecx
  001d2	8d 45 e8	 lea	 eax, DWORD PTR $T32[ebp]
  001d5	8b ce		 mov	 ecx, esi
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  001dd	8d 45 e8	 lea	 eax, DWORD PTR $T31[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  001e0	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR $T31[ebp], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  001e7	50		 push	 eax
  001e8	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  001ea	c7 45 ec 13 00
	00 00		 mov	 DWORD PTR $T31[ebp+4], 19 ; 00000013H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  001f1	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  001f6	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  001f7	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  001fa	50		 push	 eax
  001fb	51		 push	 ecx
  001fc	8d 45 e8	 lea	 eax, DWORD PTR $T30[ebp]
  001ff	8b ce		 mov	 ecx, esi
  00201	50		 push	 eax
  00202	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00207	8d 45 e8	 lea	 eax, DWORD PTR $T29[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0020a	c7 45 e8 11 00
	00 00		 mov	 DWORD PTR $T29[ebp], 17	; 00000011H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00211	50		 push	 eax
  00212	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00214	c7 45 ec 31 00
	00 00		 mov	 DWORD PTR $T29[ebp+4], 49 ; 00000031H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0021b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00220	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00221	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00224	50		 push	 eax
  00225	51		 push	 ecx
  00226	8d 45 e8	 lea	 eax, DWORD PTR $T28[ebp]
  00229	8b ce		 mov	 ecx, esi
  0022b	50		 push	 eax
  0022c	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00231	8d 45 e8	 lea	 eax, DWORD PTR $T27[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00234	c7 45 e8 12 00
	00 00		 mov	 DWORD PTR $T27[ebp], 18	; 00000012H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0023b	50		 push	 eax
  0023c	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0023e	c7 45 ec 22 00
	00 00		 mov	 DWORD PTR $T27[ebp+4], 34 ; 00000022H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00245	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0024a	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  0024b	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0024e	50		 push	 eax
  0024f	51		 push	 ecx
  00250	8d 45 e8	 lea	 eax, DWORD PTR $T26[ebp]
  00253	8b ce		 mov	 ecx, esi
  00255	50		 push	 eax
  00256	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0025b	8d 45 e8	 lea	 eax, DWORD PTR $T25[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0025e	c7 45 e8 14 00
	00 00		 mov	 DWORD PTR $T25[ebp], 20	; 00000014H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00265	50		 push	 eax
  00266	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00268	c7 45 ec 40 00
	00 00		 mov	 DWORD PTR $T25[ebp+4], 64 ; 00000040H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0026f	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00274	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00275	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00278	50		 push	 eax
  00279	51		 push	 ecx
  0027a	8d 45 e8	 lea	 eax, DWORD PTR $T24[ebp]
  0027d	8b ce		 mov	 ecx, esi
  0027f	50		 push	 eax
  00280	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00285	8d 45 e8	 lea	 eax, DWORD PTR $T23[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00288	c7 45 e8 15 00
	00 00		 mov	 DWORD PTR $T23[ebp], 21	; 00000015H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0028f	50		 push	 eax
  00290	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00292	c7 45 ec 41 00
	00 00		 mov	 DWORD PTR $T23[ebp+4], 65 ; 00000041H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00299	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0029e	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  0029f	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  002a2	50		 push	 eax
  002a3	51		 push	 ecx
  002a4	8d 45 e8	 lea	 eax, DWORD PTR $T22[ebp]
  002a7	8b ce		 mov	 ecx, esi
  002a9	50		 push	 eax
  002aa	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  002af	8d 45 e8	 lea	 eax, DWORD PTR $T21[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  002b2	c7 45 e8 16 00
	00 00		 mov	 DWORD PTR $T21[ebp], 22	; 00000016H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  002b9	50		 push	 eax
  002ba	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  002bc	c7 45 ec 5e 00
	00 00		 mov	 DWORD PTR $T21[ebp+4], 94 ; 0000005eH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  002c3	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  002c8	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  002c9	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  002cc	50		 push	 eax
  002cd	51		 push	 ecx
  002ce	8d 45 e8	 lea	 eax, DWORD PTR $T20[ebp]
  002d1	8b ce		 mov	 ecx, esi
  002d3	50		 push	 eax
  002d4	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  002d9	8d 45 e8	 lea	 eax, DWORD PTR $T19[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  002dc	c7 45 e8 17 00
	00 00		 mov	 DWORD PTR $T19[ebp], 23	; 00000017H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  002e3	50		 push	 eax
  002e4	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  002e6	c7 45 ec 5f 00
	00 00		 mov	 DWORD PTR $T19[ebp+4], 95 ; 0000005fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  002ed	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  002f2	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  002f3	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  002f6	50		 push	 eax
  002f7	51		 push	 ecx
  002f8	8d 45 e8	 lea	 eax, DWORD PTR $T18[ebp]
  002fb	8b ce		 mov	 ecx, esi
  002fd	50		 push	 eax
  002fe	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00303	8d 45 e8	 lea	 eax, DWORD PTR $T17[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00306	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR $T17[ebp], 24	; 00000018H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0030d	50		 push	 eax
  0030e	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00310	c7 45 ec 6e 00
	00 00		 mov	 DWORD PTR $T17[ebp+4], 110 ; 0000006eH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00317	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0031c	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  0031d	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00320	50		 push	 eax
  00321	51		 push	 ecx
  00322	8d 45 e8	 lea	 eax, DWORD PTR $T16[ebp]
  00325	8b ce		 mov	 ecx, esi
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0032d	8d 45 e8	 lea	 eax, DWORD PTR $T15[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00330	c7 45 e8 1d 00
	00 00		 mov	 DWORD PTR $T15[ebp], 29	; 0000001dH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00337	50		 push	 eax
  00338	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0033a	c7 45 ec 60 00
	00 00		 mov	 DWORD PTR $T15[ebp+4], 96 ; 00000060H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00341	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00346	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00347	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0034a	50		 push	 eax
  0034b	51		 push	 ecx
  0034c	8d 45 e8	 lea	 eax, DWORD PTR $T14[ebp]
  0034f	8b ce		 mov	 ecx, esi
  00351	50		 push	 eax
  00352	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00357	8d 45 e8	 lea	 eax, DWORD PTR $T13[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0035a	c7 45 e8 1e 00
	00 00		 mov	 DWORD PTR $T13[ebp], 30	; 0000001eH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00361	50		 push	 eax
  00362	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00364	c7 45 ec 6f 00
	00 00		 mov	 DWORD PTR $T13[ebp+4], 111 ; 0000006fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0036b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00370	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00371	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00374	50		 push	 eax
  00375	51		 push	 ecx
  00376	8d 45 e8	 lea	 eax, DWORD PTR $T12[ebp]
  00379	8b ce		 mov	 ecx, esi
  0037b	50		 push	 eax
  0037c	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00381	8d 45 e8	 lea	 eax, DWORD PTR $T11[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00384	c7 45 e8 20 00
	00 00		 mov	 DWORD PTR $T11[ebp], 32	; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0038b	50		 push	 eax
  0038c	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0038e	c7 45 ec 42 00
	00 00		 mov	 DWORD PTR $T11[ebp+4], 66 ; 00000042H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00395	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0039a	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  0039b	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0039e	50		 push	 eax
  0039f	51		 push	 ecx
  003a0	8d 45 e8	 lea	 eax, DWORD PTR $T10[ebp]
  003a3	8b ce		 mov	 ecx, esi
  003a5	50		 push	 eax
  003a6	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  003ab	8d 45 e8	 lea	 eax, DWORD PTR $T9[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  003ae	c7 45 e8 21 00
	00 00		 mov	 DWORD PTR $T9[ebp], 33	; 00000021H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  003b5	50		 push	 eax
  003b6	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  003b8	c7 45 ec 13 00
	00 00		 mov	 DWORD PTR $T9[ebp+4], 19 ; 00000013H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  003bf	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  003c4	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  003c5	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  003c8	50		 push	 eax
  003c9	51		 push	 ecx
  003ca	8d 45 e8	 lea	 eax, DWORD PTR $T8[ebp]
  003cd	8b ce		 mov	 ecx, esi
  003cf	50		 push	 eax
  003d0	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  003d5	8d 45 e8	 lea	 eax, DWORD PTR $T7[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  003d8	c7 45 e8 13 00
	00 00		 mov	 DWORD PTR $T7[ebp], 19	; 00000013H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  003df	50		 push	 eax
  003e0	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  003e2	c7 45 ec 3f 00
	00 00		 mov	 DWORD PTR $T7[ebp+4], 63 ; 0000003fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  003e9	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  003ee	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  003ef	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  003f2	50		 push	 eax
  003f3	51		 push	 ecx
  003f4	8d 45 e8	 lea	 eax, DWORD PTR $T6[ebp]
  003f7	8b ce		 mov	 ecx, esi
  003f9	50		 push	 eax
  003fa	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  003ff	8d 45 e8	 lea	 eax, DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00402	c7 45 e8 1a 00
	00 00		 mov	 DWORD PTR $T5[ebp], 26	; 0000001aH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00409	50		 push	 eax
  0040a	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0040c	c7 45 ec 4e 00
	00 00		 mov	 DWORD PTR $T5[ebp+4], 78 ; 0000004eH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00413	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00418	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00419	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0041c	50		 push	 eax
  0041d	51		 push	 ecx
  0041e	8d 45 e8	 lea	 eax, DWORD PTR $T4[ebp]
  00421	8b ce		 mov	 ecx, esi
  00423	50		 push	 eax
  00424	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00429	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0042c	c7 45 e8 19 00
	00 00		 mov	 DWORD PTR $T3[ebp], 25	; 00000019H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00433	50		 push	 eax
  00434	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00436	c7 45 ec 4f 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], 79 ; 0000004fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0043d	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HH@std@@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@$$QAU?$pair@HH@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::pair<int,int> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00442	50		 push	 eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00443	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00446	50		 push	 eax
  00447	51		 push	 ecx
  00448	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  0044b	8b ce		 mov	 ecx, esi
  0044d	50		 push	 eax
  0044e	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1705 : 	m_ppyGameWindow = NULL;

  00453	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1706 : 
; 1707 : 	m_sysIsCoolTime = TRUE;
; 1708 : 	m_sysIsLevelLimit = TRUE;
; 1709 : 	m_dwPlayTime = 0;
; 1710 : 
; 1711 : 	m_aeMBFButton[MBT_LEFT]=CPythonPlayer::MBF_SMART;
; 1712 : 	m_aeMBFButton[MBT_RIGHT]=CPythonPlayer::MBF_CAMERA;
; 1713 : 	m_aeMBFButton[MBT_MIDDLE]=CPythonPlayer::MBF_CAMERA;
; 1714 : 
; 1715 : 	memset(m_adwEffect, 0, sizeof(m_adwEffect));
; 1716 : 
; 1717 : 	m_isDestPosition = FALSE;
; 1718 : 	m_ixDestPos = 0;
; 1719 : 	m_iyDestPos = 0;
; 1720 : 	m_iLastAlarmTime = 0;
; 1721 : 
; 1722 : 	Clear();

  0045a	8b cf		 mov	 ecx, edi
  0045c	c7 87 e4 09 01
	00 01 00 00 00	 mov	 DWORD PTR [edi+68068], 1
  00466	c7 87 e8 09 01
	00 01 00 00 00	 mov	 DWORD PTR [edi+68072], 1
  00470	c7 87 1c 0a 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68124], 0
  0047a	c7 87 08 0a 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68104], 0
  00484	c7 87 0c 0a 01
	00 02 00 00 00	 mov	 DWORD PTR [edi+68108], 2
  0048e	c7 87 10 0a 01
	00 02 00 00 00	 mov	 DWORD PTR [edi+68112], 2
  00498	c7 87 fc 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68092], 0
  004a2	c7 87 9c 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+67996], 0
  004ac	c7 87 a0 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68000], 0
  004b6	c7 87 a4 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68004], 0
  004c0	c7 87 a8 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68008], 0
  004ca	e8 00 00 00 00	 call	 ?Clear@CPythonPlayer@@QAEXXZ ; CPythonPlayer::Clear

; 1723 : }

  004cf	8b c7		 mov	 eax, edi
  004d1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004db	59		 pop	 ecx
  004dc	5f		 pop	 edi
  004dd	5e		 pop	 esi
  004de	8b e5		 mov	 esp, ebp
  004e0	5d		 pop	 ebp
  004e1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CPythonPlayer@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCPythonPlayer@@@@UAE@XZ ; CSingleton<CPythonPlayer>::~CSingleton<CPythonPlayer>
__unwindfunclet$??0CPythonPlayer@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1IAbstractPlayer@@UAE@XZ ; IAbstractPlayer::~IAbstractPlayer
__unwindfunclet$??0CPythonPlayer@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$map@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CPythonPlayer@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonPlayer@@QAE@XZ$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	81 c1 ac 09 01
	00		 add	 ecx, 68012		; 000109acH
  00032	e9 00 00 00 00	 jmp	 ??1?$map@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@@std@@QAE@XZ
__unwindfunclet$??0CPythonPlayer@@QAE@XZ$5:
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 b4 09 01
	00		 add	 ecx, 68020		; 000109b4H
  00040	e9 00 00 00 00	 jmp	 ??1?$set@KU?$less@K@std@@V?$allocator@K@2@@std@@QAE@XZ
__unwindfunclet$??0CPythonPlayer@@QAE@XZ$6:
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	81 c1 bc 09 01
	00		 add	 ecx, 68028		; 000109bcH
  0004e	e9 00 00 00 00	 jmp	 ??1?$set@KU?$less@K@std@@V?$allocator@K@2@@std@@QAE@XZ
__unwindfunclet$??0CPythonPlayer@@QAE@XZ$7:
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	81 c1 c4 09 01
	00		 add	 ecx, 68036		; 000109c4H
  0005c	e9 00 00 00 00	 jmp	 ??1?$set@KU?$less@K@std@@V?$allocator@K@2@@std@@QAE@XZ
__unwindfunclet$??0CPythonPlayer@@QAE@XZ$8:
  00061	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	81 c1 44 0a 01
	00		 add	 ecx, 68164		; 00010a44H
  0006a	e9 00 00 00 00	 jmp	 ??1?$map@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAE@XZ
__ehhandler$??0CPythonPlayer@@QAE@XZ:
  0006f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00073	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00076	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00079	33 c8		 xor	 ecx, eax
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CPythonPlayer@@QAE@XZ
  00085	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CPythonPlayer@@QAE@XZ ENDP				; CPythonPlayer::CPythonPlayer
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?NEW_ClearSkillData@CPythonPlayer@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_bAll$ = 8						; size = 1
?NEW_ClearSkillData@CPythonPlayer@@QAEX_N@Z PROC	; CPythonPlayer::NEW_ClearSkillData, COMDAT
; _this$ = ecx

; 1562 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00009	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1565 : 	for (it = m_skillSlotDict.begin(); it != m_skillSlotDict.end();)

  0000c	8b 30		 mov	 esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  0000e	3b f0		 cmp	 esi, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1565 : 	for (it = m_skillSlotDict.begin(); it != m_skillSlotDict.end();)

  00010	74 6b		 je	 SHORT $LN11@NEW_ClearS
$LL12@NEW_ClearS:

; 1566 : 	{
; 1567 : 		if (bAll || __GetSkillType(it->first) == CPythonSkill::SKILL_TYPE_ACTIVE)

  00012	80 7d 08 00	 cmp	 BYTE PTR _bAll$[ebp], 0
  00016	75 51		 jne	 SHORT $LN9@NEW_ClearS
  00018	ff 76 10	 push	 DWORD PTR [esi+16]
  0001b	8b cf		 mov	 ecx, edi
  0001d	e8 00 00 00 00	 call	 ?__GetSkillType@CPythonPlayer@@IAEEK@Z ; CPythonPlayer::__GetSkillType
  00022	3c 01		 cmp	 al, 1
  00024	74 43		 je	 SHORT $LN9@NEW_ClearS
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00026	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002a	75 4c		 jne	 SHORT $LN67@NEW_ClearS

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0002f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00033	75 17		 jne	 SHORT $LN99@NEW_ClearS

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00035	8b f0		 mov	 esi, eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00037	8b 06		 mov	 eax, DWORD PTR [esi]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00039	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0003d	75 39		 jne	 SHORT $LN67@NEW_ClearS
  0003f	90		 npad	 1
$LL82@NEW_ClearS:

; 617  : 			_Pnode = _Left(_Pnode);

  00040	8b f0		 mov	 esi, eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00042	8b 06		 mov	 eax, DWORD PTR [esi]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00044	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00048	74 f6		 je	 SHORT $LL82@NEW_ClearS

; 65   : 		else

  0004a	eb 2c		 jmp	 SHORT $LN67@NEW_ClearS
$LN99@NEW_ClearS:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0004c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00053	75 10		 jne	 SHORT $LN116@NEW_ClearS
$LL66@NEW_ClearS:
  00055	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00058	75 0b		 jne	 SHORT $LN116@NEW_ClearS

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0005a	8b f0		 mov	 esi, eax
  0005c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00063	74 f0		 je	 SHORT $LL66@NEW_ClearS
$LN116@NEW_ClearS:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00065	8b f0		 mov	 esi, eax
  00067	eb 0f		 jmp	 SHORT $LN67@NEW_ClearS
$LN9@NEW_ClearS:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1568 : 			it = m_skillSlotDict.erase(it);

  00069	56		 push	 esi
  0006a	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0006d	50		 push	 eax
  0006e	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00071	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::erase
  00076	8b 30		 mov	 esi, DWORD PTR [eax]
$LN67@NEW_ClearS:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00078	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1565 : 	for (it = m_skillSlotDict.begin(); it != m_skillSlotDict.end();)

  0007b	75 95		 jne	 SHORT $LL12@NEW_ClearS
$LN11@NEW_ClearS:

; 1569 : 		else
; 1570 : 			++it;
; 1571 : 	}
; 1572 : 
; 1573 : 	for (int i = 0; i < SKILL_MAX_NUM; ++i)
; 1574 : 	{
; 1575 : 		ZeroMemory(&m_playerStatus.aSkill[i], sizeof(TSkillInstance));

  0007d	68 d8 27 00 00	 push	 10200			; 000027d8H
  00082	8d 87 90 dd 00
	00		 lea	 eax, DWORD PTR [edi+56720]
  00088	6a 00		 push	 0
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _memset
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1576 : 	}
; 1577 : 
; 1578 : 	for (int j = 0; j < SKILL_MAX_NUM; ++j)

  00093	8d 87 a0 dd 00
	00		 lea	 eax, DWORD PTR [edi+56736]
  00099	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  0009e	8b ff		 npad	 2
$LL4@NEW_ClearS:

; 1579 : 	{
; 1580 : 		// 2004.09.30.myevan.  [+]   
; 1581 : 		m_playerStatus.aSkill[j].iGrade = 0;

  000a0	c7 40 f8 00 00
	00 00		 mov	 DWORD PTR [eax-8], 0
  000a7	8d 40 28	 lea	 eax, DWORD PTR [eax+40]

; 1582 : 		m_playerStatus.aSkill[j].fcurEfficientPercentage=0.0f;

  000aa	c7 40 d8 00 00
	00 00		 mov	 DWORD PTR [eax-40], 0

; 1583 : 		m_playerStatus.aSkill[j].fnextEfficientPercentage=0.05f;

  000b1	c7 40 dc cd cc
	4c 3d		 mov	 DWORD PTR [eax-36], 1028443341 ; 3d4ccccdH
  000b8	49		 dec	 ecx
  000b9	75 e5		 jne	 SHORT $LL4@NEW_ClearS

; 1584 : 	}
; 1585 : 
; 1586 : 	if (m_ppyGameWindow)

  000bb	39 4f 08	 cmp	 DWORD PTR [edi+8], ecx
  000be	74 16		 je	 SHORT $LN1@NEW_ClearS

; 1587 : 		PyCallClassMemberFunc(m_ppyGameWindow, "BINARY_CheckGameButton", Py_BuildNone());

  000c0	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
  000c5	50		 push	 eax
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@PIKHDMAM@BINARY_CheckGameButton?$AA@
  000cb	ff 77 08	 push	 DWORD PTR [edi+8]
  000ce	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@NEW_ClearS:
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx

; 1588 : }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
?NEW_ClearSkillData@CPythonPlayer@@QAEX_N@Z ENDP	; CPythonPlayer::NEW_ClearSkillData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?OpenPrivateShop@CPythonPlayer@@QAEXXZ
_TEXT	SEGMENT
?OpenPrivateShop@CPythonPlayer@@QAEXXZ PROC		; CPythonPlayer::OpenPrivateShop, COMDAT
; _this$ = ecx

; 1483 : 	m_isOpenPrivateShop = TRUE;

  00000	c6 81 cc 09 01
	00 01		 mov	 BYTE PTR [ecx+68044], 1

; 1484 : }

  00007	c3		 ret	 0
?OpenPrivateShop@CPythonPlayer@@QAEXXZ ENDP		; CPythonPlayer::OpenPrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?ClosePrivateShop@CPythonPlayer@@QAEXXZ
_TEXT	SEGMENT
?ClosePrivateShop@CPythonPlayer@@QAEXXZ PROC		; CPythonPlayer::ClosePrivateShop, COMDAT
; _this$ = ecx

; 1487 : 	m_isOpenPrivateShop = FALSE;

  00000	c6 81 cc 09 01
	00 00		 mov	 BYTE PTR [ecx+68044], 0

; 1488 : }

  00007	c3		 ret	 0
?ClosePrivateShop@CPythonPlayer@@QAEXXZ ENDP		; CPythonPlayer::ClosePrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetDungeonDestinationPosition@CPythonPlayer@@QAEXHH@Z
_TEXT	SEGMENT
_ix$ = 8						; size = 4
_iy$ = 12						; size = 4
?SetDungeonDestinationPosition@CPythonPlayer@@QAEXHH@Z PROC ; CPythonPlayer::SetDungeonDestinationPosition, COMDAT
; _this$ = ecx

; 1252 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1253 : 	m_isDestPosition = TRUE;
; 1254 : 	m_ixDestPos = ix;

  00003	8b 45 08	 mov	 eax, DWORD PTR _ix$[ebp]
  00006	89 81 a0 09 01
	00		 mov	 DWORD PTR [ecx+68000], eax

; 1255 : 	m_iyDestPos = iy;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _iy$[ebp]
  0000f	c7 81 9c 09 01
	00 01 00 00 00	 mov	 DWORD PTR [ecx+67996], 1
  00019	89 81 a4 09 01
	00		 mov	 DWORD PTR [ecx+68004], eax

; 1256 : 
; 1257 : 	AlarmHaveToGo();

  0001f	e8 00 00 00 00	 call	 ?AlarmHaveToGo@CPythonPlayer@@QAEXXZ ; CPythonPlayer::AlarmHaveToGo

; 1258 : }

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?SetDungeonDestinationPosition@CPythonPlayer@@QAEXHH@Z ENDP ; CPythonPlayer::SetDungeonDestinationPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?UnlinkPartyMember@CPythonPlayer@@QAEXK@Z
_TEXT	SEGMENT
_pPartyMemberInfo$ = -4					; size = 4
_dwPID$ = 8						; size = 4
?UnlinkPartyMember@CPythonPlayer@@QAEXK@Z PROC		; CPythonPlayer::UnlinkPartyMember, COMDAT
; _this$ = ecx

; 1313 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1314 : 	TPartyMemberInfo * pPartyMemberInfo;
; 1315 : 	if (!GetPartyMemberPtr(dwPID, &pPartyMemberInfo))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00007	50		 push	 eax
  00008	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  0000b	e8 00 00 00 00	 call	 ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
  00010	84 c0		 test	 al, al
  00012	75 16		 jne	 SHORT $LN1@UnlinkPart

; 1316 : 	{
; 1317 : 		TraceError(" CPythonPlayer::UnlinkPartyMember(dwPID=%d) - Failed to find party member", dwPID);

  00014	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OICEDEOK@?5CPythonPlayer?3?3UnlinkPartyMembe@
  0001c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00021	83 c4 08	 add	 esp, 8

; 1322 : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN1@UnlinkPart:

; 1318 : 		return;
; 1319 : 	}
; 1320 : 
; 1321 : 	pPartyMemberInfo->dwVID = 0;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1322 : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?UnlinkPartyMember@CPythonPlayer@@QAEXK@Z ENDP		; CPythonPlayer::UnlinkPartyMember
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?LinkPartyMember@CPythonPlayer@@QAEXKK@Z
_TEXT	SEGMENT
_pPartyMemberInfo$ = -4					; size = 4
_dwPID$ = 8						; size = 4
_dwVID$ = 12						; size = 4
?LinkPartyMember@CPythonPlayer@@QAEXKK@Z PROC		; CPythonPlayer::LinkPartyMember, COMDAT
; _this$ = ecx

; 1297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1298 : 	TPartyMemberInfo * pPartyMemberInfo;
; 1299 : 	if (!GetPartyMemberPtr(dwPID, &pPartyMemberInfo))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00007	50		 push	 eax
  00008	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  0000b	e8 00 00 00 00	 call	 ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
  00010	84 c0		 test	 al, al
  00012	75 19		 jne	 SHORT $LN2@LinkPartyM

; 1300 : 	{
; 1301 : 		TraceError(" CPythonPlayer::LinkPartyMember(dwPID=%d, dwVID=%d) - Failed to find party member", dwPID, dwVID);

  00014	ff 75 0c	 push	 DWORD PTR _dwVID$[ebp]
  00017	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@JHEGNFED@?5CPythonPlayer?3?3LinkPartyMember?$CI@
  0001f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1310 : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
$LN2@LinkPartyM:

; 1302 : 		return;
; 1303 : 	}
; 1304 : 
; 1305 : 	pPartyMemberInfo->dwVID = dwVID;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _dwVID$[ebp]

; 1306 : 
; 1307 : 	CInstanceBase * pInstance = NEW_FindActorPtr(dwVID);

  00033	51		 push	 ecx
  00034	89 08		 mov	 DWORD PTR [eax], ecx
  00036	e8 00 00 00 00	 call	 ?NEW_FindActorPtr@CPythonPlayer@@QAEPAVCInstanceBase@@K@Z ; CPythonPlayer::NEW_FindActorPtr

; 1308 : 	if (pInstance)

  0003b	85 c0		 test	 eax, eax
  0003d	74 07		 je	 SHORT $LN1@LinkPartyM

; 1309 : 		pInstance->RefreshTextTail();

  0003f	8b c8		 mov	 ecx, eax
  00041	e8 00 00 00 00	 call	 ?RefreshTextTail@CInstanceBase@@QAEXXZ ; CInstanceBase::RefreshTextTail
$LN1@LinkPartyM:

; 1310 : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?LinkPartyMember@CPythonPlayer@@QAEXKK@Z ENDP		; CPythonPlayer::LinkPartyMember
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?PartyMemberPIDToVID@CPythonPlayer@@QAE_NKPAK@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
$T2 = 8							; size = 4
_dwPID$ = 8						; size = 4
_pdwVID$ = 12						; size = 4
?PartyMemberPIDToVID@CPythonPlayer@@QAE_NKPAK@Z PROC	; CPythonPlayer::PartyMemberPIDToVID, COMDAT
; _this$ = ecx

; 1413 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2109 : 		while (!this->_Isnil(_Pnode))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwPID$[ebp]
  00007	57		 push	 edi

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00008	8b b9 ac 09 01
	00		 mov	 edi, DWORD PTR [ecx+68012]

; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  0000e	8b d7		 mov	 edx, edi
  00010	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 2109 : 		while (!this->_Isnil(_Pnode))

  00013	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00017	75 1b		 jne	 SHORT $LN12@PartyMembe
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL13@PartyMembe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00020	39 70 10	 cmp	 DWORD PTR [eax+16], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00023	73 05		 jae	 SHORT $LN11@PartyMembe

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  00028	eb 04		 jmp	 SHORT $LN10@PartyMembe
$LN11@PartyMembe:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0002a	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN10@PartyMembe:

; 2109 : 		while (!this->_Isnil(_Pnode))

  0002e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00032	74 ec		 je	 SHORT $LL13@PartyMembe
$LN12@PartyMembe:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00034	3b d7		 cmp	 edx, edi

; 1553 : 					? end() : _Where);

  00036	74 08		 je	 SHORT $LN6@PartyMembe
  00038	89 55 08	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0003b	3b 72 10	 cmp	 esi, DWORD PTR [edx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  0003e	73 03		 jae	 SHORT $LN109@PartyMembe
$LN6@PartyMembe:

; 44   : 		{	// construct with node pointer _Pnode

  00040	89 7d 08	 mov	 DWORD PTR $T2[ebp], edi
$LN109@PartyMembe:

; 1553 : 					? end() : _Where);

  00043	8d 45 08	 lea	 eax, DWORD PTR $T2[ebp]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0004a	39 81 ac 09 01
	00		 cmp	 DWORD PTR [ecx+68012], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1416 : 	if (m_PartyMemberMap.end() == itor)

  00050	75 06		 jne	 SHORT $LN1@PartyMembe

; 1417 : 		return false;

  00052	32 c0		 xor	 al, al

; 1423 : }

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
$LN1@PartyMembe:

; 1418 : 
; 1419 : 	const TPartyMemberInfo & c_rPartyMemberInfo = itor->second;
; 1420 : 	*pdwVID = c_rPartyMemberInfo.dwVID;

  00058	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0005b	8b 45 0c	 mov	 eax, DWORD PTR _pdwVID$[ebp]
  0005e	89 08		 mov	 DWORD PTR [eax], ecx

; 1421 : 
; 1422 : 	return true;

  00060	b0 01		 mov	 al, 1

; 1423 : }

  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
?PartyMemberPIDToVID@CPythonPlayer@@QAE_NKPAK@Z ENDP	; CPythonPlayer::PartyMemberPIDToVID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?UpdatePartyMemberAffect@CPythonPlayer@@QAEXKEF@Z
_TEXT	SEGMENT
_dwPID$ = 8						; size = 4
_pPartyMemberInfo$ = 12					; size = 4
_byAffectSlotIndex$ = 12				; size = 1
_sAffectNumber$ = 16					; size = 2
?UpdatePartyMemberAffect@CPythonPlayer@@QAEXKEF@Z PROC	; CPythonPlayer::UpdatePartyMemberAffect, COMDAT
; _this$ = ecx

; 1338 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1339 : 	if (byAffectSlotIndex >= PARTY_AFFECT_SLOT_MAX_NUM)

  00004	8a 5d 0c	 mov	 bl, BYTE PTR _byAffectSlotIndex$[ebp]
  00007	80 fb 07	 cmp	 bl, 7
  0000a	72 1e		 jb	 SHORT $LN2@UpdatePart

; 1340 : 	{
; 1341 : 		TraceError(" CPythonPlayer::UpdatePartyMemberAffect(dwPID=%d, byAffectSlotIndex=%d, sAffectNumber=%d) - Strange affect slot index", dwPID, byAffectSlotIndex, sAffectNumber);

  0000c	8b 45 10	 mov	 eax, DWORD PTR _sAffectNumber$[ebp]
  0000f	98		 cwde
  00010	50		 push	 eax
  00011	0f b6 c3	 movzx	 eax, bl
  00014	50		 push	 eax
  00015	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0HG@LLGBHOIA@?5CPythonPlayer?3?3UpdatePartyMembe@
  0001d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	5b		 pop	 ebx

; 1353 : }

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
$LN2@UpdatePart:

; 1342 : 		return;
; 1343 : 	}
; 1344 : 
; 1345 : 	TPartyMemberInfo * pPartyMemberInfo;
; 1346 : 	if (!GetPartyMemberPtr(dwPID, &pPartyMemberInfo))

  0002a	8d 45 0c	 lea	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  0002d	50		 push	 eax
  0002e	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  00031	e8 00 00 00 00	 call	 ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
  00036	84 c0		 test	 al, al
  00038	75 1e		 jne	 SHORT $LN1@UpdatePart

; 1347 : 	{
; 1348 : 		TraceError(" CPythonPlayer::UpdatePartyMemberAffect(dwPID=%d, byAffectSlotIndex=%d, sAffectNumber=%d) - Failed to find character", dwPID, byAffectSlotIndex, sAffectNumber);

  0003a	8b 45 10	 mov	 eax, DWORD PTR _sAffectNumber$[ebp]
  0003d	98		 cwde
  0003e	50		 push	 eax
  0003f	0f b6 c3	 movzx	 eax, bl
  00042	50		 push	 eax
  00043	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0HF@NJGIGGLI@?5CPythonPlayer?3?3UpdatePartyMembe@
  0004b	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00050	83 c4 10	 add	 esp, 16			; 00000010H
  00053	5b		 pop	 ebx

; 1353 : }

  00054	5d		 pop	 ebp
  00055	c2 0c 00	 ret	 12			; 0000000cH
$LN1@UpdatePart:

; 1349 : 		return;
; 1350 : 	}
; 1351 : 
; 1352 : 	pPartyMemberInfo->sAffects[byAffectSlotIndex] = sAffectNumber;

  00058	8b 45 0c	 mov	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  0005b	66 8b 4d 10	 mov	 cx, WORD PTR _sAffectNumber$[ebp]
  0005f	0f b6 d3	 movzx	 edx, bl
  00062	5b		 pop	 ebx
  00063	66 89 4c 50 22	 mov	 WORD PTR [eax+edx*2+34], cx

; 1353 : }

  00068	5d		 pop	 ebp
  00069	c2 0c 00	 ret	 12			; 0000000cH
?UpdatePartyMemberAffect@CPythonPlayer@@QAEXKEF@Z ENDP	; CPythonPlayer::UpdatePartyMemberAffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?UpdatePartyMemberInfo@CPythonPlayer@@QAEXKEE@Z
_TEXT	SEGMENT
_pPartyMemberInfo$ = -4					; size = 4
_dwPID$ = 8						; size = 4
_byState$ = 12						; size = 1
_byHPPercentage$ = 16					; size = 1
?UpdatePartyMemberInfo@CPythonPlayer@@QAEXKEE@Z PROC	; CPythonPlayer::UpdatePartyMemberInfo, COMDAT
; _this$ = ecx

; 1325 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1326 : 	TPartyMemberInfo * pPartyMemberInfo;
; 1327 : 	if (!GetPartyMemberPtr(dwPID, &pPartyMemberInfo))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00007	50		 push	 eax
  00008	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  0000b	e8 00 00 00 00	 call	 ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
  00010	84 c0		 test	 al, al
  00012	75 24		 jne	 SHORT $LN1@UpdatePart

; 1328 : 	{
; 1329 : 		TraceError(" CPythonPlayer::UpdatePartyMemberInfo(dwPID=%d, byState=%d, byHPPercentage=%d) - Failed to find character", dwPID, byState, byHPPercentage);

  00014	8b 45 10	 mov	 eax, DWORD PTR _byHPPercentage$[ebp]
  00017	0f b6 c0	 movzx	 eax, al
  0001a	50		 push	 eax
  0001b	8b 45 0c	 mov	 eax, DWORD PTR _byState$[ebp]
  0001e	0f b6 c0	 movzx	 eax, al
  00021	50		 push	 eax
  00022	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@FIFNELKC@?5CPythonPlayer?3?3UpdatePartyMembe@
  0002a	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0002f	83 c4 10	 add	 esp, 16			; 00000010H

; 1335 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 0c 00	 ret	 12			; 0000000cH
$LN1@UpdatePart:

; 1330 : 		return;
; 1331 : 	}
; 1332 : 
; 1333 : 	pPartyMemberInfo->byState = byState;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _pPartyMemberInfo$[ebp]
  0003b	8a 45 0c	 mov	 al, BYTE PTR _byState$[ebp]
  0003e	88 41 20	 mov	 BYTE PTR [ecx+32], al

; 1334 : 	pPartyMemberInfo->byHPPercentage = byHPPercentage;

  00041	8a 45 10	 mov	 al, BYTE PTR _byHPPercentage$[ebp]
  00044	88 41 21	 mov	 BYTE PTR [ecx+33], al

; 1335 : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
?UpdatePartyMemberInfo@CPythonPlayer@@QAEXKEE@Z ENDP	; CPythonPlayer::UpdatePartyMemberInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
$T2 = 8							; size = 4
_dwPID$ = 8						; size = 4
_ppPartyMemberInfo$ = 12				; size = 4
?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z PROC ; CPythonPlayer::GetPartyMemberPtr, COMDAT
; _this$ = ecx

; 1401 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2109 : 		while (!this->_Isnil(_Pnode))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwPID$[ebp]
  00007	57		 push	 edi

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00008	8b b9 ac 09 01
	00		 mov	 edi, DWORD PTR [ecx+68012]

; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  0000e	8b d7		 mov	 edx, edi
  00010	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 2109 : 		while (!this->_Isnil(_Pnode))

  00013	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00017	75 1b		 jne	 SHORT $LN12@GetPartyMe
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL13@GetPartyMe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00020	39 70 10	 cmp	 DWORD PTR [eax+16], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00023	73 05		 jae	 SHORT $LN11@GetPartyMe

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  00028	eb 04		 jmp	 SHORT $LN10@GetPartyMe
$LN11@GetPartyMe:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0002a	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN10@GetPartyMe:

; 2109 : 		while (!this->_Isnil(_Pnode))

  0002e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00032	74 ec		 je	 SHORT $LL13@GetPartyMe
$LN12@GetPartyMe:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00034	3b d7		 cmp	 edx, edi

; 1553 : 					? end() : _Where);

  00036	74 08		 je	 SHORT $LN6@GetPartyMe
  00038	89 55 08	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0003b	3b 72 10	 cmp	 esi, DWORD PTR [edx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  0003e	73 03		 jae	 SHORT $LN109@GetPartyMe
$LN6@GetPartyMe:

; 44   : 		{	// construct with node pointer _Pnode

  00040	89 7d 08	 mov	 DWORD PTR $T2[ebp], edi
$LN109@GetPartyMe:

; 1553 : 					? end() : _Where);

  00043	8d 45 08	 lea	 eax, DWORD PTR $T2[ebp]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0004a	39 81 ac 09 01
	00		 cmp	 DWORD PTR [ecx+68012], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1404 : 	if (m_PartyMemberMap.end() == itor)

  00050	75 06		 jne	 SHORT $LN1@GetPartyMe

; 1405 : 		return false;

  00052	32 c0		 xor	 al, al

; 1410 : }

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
$LN1@GetPartyMe:

; 1406 : 
; 1407 : 	*ppPartyMemberInfo = &(itor->second);

  00058	8d 48 14	 lea	 ecx, DWORD PTR [eax+20]
  0005b	8b 45 0c	 mov	 eax, DWORD PTR _ppPartyMemberInfo$[ebp]
  0005e	89 08		 mov	 DWORD PTR [eax], ecx

; 1408 : 
; 1409 : 	return true;

  00060	b0 01		 mov	 al, 1

; 1410 : }

  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ENDP ; CPythonPlayer::GetPartyMemberPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z
_TEXT	SEGMENT
$T2 = -124						; size = 8
_dwPID$GSCopy$ = -120					; size = 4
$T3 = -116						; size = 52
$T4 = -64						; size = 48
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwPID$ = 8						; size = 4
_c_szName$ = 12						; size = 4
?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z PROC	; CPythonPlayer::AppendPartyMember, COMDAT
; _this$ = ecx

; 1292 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 70	 sub	 esp, 112		; 00000070H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx
  0002c	8b 55 0c	 mov	 edx, DWORD PTR _c_szName$[ebp]
  0002f	8b 45 08	 mov	 eax, DWORD PTR _dwPID$[ebp]
  00032	89 45 88	 mov	 DWORD PTR _dwPID$GSCopy$[ebp], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h

; 133  : 			SPartyMemberInfo(DWORD _dwPID, const char * c_szName) : dwPID(_dwPID), strName(c_szName), dwVID(0) {}

  00035	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0003c	80 3a 00	 cmp	 BYTE PTR [edx], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h

; 133  : 			SPartyMemberInfo(DWORD _dwPID, const char * c_szName) : dwPID(_dwPID), strName(c_szName), dwVID(0) {}

  0003f	89 45 c4	 mov	 DWORD PTR $T4[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00042	c7 45 dc 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+28], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00049	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00050	c6 45 c8 00	 mov	 BYTE PTR $T4[ebp+8], 0

; 523  : 			: _CSTD strlen(_First));

  00054	75 04		 jne	 SHORT $LN50@AppendPart
  00056	33 c0		 xor	 eax, eax
  00058	eb 0f		 jmp	 SHORT $LN51@AppendPart
$LN50@AppendPart:
  0005a	8b c2		 mov	 eax, edx
  0005c	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0005f	90		 npad	 1
$LL128@AppendPart:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 c9		 test	 cl, cl
  00065	75 f9		 jne	 SHORT $LL128@AppendPart
  00067	2b c6		 sub	 eax, esi
$LN51@AppendPart:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00069	50		 push	 eax
  0006a	52		 push	 edx
  0006b	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp+8]
  0006e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1293 : 	m_PartyMemberMap.insert(make_pair(dwPID, TPartyMemberInfo(dwPID, c_szName)));

  00073	8d 45 c0	 lea	 eax, DWORD PTR $T4[ebp]
  00076	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007d	50		 push	 eax
  0007e	8d 55 88	 lea	 edx, DWORD PTR _dwPID$GSCopy$[ebp]
  00081	8d 4d 8c	 lea	 ecx, DWORD PTR $T3[ebp]
  00084	e8 00 00 00 00	 call	 ??$make_pair@AAKUSPartyMemberInfo@CPythonPlayer@@@std@@YA?AU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@0@AAK$$QAUSPartyMemberInfo@CPythonPlayer@@@Z ; std::make_pair<unsigned long &,CPythonPlayer::SPartyMemberInfo>
  00089	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0008c	50		 push	 eax
  0008d	8d 8f ac 09 01
	00		 lea	 ecx, DWORD PTR [edi+68012]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1293 : 	m_PartyMemberMap.insert(make_pair(dwPID, TPartyMemberInfo(dwPID, c_szName)));

  00093	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00097	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Buynode<std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0009c	50		 push	 eax

; 604  : 		return ((reference)_Pnode->_Myval);

  0009d	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  000a0	50		 push	 eax
  000a1	51		 push	 ecx
  000a2	8d 45 84	 lea	 eax, DWORD PTR $T2[ebp]
  000a5	50		 push	 eax
  000a6	8d 8f ac 09 01
	00		 lea	 ecx, DWORD PTR [edi+68012]
  000ac	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Insert_nohint<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000b1	83 7d ac 10	 cmp	 DWORD PTR $T3[ebp+32], 16 ; 00000010H
  000b5	72 0b		 jb	 SHORT $LN82@AppendPart
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000b7	ff 75 98	 push	 DWORD PTR $T3[ebp+12]
  000ba	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000bf	83 c4 04	 add	 esp, 4
$LN82@AppendPart:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000c2	83 7d dc 10	 cmp	 DWORD PTR $T4[ebp+28], 16 ; 00000010H

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  000c6	c7 45 ac 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+32], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000cd	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000d4	c6 45 98 00	 mov	 BYTE PTR $T3[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000d8	72 0b		 jb	 SHORT $LN116@AppendPart
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000da	ff 75 c8	 push	 DWORD PTR $T4[ebp+8]
  000dd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e2	83 c4 04	 add	 esp, 4
$LN116@AppendPart:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1294 : }

  000e5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ef	59		 pop	 ecx
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f5	33 cd		 xor	 ecx, ebp
  000f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SPartyMemberInfo@CPythonPlayer@@QAE@XZ
__unwindfunclet$?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z$1:
  00008	8d 4d 8c	 lea	 ecx, DWORD PTR $T3[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@XZ
__ehhandler$?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AppendPartyMember@CPythonPlayer@@QAEXKPBD@Z ENDP	; CPythonPlayer::AppendPartyMember
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetSkillLevel_@CPythonPlayer@@QAEXKKK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = -4					; size = 4
_dwSkillIndex$ = 8					; size = 4
_dwSkillGrade$ = 12					; size = 4
_dwSkillLevel$ = 16					; size = 4
?SetSkillLevel_@CPythonPlayer@@QAEXKKK@Z PROC		; CPythonPlayer::SetSkillLevel_, COMDAT
; _this$ = ecx

; 990  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 991  : 	DWORD dwSlotIndex;
; 992  : 	if (!GetSkillSlotIndex(dwSkillIndex, &dwSlotIndex))

  00005	8d 45 fc	 lea	 eax, DWORD PTR _dwSlotIndex$[ebp]
  00008	8b f9		 mov	 edi, ecx
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR _dwSkillIndex$[ebp]
  0000e	e8 00 00 00 00	 call	 ?GetSkillSlotIndex@CPythonPlayer@@QAE_NKPAK@Z ; CPythonPlayer::GetSkillSlotIndex
  00013	84 c0		 test	 al, al
  00015	0f 84 f1 00 00
	00		 je	 $LN10@SetSkillLe

; 993  : 		return;
; 994  : 
; 995  : 	if (dwSlotIndex >= SKILL_MAX_NUM)

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _dwSlotIndex$[ebp]
  0001e	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00024	0f 83 e2 00 00
	00		 jae	 $LN10@SetSkillLe

; 996  : 		return;
; 997  : 
; 998  : 	switch (dwSkillGrade)

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _dwSkillGrade$[ebp]
  0002d	53		 push	 ebx
  0002e	8b 5d 10	 mov	 ebx, DWORD PTR _dwSkillLevel$[ebp]
  00031	83 f8 03	 cmp	 eax, 3
  00034	77 5c		 ja	 SHORT $LN6@SetSkillLe
  00036	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN15@SetSkillLe[eax*4]
$LN5@SetSkillLe:

; 999  : 	{
; 1000 : 		case 0:
; 1001 : 			m_playerStatus.aSkill[dwSlotIndex].iGrade = dwSkillGrade;

  0003d	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00040	c7 84 c7 98 dd
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax*8+56728], 0

; 1002 : 			m_playerStatus.aSkill[dwSlotIndex].iLevel = dwSkillLevel;

  0004b	89 9c c7 9c dd
	00 00		 mov	 DWORD PTR [edi+eax*8+56732], ebx

; 1003 : 			break;

  00052	eb 3e		 jmp	 SHORT $LN6@SetSkillLe
$LN4@SetSkillLe:

; 1004 : 		case 1:
; 1005 : 			m_playerStatus.aSkill[dwSlotIndex].iGrade = dwSkillGrade;

  00054	8d 0c 92	 lea	 ecx, DWORD PTR [edx+edx*4]
  00057	c7 84 cf 98 dd
	00 00 01 00 00
	00		 mov	 DWORD PTR [edi+ecx*8+56728], 1

; 1006 : 			m_playerStatus.aSkill[dwSlotIndex].iLevel = dwSkillLevel-20+1;

  00062	8d 43 ed	 lea	 eax, DWORD PTR [ebx-19]

; 1007 : 			break;

  00065	eb 24		 jmp	 SHORT $LN13@SetSkillLe
$LN3@SetSkillLe:

; 1008 : 		case 2:
; 1009 : 			m_playerStatus.aSkill[dwSlotIndex].iGrade = dwSkillGrade;

  00067	8d 0c 92	 lea	 ecx, DWORD PTR [edx+edx*4]
  0006a	c7 84 cf 98 dd
	00 00 02 00 00
	00		 mov	 DWORD PTR [edi+ecx*8+56728], 2

; 1010 : 			m_playerStatus.aSkill[dwSlotIndex].iLevel = dwSkillLevel-30+1;

  00075	8d 43 e3	 lea	 eax, DWORD PTR [ebx-29]

; 1011 : 			break;

  00078	eb 11		 jmp	 SHORT $LN13@SetSkillLe
$LN2@SetSkillLe:

; 1012 : 		case 3:
; 1013 : 			m_playerStatus.aSkill[dwSlotIndex].iGrade = dwSkillGrade;

  0007a	8d 0c 92	 lea	 ecx, DWORD PTR [edx+edx*4]
  0007d	c7 84 cf 98 dd
	00 00 03 00 00
	00		 mov	 DWORD PTR [edi+ecx*8+56728], 3

; 1014 : 			m_playerStatus.aSkill[dwSlotIndex].iLevel = dwSkillLevel-40+1;

  00088	8d 43 d9	 lea	 eax, DWORD PTR [ebx-39]
$LN13@SetSkillLe:
  0008b	89 84 cf 9c dd
	00 00		 mov	 DWORD PTR [edi+ecx*8+56732], eax
$LN6@SetSkillLe:

; 1015 : 			break;
; 1016 : 	}
; 1017 : 
; 1018 : 	const DWORD SKILL_MAX_LEVEL = 40;
; 1019 : 
; 1020 : 
; 1021 : 
; 1022 : 
; 1023 : 
; 1024 : 	if (dwSkillLevel>SKILL_MAX_LEVEL)

  00092	83 fb 28	 cmp	 ebx, 40			; 00000028H
  00095	76 30		 jbe	 SHORT $LN1@SetSkillLe

; 1025 : 	{
; 1026 : 		m_playerStatus.aSkill[dwSlotIndex].fcurEfficientPercentage = 0.0f;
; 1027 : 		m_playerStatus.aSkill[dwSlotIndex].fnextEfficientPercentage = 0.0f;
; 1028 : 
; 1029 : 		TraceError("CPythonPlayer::SetSkillLevel(SlotIndex=%d, SkillLevel=%d)", dwSlotIndex, dwSkillLevel);

  00097	53		 push	 ebx
  00098	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  0009b	52		 push	 edx
  0009c	c7 84 c7 a0 dd
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax*8+56736], 0
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@OJMDGNKA@CPythonPlayer?3?3SetSkillLevel?$CISlo@
  000ac	c7 84 c7 a4 dd
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax*8+56740], 0
  000b7	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	5b		 pop	 ebx
  000c0	5f		 pop	 edi

; 1035 : 
; 1036 : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
$LN1@SetSkillLe:
  000c7	56		 push	 esi

; 1030 : 		return;
; 1031 : 	}
; 1032 : 
; 1033 : 	m_playerStatus.aSkill[dwSlotIndex].fcurEfficientPercentage	= LocaleService_GetSkillPower(dwSkillLevel)/100.0f;

  000c8	8b cb		 mov	 ecx, ebx
  000ca	8d 34 92	 lea	 esi, DWORD PTR [edx+edx*4]
  000cd	e8 00 00 00 00	 call	 ?LocaleService_GetSkillPower@@YAHI@Z ; LocaleService_GetSkillPower

; 1034 : 	m_playerStatus.aSkill[dwSlotIndex].fnextEfficientPercentage = LocaleService_GetSkillPower(dwSkillLevel+1)/100.0f;

  000d2	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  000d5	66 0f 6e c0	 movd	 xmm0, eax
  000d9	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000dc	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  000e4	f3 0f 11 84 f7
	a0 dd 00 00	 movss	 DWORD PTR [edi+esi*8+56736], xmm0
  000ed	e8 00 00 00 00	 call	 ?LocaleService_GetSkillPower@@YAHI@Z ; LocaleService_GetSkillPower
  000f2	66 0f 6e c0	 movd	 xmm0, eax
  000f6	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000f9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00101	f3 0f 11 84 f7
	a4 dd 00 00	 movss	 DWORD PTR [edi+esi*8+56740], xmm0
  0010a	5e		 pop	 esi
  0010b	5b		 pop	 ebx
$LN10@SetSkillLe:
  0010c	5f		 pop	 edi

; 1035 : 
; 1036 : }

  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 0c 00	 ret	 12			; 0000000cH
  00113	90		 npad	 1
$LN15@SetSkillLe:
  00114	00 00 00 00	 DD	 $LN5@SetSkillLe
  00118	00 00 00 00	 DD	 $LN4@SetSkillLe
  0011c	00 00 00 00	 DD	 $LN3@SetSkillLe
  00120	00 00 00 00	 DD	 $LN2@SetSkillLe
?SetSkillLevel_@CPythonPlayer@@QAEXKKK@Z ENDP		; CPythonPlayer::SetSkillLevel_
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetSkill@CPythonPlayer@@QAEXKK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
_dwSkillIndex$ = 12					; size = 4
?SetSkill@CPythonPlayer@@QAEXKK@Z PROC			; CPythonPlayer::SetSkill, COMDAT
; _this$ = ecx

; 918  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 919  : 	if (dwSlotIndex >= SKILL_MAX_NUM)

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwSlotIndex$[ebp]
  00007	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  0000d	73 1b		 jae	 SHORT $LN2@SetSkill

; 920  : 		return;
; 921  : 
; 922  : 	m_playerStatus.aSkill[dwSlotIndex].dwIndex = dwSkillIndex;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR _dwSkillIndex$[ebp]
  00012	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  00015	89 84 d1 90 dd
	00 00		 mov	 DWORD PTR [ecx+edx*8+56720], eax

; 923  : 	m_skillSlotDict[dwSkillIndex] = dwSlotIndex;

  0001c	8d 45 0c	 lea	 eax, DWORD PTR _dwSkillIndex$[ebp]
  0001f	50		 push	 eax
  00020	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00023	e8 00 00 00 00	 call	 ??A?$map@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEAAKABK@Z ; std::map<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::operator[]
  00028	89 30		 mov	 DWORD PTR [eax], esi
$LN2@SetSkill:
  0002a	5e		 pop	 esi

; 924  : }

  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
?SetSkill@CPythonPlayer@@QAEXKK@Z ENDP			; CPythonPlayer::SetSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetSkillLevel@CPythonPlayer@@QAEXKK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
_dwSkillLevel$ = 12					; size = 4
?SetSkillLevel@CPythonPlayer@@QAEXKK@Z PROC		; CPythonPlayer::SetSkillLevel, COMDAT
; _this$ = ecx

; 980  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 981  : 	assert(!"CPythonPlayer::SetSkillLevel -   ");
; 982  : 	if (dwSlotIndex >= SKILL_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwSlotIndex$[ebp]
  00006	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0000b	73 19		 jae	 SHORT $LN2@SetSkillLe

; 983  : 		return;
; 984  : 
; 985  : 	m_playerStatus.aSkill[dwSlotIndex].iGrade = -1;

  0000d	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00010	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]

; 986  : 	m_playerStatus.aSkill[dwSlotIndex].iLevel = dwSkillLevel;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _dwSkillLevel$[ebp]
  00016	c7 81 98 dd 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+56728], -1
  00020	89 81 9c dd 00
	00		 mov	 DWORD PTR [ecx+56732], eax
$LN2@SetSkillLe:

; 987  : }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?SetSkillLevel@CPythonPlayer@@QAEXKK@Z ENDP		; CPythonPlayer::SetSkillLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetSkillSlotIndex@CPythonPlayer@@QAE_NKPAK@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
$T2 = 8							; size = 4
_dwSkillIndex$ = 8					; size = 4
_pdwSlotIndex$ = 12					; size = 4
?GetSkillSlotIndex@CPythonPlayer@@QAE_NKPAK@Z PROC	; CPythonPlayer::GetSkillSlotIndex, COMDAT
; _this$ = ecx

; 935  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2109 : 		while (!this->_Isnil(_Pnode))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwSkillIndex$[ebp]
  00007	57		 push	 edi

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00008	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]

; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  0000b	8b d7		 mov	 edx, edi
  0000d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 2109 : 		while (!this->_Isnil(_Pnode))

  00010	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00014	75 14		 jne	 SHORT $LN12@GetSkillSl
$LL13@GetSkillSl:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00016	39 70 10	 cmp	 DWORD PTR [eax+16], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00019	73 05		 jae	 SHORT $LN11@GetSkillSl

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0001b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001e	eb 04		 jmp	 SHORT $LN10@GetSkillSl
$LN11@GetSkillSl:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  00020	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00022	8b 00		 mov	 eax, DWORD PTR [eax]
$LN10@GetSkillSl:

; 2109 : 		while (!this->_Isnil(_Pnode))

  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 ec		 je	 SHORT $LL13@GetSkillSl
$LN12@GetSkillSl:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0002a	3b d7		 cmp	 edx, edi

; 1553 : 					? end() : _Where);

  0002c	74 08		 je	 SHORT $LN6@GetSkillSl
  0002e	89 55 08	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00031	3b 72 10	 cmp	 esi, DWORD PTR [edx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  00034	73 03		 jae	 SHORT $LN109@GetSkillSl
$LN6@GetSkillSl:

; 44   : 		{	// construct with node pointer _Pnode

  00036	89 7d 08	 mov	 DWORD PTR $T2[ebp], edi
$LN109@GetSkillSl:

; 1553 : 					? end() : _Where);

  00039	8d 45 08	 lea	 eax, DWORD PTR $T2[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00040	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 937  : 	if (m_skillSlotDict.end()==f)

  00043	75 06		 jne	 SHORT $LN1@GetSkillSl

; 938  : 	{
; 939  : 		return false;

  00045	32 c0		 xor	 al, al

; 945  : }

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
$LN1@GetSkillSl:

; 940  : 	}
; 941  : 
; 942  : 	*pdwSlotIndex=f->second;

  0004b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0004e	8b 45 0c	 mov	 eax, DWORD PTR _pdwSlotIndex$[ebp]
  00051	89 08		 mov	 DWORD PTR [eax], ecx

; 943  : 
; 944  : 	return true;

  00053	b0 01		 mov	 al, 1

; 945  : }

  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
?GetSkillSlotIndex@CPythonPlayer@@QAE_NKPAK@Z ENDP	; CPythonPlayer::GetSkillSlotIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?NotifyDeadMainCharacter@CPythonPlayer@@QAEXXZ
_TEXT	SEGMENT
?NotifyDeadMainCharacter@CPythonPlayer@@QAEXXZ PROC	; CPythonPlayer::NotifyDeadMainCharacter, COMDAT
; _this$ = ecx

; 523  : 	__ClearAutoAttackTargetActorID();

  00000	e9 00 00 00 00	 jmp	 ?__ClearAutoAttackTargetActorID@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__ClearAutoAttackTargetActorID
?NotifyDeadMainCharacter@CPythonPlayer@@QAEXXZ ENDP	; CPythonPlayer::NotifyDeadMainCharacter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetStatus@CPythonPlayer@@QAEXKJ@Z
_TEXT	SEGMENT
_dwType$ = 8						; size = 4
_lValue$ = 12						; size = 4
?SetStatus@CPythonPlayer@@QAEXKJ@Z PROC			; CPythonPlayer::SetStatus, COMDAT
; _this$ = ecx

; 427  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 428  : 	if (dwType >= POINT_MAX_NUM)

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwType$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  00010	72 13		 jb	 SHORT $LN7@SetStatus

; 429  : 	{
; 430  : 		assert(!" CPythonPlayer::SetStatus - Strange Status Type!");
; 431  : 		Tracef("CPythonPlayer::SetStatus - Set Status Type Error\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@HBNJHHEJ@CPythonPlayer?3?3SetStatus?5?9?5Set?5S@
  00017	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0001c	83 c4 04	 add	 esp, 4
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi

; 460  : 			break;
; 461  : 	}		
; 462  : }

  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
$LN7@SetStatus:
  00025	53		 push	 ebx

; 432  : 		return;
; 433  : 	}
; 434  : 
; 435  : 	if (dwType == POINT_LEVEL)

  00026	8b 5d 0c	 mov	 ebx, DWORD PTR _lValue$[ebp]
  00029	83 fe 01	 cmp	 esi, 1
  0002c	75 18		 jne	 SHORT $LN5@SetStatus

; 436  : 	{
; 437  : 		CInstanceBase* pkPlayer = NEW_GetMainActorPtr();

  0002e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00031	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00034	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 438  : 
; 439  : 		if (pkPlayer)

  0003a	85 c0		 test	 eax, eax
  0003c	74 08		 je	 SHORT $LN5@SetStatus

; 440  : 			pkPlayer->UpdateTextTailLevel(lValue);

  0003e	53		 push	 ebx
  0003f	8b c8		 mov	 ecx, eax
  00041	e8 00 00 00 00	 call	 ?UpdateTextTailLevel@CInstanceBase@@QAEXK@Z ; CInstanceBase::UpdateTextTailLevel
$LN5@SetStatus:

; 441  : 	}
; 442  : 
; 443  : 	switch (dwType)

  00046	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00049	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  0004e	77 26		 ja	 SHORT $LN1@SetStatus
  00050	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN10@SetStatus[eax]
  00057	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN13@SetStatus[eax*4]
$LN2@SetStatus:

; 444  : 	{
; 445  : 		case POINT_MIN_WEP:
; 446  : 		case POINT_MAX_WEP:
; 447  : 		case POINT_MIN_ATK:
; 448  : 		case POINT_MAX_ATK:
; 449  : 		case POINT_HIT_RATE:
; 450  : 		case POINT_EVADE_RATE:
; 451  : 		case POINT_LEVEL:
; 452  : 		case POINT_ST:
; 453  : 		case POINT_DX:
; 454  : 		case POINT_IQ:
; 455  : 			m_playerStatus.SetPoint(dwType, lValue);

  0005e	53		 push	 ebx
  0005f	56		 push	 esi
  00060	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  00063	e8 00 00 00 00	 call	 ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ; CPythonPlayer::SPlayerStatus::SetPoint

; 456  : 			__UpdateBattleStatus();

  00068	8b cf		 mov	 ecx, edi
  0006a	e8 00 00 00 00	 call	 ?__UpdateBattleStatus@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__UpdateBattleStatus
  0006f	5b		 pop	 ebx
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi

; 460  : 			break;
; 461  : 	}		
; 462  : }

  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
$LN1@SetStatus:

; 457  : 			break;
; 458  : 		default:
; 459  : 			m_playerStatus.SetPoint(dwType, lValue);

  00076	53		 push	 ebx
  00077	56		 push	 esi
  00078	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  0007b	e8 00 00 00 00	 call	 ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ; CPythonPlayer::SPlayerStatus::SetPoint
  00080	5b		 pop	 ebx
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi

; 460  : 			break;
; 461  : 	}		
; 462  : }

  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
  00087	90		 npad	 1
$LN13@SetStatus:
  00088	00 00 00 00	 DD	 $LN2@SetStatus
  0008c	00 00 00 00	 DD	 $LN1@SetStatus
$LN10@SetStatus:
  00090	00		 DB	 0
  00091	01		 DB	 1
  00092	01		 DB	 1
  00093	01		 DB	 1
  00094	01		 DB	 1
  00095	01		 DB	 1
  00096	01		 DB	 1
  00097	01		 DB	 1
  00098	01		 DB	 1
  00099	01		 DB	 1
  0009a	01		 DB	 1
  0009b	00		 DB	 0
  0009c	01		 DB	 1
  0009d	00		 DB	 0
  0009e	00		 DB	 0
  0009f	01		 DB	 1
  000a0	01		 DB	 1
  000a1	00		 DB	 0
  000a2	01		 DB	 1
  000a3	01		 DB	 1
  000a4	01		 DB	 1
  000a5	01		 DB	 1
  000a6	01		 DB	 1
  000a7	01		 DB	 1
  000a8	01		 DB	 1
  000a9	01		 DB	 1
  000aa	01		 DB	 1
  000ab	01		 DB	 1
  000ac	00		 DB	 0
  000ad	00		 DB	 0
  000ae	01		 DB	 1
  000af	01		 DB	 1
  000b0	01		 DB	 1
  000b1	01		 DB	 1
  000b2	01		 DB	 1
  000b3	01		 DB	 1
  000b4	01		 DB	 1
  000b5	01		 DB	 1
  000b6	01		 DB	 1
  000b7	01		 DB	 1
  000b8	01		 DB	 1
  000b9	01		 DB	 1
  000ba	01		 DB	 1
  000bb	01		 DB	 1
  000bc	01		 DB	 1
  000bd	01		 DB	 1
  000be	01		 DB	 1
  000bf	01		 DB	 1
  000c0	01		 DB	 1
  000c1	01		 DB	 1
  000c2	01		 DB	 1
  000c3	01		 DB	 1
  000c4	01		 DB	 1
  000c5	01		 DB	 1
  000c6	01		 DB	 1
  000c7	01		 DB	 1
  000c8	01		 DB	 1
  000c9	01		 DB	 1
  000ca	01		 DB	 1
  000cb	01		 DB	 1
  000cc	01		 DB	 1
  000cd	01		 DB	 1
  000ce	01		 DB	 1
  000cf	01		 DB	 1
  000d0	01		 DB	 1
  000d1	01		 DB	 1
  000d2	01		 DB	 1
  000d3	01		 DB	 1
  000d4	01		 DB	 1
  000d5	01		 DB	 1
  000d6	01		 DB	 1
  000d7	01		 DB	 1
  000d8	01		 DB	 1
  000d9	01		 DB	 1
  000da	01		 DB	 1
  000db	01		 DB	 1
  000dc	01		 DB	 1
  000dd	01		 DB	 1
  000de	01		 DB	 1
  000df	01		 DB	 1
  000e0	01		 DB	 1
  000e1	01		 DB	 1
  000e2	01		 DB	 1
  000e3	01		 DB	 1
  000e4	01		 DB	 1
  000e5	01		 DB	 1
  000e6	01		 DB	 1
  000e7	01		 DB	 1
  000e8	01		 DB	 1
  000e9	01		 DB	 1
  000ea	01		 DB	 1
  000eb	01		 DB	 1
  000ec	01		 DB	 1
  000ed	01		 DB	 1
  000ee	01		 DB	 1
  000ef	01		 DB	 1
  000f0	01		 DB	 1
  000f1	01		 DB	 1
  000f2	01		 DB	 1
  000f3	01		 DB	 1
  000f4	01		 DB	 1
  000f5	01		 DB	 1
  000f6	01		 DB	 1
  000f7	01		 DB	 1
  000f8	01		 DB	 1
  000f9	01		 DB	 1
  000fa	01		 DB	 1
  000fb	01		 DB	 1
  000fc	01		 DB	 1
  000fd	01		 DB	 1
  000fe	01		 DB	 1
  000ff	01		 DB	 1
  00100	01		 DB	 1
  00101	01		 DB	 1
  00102	01		 DB	 1
  00103	01		 DB	 1
  00104	01		 DB	 1
  00105	01		 DB	 1
  00106	01		 DB	 1
  00107	01		 DB	 1
  00108	01		 DB	 1
  00109	01		 DB	 1
  0010a	01		 DB	 1
  0010b	01		 DB	 1
  0010c	01		 DB	 1
  0010d	01		 DB	 1
  0010e	01		 DB	 1
  0010f	01		 DB	 1
  00110	01		 DB	 1
  00111	01		 DB	 1
  00112	01		 DB	 1
  00113	01		 DB	 1
  00114	01		 DB	 1
  00115	01		 DB	 1
  00116	01		 DB	 1
  00117	01		 DB	 1
  00118	01		 DB	 1
  00119	01		 DB	 1
  0011a	01		 DB	 1
  0011b	01		 DB	 1
  0011c	01		 DB	 1
  0011d	01		 DB	 1
  0011e	01		 DB	 1
  0011f	01		 DB	 1
  00120	01		 DB	 1
  00121	01		 DB	 1
  00122	01		 DB	 1
  00123	01		 DB	 1
  00124	01		 DB	 1
  00125	01		 DB	 1
  00126	01		 DB	 1
  00127	01		 DB	 1
  00128	01		 DB	 1
  00129	01		 DB	 1
  0012a	01		 DB	 1
  0012b	01		 DB	 1
  0012c	01		 DB	 1
  0012d	01		 DB	 1
  0012e	01		 DB	 1
  0012f	01		 DB	 1
  00130	01		 DB	 1
  00131	01		 DB	 1
  00132	01		 DB	 1
  00133	01		 DB	 1
  00134	01		 DB	 1
  00135	01		 DB	 1
  00136	01		 DB	 1
  00137	01		 DB	 1
  00138	01		 DB	 1
  00139	01		 DB	 1
  0013a	01		 DB	 1
  0013b	01		 DB	 1
  0013c	01		 DB	 1
  0013d	01		 DB	 1
  0013e	01		 DB	 1
  0013f	01		 DB	 1
  00140	01		 DB	 1
  00141	01		 DB	 1
  00142	01		 DB	 1
  00143	01		 DB	 1
  00144	01		 DB	 1
  00145	01		 DB	 1
  00146	01		 DB	 1
  00147	01		 DB	 1
  00148	01		 DB	 1
  00149	01		 DB	 1
  0014a	01		 DB	 1
  0014b	01		 DB	 1
  0014c	01		 DB	 1
  0014d	01		 DB	 1
  0014e	01		 DB	 1
  0014f	01		 DB	 1
  00150	01		 DB	 1
  00151	01		 DB	 1
  00152	01		 DB	 1
  00153	01		 DB	 1
  00154	01		 DB	 1
  00155	01		 DB	 1
  00156	01		 DB	 1
  00157	00		 DB	 0
  00158	00		 DB	 0
  00159	01		 DB	 1
  0015a	01		 DB	 1
  0015b	00		 DB	 0
?SetStatus@CPythonPlayer@@QAEXKJ@Z ENDP			; CPythonPlayer::SetStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?ForgetInstance@CPythonPlayer@@QAEXK@Z
_TEXT	SEGMENT
__Where$1 = -12						; size = 8
__Where$2 = -12						; size = 8
__Where$3 = -12						; size = 8
$T4 = -8						; size = 4
$T5 = -8						; size = 4
$T6 = 8							; size = 4
_dwVID$ = 8						; size = 4
?ForgetInstance@CPythonPlayer@@QAEXK@Z PROC		; CPythonPlayer::ForgetInstance, COMDAT
; _this$ = ecx

; 1462 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1595 : 		return (_Eqrange(_Keyval));

  0000a	8d 45 08	 lea	 eax, DWORD PTR _dwVID$[ebp]
  0000d	50		 push	 eax
  0000e	8d 45 f4	 lea	 eax, DWORD PTR __Where$3[ebp]
  00011	50		 push	 eax
  00012	8d 8f b4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68020]
  00018	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@std@@V12@@2@ABK@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::_Eqrange

; 1530 : 		erase(_Where.first, _Where.second);

  0001d	ff 75 f8	 push	 DWORD PTR __Where$3[ebp+4]
  00020	8d 45 f8	 lea	 eax, DWORD PTR $T5[ebp]
  00023	ff 75 f4	 push	 DWORD PTR __Where$3[ebp]
  00026	8d 8f b4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68020]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::erase

; 1595 : 		return (_Eqrange(_Keyval));

  00032	8d 45 08	 lea	 eax, DWORD PTR _dwVID$[ebp]
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __Where$2[ebp]
  00039	50		 push	 eax
  0003a	8d 8f bc 09 01
	00		 lea	 ecx, DWORD PTR [edi+68028]
  00040	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@std@@V12@@2@ABK@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::_Eqrange

; 1530 : 		erase(_Where.first, _Where.second);

  00045	ff 75 f8	 push	 DWORD PTR __Where$2[ebp+4]
  00048	8d 45 f8	 lea	 eax, DWORD PTR $T4[ebp]
  0004b	ff 75 f4	 push	 DWORD PTR __Where$2[ebp]
  0004e	8d 8f bc 09 01
	00		 lea	 ecx, DWORD PTR [edi+68028]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::erase

; 1595 : 		return (_Eqrange(_Keyval));

  0005a	8d 45 08	 lea	 eax, DWORD PTR _dwVID$[ebp]
  0005d	50		 push	 eax
  0005e	8d 45 f4	 lea	 eax, DWORD PTR __Where$1[ebp]
  00061	50		 push	 eax
  00062	8d 8f c4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68036]
  00068	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@std@@V12@@2@ABK@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::_Eqrange

; 1530 : 		erase(_Where.first, _Where.second);

  0006d	ff 75 f8	 push	 DWORD PTR __Where$1[ebp+4]
  00070	8d 45 08	 lea	 eax, DWORD PTR $T6[ebp]
  00073	ff 75 f4	 push	 DWORD PTR __Where$1[ebp]
  00076	8d 8f c4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68036]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::erase
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1466 : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
?ForgetInstance@CPythonPlayer@@QAEXK@Z ENDP		; CPythonPlayer::ForgetInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?RememberRevengeInstance@CPythonPlayer@@QAEXK@Z
_TEXT	SEGMENT
__Where$1 = -12						; size = 8
$T2 = -12						; size = 8
$T3 = -8						; size = 4
_dwVID$ = 8						; size = 4
?RememberRevengeInstance@CPythonPlayer@@QAEXK@Z PROC	; CPythonPlayer::RememberRevengeInstance, COMDAT
; _this$ = ecx

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1595 : 		return (_Eqrange(_Keyval));

  0000a	8d 45 08	 lea	 eax, DWORD PTR _dwVID$[ebp]
  0000d	50		 push	 eax
  0000e	8d 45 f4	 lea	 eax, DWORD PTR __Where$1[ebp]
  00011	50		 push	 eax
  00012	8d 8f b4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68020]
  00018	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@std@@V12@@2@ABK@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::_Eqrange

; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);

  0001d	ff 75 f8	 push	 DWORD PTR __Where$1[ebp+4]
  00020	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00023	ff 75 f4	 push	 DWORD PTR __Where$1[ebp]
  00026	8d 8f b4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68020]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::erase

; 1303 : 			_Val, _Nil_obj));

  00032	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR __Nil_obj
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1455 : 	m_RevengeInstanceSet.insert(dwVID);

  00039	8d 8f bc 09 01
	00		 lea	 ecx, DWORD PTR [edi+68028]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1303 : 			_Val, _Nil_obj));

  0003f	50		 push	 eax
  00040	8d 45 08	 lea	 eax, DWORD PTR _dwVID$[ebp]
  00043	50		 push	 eax
  00044	6a 00		 push	 0
  00046	8d 45 f4	 lea	 eax, DWORD PTR $T2[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??$_Insert_nohint@ABKU_Nil@std@@@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@std@@_N@1@_NABKU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::_Insert_nohint<unsigned long const &,std::_Nil>
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1456 : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?RememberRevengeInstance@CPythonPlayer@@QAEXK@Z ENDP	; CPythonPlayer::RememberRevengeInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?RememberCantFightInstance@CPythonPlayer@@QAEXK@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_dwVID$ = 8						; size = 4
?RememberCantFightInstance@CPythonPlayer@@QAEXK@Z PROC	; CPythonPlayer::RememberCantFightInstance, COMDAT
; _this$ = ecx

; 1458 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1303 : 			_Val, _Nil_obj));

  00003	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR __Nil_obj
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1458 : {

  0000a	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1459 : 	m_CantFightInstanceSet.insert(dwVID);

  0000d	81 c1 c4 09 01
	00		 add	 ecx, 68036		; 000109c4H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1303 : 			_Val, _Nil_obj));

  00013	50		 push	 eax
  00014	8d 45 08	 lea	 eax, DWORD PTR _dwVID$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Insert_nohint@ABKU_Nil@std@@@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@std@@_N@1@_NABKU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::_Insert_nohint<unsigned long const &,std::_Nil>
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1460 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?RememberCantFightInstance@CPythonPlayer@@QAEXK@Z ENDP	; CPythonPlayer::RememberCantFightInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?RememberChallengeInstance@CPythonPlayer@@QAEXK@Z
_TEXT	SEGMENT
__Where$1 = -12						; size = 8
$T2 = -12						; size = 8
$T3 = -8						; size = 4
_dwVID$ = 8						; size = 4
?RememberChallengeInstance@CPythonPlayer@@QAEXK@Z PROC	; CPythonPlayer::RememberChallengeInstance, COMDAT
; _this$ = ecx

; 1448 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1595 : 		return (_Eqrange(_Keyval));

  0000a	8d 45 08	 lea	 eax, DWORD PTR _dwVID$[ebp]
  0000d	50		 push	 eax
  0000e	8d 45 f4	 lea	 eax, DWORD PTR __Where$1[ebp]
  00011	50		 push	 eax
  00012	8d 8f bc 09 01
	00		 lea	 ecx, DWORD PTR [edi+68028]
  00018	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@std@@V12@@2@ABK@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::_Eqrange

; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);

  0001d	ff 75 f8	 push	 DWORD PTR __Where$1[ebp+4]
  00020	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00023	ff 75 f4	 push	 DWORD PTR __Where$1[ebp]
  00026	8d 8f bc 09 01
	00		 lea	 ecx, DWORD PTR [edi+68028]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::erase

; 1303 : 			_Val, _Nil_obj));

  00032	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR __Nil_obj
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1450 : 	m_ChallengeInstanceSet.insert(dwVID);

  00039	8d 8f b4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68020]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1303 : 			_Val, _Nil_obj));

  0003f	50		 push	 eax
  00040	8d 45 08	 lea	 eax, DWORD PTR _dwVID$[ebp]
  00043	50		 push	 eax
  00044	6a 00		 push	 0
  00046	8d 45 f4	 lea	 eax, DWORD PTR $T2[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??$_Insert_nohint@ABKU_Nil@std@@@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@K@std@@@std@@@std@@_N@1@_NABKU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::_Insert_nohint<unsigned long const &,std::_Nil>
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1451 : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?RememberChallengeInstance@CPythonPlayer@@QAEXK@Z ENDP	; CPythonPlayer::RememberChallengeInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetName@CPythonPlayer@@QAEXPBD@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
?SetName@CPythonPlayer@@QAEXPBD@Z PROC			; CPythonPlayer::SetName, COMDAT
; _this$ = ecx

; 482  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00004	8b 75 08	 mov	 esi, DWORD PTR _name$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN9@SetName
  0000c	33 d2		 xor	 edx, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 483  : 	m_stName = name;

  0000e	83 c1 14	 add	 ecx, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00011	52		 push	 edx
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00018	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 484  : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN9@SetName:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL11@SetName:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL11@SetName
  0002a	2b d7		 sub	 edx, edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 483  : 	m_stName = name;

  0002c	83 c1 14	 add	 ecx, 20			; 00000014H
  0002f	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00030	52		 push	 edx
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00037	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 484  : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?SetName@CPythonPlayer@@QAEXPBD@Z ENDP			; CPythonPlayer::SetName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?Clear@CPythonPlayer@@QAEXXZ
_TEXT	SEGMENT
$T1 = -20						; size = 12
$T2 = -20						; size = 12
$T3 = -8						; size = 8
?Clear@CPythonPlayer@@QAEXXZ PROC			; CPythonPlayer::Clear, COMDAT
; _this$ = ecx

; 1609 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 1610 : 	memset(&m_playerStatus, 0, sizeof(m_playerStatus));

  0000a	68 f8 08 01 00	 push	 67832			; 000108f8H
  0000f	6a 00		 push	 0
  00011	8d 47 70	 lea	 eax, DWORD PTR [edi+112]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1611 : 	NEW_ClearSkillData(true);

  0001d	8b cf		 mov	 ecx, edi
  0001f	6a 01		 push	 1
  00021	e8 00 00 00 00	 call	 ?NEW_ClearSkillData@CPythonPlayer@@QAEX_N@Z ; CPythonPlayer::NEW_ClearSkillData
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00026	6a 00		 push	 0
  00028	0f 57 c0	 xorps	 xmm0, xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1613 : 	m_bisProcessingEmotion = FALSE;

  0002b	c7 87 98 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+67992], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00035	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1619 : 	m_stName = "";

  0003a	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  0003d	c7 47 48 00 00
	00 00		 mov	 DWORD PTR [edi+72], 0
  00044	66 0f d6 45 f8	 movq	 QWORD PTR $T3[ebp], xmm0
  00049	c7 47 4c 00 00
	00 00		 mov	 DWORD PTR [edi+76], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00050	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1629 : 	m_MovingCursorPosition = TPixelPosition(0, 0, 0);

  00055	f3 0f 7e 4d f8	 movq	 xmm1, QWORD PTR $T3[ebp]

; 1661 : 
; 1662 : 	m_PartyMemberMap.clear();

  0005a	8d b7 ac 09 01
	00		 lea	 esi, DWORD PTR [edi+68012]
  00060	f3 0f 10 c1	 movss	 xmm0, xmm1
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00064	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+8], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1629 : 	m_MovingCursorPosition = TPixelPosition(0, 0, 0);

  0006b	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1540 : 		_Erase(_Root());

  0006e	8b ce		 mov	 ecx, esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1629 : 	m_MovingCursorPosition = TPixelPosition(0, 0, 0);

  00070	0f 14 c1	 unpcklps xmm0, xmm1
  00073	66 0f d6 87 ec
	09 01 00	 movq	 QWORD PTR [edi+68076], xmm0
  0007b	89 87 f4 09 01
	00		 mov	 DWORD PTR [edi+68084], eax

; 1634 : 	m_kPPosReserved = TPixelPosition(0, 0, 0);

  00081	0f 14 c9	 unpcklps xmm1, xmm1
  00084	66 0f d6 8f 8c
	09 01 00	 movq	 QWORD PTR [edi+67980], xmm1
  0008c	c7 47 2c 00 00
	00 00		 mov	 DWORD PTR [edi+44], 0
  00093	c7 47 30 00 00
	00 00		 mov	 DWORD PTR [edi+48], 0
  0009a	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
  000a1	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  000a8	c7 47 3c 00 00
	00 00		 mov	 DWORD PTR [edi+60], 0
  000af	c7 47 40 00 00
	00 00		 mov	 DWORD PTR [edi+64], 0
  000b6	c7 47 44 00 00
	00 00		 mov	 DWORD PTR [edi+68], 0
  000bd	c7 87 f8 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68088], 0
  000c7	c7 47 54 00 00
	00 00		 mov	 DWORD PTR [edi+84], 0
  000ce	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 182  :     z = fz;

  000d5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+8], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1634 : 	m_kPPosReserved = TPixelPosition(0, 0, 0);

  000dc	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp+8]
  000df	89 87 94 09 01
	00		 mov	 DWORD PTR [edi+67988], eax

; 1635 : 	m_dwVIDReserved = 0;

  000e5	c7 87 6c 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+67948], 0

; 1636 : 	m_dwIIDReserved = 0;

  000ef	c7 87 70 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+67952], 0

; 1637 : 	m_dwSkillSlotIndexReserved = 0;

  000f9	c7 87 78 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+67960], 0

; 1638 : 	m_dwSkillRangeReserved = 0;

  00103	c7 87 7c 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+67964], 0

; 1639 : 
; 1640 : 	m_isUp = false;

  0010d	c7 47 60 00 00
	00 00		 mov	 DWORD PTR [edi+96], 0

; 1641 : 	m_isDown = false;
; 1642 : 	m_isLeft = false;
; 1643 : 	m_isRight = false;
; 1644 : 	m_isSmtMov = false;

  00114	66 c7 47 67 00
	00		 mov	 WORD PTR [edi+103], 0

; 1645 : 	m_isDirMov = false;
; 1646 : 	m_isDirKey = false;
; 1647 : 	m_isAtkKey = false;

  0011a	66 c7 47 64 00
	00		 mov	 WORD PTR [edi+100], 0

; 1648 : 
; 1649 : 	m_isCmrRot = true;

  00120	c6 47 66 01	 mov	 BYTE PTR [edi+102], 1

; 1650 : 	m_fCmrRotSpd = 20.0f;

  00124	c7 47 6c 00 00
	a0 41		 mov	 DWORD PTR [edi+108], 1101004800 ; 41a00000H

; 1651 : 
; 1652 : 	m_iComboOld = 0;

  0012b	c7 87 68 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+67944], 0

; 1653 : 
; 1654 : 	m_dwVIDPicked=0;

  00135	c7 87 00 0a 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68096], 0

; 1655 : 	m_dwIIDPicked=0;

  0013f	c7 87 04 0a 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68100], 0

; 1656 : 
; 1657 : 	m_dwcurSkillSlotIndex = DWORD(-1);

  00149	c7 87 74 09 01
	00 ff ff ff ff	 mov	 DWORD PTR [edi+67956], -1

; 1658 : 
; 1659 : 	m_dwTargetVID = 0;

  00153	c7 87 14 0a 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68116], 0

; 1660 : 	m_dwTargetEndTime = 0;

  0015d	c7 87 18 0a 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68120], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1540 : 		_Erase(_Root());

  00167	8b 06		 mov	 eax, DWORD PTR [esi]
  00169	ff 70 04	 push	 DWORD PTR [eax+4]
  0016c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Erase

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00171	8b 06		 mov	 eax, DWORD PTR [esi]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1664 : 	m_ChallengeInstanceSet.clear();

  00173	8d 8f b4 09 01
	00		 lea	 ecx, DWORD PTR [edi+68020]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1541 : 		_Root() = this->_Myhead;

  00179	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1542 : 		_Lmost() = this->_Myhead;

  0017c	8b 06		 mov	 eax, DWORD PTR [esi]
  0017e	89 00		 mov	 DWORD PTR [eax], eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00180	8b 06		 mov	 eax, DWORD PTR [esi]

; 1543 : 		_Rmost() = this->_Myhead;

  00182	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1544 : 		this->_Mysize = 0;

  00185	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1664 : 	m_ChallengeInstanceSet.clear();

  0018c	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::clear

; 1665 : 	m_RevengeInstanceSet.clear();

  00191	8d 8f bc 09 01
	00		 lea	 ecx, DWORD PTR [edi+68028]
  00197	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tset_traits@KU?$less@K@std@@V?$allocator@K@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<unsigned long,std::less<unsigned long>,std::allocator<unsigned long>,0> >::clear

; 1666 : 
; 1667 : 	m_isOpenPrivateShop = false;

  0019c	66 c7 87 cc 09
	01 00 00 00	 mov	 WORD PTR [edi+68044], 0

; 1668 : 	m_isObserverMode = false;
; 1669 : 
; 1670 : 	m_isConsumingStamina = FALSE;
; 1671 : 	m_fConsumeStaminaPerSec = 0.0f;
; 1672 : 	m_fCurrentStamina = 0.0f;
; 1673 : 
; 1674 : 	m_inGuildAreaID = 0xffffffff;
; 1675 : 
; 1676 : 	m_bMobileFlag = FALSE;
; 1677 : 
; 1678 : 	__ClearAutoAttackTargetActorID();

  001a5	8b cf		 mov	 ecx, edi
  001a7	c7 87 d0 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68048], 0
  001b1	c7 87 d8 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68056], 0
  001bb	c7 87 d4 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68052], 0
  001c5	c7 87 dc 09 01
	00 ff ff ff ff	 mov	 DWORD PTR [edi+68060], -1
  001cf	c7 87 e0 09 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+68064], 0
  001d9	e8 00 00 00 00	 call	 ?__ClearAutoAttackTargetActorID@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__ClearAutoAttackTargetActorID
  001de	5f		 pop	 edi
  001df	5e		 pop	 esi

; 1679 : }

  001e0	8b e5		 mov	 esp, ebp
  001e2	5d		 pop	 ebp
  001e3	c3		 ret	 0
?Clear@CPythonPlayer@@QAEXXZ ENDP			; CPythonPlayer::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractplayer.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractplayer.h
;	COMDAT ??0IAbstractPlayer@@QAE@XZ
_TEXT	SEGMENT
??0IAbstractPlayer@@QAE@XZ PROC				; IAbstractPlayer::IAbstractPlayer, COMDAT
; _this$ = ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h

; 13   : 		ms_singleton = (T*) ((int) this + offset);

  00000	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A, ecx ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractplayer.h

; 10   : 		IAbstractPlayer() {}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IAbstractPlayer@@6B@
  0000e	c3		 ret	 0
??0IAbstractPlayer@@QAE@XZ ENDP				; IAbstractPlayer::IAbstractPlayer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractplayer.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractplayer.h
;	COMDAT ??1IAbstractPlayer@@UAE@XZ
_TEXT	SEGMENT
??1IAbstractPlayer@@UAE@XZ PROC				; IAbstractPlayer::~IAbstractPlayer, COMDAT
; _this$ = ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h

; 17   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$TAbstractSingleton@VIAbstractPlayer@@@@6B@

; 18   : 		assert(ms_singleton);
; 19   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A, 0 ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractplayer.h

; 11   : 		virtual ~IAbstractPlayer() {}

  00010	c3		 ret	 0
??1IAbstractPlayer@@UAE@XZ ENDP				; IAbstractPlayer::~IAbstractPlayer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
;	COMDAT ??_GIAbstractPlayer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GIAbstractPlayer@@UAEPAXI@Z PROC			; IAbstractPlayer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 19   : 		ms_singleton = 0; 

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A, 0 ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$TAbstractSingleton@VIAbstractPlayer@@@@6B@
  0001a	74 09		 je	 SHORT $LN8@scalar
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$LN8@scalar:
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GIAbstractPlayer@@UAEPAXI@Z ENDP			; IAbstractPlayer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
;	COMDAT ??0SPartyMemberInfo@CPythonPlayer@@QAE@KPBD@Z
_TEXT	SEGMENT
__dwPID$ = 8						; size = 4
_c_szName$ = 12						; size = 4
??0SPartyMemberInfo@CPythonPlayer@@QAE@KPBD@Z PROC	; CPythonPlayer::SPartyMemberInfo::SPartyMemberInfo, COMDAT
; _this$ = ecx

; 133  : 			SPartyMemberInfo(DWORD _dwPID, const char * c_szName) : dwPID(_dwPID), strName(c_szName), dwVID(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __dwPID$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _c_szName$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h

; 133  : 			SPartyMemberInfo(DWORD _dwPID, const char * c_szName) : dwPID(_dwPID), strName(c_szName), dwVID(0) {}

  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00013	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00016	c7 46 1c 0f 00
	00 00		 mov	 DWORD PTR [esi+28], 15	; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001d	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00024	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0

; 523  : 			: _CSTD strlen(_First));

  00028	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0002b	75 14		 jne	 SHORT $LN46@SPartyMemb
  0002d	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0002f	51		 push	 ecx
  00030	57		 push	 edi
  00031	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00034	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00039	5f		 pop	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h

; 133  : 			SPartyMemberInfo(DWORD _dwPID, const char * c_szName) : dwPID(_dwPID), strName(c_szName), dwVID(0) {}

  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN46@SPartyMemb:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00041	8b cf		 mov	 ecx, edi
  00043	53		 push	 ebx
  00044	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]
$LL48@SPartyMemb:
  00047	8a 01		 mov	 al, BYTE PTR [ecx]
  00049	41		 inc	 ecx
  0004a	84 c0		 test	 al, al
  0004c	75 f9		 jne	 SHORT $LL48@SPartyMemb
  0004e	2b cb		 sub	 ecx, ebx
  00050	5b		 pop	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00051	51		 push	 ecx
  00052	57		 push	 edi
  00053	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00056	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0005b	5f		 pop	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h

; 133  : 			SPartyMemberInfo(DWORD _dwPID, const char * c_szName) : dwPID(_dwPID), strName(c_szName), dwVID(0) {}

  0005c	8b c6		 mov	 eax, esi
  0005e	5e		 pop	 esi
  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
??0SPartyMemberInfo@CPythonPlayer@@QAE@KPBD@Z ENDP	; CPythonPlayer::SPartyMemberInfo::SPartyMemberInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.h
;	COMDAT ??0SAutoPotionInfo@CPythonPlayer@@QAE@XZ
_TEXT	SEGMENT
??0SAutoPotionInfo@CPythonPlayer@@QAE@XZ PROC		; CPythonPlayer::SAutoPotionInfo::SAutoPotionInfo, COMDAT
; _this$ = ecx

; 167  : 			SAutoPotionInfo() : bActivated(false), totalAmount(0), currentAmount(0) {}

  00000	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00003	8b c1		 mov	 eax, ecx
  00005	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000c	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00013	c3		 ret	 0
??0SAutoPotionInfo@CPythonPlayer@@QAE@XZ ENDP		; CPythonPlayer::SAutoPotionInfo::SAutoPotionInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z
_TEXT	SEGMENT
_ePoint$ = 8						; size = 4
_lPoint$ = 12						; size = 4
?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z PROC	; CPythonPlayer::SPlayerStatus::SetPoint, COMDAT
; _this$ = ecx

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 26   : 	m_alPoint[ePoint]=lPoint ^ POINT_MAGIC_NUMBER;

  00003	8b 45 08	 mov	 eax, DWORD PTR _ePoint$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _lPoint$[ebp]
  00009	81 f2 da c1 3a
	e7		 xor	 edx, -415579686		; e73ac1daH
  0000f	89 94 81 f8 04
	01 00		 mov	 DWORD PTR [ecx+eax*4+66808], edx

; 27   : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ENDP	; CPythonPlayer::SPlayerStatus::SetPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetPoint@SPlayerStatus@CPythonPlayer@@QAEJI@Z
_TEXT	SEGMENT
_ePoint$ = 8						; size = 4
?GetPoint@SPlayerStatus@CPythonPlayer@@QAEJI@Z PROC	; CPythonPlayer::SPlayerStatus::GetPoint, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	return m_alPoint[ePoint] ^ POINT_MAGIC_NUMBER;

  00003	8b 45 08	 mov	 eax, DWORD PTR _ePoint$[ebp]
  00006	8b 84 81 f8 04
	01 00		 mov	 eax, DWORD PTR [ecx+eax*4+66808]
  0000d	35 da c1 3a e7	 xor	 eax, -415579686		; e73ac1daH

; 32   : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?GetPoint@SPlayerStatus@CPythonPlayer@@QAEJI@Z ENDP	; CPythonPlayer::SPlayerStatus::GetPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?AffectIndexToSkillIndex@CPythonPlayer@@QAE_NKPAK@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
$T2 = -4						; size = 4
_dwAffectIndex$ = 8					; size = 4
_pdwSkillIndex$ = 12					; size = 4
?AffectIndexToSkillIndex@CPythonPlayer@@QAE_NKPAK@Z PROC ; CPythonPlayer::AffectIndexToSkillIndex, COMDAT
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2109 : 		while (!this->_Isnil(_Pnode))

  00004	8b 55 08	 mov	 edx, DWORD PTR _dwAffectIndex$[ebp]
  00007	56		 push	 esi

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00008	8b b1 44 0a 01
	00		 mov	 esi, DWORD PTR [ecx+68164]
  0000e	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 36   : 	if (m_kMap_dwAffectIndexToSkillIndex.end() == m_kMap_dwAffectIndexToSkillIndex.find(dwAffectIndex))

  0000f	8d b9 44 0a 01
	00		 lea	 edi, DWORD PTR [ecx+68164]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00015	8b ce		 mov	 ecx, esi
  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 2109 : 		while (!this->_Isnil(_Pnode))

  0001a	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001e	75 14		 jne	 SHORT $LN12@AffectInde
$LL13@AffectInde:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00020	39 50 10	 cmp	 DWORD PTR [eax+16], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00023	73 05		 jae	 SHORT $LN11@AffectInde

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  00028	eb 04		 jmp	 SHORT $LN10@AffectInde
$LN11@AffectInde:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0002a	8b c8		 mov	 ecx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN10@AffectInde:

; 2109 : 		while (!this->_Isnil(_Pnode))

  0002e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00032	74 ec		 je	 SHORT $LL13@AffectInde
$LN12@AffectInde:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00034	3b ce		 cmp	 ecx, esi

; 1553 : 					? end() : _Where);

  00036	74 08		 je	 SHORT $LN6@AffectInde
  00038	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0003b	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  0003e	73 03		 jae	 SHORT $LN97@AffectInde
$LN6@AffectInde:

; 44   : 		{	// construct with node pointer _Pnode

  00040	89 75 fc	 mov	 DWORD PTR $T2[ebp], esi
$LN97@AffectInde:

; 1553 : 					? end() : _Where);

  00043	8d 4d fc	 lea	 ecx, DWORD PTR $T2[ebp]

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00046	8b c6		 mov	 eax, esi
  00048	3b 01		 cmp	 eax, DWORD PTR [ecx]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 36   : 	if (m_kMap_dwAffectIndexToSkillIndex.end() == m_kMap_dwAffectIndexToSkillIndex.find(dwAffectIndex))

  0004a	75 0a		 jne	 SHORT $LN1@AffectInde

; 37   : 		return false;

  0004c	5f		 pop	 edi
  0004d	32 c0		 xor	 al, al
  0004f	5e		 pop	 esi

; 41   : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN1@AffectInde:

; 38   : 
; 39   : 	*pdwSkillIndex = m_kMap_dwAffectIndexToSkillIndex[dwAffectIndex];

  00056	8d 45 08	 lea	 eax, DWORD PTR _dwAffectIndex$[ebp]
  00059	8b cf		 mov	 ecx, edi
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ??A?$map@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEAAKABK@Z ; std::map<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::operator[]
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	8b 08		 mov	 ecx, DWORD PTR [eax]
  00065	8b 45 0c	 mov	 eax, DWORD PTR _pdwSkillIndex$[ebp]
  00068	89 08		 mov	 DWORD PTR [eax], ecx

; 40   : 	return true;

  0006a	b0 01		 mov	 al, 1

; 41   : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
?AffectIndexToSkillIndex@CPythonPlayer@@QAE_NKPAK@Z ENDP ; CPythonPlayer::AffectIndexToSkillIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__GetPickedActorPtr@CPythonPlayer@@IAE_NPAPAVCInstanceBase@@@Z
_TEXT	SEGMENT
_ppkInstPicked$ = 8					; size = 4
?__GetPickedActorPtr@CPythonPlayer@@IAE_NPAPAVCInstanceBase@@@Z PROC ; CPythonPlayer::__GetPickedActorPtr, COMDAT
; _this$dead$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();
; 53   : 	CInstanceBase* pkInstPicked=rkChrMgr.OLD_GetPickedInstancePtr();

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00009	e8 00 00 00 00	 call	 ?OLD_GetPickedInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::OLD_GetPickedInstancePtr
  0000e	8b c8		 mov	 ecx, eax

; 54   : 	if (!pkInstPicked)

  00010	85 c9		 test	 ecx, ecx
  00012	75 06		 jne	 SHORT $LN1@GetPickedA

; 55   : 		return false;

  00014	32 c0		 xor	 al, al

; 59   : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN1@GetPickedA:

; 56   : 
; 57   : 	*ppkInstPicked=pkInstPicked;

  0001a	8b 45 08	 mov	 eax, DWORD PTR _ppkInstPicked$[ebp]
  0001d	89 08		 mov	 DWORD PTR [eax], ecx

; 58   : 	return true;

  0001f	b0 01		 mov	 al, 1

; 59   : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?__GetPickedActorPtr@CPythonPlayer@@IAE_NPAPAVCInstanceBase@@@Z ENDP ; CPythonPlayer::__GetPickedActorPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__GetPickedActorID@CPythonPlayer@@IAE_NPAK@Z
_TEXT	SEGMENT
_pdwActorID$ = 8					; size = 4
?__GetPickedActorID@CPythonPlayer@@IAE_NPAK@Z PROC	; CPythonPlayer::__GetPickedActorID, COMDAT
; _this$dead$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();
; 64   : 	return rkChrMgr.OLD_GetPickedInstanceVID(pdwActorID);

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton

; 65   : }

  00009	5d		 pop	 ebp

; 63   : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();
; 64   : 	return rkChrMgr.OLD_GetPickedInstanceVID(pdwActorID);

  0000a	e9 00 00 00 00	 jmp	 ?OLD_GetPickedInstanceVID@CPythonCharacterManager@@QAE_NPAK@Z ; CPythonCharacterManager::OLD_GetPickedInstanceVID
?__GetPickedActorID@CPythonPlayer@@IAE_NPAK@Z ENDP	; CPythonPlayer::__GetPickedActorID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__GetPickedItemID@CPythonPlayer@@IAE_NPAK@Z
_TEXT	SEGMENT
_pdwItemID$ = 8						; size = 4
?__GetPickedItemID@CPythonPlayer@@IAE_NPAK@Z PROC	; CPythonPlayer::__GetPickedItemID, COMDAT
; _this$dead$ = ecx

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   : 	CPythonItem& rkItemMgr=CPythonItem::Instance();
; 70   : 	return rkItemMgr.GetPickedItemID(pdwItemID);

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonItem@@@@0PAVCPythonItem@@A ; CSingleton<CPythonItem>::ms_singleton

; 71   : }

  00009	5d		 pop	 ebp

; 69   : 	CPythonItem& rkItemMgr=CPythonItem::Instance();
; 70   : 	return rkItemMgr.GetPickedItemID(pdwItemID);

  0000a	e9 00 00 00 00	 jmp	 ?GetPickedItemID@CPythonItem@@QAE_NPAK@Z ; CPythonItem::GetPickedItemID
?__GetPickedItemID@CPythonPlayer@@IAE_NPAK@Z ENDP	; CPythonPlayer::__GetPickedItemID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__GetPickedGroundPos@CPythonPlayer@@IAE_NPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pkPPosPicked$ = 8					; size = 4
?__GetPickedGroundPos@CPythonPlayer@@IAE_NPAUD3DXVECTOR3@@@Z PROC ; CPythonPlayer::__GetPickedGroundPos, COMDAT
; _this$dead$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 75   : 	CPythonBackground& rkBG=CPythonBackground::Instance();
; 76   : 
; 77   : 	TPixelPosition kPPosPicked;
; 78   : 	if (rkBG.GetPickingPoint(pkPPosPicked))

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR _pkPPosPicked$[ebp]
  0000d	56		 push	 esi
  0000e	e8 00 00 00 00	 call	 ?GetPickingPoint@CPythonBackground@@QAE_NPAUD3DXVECTOR3@@@Z ; CPythonBackground::GetPickingPoint
  00013	84 c0		 test	 al, al
  00015	74 18		 je	 SHORT $LN1@GetPickedG

; 79   : 	{
; 80   : 		pkPPosPicked->y=-pkPPosPicked->y;

  00017	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]

; 81   : 		return true;

  0001c	b0 01		 mov	 al, 1
  0001e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00025	f3 0f 11 46 04	 movss	 DWORD PTR [esi+4], xmm0
  0002a	5e		 pop	 esi

; 85   : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN1@GetPickedG:

; 82   : 	}
; 83   : 
; 84   : 	return false;

  0002f	32 c0		 xor	 al, al
  00031	5e		 pop	 esi

; 85   : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?__GetPickedGroundPos@CPythonPlayer@@IAE_NPAUD3DXVECTOR3@@@Z ENDP ; CPythonPlayer::__GetPickedGroundPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?RegisterEffect@CPythonPlayer@@QAE_NKPBD_N@Z
_TEXT	SEGMENT
_dwEID$ = 8						; size = 4
_c_szFileName$ = 12					; size = 4
_isCache$ = 16						; size = 1
?RegisterEffect@CPythonPlayer@@QAE_NKPBD_N@Z PROC	; CPythonPlayer::RegisterEffect, COMDAT
; _this$ = ecx

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  : 	if (dwEID>=EFFECT_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwEID$[ebp]
  00006	83 f8 01	 cmp	 eax, 1
  00009	72 06		 jb	 SHORT $LN1@RegisterEf

; 108  : 		return false;

  0000b	32 c0		 xor	 al, al

; 113  : }

  0000d	5d		 pop	 ebp
  0000e	c2 0c 00	 ret	 12			; 0000000cH
$LN1@RegisterEf:

; 109  : 
; 110  : 	CEffectManager& rkEftMgr=CEffectManager::Instance();
; 111  : 	rkEftMgr.RegisterEffect2(c_szFileName, &m_adwEffect[dwEID], isCache);

  00011	ff 75 10	 push	 DWORD PTR _isCache$[ebp]
  00014	81 c1 fc 09 01
	00		 add	 ecx, 68092		; 000109fcH
  0001a	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  00023	50		 push	 eax
  00024	ff 75 0c	 push	 DWORD PTR _c_szFileName$[ebp]
  00027	e8 00 00 00 00	 call	 ?RegisterEffect2@CEffectManager@@QAEHPBDPAK_N@Z ; CEffectManager::RegisterEffect2

; 112  : 	return true;

  0002c	b0 01		 mov	 al, 1

; 113  : }

  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?RegisterEffect@CPythonPlayer@@QAE_NKPBD_N@Z ENDP	; CPythonPlayer::RegisterEffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?NEW_ShowEffect@CPythonPlayer@@IAEXHUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_kD3DVt3Pos$ = -28					; size = 12
_kD3DVt3Dir$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_dwEID$dead$ = 8					; size = 4
_kPPosDst$ = 12						; size = 12
?NEW_ShowEffect@CPythonPlayer@@IAEXHUD3DXVECTOR3@@@Z PROC ; CPythonPlayer::NEW_ShowEffect, COMDAT
; _this$ = ecx

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00010	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _kPPosDst$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 124  : 	rkEftMgr.CreateEffect(m_adwEffect[dwEID], kD3DVt3Pos, kD3DVt3Dir);

  00015	8d 45 f0	 lea	 eax, DWORD PTR _kD3DVt3Dir$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00018	f3 0f 11 45 e4	 movss	 DWORD PTR _kD3DVt3Pos$[ebp], xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 120  : 	D3DXVECTOR3 kD3DVt3Pos(kPPosDst.x, -kPPosDst.y, kPPosDst.z);

  0001d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _kPPosDst$[ebp+4]
  00022	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000

; 124  : 	rkEftMgr.CreateEffect(m_adwEffect[dwEID], kD3DVt3Pos, kD3DVt3Dir);

  00029	50		 push	 eax
  0002a	8d 45 e4	 lea	 eax, DWORD PTR _kD3DVt3Pos$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 181  :     y = fy;

  0002d	f3 0f 11 45 e8	 movss	 DWORD PTR _kD3DVt3Pos$[ebp+4], xmm0

; 182  :     z = fz;

  00032	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _kPPosDst$[ebp+8]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 124  : 	rkEftMgr.CreateEffect(m_adwEffect[dwEID], kD3DVt3Pos, kD3DVt3Dir);

  00037	50		 push	 eax
  00038	ff b1 fc 09 01
	00		 push	 DWORD PTR [ecx+68092]
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00044	f3 0f 11 45 ec	 movss	 DWORD PTR _kD3DVt3Pos$[ebp+8], xmm0

; 180  :     x = fx;

  00049	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _kD3DVt3Dir$[ebp], 0

; 181  :     y = fy;

  00050	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _kD3DVt3Dir$[ebp+4], 0

; 182  :     z = fz;

  00057	c7 45 f8 00 00
	80 3f		 mov	 DWORD PTR _kD3DVt3Dir$[ebp+8], 1065353216 ; 3f800000H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 124  : 	rkEftMgr.CreateEffect(m_adwEffect[dwEID], kD3DVt3Pos, kD3DVt3Dir);

  0005e	e8 00 00 00 00	 call	 ?CreateEffect@CEffectManager@@QAEHKABUD3DXVECTOR3@@0@Z ; CEffectManager::CreateEffect

; 125  : }

  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 10 00	 ret	 16			; 00000010H
?NEW_ShowEffect@CPythonPlayer@@IAEXHUD3DXVECTOR3@@@Z ENDP ; CPythonPlayer::NEW_ShowEffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?NEW_FindActorPtr@CPythonPlayer@@QAEPAVCInstanceBase@@K@Z
_TEXT	SEGMENT
_dwVID$ = 8						; size = 4
?NEW_FindActorPtr@CPythonPlayer@@QAEPAVCInstanceBase@@K@Z PROC ; CPythonPlayer::NEW_FindActorPtr, COMDAT
; _this$dead$ = ecx

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 129  : 	CPythonCharacterManager& rkChrMgr = CPythonCharacterManager::Instance();

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton

; 130  : 	return rkChrMgr.GetInstancePtr(dwVID);

  00009	83 c1 04	 add	 ecx, 4
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]

; 131  : }

  0000e	5d		 pop	 ebp

; 130  : 	return rkChrMgr.GetInstancePtr(dwVID);

  0000f	ff 60 08	 jmp	 DWORD PTR [eax+8]
?NEW_FindActorPtr@CPythonPlayer@@QAEPAVCInstanceBase@@K@Z ENDP ; CPythonPlayer::NEW_FindActorPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?NEW_GetMainActorPtr@CPythonPlayer@@UAEPAVCInstanceBase@@XZ
_TEXT	SEGMENT
?NEW_GetMainActorPtr@CPythonPlayer@@UAEPAVCInstanceBase@@XZ PROC ; CPythonPlayer::NEW_GetMainActorPtr, COMDAT
; _this$ = ecx

; 135  : 	return NEW_FindActorPtr(m_dwMainCharacterIndex);

  00000	ff 71 28	 push	 DWORD PTR [ecx+40]
  00003	e8 00 00 00 00	 call	 ?NEW_FindActorPtr@CPythonPlayer@@QAEPAVCInstanceBase@@K@Z ; CPythonPlayer::NEW_FindActorPtr

; 136  : }

  00008	c3		 ret	 0
?NEW_GetMainActorPtr@CPythonPlayer@@UAEPAVCInstanceBase@@XZ ENDP ; CPythonPlayer::NEW_GetMainActorPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__IsUsingChargeSkill@CPythonPlayer@@IAE_NXZ
_TEXT	SEGMENT
_pSkillData$ = -4					; size = 4
?__IsUsingChargeSkill@CPythonPlayer@@IAE_NXZ PROC	; CPythonPlayer::__IsUsingChargeSkill, COMDAT
; _this$ = ecx

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 185  : 	CInstanceBase * pkInstMain = NEW_GetMainActorPtr();

  00007	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000d	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 186  : 	if (!pkInstMain)

  00013	85 c0		 test	 eax, eax
  00015	75 07		 jne	 SHORT $LN5@IsUsingCha
$LN10@IsUsingCha:

; 187  : 		return false;

  00017	32 c0		 xor	 al, al
  00019	5e		 pop	 esi

; 205  : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN5@IsUsingCha:

; 188  : 
; 189  : 	if (__CheckDashAffect(*pkInstMain))

  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?__CheckDashAffect@CPythonPlayer@@IAE_NAAVCInstanceBase@@@Z ; CPythonPlayer::__CheckDashAffect
  00024	84 c0		 test	 al, al
  00026	74 07		 je	 SHORT $LN4@IsUsingCha

; 190  : 		return true;

  00028	b0 01		 mov	 al, 1
  0002a	5e		 pop	 esi

; 205  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN4@IsUsingCha:

; 191  : 
; 192  : 	if (MODE_USE_SKILL != m_eReservedMode)

  0002f	83 7e 54 04	 cmp	 DWORD PTR [esi+84], 4
  00033	75 e2		 jne	 SHORT $LN10@IsUsingCha

; 193  : 		return false;
; 194  : 
; 195  : 	if (m_dwSkillSlotIndexReserved >= SKILL_MAX_NUM)

  00035	8b 86 78 09 01
	00		 mov	 eax, DWORD PTR [esi+67960]
  0003b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00040	73 d5		 jae	 SHORT $LN10@IsUsingCha

; 196  : 		return false;
; 197  : 
; 198  : 	TSkillInstance & rkSkillInst = m_playerStatus.aSkill[m_dwSkillSlotIndexReserved];
; 199  : 
; 200  : 	CPythonSkill::TSkillData * pSkillData;
; 201  : 	if (!CPythonSkill::Instance().GetSkillData(rkSkillInst.dwIndex, &pSkillData))

  00042	8d 4d fc	 lea	 ecx, DWORD PTR _pSkillData$[ebp]
  00045	51		 push	 ecx
  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonSkill@@@@0PAVCPythonSkill@@A ; CSingleton<CPythonSkill>::ms_singleton
  0004c	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0004f	ff b4 c6 90 dd
	00 00		 push	 DWORD PTR [esi+eax*8+56720]
  00056	e8 00 00 00 00	 call	 ?GetSkillData@CPythonSkill@@QAEHKPAPAUSSkillData@1@@Z ; CPythonSkill::GetSkillData
  0005b	85 c0		 test	 eax, eax
  0005d	74 b8		 je	 SHORT $LN10@IsUsingCha

; 202  : 		return false;
; 203  : 
; 204  : 	return pSkillData->IsChargeSkill() ? true : false;

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _pSkillData$[ebp]
  00062	e8 00 00 00 00	 call	 ?IsChargeSkill@SSkillData@CPythonSkill@@QAEHXZ ; CPythonSkill::SSkillData::IsChargeSkill
  00067	85 c0		 test	 eax, eax
  00069	5e		 pop	 esi
  0006a	0f 95 c0	 setne	 al

; 205  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?__IsUsingChargeSkill@CPythonPlayer@@IAE_NXZ ENDP	; CPythonPlayer::__IsUsingChargeSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__Update_AutoAttack@CPythonPlayer@@IAEXXZ
_TEXT	SEGMENT
?__Update_AutoAttack@CPythonPlayer@@IAEXXZ PROC		; CPythonPlayer::__Update_AutoAttack, COMDAT
; _this$ = ecx

; 208  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 209  : 	if (0 == m_dwAutoAttackTargetVID)

  00003	83 7e 50 00	 cmp	 DWORD PTR [esi+80], 0
  00007	0f 84 8f 00 00
	00		 je	 $LN1@Update_Aut

; 210  : 		return;
; 211  : 
; 212  : 	CInstanceBase * pkInstMain = NEW_GetMainActorPtr();

  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00013	57		 push	 edi
  00014	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]
  0001a	8b f8		 mov	 edi, eax

; 213  : 	if (!pkInstMain)

  0001c	85 ff		 test	 edi, edi
  0001e	74 7b		 je	 SHORT $LN15@Update_Aut

; 214  : 		return;
; 215  : 
; 216  : 	//     
; 217  : 	if (__IsUsingChargeSkill())

  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?__IsUsingChargeSkill@CPythonPlayer@@IAE_NXZ ; CPythonPlayer::__IsUsingChargeSkill
  00027	84 c0		 test	 al, al
  00029	75 70		 jne	 SHORT $LN15@Update_Aut

; 218  : 		return;
; 219  : 
; 220  : 	CInstanceBase* pkInstVictim=NEW_FindActorPtr(m_dwAutoAttackTargetVID);

  0002b	53		 push	 ebx
  0002c	ff 76 50	 push	 DWORD PTR [esi+80]
  0002f	e8 00 00 00 00	 call	 ?NEW_FindActorPtr@CPythonPlayer@@QAEPAVCInstanceBase@@K@Z ; CPythonPlayer::NEW_FindActorPtr
  00034	8b d8		 mov	 ebx, eax

; 221  : 	if (!pkInstVictim)

  00036	85 db		 test	 ebx, ebx
  00038	75 0a		 jne	 SHORT $LN9@Update_Aut

; 222  : 	{
; 223  : 		__ClearAutoAttackTargetActorID();

  0003a	5b		 pop	 ebx
  0003b	5f		 pop	 edi
  0003c	8b ce		 mov	 ecx, esi
  0003e	5e		 pop	 esi
  0003f	e9 00 00 00 00	 jmp	 ?__ClearAutoAttackTargetActorID@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__ClearAutoAttackTargetActorID
$LN9@Update_Aut:

; 224  : 	}
; 225  : 	else
; 226  : 	{
; 227  : 		if (pkInstVictim->IsDead())

  00044	8b cb		 mov	 ecx, ebx
  00046	e8 00 00 00 00	 call	 ?IsDead@CInstanceBase@@QAEHXZ ; CInstanceBase::IsDead
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN7@Update_Aut

; 228  : 		{
; 229  : 			__ClearAutoAttackTargetActorID();

  0004f	5b		 pop	 ebx
  00050	5f		 pop	 edi
  00051	8b ce		 mov	 ecx, esi
  00053	5e		 pop	 esi
  00054	e9 00 00 00 00	 jmp	 ?__ClearAutoAttackTargetActorID@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__ClearAutoAttackTargetActorID
$LN7@Update_Aut:

; 230  : 		}
; 231  : 		else if (pkInstMain->IsMountingHorse() && !pkInstMain->CanAttackHorseLevel())

  00059	8b cf		 mov	 ecx, edi
  0005b	e8 00 00 00 00	 call	 ?IsMountingHorse@CInstanceBase@@QAEHXZ ; CInstanceBase::IsMountingHorse
  00060	85 c0		 test	 eax, eax
  00062	74 15		 je	 SHORT $LN5@Update_Aut
  00064	8b cf		 mov	 ecx, edi
  00066	e8 00 00 00 00	 call	 ?CanAttackHorseLevel@CInstanceBase@@QAEHXZ ; CInstanceBase::CanAttackHorseLevel
  0006b	85 c0		 test	 eax, eax
  0006d	75 0a		 jne	 SHORT $LN5@Update_Aut

; 232  : 		{
; 233  : 			__ClearAutoAttackTargetActorID();

  0006f	5b		 pop	 ebx
  00070	5f		 pop	 edi
  00071	8b ce		 mov	 ecx, esi
  00073	5e		 pop	 esi
  00074	e9 00 00 00 00	 jmp	 ?__ClearAutoAttackTargetActorID@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__ClearAutoAttackTargetActorID
$LN5@Update_Aut:

; 234  : 		}
; 235  : 		else if (pkInstMain->IsAttackableInstance(*pkInstVictim))

  00079	53		 push	 ebx
  0007a	8b cf		 mov	 ecx, edi
  0007c	e8 00 00 00 00	 call	 ?IsAttackableInstance@CInstanceBase@@QAE_NAAV1@@Z ; CInstanceBase::IsAttackableInstance
  00081	84 c0		 test	 al, al
  00083	74 15		 je	 SHORT $LN16@Update_Aut

; 236  : 		{
; 237  : 			if (pkInstMain->IsSleep())

  00085	8b cf		 mov	 ecx, edi
  00087	e8 00 00 00 00	 call	 ?IsSleep@CInstanceBase@@QAEHXZ ; CInstanceBase::IsSleep
  0008c	85 c0		 test	 eax, eax
  0008e	75 0a		 jne	 SHORT $LN16@Update_Aut

; 238  : 			{
; 239  : 				//TraceError("SKIP_AUTO_ATTACK_IN_SLEEPING");
; 240  : 			}
; 241  : 			else
; 242  : 			{
; 243  : 				__ReserveClickActor(m_dwAutoAttackTargetVID);

  00090	ff 76 50	 push	 DWORD PTR [esi+80]
  00093	8b ce		 mov	 ecx, esi
  00095	e8 00 00 00 00	 call	 ?__ReserveClickActor@CPythonPlayer@@IAEXK@Z ; CPythonPlayer::__ReserveClickActor
$LN16@Update_Aut:
  0009a	5b		 pop	 ebx
$LN15@Update_Aut:
  0009b	5f		 pop	 edi
$LN1@Update_Aut:
  0009c	5e		 pop	 esi

; 244  : 			}
; 245  : 		}
; 246  : 	}
; 247  : }

  0009d	c3		 ret	 0
?__Update_AutoAttack@CPythonPlayer@@IAEXXZ ENDP		; CPythonPlayer::__Update_AutoAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__Update_NotifyGuildAreaEvent@CPythonPlayer@@IAEXXZ
_TEXT	SEGMENT
_kPixelPosition$1 = -12					; size = 12
?__Update_NotifyGuildAreaEvent@CPythonPlayer@@IAEXXZ PROC ; CPythonPlayer::__Update_NotifyGuildAreaEvent, COMDAT
; _this$ = ecx

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 251  : 	CInstanceBase * pkInstMain = NEW_GetMainActorPtr();

  00009	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000f	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 252  : 	if (pkInstMain)

  00015	85 c0		 test	 eax, eax
  00017	74 75		 je	 SHORT $LN3@Update_Not

; 253  : 	{
; 254  : 		TPixelPosition kPixelPosition;
; 255  : 		pkInstMain->NEW_GetPixelPosition(&kPixelPosition);

  00019	57		 push	 edi
  0001a	8d 4d f4	 lea	 ecx, DWORD PTR _kPixelPosition$1[ebp]
  0001d	51		 push	 ecx
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 256  : 
; 257  : 		DWORD dwAreaID = CPythonMiniMap::Instance().GetGuildAreaID(
; 258  : 			ULONG(kPixelPosition.x), ULONG(kPixelPosition.y));

  00025	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _kPixelPosition$1[ebp+4]
  0002a	e8 00 00 00 00	 call	 __ftoui3
  0002f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _kPixelPosition$1[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 __ftoui3
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?GetGuildAreaID@CPythonMiniMap@@QAEKKK@Z ; CPythonMiniMap::GetGuildAreaID
  00046	8b f8		 mov	 edi, eax

; 259  : 
; 260  : 		if (dwAreaID != m_inGuildAreaID)

  00048	3b be dc 09 01
	00		 cmp	 edi, DWORD PTR [esi+68060]
  0004e	74 3d		 je	 SHORT $LN11@Update_Not

; 261  : 		{
; 262  : 			if (0xffffffff != dwAreaID)

  00050	83 ff ff	 cmp	 edi, -1
  00053	74 14		 je	 SHORT $LN2@Update_Not

; 263  : 			{
; 264  : 				PyCallClassMemberFunc(m_ppyGameWindow, "BINARY_Guild_EnterGuildArea", Py_BuildValue("(i)", dwAreaID));

  00055	57		 push	 edi
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00061	50		 push	 eax
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@OMJPBBKE@BINARY_Guild_EnterGuildArea?$AA@

; 265  : 			}
; 266  : 			else

  00067	eb 13		 jmp	 SHORT $LN12@Update_Not
$LN2@Update_Not:

; 267  : 			{
; 268  : 				PyCallClassMemberFunc(m_ppyGameWindow, "BINARY_Guild_ExitGuildArea", Py_BuildValue("(i)", dwAreaID));

  00069	6a ff		 push	 -1
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00076	50		 push	 eax
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KCKDPCFN@BINARY_Guild_ExitGuildArea?$AA@
$LN12@Update_Not:
  0007c	ff 76 08	 push	 DWORD PTR [esi+8]
  0007f	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00084	83 c4 14	 add	 esp, 20			; 00000014H

; 269  : 			}
; 270  : 
; 271  : 			m_inGuildAreaID = dwAreaID;

  00087	89 be dc 09 01
	00		 mov	 DWORD PTR [esi+68060], edi
$LN11@Update_Not:
  0008d	5f		 pop	 edi
$LN3@Update_Not:
  0008e	5e		 pop	 esi

; 272  : 		}
; 273  : 	}
; 274  : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?__Update_NotifyGuildAreaEvent@CPythonPlayer@@IAEXXZ ENDP ; CPythonPlayer::__Update_NotifyGuildAreaEvent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetMainCharacterIndex@CPythonPlayer@@UAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?SetMainCharacterIndex@CPythonPlayer@@UAEXH@Z PROC	; CPythonPlayer::SetMainCharacterIndex, COMDAT
; _this$ = ecx

; 277  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 278  : 	m_dwMainCharacterIndex = iIndex;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 279  : 
; 280  : 	CInstanceBase* pkInstMain=NEW_GetMainActorPtr();

  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	56		 push	 esi
  0000c	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]
  00012	8b f0		 mov	 esi, eax

; 281  : 	if (pkInstMain)

  00014	85 f6		 test	 esi, esi
  00016	74 0d		 je	 SHORT $LN1@SetMainCha

; 282  : 	{
; 283  : 		CPythonPlayerEventHandler& rkPlayerEventHandler=CPythonPlayerEventHandler::GetSingleton();

  00018	e8 00 00 00 00	 call	 ?GetSingleton@CPythonPlayerEventHandler@@SAAAV1@XZ ; CPythonPlayerEventHandler::GetSingleton

; 284  : 		pkInstMain->SetEventHandler(&rkPlayerEventHandler);

  0001d	50		 push	 eax
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?SetEventHandler@CInstanceBase@@QAEXPAVIEventHandler@CActorInstance@@@Z ; CInstanceBase::SetEventHandler
$LN1@SetMainCha:
  00025	5e		 pop	 esi

; 285  : 	}
; 286  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?SetMainCharacterIndex@CPythonPlayer@@UAEXH@Z ENDP	; CPythonPlayer::SetMainCharacterIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetMainCharacterIndex@CPythonPlayer@@UAEKXZ
_TEXT	SEGMENT
?GetMainCharacterIndex@CPythonPlayer@@UAEKXZ PROC	; CPythonPlayer::GetMainCharacterIndex, COMDAT
; _this$ = ecx

; 290  : 	return m_dwMainCharacterIndex;

  00000	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]

; 291  : }

  00003	c3		 ret	 0
?GetMainCharacterIndex@CPythonPlayer@@UAEKXZ ENDP	; CPythonPlayer::GetMainCharacterIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsMainCharacterIndex@CPythonPlayer@@UAE_NK@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?IsMainCharacterIndex@CPythonPlayer@@UAE_NK@Z PROC	; CPythonPlayer::IsMainCharacterIndex, COMDAT
; _this$ = ecx

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 295  : 	return (m_dwMainCharacterIndex == dwIndex);

  00003	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  00006	33 c0		 xor	 eax, eax
  00008	3b 4d 08	 cmp	 ecx, DWORD PTR _dwIndex$[ebp]
  0000b	0f 94 c0	 sete	 al

; 296  : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?IsMainCharacterIndex@CPythonPlayer@@UAE_NK@Z ENDP	; CPythonPlayer::IsMainCharacterIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetWeaponPower@CPythonPlayer@@UAEXKKKKK@Z
_TEXT	SEGMENT
_dwMinPower$ = 8					; size = 4
_dwMaxPower$ = 12					; size = 4
_dwMinMagicPower$ = 16					; size = 4
_dwMaxMagicPower$ = 20					; size = 4
_dwAddPower$ = 24					; size = 4
?SetWeaponPower@CPythonPlayer@@UAEXKKKKK@Z PROC		; CPythonPlayer::SetWeaponPower, COMDAT
; _this$ = ecx

; 308  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 309  : 	m_dwWeaponMinPower=dwMinPower;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwMinPower$[ebp]
  00006	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 310  : 	m_dwWeaponMaxPower=dwMaxPower;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _dwMaxPower$[ebp]
  0000c	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 311  : 	m_dwWeaponMinMagicPower=dwMinMagicPower;

  0000f	8b 45 10	 mov	 eax, DWORD PTR _dwMinMagicPower$[ebp]
  00012	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 312  : 	m_dwWeaponMaxMagicPower=dwMaxMagicPower;

  00015	8b 45 14	 mov	 eax, DWORD PTR _dwMaxMagicPower$[ebp]
  00018	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 313  : 	m_dwWeaponAddPower=dwAddPower;

  0001b	8b 45 18	 mov	 eax, DWORD PTR _dwAddPower$[ebp]
  0001e	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 314  : 
; 315  : 	__UpdateBattleStatus();	

  00021	83 c1 fc	 add	 ecx, -4			; fffffffcH
  00024	e8 00 00 00 00	 call	 ?__UpdateBattleStatus@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__UpdateBattleStatus

; 316  : }

  00029	5d		 pop	 ebp
  0002a	c2 14 00	 ret	 20			; 00000014H
?SetWeaponPower@CPythonPlayer@@UAEXKKKKK@Z ENDP		; CPythonPlayer::SetWeaponPower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetRace@CPythonPlayer@@UAEXK@Z
_TEXT	SEGMENT
_dwRace$ = 8						; size = 4
?SetRace@CPythonPlayer@@UAEXK@Z PROC			; CPythonPlayer::SetRace, COMDAT
; _this$ = ecx

; 319  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 320  : 	m_dwRace=dwRace;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwRace$[ebp]
  00006	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 321  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetRace@CPythonPlayer@@UAEXK@Z ENDP			; CPythonPlayer::SetRace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetRace@CPythonPlayer@@QAEKXZ
_TEXT	SEGMENT
?GetRace@CPythonPlayer@@QAEKXZ PROC			; CPythonPlayer::GetRace, COMDAT
; _this$ = ecx

; 325  : 	return m_dwRace;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]

; 326  : }

  00003	c3		 ret	 0
?GetRace@CPythonPlayer@@QAEKXZ ENDP			; CPythonPlayer::GetRace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__GetRaceStat@CPythonPlayer@@IAEKXZ
_TEXT	SEGMENT
?__GetRaceStat@CPythonPlayer@@IAEKXZ PROC		; CPythonPlayer::__GetRaceStat, COMDAT
; _this$ = ecx

; 330  : 	switch (GetRace())

  00000	e8 00 00 00 00	 call	 ?GetRace@CPythonPlayer@@QAEKXZ ; CPythonPlayer::GetRace
  00005	83 f8 07	 cmp	 eax, 7
  00008	77 1f		 ja	 SHORT $LN5@GetRaceSta
  0000a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN11@GetRaceSta[eax*4]
$LN3@GetRaceSta:

; 331  : 	{
; 332  : 		case MAIN_RACE_WARRIOR_M:
; 333  : 		case MAIN_RACE_WARRIOR_W:
; 334  : 			return GetStatus(POINT_ST);
; 335  : 			break;
; 336  : 		case MAIN_RACE_ASSASSIN_M:
; 337  : 		case MAIN_RACE_ASSASSIN_W:
; 338  : 			return GetStatus(POINT_DX);
; 339  : 			break;
; 340  : 		case MAIN_RACE_SURA_M:
; 341  : 		case MAIN_RACE_SURA_W:
; 342  : 			return GetStatus(POINT_ST);
; 343  : 			break;
; 344  : 		case MAIN_RACE_SHAMAN_M:
; 345  : 		case MAIN_RACE_SHAMAN_W:
; 346  : 			return GetStatus(POINT_IQ);
; 347  : 			break;
; 348  : 	}	
; 349  : 	return GetStatus(POINT_ST);

  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	83 c1 04	 add	 ecx, 4
  00017	6a 0e		 push	 14			; 0000000eH
  00019	ff 50 10	 call	 DWORD PTR [eax+16]

; 350  : }

  0001c	c3		 ret	 0
$LN1@GetRaceSta:

; 331  : 	{
; 332  : 		case MAIN_RACE_WARRIOR_M:
; 333  : 		case MAIN_RACE_WARRIOR_W:
; 334  : 			return GetStatus(POINT_ST);
; 335  : 			break;
; 336  : 		case MAIN_RACE_ASSASSIN_M:
; 337  : 		case MAIN_RACE_ASSASSIN_W:
; 338  : 			return GetStatus(POINT_DX);
; 339  : 			break;
; 340  : 		case MAIN_RACE_SURA_M:
; 341  : 		case MAIN_RACE_SURA_W:
; 342  : 			return GetStatus(POINT_ST);
; 343  : 			break;
; 344  : 		case MAIN_RACE_SHAMAN_M:
; 345  : 		case MAIN_RACE_SHAMAN_W:
; 346  : 			return GetStatus(POINT_IQ);
; 347  : 			break;
; 348  : 	}	
; 349  : 	return GetStatus(POINT_ST);

  0001d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00020	83 c1 04	 add	 ecx, 4
  00023	6a 0f		 push	 15			; 0000000fH
  00025	ff 50 10	 call	 DWORD PTR [eax+16]

; 350  : }

  00028	c3		 ret	 0
$LN5@GetRaceSta:

; 331  : 	{
; 332  : 		case MAIN_RACE_WARRIOR_M:
; 333  : 		case MAIN_RACE_WARRIOR_W:
; 334  : 			return GetStatus(POINT_ST);
; 335  : 			break;
; 336  : 		case MAIN_RACE_ASSASSIN_M:
; 337  : 		case MAIN_RACE_ASSASSIN_W:
; 338  : 			return GetStatus(POINT_DX);
; 339  : 			break;
; 340  : 		case MAIN_RACE_SURA_M:
; 341  : 		case MAIN_RACE_SURA_W:
; 342  : 			return GetStatus(POINT_ST);
; 343  : 			break;
; 344  : 		case MAIN_RACE_SHAMAN_M:
; 345  : 		case MAIN_RACE_SHAMAN_W:
; 346  : 			return GetStatus(POINT_IQ);
; 347  : 			break;
; 348  : 	}	
; 349  : 	return GetStatus(POINT_ST);

  00029	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002c	83 c1 04	 add	 ecx, 4
  0002f	6a 0c		 push	 12			; 0000000cH
  00031	ff 50 10	 call	 DWORD PTR [eax+16]

; 350  : }

  00034	c3		 ret	 0
  00035	8d 49 00	 npad	 3
$LN11@GetRaceSta:
  00038	00 00 00 00	 DD	 $LN5@GetRaceSta
  0003c	00 00 00 00	 DD	 $LN3@GetRaceSta
  00040	00 00 00 00	 DD	 $LN5@GetRaceSta
  00044	00 00 00 00	 DD	 $LN1@GetRaceSta
  00048	00 00 00 00	 DD	 $LN5@GetRaceSta
  0004c	00 00 00 00	 DD	 $LN3@GetRaceSta
  00050	00 00 00 00	 DD	 $LN5@GetRaceSta
  00054	00 00 00 00	 DD	 $LN1@GetRaceSta
?__GetRaceStat@CPythonPlayer@@IAEKXZ ENDP		; CPythonPlayer::__GetRaceStat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__GetLevelAtk@CPythonPlayer@@IAEKXZ
_TEXT	SEGMENT
?__GetLevelAtk@CPythonPlayer@@IAEKXZ PROC		; CPythonPlayer::__GetLevelAtk, COMDAT
; _this$ = ecx

; 354  : 	return 2*GetStatus(POINT_LEVEL);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c1 04	 add	 ecx, 4
  00006	6a 01		 push	 1
  00008	ff 50 10	 call	 DWORD PTR [eax+16]
  0000b	03 c0		 add	 eax, eax

; 355  : }

  0000d	c3		 ret	 0
?__GetLevelAtk@CPythonPlayer@@IAEKXZ ENDP		; CPythonPlayer::__GetLevelAtk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__GetStatAtk@CPythonPlayer@@IAEKXZ
_TEXT	SEGMENT
?__GetStatAtk@CPythonPlayer@@IAEKXZ PROC		; CPythonPlayer::__GetStatAtk, COMDAT
; _this$ = ecx

; 358  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 359  : 	return (4*GetStatus(POINT_ST)+2*__GetRaceStat())/3;

  00004	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00007	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0000a	6a 0c		 push	 12			; 0000000cH
  0000c	ff 50 10	 call	 DWORD PTR [eax+16]
  0000f	8b cf		 mov	 ecx, edi
  00011	8b f0		 mov	 esi, eax
  00013	e8 00 00 00 00	 call	 ?__GetRaceStat@CPythonPlayer@@IAEKXZ ; CPythonPlayer::__GetRaceStat
  00018	5f		 pop	 edi
  00019	8d 0c 70	 lea	 ecx, DWORD PTR [eax+esi*2]
  0001c	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00021	03 c9		 add	 ecx, ecx
  00023	f7 e1		 mul	 ecx
  00025	5e		 pop	 esi
  00026	d1 ea		 shr	 edx, 1
  00028	8b c2		 mov	 eax, edx

; 360  : }

  0002a	c3		 ret	 0
?__GetStatAtk@CPythonPlayer@@IAEKXZ ENDP		; CPythonPlayer::__GetStatAtk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__GetWeaponAtk@CPythonPlayer@@IAEKK@Z
_TEXT	SEGMENT
_dwWeaponPower$ = 8					; size = 4
?__GetWeaponAtk@CPythonPlayer@@IAEKK@Z PROC		; CPythonPlayer::__GetWeaponAtk, COMDAT
; _this$dead$ = ecx

; 363  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 364  : 	return 2*dwWeaponPower;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwWeaponPower$[ebp]
  00006	03 c0		 add	 eax, eax

; 365  : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?__GetWeaponAtk@CPythonPlayer@@IAEKK@Z ENDP		; CPythonPlayer::__GetWeaponAtk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__GetTotalAtk@CPythonPlayer@@IAEKKK@Z
_TEXT	SEGMENT
_dwStAtk$1$ = -4					; size = 4
_dwWeaponPower$ = 8					; size = 4
_dwRefineBonus$ = 12					; size = 4
?__GetTotalAtk@CPythonPlayer@@IAEKKK@Z PROC		; CPythonPlayer::__GetTotalAtk, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 369  : 	DWORD dwLvAtk=__GetLevelAtk();

  00009	e8 00 00 00 00	 call	 ?__GetLevelAtk@CPythonPlayer@@IAEKXZ ; CPythonPlayer::__GetLevelAtk

; 370  : 	DWORD dwStAtk=__GetStatAtk();

  0000e	8b cf		 mov	 ecx, edi
  00010	8b d8		 mov	 ebx, eax
  00012	e8 00 00 00 00	 call	 ?__GetStatAtk@CPythonPlayer@@IAEKXZ ; CPythonPlayer::__GetStatAtk
  00017	89 45 fc	 mov	 DWORD PTR _dwStAtk$1$[ebp], eax

; 371  : 
; 372  : 	/////
; 373  : 
; 374  : 	DWORD dwWepAtk;
; 375  : 	DWORD dwTotalAtk;	
; 376  : 
; 377  : 	if (LocaleService_IsCHEONMA())

  0001a	e8 00 00 00 00	 call	 ?LocaleService_IsCHEONMA@@YA_NXZ ; LocaleService_IsCHEONMA
  0001f	84 c0		 test	 al, al
  00021	74 39		 je	 SHORT $LN2@GetTotalAt

; 378  : 	{
; 379  : 		dwWepAtk = __GetWeaponAtk(dwWeaponPower+dwRefineBonus);

  00023	8b 55 08	 mov	 edx, DWORD PTR _dwWeaponPower$[ebp]

; 380  : 		dwTotalAtk = dwLvAtk+(dwStAtk+dwWepAtk)*(GetStatus(POINT_DX)+210)/300;		

  00026	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00029	03 55 0c	 add	 edx, DWORD PTR _dwRefineBonus$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?__GetWeaponAtk@CPythonPlayer@@IAEKK@Z ; CPythonPlayer::__GetWeaponAtk
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	8b f0		 mov	 esi, eax
  00036	03 75 fc	 add	 esi, DWORD PTR _dwStAtk$1$[ebp]
  00039	6a 0e		 push	 14			; 0000000eH
  0003b	ff 52 10	 call	 DWORD PTR [edx+16]
  0003e	05 d2 00 00 00	 add	 eax, 210		; 000000d2H
  00043	0f af f0	 imul	 esi, eax
  00046	b8 b5 81 4e 1b	 mov	 eax, 458129845		; 1b4e81b5H
  0004b	5f		 pop	 edi

; 386  : 		dwTotalAtk = dwLvAtk+(dwStAtk+dwWepAtk)*hr/100;	

  0004c	f7 e6		 mul	 esi
  0004e	5e		 pop	 esi
  0004f	c1 ea 05	 shr	 edx, 5
  00052	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00055	5b		 pop	 ebx

; 387  : 	}
; 388  : 
; 389  : 	return dwTotalAtk;
; 390  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
$LN2@GetTotalAt:

; 381  : 	}
; 382  : 	else
; 383  : 	{
; 384  : 		int hr = __GetHitRate();
; 385  : 		dwWepAtk = __GetWeaponAtk(dwWeaponPower+dwRefineBonus);

  0005c	8b 45 08	 mov	 eax, DWORD PTR _dwWeaponPower$[ebp]
  0005f	03 45 0c	 add	 eax, DWORD PTR _dwRefineBonus$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?__GetWeaponAtk@CPythonPlayer@@IAEKK@Z ; CPythonPlayer::__GetWeaponAtk
  00068	8b f0		 mov	 esi, eax
  0006a	8b cf		 mov	 ecx, edi

; 386  : 		dwTotalAtk = dwLvAtk+(dwStAtk+dwWepAtk)*hr/100;	

  0006c	03 75 fc	 add	 esi, DWORD PTR _dwStAtk$1$[ebp]
  0006f	e8 00 00 00 00	 call	 ?__GetHitRate@CPythonPlayer@@IAEKXZ ; CPythonPlayer::__GetHitRate
  00074	0f af f0	 imul	 esi, eax
  00077	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0007c	5f		 pop	 edi
  0007d	f7 e6		 mul	 esi
  0007f	5e		 pop	 esi
  00080	c1 ea 05	 shr	 edx, 5
  00083	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00086	5b		 pop	 ebx

; 387  : 	}
; 388  : 
; 389  : 	return dwTotalAtk;
; 390  : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8
?__GetTotalAtk@CPythonPlayer@@IAEKKK@Z ENDP		; CPythonPlayer::__GetTotalAtk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__GetHitRate@CPythonPlayer@@IAEKXZ
_TEXT	SEGMENT
?__GetHitRate@CPythonPlayer@@IAEKXZ PROC		; CPythonPlayer::__GetHitRate, COMDAT
; _this$ = ecx

; 393  : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 394  : 	int src = 0;
; 395  : 
; 396  : 	if (LocaleService_IsCHEONMA())

  00003	e8 00 00 00 00	 call	 ?LocaleService_IsCHEONMA@@YA_NXZ ; LocaleService_IsCHEONMA

; 397  : 	{
; 398  : 		src = GetStatus(POINT_DX);

  00008	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0000b	84 c0		 test	 al, al
  0000d	74 09		 je	 SHORT $LN2@GetHitRate
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	6a 0e		 push	 14			; 0000000eH
  00013	ff 50 10	 call	 DWORD PTR [eax+16]

; 399  : 	}
; 400  : 	else

  00016	eb 2a		 jmp	 SHORT $LN1@GetHitRate
$LN2@GetHitRate:

; 401  : 	{
; 402  : 		src = (GetStatus(POINT_DX) * 4 + GetStatus(POINT_LEVEL) * 2)/6;

  00018	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001b	56		 push	 esi
  0001c	6a 0e		 push	 14			; 0000000eH
  0001e	ff 50 10	 call	 DWORD PTR [eax+16]
  00021	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00024	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00027	6a 01		 push	 1
  00029	8b f0		 mov	 esi, eax
  0002b	ff 52 10	 call	 DWORD PTR [edx+16]
  0002e	8d 0c 70	 lea	 ecx, DWORD PTR [eax+esi*2]
  00031	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00036	03 c9		 add	 ecx, ecx
  00038	f7 e9		 imul	 ecx
  0003a	5e		 pop	 esi
  0003b	8b c2		 mov	 eax, edx
  0003d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00040	03 c2		 add	 eax, edx
$LN1@GetHitRate:

; 403  : 	}
; 404  : 
; 405  : 	return 100*(min(90, src)+210)/300;

  00042	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00047	3b c1		 cmp	 eax, ecx
  00049	5f		 pop	 edi
  0004a	0f 4f c1	 cmovg	 eax, ecx
  0004d	05 d2 00 00 00	 add	 eax, 210		; 000000d2H
  00052	6b c8 64	 imul	 ecx, eax, 100
  00055	b8 b5 81 4e 1b	 mov	 eax, 458129845		; 1b4e81b5H
  0005a	f7 e9		 imul	 ecx
  0005c	c1 fa 05	 sar	 edx, 5
  0005f	8b c2		 mov	 eax, edx
  00061	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00064	03 c2		 add	 eax, edx

; 406  : }

  00066	c3		 ret	 0
?__GetHitRate@CPythonPlayer@@IAEKXZ ENDP		; CPythonPlayer::__GetHitRate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__GetEvadeRate@CPythonPlayer@@IAEKXZ
_TEXT	SEGMENT
?__GetEvadeRate@CPythonPlayer@@IAEKXZ PROC		; CPythonPlayer::__GetEvadeRate, COMDAT
; _this$ = ecx

; 410  : 	return 30*(2*GetStatus(POINT_DX)+5)/(GetStatus(POINT_DX)+95);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  00008	6a 0e		 push	 14			; 0000000eH
  0000a	8b cf		 mov	 ecx, edi
  0000c	ff 50 10	 call	 DWORD PTR [eax+16]
  0000f	8b d0		 mov	 edx, eax
  00011	8b cf		 mov	 ecx, edi
  00013	c1 e2 04	 shl	 edx, 4
  00016	2b d0		 sub	 edx, eax
  00018	6a 0e		 push	 14			; 0000000eH
  0001a	8d 34 95 96 00
	00 00		 lea	 esi, DWORD PTR [edx*4+150]
  00021	8b 17		 mov	 edx, DWORD PTR [edi]
  00023	ff 52 10	 call	 DWORD PTR [edx+16]
  00026	5f		 pop	 edi
  00027	8d 48 5f	 lea	 ecx, DWORD PTR [eax+95]
  0002a	8b c6		 mov	 eax, esi
  0002c	99		 cdq
  0002d	f7 f9		 idiv	 ecx
  0002f	5e		 pop	 esi

; 411  : } 

  00030	c3		 ret	 0
?__GetEvadeRate@CPythonPlayer@@IAEKXZ ENDP		; CPythonPlayer::__GetEvadeRate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__UpdateBattleStatus@CPythonPlayer@@IAEXXZ
_TEXT	SEGMENT
?__UpdateBattleStatus@CPythonPlayer@@IAEXXZ PROC	; CPythonPlayer::__UpdateBattleStatus, COMDAT
; _this$ = ecx

; 414  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 415  : 	m_playerStatus.SetPoint(POINT_NONE, 0);

  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  0000b	e8 00 00 00 00	 call	 ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ; CPythonPlayer::SPlayerStatus::SetPoint

; 416  : 	m_playerStatus.SetPoint(POINT_EVADE_RATE, __GetEvadeRate());

  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?__GetEvadeRate@CPythonPlayer@@IAEKXZ ; CPythonPlayer::__GetEvadeRate
  00017	50		 push	 eax
  00018	6a 12		 push	 18			; 00000012H
  0001a	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  0001d	e8 00 00 00 00	 call	 ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ; CPythonPlayer::SPlayerStatus::SetPoint

; 417  : 	m_playerStatus.SetPoint(POINT_HIT_RATE, __GetHitRate());

  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?__GetHitRate@CPythonPlayer@@IAEKXZ ; CPythonPlayer::__GetHitRate
  00029	50		 push	 eax
  0002a	68 cc 00 00 00	 push	 204			; 000000ccH
  0002f	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  00032	e8 00 00 00 00	 call	 ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ; CPythonPlayer::SPlayerStatus::SetPoint

; 418  : 	m_playerStatus.SetPoint(POINT_MIN_WEP, m_dwWeaponMinPower+m_dwWeaponAddPower);

  00037	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0003a	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  0003d	03 46 44	 add	 eax, DWORD PTR [esi+68]
  00040	50		 push	 eax
  00041	68 c8 00 00 00	 push	 200			; 000000c8H
  00046	e8 00 00 00 00	 call	 ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ; CPythonPlayer::SPlayerStatus::SetPoint

; 419  : 	m_playerStatus.SetPoint(POINT_MAX_WEP, m_dwWeaponMaxPower+m_dwWeaponAddPower);

  0004b	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0004e	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  00051	03 46 38	 add	 eax, DWORD PTR [esi+56]
  00054	50		 push	 eax
  00055	68 c9 00 00 00	 push	 201			; 000000c9H
  0005a	e8 00 00 00 00	 call	 ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ; CPythonPlayer::SPlayerStatus::SetPoint

; 420  : 	m_playerStatus.SetPoint(POINT_MIN_MAGIC_WEP, m_dwWeaponMinMagicPower+m_dwWeaponAddPower);

  0005f	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00062	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  00065	03 46 44	 add	 eax, DWORD PTR [esi+68]
  00068	50		 push	 eax
  00069	68 ca 00 00 00	 push	 202			; 000000caH
  0006e	e8 00 00 00 00	 call	 ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ; CPythonPlayer::SPlayerStatus::SetPoint

; 421  : 	m_playerStatus.SetPoint(POINT_MAX_MAGIC_WEP, m_dwWeaponMaxMagicPower+m_dwWeaponAddPower);

  00073	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00076	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  00079	03 46 44	 add	 eax, DWORD PTR [esi+68]
  0007c	50		 push	 eax
  0007d	68 cb 00 00 00	 push	 203			; 000000cbH
  00082	e8 00 00 00 00	 call	 ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ; CPythonPlayer::SPlayerStatus::SetPoint

; 422  : 	m_playerStatus.SetPoint(POINT_MIN_ATK, __GetTotalAtk(m_dwWeaponMinPower, m_dwWeaponAddPower));

  00087	ff 76 44	 push	 DWORD PTR [esi+68]
  0008a	8b ce		 mov	 ecx, esi
  0008c	ff 76 34	 push	 DWORD PTR [esi+52]
  0008f	e8 00 00 00 00	 call	 ?__GetTotalAtk@CPythonPlayer@@IAEKKK@Z ; CPythonPlayer::__GetTotalAtk
  00094	50		 push	 eax
  00095	6a 1d		 push	 29			; 0000001dH
  00097	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  0009a	e8 00 00 00 00	 call	 ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ; CPythonPlayer::SPlayerStatus::SetPoint

; 423  : 	m_playerStatus.SetPoint(POINT_MAX_ATK, __GetTotalAtk(m_dwWeaponMaxPower, m_dwWeaponAddPower));	

  0009f	ff 76 44	 push	 DWORD PTR [esi+68]
  000a2	8b ce		 mov	 ecx, esi
  000a4	ff 76 38	 push	 DWORD PTR [esi+56]
  000a7	e8 00 00 00 00	 call	 ?__GetTotalAtk@CPythonPlayer@@IAEKKK@Z ; CPythonPlayer::__GetTotalAtk
  000ac	50		 push	 eax
  000ad	6a 1e		 push	 30			; 0000001eH
  000af	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  000b2	e8 00 00 00 00	 call	 ?SetPoint@SPlayerStatus@CPythonPlayer@@QAEXIJ@Z ; CPythonPlayer::SPlayerStatus::SetPoint
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi

; 424  : }

  000b9	c3		 ret	 0
?__UpdateBattleStatus@CPythonPlayer@@IAEXXZ ENDP	; CPythonPlayer::__UpdateBattleStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetStatus@CPythonPlayer@@UAEHK@Z
_TEXT	SEGMENT
_dwType$ = 8						; size = 4
?GetStatus@CPythonPlayer@@UAEHK@Z PROC			; CPythonPlayer::GetStatus, COMDAT
; _this$ = ecx

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 466  : 	if (dwType >= POINT_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwType$[ebp]
  00006	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0000b	72 13		 jb	 SHORT $LN1@GetStatus

; 467  : 	{
; 468  : 		assert(!" CPythonPlayer::GetStatus - Strange Status Type!");
; 469  : 		Tracef("CPythonPlayer::GetStatus - Get Status Type Error\n");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@LHJHEHHP@CPythonPlayer?3?3GetStatus?5?9?5Get?5S@
  00012	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00017	83 c4 04	 add	 esp, 4

; 470  : 		return 0;

  0001a	33 c0		 xor	 eax, eax

; 474  : }

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN1@GetStatus:

; 471  : 	}
; 472  : 
; 473  : 	return m_playerStatus.GetPoint(dwType);

  00020	89 45 08	 mov	 DWORD PTR _dwType$[ebp], eax
  00023	83 c1 6c	 add	 ecx, 108		; 0000006cH

; 474  : }

  00026	5d		 pop	 ebp

; 471  : 	}
; 472  : 
; 473  : 	return m_playerStatus.GetPoint(dwType);

  00027	e9 00 00 00 00	 jmp	 ?GetPoint@SPlayerStatus@CPythonPlayer@@QAEJI@Z ; CPythonPlayer::SPlayerStatus::GetPoint
?GetStatus@CPythonPlayer@@UAEHK@Z ENDP			; CPythonPlayer::GetStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetName@CPythonPlayer@@UAEPBDXZ
_TEXT	SEGMENT
?GetName@CPythonPlayer@@UAEPBDXZ PROC			; CPythonPlayer::GetName, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00000	83 79 24 10	 cmp	 DWORD PTR [ecx+36], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 478  : 	return m_stName.c_str();

  00004	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00007	72 02		 jb	 SHORT $LN8@GetName
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 478  : 	return m_stName.c_str();

  00009	8b 00		 mov	 eax, DWORD PTR [eax]
$LN8@GetName:

; 479  : }

  0000b	c3		 ret	 0
?GetName@CPythonPlayer@@UAEPBDXZ ENDP			; CPythonPlayer::GetName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?NotifyDeletingCharacterInstance@CPythonPlayer@@UAEXK@Z
_TEXT	SEGMENT
_dwVID$ = 8						; size = 4
?NotifyDeletingCharacterInstance@CPythonPlayer@@UAEXK@Z PROC ; CPythonPlayer::NotifyDeletingCharacterInstance, COMDAT
; _this$ = ecx

; 487  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 488  : 	if (m_dwMainCharacterIndex == dwVID)

  00003	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00006	3b 45 08	 cmp	 eax, DWORD PTR _dwVID$[ebp]
  00009	75 07		 jne	 SHORT $LN1@NotifyDele

; 489  : 		m_dwMainCharacterIndex = 0;

  0000b	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
$LN1@NotifyDele:

; 490  : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?NotifyDeletingCharacterInstance@CPythonPlayer@@UAEXK@Z ENDP ; CPythonPlayer::NotifyDeletingCharacterInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?NotifyCharacterDead@CPythonPlayer@@UAEXK@Z
_TEXT	SEGMENT
_dwVID$ = 8						; size = 4
?NotifyCharacterDead@CPythonPlayer@@UAEXK@Z PROC	; CPythonPlayer::NotifyCharacterDead, COMDAT
; _this$ = ecx

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 494  : 	if (__IsSameTargetVID(dwVID))

  00003	ff 75 08	 push	 DWORD PTR _dwVID$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	8d 4a fc	 lea	 ecx, DWORD PTR [edx-4]
  0000b	e8 00 00 00 00	 call	 ?__IsSameTargetVID@CPythonPlayer@@IAE_NK@Z ; CPythonPlayer::__IsSameTargetVID
  00010	84 c0		 test	 al, al
  00012	74 0b		 je	 SHORT $LN1@NotifyChar

; 495  : 	{
; 496  : 		SetTarget(0);

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8b ca		 mov	 ecx, edx
  00018	6a 01		 push	 1
  0001a	6a 00		 push	 0
  0001c	ff 50 60	 call	 DWORD PTR [eax+96]
$LN1@NotifyChar:

; 497  : 	}
; 498  : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?NotifyCharacterDead@CPythonPlayer@@UAEXK@Z ENDP	; CPythonPlayer::NotifyCharacterDead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?NotifyCharacterUpdate@CPythonPlayer@@UAEXK@Z
_TEXT	SEGMENT
_dwVID$ = 8						; size = 4
?NotifyCharacterUpdate@CPythonPlayer@@UAEXK@Z PROC	; CPythonPlayer::NotifyCharacterUpdate, COMDAT
; _this$ = ecx

; 501  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 502  : 	if (__IsSameTargetVID(dwVID))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _dwVID$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	53		 push	 ebx
  0000b	8d 4f fc	 lea	 ecx, DWORD PTR [edi-4]
  0000e	e8 00 00 00 00	 call	 ?__IsSameTargetVID@CPythonPlayer@@IAE_NK@Z ; CPythonPlayer::__IsSameTargetVID
  00013	84 c0		 test	 al, al
  00015	74 79		 je	 SHORT $LN1@NotifyChar

; 503  : 	{
; 504  : 		CInstanceBase * pMainInstance = NEW_GetMainActorPtr();

  00017	8b 07		 mov	 eax, DWORD PTR [edi]
  00019	8b cf		 mov	 ecx, edi
  0001b	56		 push	 esi
  0001c	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 505  : 		CInstanceBase * pTargetInstance = CPythonCharacterManager::Instance().GetInstancePtr(dwVID);

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  00028	8b f0		 mov	 esi, eax
  0002a	83 c1 04	 add	 ecx, 4
  0002d	53		 push	 ebx
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	ff 52 08	 call	 DWORD PTR [edx+8]

; 506  : 		if (pMainInstance && pTargetInstance)

  00033	85 f6		 test	 esi, esi
  00035	5e		 pop	 esi
  00036	74 58		 je	 SHORT $LN1@NotifyChar
  00038	85 c0		 test	 eax, eax
  0003a	74 54		 je	 SHORT $LN1@NotifyChar

; 507  : 		{
; 508  : 			if (!pMainInstance->IsTargetableInstance(*pTargetInstance))

  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?IsTargetableInstance@CInstanceBase@@QAE_NAAV1@@Z ; CInstanceBase::IsTargetableInstance
  00042	84 c0		 test	 al, al
  00044	75 2d		 jne	 SHORT $LN2@NotifyChar

; 509  : 			{
; 510  : 				SetTarget(0);

  00046	8b 07		 mov	 eax, DWORD PTR [edi]
  00048	8b cf		 mov	 ecx, edi
  0004a	6a 01		 push	 1
  0004c	6a 00		 push	 0
  0004e	ff 50 60	 call	 DWORD PTR [eax+96]

; 511  : 				PyCallClassMemberFunc(m_ppyGameWindow, "CloseTargetBoard", Py_BuildValue("()"));

  00051	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0005c	50		 push	 eax
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FNPCBFHE@CloseTargetBoard?$AA@
  00062	ff 77 04	 push	 DWORD PTR [edi+4]
  00065	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0006a	83 c4 10	 add	 esp, 16			; 00000010H
  0006d	5f		 pop	 edi
  0006e	5b		 pop	 ebx

; 516  : 			}
; 517  : 		}
; 518  : 	}
; 519  : }

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@NotifyChar:

; 512  : 			}
; 513  : 			else
; 514  : 			{
; 515  : 				PyCallClassMemberFunc(m_ppyGameWindow, "RefreshTargetBoardByVID", Py_BuildValue("(i)", dwVID));

  00073	53		 push	 ebx
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@IJENFIMO@RefreshTargetBoardByVID?$AA@
  00085	ff 77 04	 push	 DWORD PTR [edi+4]
  00088	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0008d	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@NotifyChar:
  00090	5f		 pop	 edi
  00091	5b		 pop	 ebx

; 516  : 			}
; 517  : 		}
; 518  : 	}
; 519  : }

  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?NotifyCharacterUpdate@CPythonPlayer@@UAEXK@Z ENDP	; CPythonPlayer::NotifyCharacterUpdate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?NotifyChangePKMode@CPythonPlayer@@UAEXXZ
_TEXT	SEGMENT
?NotifyChangePKMode@CPythonPlayer@@UAEXXZ PROC		; CPythonPlayer::NotifyChangePKMode, COMDAT
; _this$ = ecx

; 527  : {

  00000	56		 push	 esi

; 528  : 	PyCallClassMemberFunc(m_ppyGameWindow, "OnChangePKMode", Py_BuildValue("()"));

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00006	8b f1		 mov	 esi, ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PDEFNCOA@OnChangePKMode?$AA@
  00014	ff 76 04	 push	 DWORD PTR [esi+4]
  00017	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0001c	83 c4 10	 add	 esp, 16			; 00000010H
  0001f	5e		 pop	 esi

; 529  : }

  00020	c3		 ret	 0
?NotifyChangePKMode@CPythonPlayer@@UAEXXZ ENDP		; CPythonPlayer::NotifyChangePKMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?MoveItemData@CPythonPlayer@@QAEXUSItemPos@@0@Z
_TEXT	SEGMENT
_dst_item$ = -100					; size = 46
_src_item$ = -52					; size = 46
__$ArrayPad$ = -4					; size = 4
_SrcCell$ = 8						; size = 3
_DstCell$ = 12						; size = 3
?MoveItemData@CPythonPlayer@@QAEXUSItemPos@@0@Z PROC	; CPythonPlayer::MoveItemData, COMDAT
; _this$ = ecx

; 533  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00010	66 8b 55 08	 mov	 dx, WORD PTR _SrcCell$[ebp]
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	0f b6 c2	 movzx	 eax, dl
  00019	be c0 03 00 00	 mov	 esi, 960		; 000003c0H
  0001e	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 533  : {

  0001f	8b f9		 mov	 edi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00021	b9 0d 01 00 00	 mov	 ecx, 269		; 0000010dH
  00026	48		 dec	 eax
  00027	74 12		 je	 SHORT $LN8@MoveItemDa
  00029	48		 dec	 eax
  0002a	74 0f		 je	 SHORT $LN8@MoveItemDa
  0002c	83 e8 03	 sub	 eax, 3
  0002f	0f 85 f1 00 00
	00		 jne	 $LN1@MoveItemDa

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00035	66 39 75 09	 cmp	 WORD PTR _SrcCell$[ebp+1], si
  00039	eb 04		 jmp	 SHORT $LN21@MoveItemDa
$LN8@MoveItemDa:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  0003b	66 39 4d 09	 cmp	 WORD PTR _SrcCell$[ebp+1], cx
$LN21@MoveItemDa:
  0003f	0f 92 c0	 setb	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 534  : 	if (!SrcCell.IsValidCell() || !DstCell.IsValidCell())

  00042	84 c0		 test	 al, al
  00044	0f 84 dc 00 00
	00		 je	 $LN1@MoveItemDa
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  0004a	66 8b 5d 0c	 mov	 bx, WORD PTR _DstCell$[ebp]
  0004e	0f b6 c3	 movzx	 eax, bl
  00051	48		 dec	 eax
  00052	74 12		 je	 SHORT $LN16@MoveItemDa
  00054	48		 dec	 eax
  00055	74 0f		 je	 SHORT $LN16@MoveItemDa
  00057	83 e8 03	 sub	 eax, 3
  0005a	0f 85 c6 00 00
	00		 jne	 $LN1@MoveItemDa

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00060	66 39 75 0d	 cmp	 WORD PTR _DstCell$[ebp+1], si
  00064	eb 04		 jmp	 SHORT $LN22@MoveItemDa
$LN16@MoveItemDa:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  00066	66 39 4d 0d	 cmp	 WORD PTR _DstCell$[ebp+1], cx
$LN22@MoveItemDa:
  0006a	0f 92 c0	 setb	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 534  : 	if (!SrcCell.IsValidCell() || !DstCell.IsValidCell())

  0006d	84 c0		 test	 al, al
  0006f	0f 84 b1 00 00
	00		 je	 $LN1@MoveItemDa

; 535  : 		return;
; 536  : 
; 537  : 	TItemData src_item(*GetItemData(SrcCell));

  00075	8a 45 0a	 mov	 al, BYTE PTR _SrcCell$[ebp+2]
  00078	51		 push	 ecx
  00079	8b cc		 mov	 ecx, esp
  0007b	66 89 11	 mov	 WORD PTR [ecx], dx
  0007e	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00081	8b cf		 mov	 ecx, edi
  00083	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData
  00088	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  0008c	f3 0f 7f 45 cc	 movdqu	 XMMWORD PTR _src_item$[ebp], xmm0
  00091	f3 0f 6f 40 10	 movdqu	 xmm0, XMMWORD PTR [eax+16]
  00096	f3 0f 7f 45 dc	 movdqu	 XMMWORD PTR _src_item$[ebp+16], xmm0
  0009b	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  000a0	66 0f d6 45 ec	 movq	 QWORD PTR _src_item$[ebp+32], xmm0
  000a5	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000a8	89 4d f4	 mov	 DWORD PTR _src_item$[ebp+40], ecx
  000ab	0f b7 40 2c	 movzx	 eax, WORD PTR [eax+44]

; 538  : 	TItemData dst_item(*GetItemData(DstCell));

  000af	51		 push	 ecx
  000b0	8b cc		 mov	 ecx, esp
  000b2	66 89 45 f8	 mov	 WORD PTR _src_item$[ebp+44], ax
  000b6	8a 45 0e	 mov	 al, BYTE PTR _DstCell$[ebp+2]
  000b9	66 89 19	 mov	 WORD PTR [ecx], bx
  000bc	88 41 02	 mov	 BYTE PTR [ecx+2], al
  000bf	8b cf		 mov	 ecx, edi
  000c1	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData

; 539  : 	SetItemData(DstCell, src_item);

  000c6	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000c9	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  000cd	f3 0f 7f 45 9c	 movdqu	 XMMWORD PTR _dst_item$[ebp], xmm0
  000d2	f3 0f 6f 40 10	 movdqu	 xmm0, XMMWORD PTR [eax+16]
  000d7	f3 0f 7f 45 ac	 movdqu	 XMMWORD PTR _dst_item$[ebp+16], xmm0
  000dc	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  000e1	66 0f d6 45 bc	 movq	 QWORD PTR _dst_item$[ebp+32], xmm0
  000e6	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000e9	89 4d c4	 mov	 DWORD PTR _dst_item$[ebp+40], ecx
  000ec	0f b7 40 2c	 movzx	 eax, WORD PTR [eax+44]
  000f0	66 89 45 c8	 mov	 WORD PTR _dst_item$[ebp+44], ax
  000f4	8d 45 cc	 lea	 eax, DWORD PTR _src_item$[ebp]
  000f7	50		 push	 eax
  000f8	8a 45 0e	 mov	 al, BYTE PTR _DstCell$[ebp+2]
  000fb	51		 push	 ecx
  000fc	8b cc		 mov	 ecx, esp
  000fe	66 89 19	 mov	 WORD PTR [ecx], bx
  00101	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00104	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00107	ff 52 30	 call	 DWORD PTR [edx+48]

; 540  : 	SetItemData(SrcCell, dst_item);

  0010a	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0010d	8d 45 9c	 lea	 eax, DWORD PTR _dst_item$[ebp]
  00110	50		 push	 eax
  00111	8b 45 08	 mov	 eax, DWORD PTR _SrcCell$[ebp]
  00114	51		 push	 ecx
  00115	8b d4		 mov	 edx, esp
  00117	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0011a	66 89 02	 mov	 WORD PTR [edx], ax
  0011d	8a 45 0a	 mov	 al, BYTE PTR _SrcCell$[ebp+2]
  00120	88 42 02	 mov	 BYTE PTR [edx+2], al
  00123	ff 56 30	 call	 DWORD PTR [esi+48]
$LN1@MoveItemDa:

; 541  : }

  00126	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00129	5f		 pop	 edi
  0012a	5e		 pop	 esi
  0012b	33 cd		 xor	 ecx, ebp
  0012d	5b		 pop	 ebx
  0012e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c2 08 00	 ret	 8
?MoveItemData@CPythonPlayer@@QAEXUSItemPos@@0@Z ENDP	; CPythonPlayer::MoveItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z PROC ; CPythonPlayer::GetItemData, COMDAT
; _this$ = ecx

; 544  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00003	8a 55 08	 mov	 dl, BYTE PTR _Cell$[ebp]
  00006	0f b6 c2	 movzx	 eax, dl
  00009	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 544  : {

  0000a	8b f1		 mov	 esi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  0000c	48		 dec	 eax
  0000d	74 0f		 je	 SHORT $LN12@GetItemDat
  0000f	48		 dec	 eax
  00010	74 0c		 je	 SHORT $LN12@GetItemDat
  00012	83 e8 03	 sub	 eax, 3
  00015	75 4a		 jne	 SHORT $LN1@GetItemDat

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00017	b9 c0 03 00 00	 mov	 ecx, 960		; 000003c0H
  0001c	eb 05		 jmp	 SHORT $LN18@GetItemDat
$LN12@GetItemDat:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  0001e	b9 0d 01 00 00	 mov	 ecx, 269		; 0000010dH
$LN18@GetItemDat:
  00023	66 8b 45 09	 mov	 ax, WORD PTR _Cell$[ebp+1]
  00027	66 3b c1	 cmp	 ax, cx
  0002a	0f 92 c1	 setb	 cl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 545  : 	if (!Cell.IsValidCell())

  0002d	84 c9		 test	 cl, cl
  0002f	74 30		 je	 SHORT $LN1@GetItemDat

; 546  : 		return NULL;
; 547  : 
; 548  : 	switch (Cell.window_type)

  00031	84 d2		 test	 dl, dl
  00033	74 2c		 je	 SHORT $LN1@GetItemDat
  00035	80 fa 02	 cmp	 dl, 2
  00038	76 17		 jbe	 SHORT $LN3@GetItemDat
  0003a	80 fa 05	 cmp	 dl, 5
  0003d	75 22		 jne	 SHORT $LN1@GetItemDat

; 553  : 	case DRAGON_SOUL_INVENTORY:
; 554  : 		return &m_playerStatus.aDSItem[Cell.cell];

  0003f	0f b7 c0	 movzx	 eax, ax
  00042	6b c0 2e	 imul	 eax, eax, 46
  00045	05 c6 30 00 00	 add	 eax, 12486		; 000030c6H
  0004a	03 c6		 add	 eax, esi
  0004c	5e		 pop	 esi

; 557  : 	}
; 558  : }

  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN3@GetItemDat:

; 549  : 	{
; 550  : 	case INVENTORY:
; 551  : 	case EQUIPMENT:
; 552  : 		return &m_playerStatus.aItem[Cell.cell];

  00051	0f b7 c0	 movzx	 eax, ax
  00054	6b c0 2e	 imul	 eax, eax, 46
  00057	83 c0 70	 add	 eax, 112		; 00000070H
  0005a	03 c6		 add	 eax, esi
  0005c	5e		 pop	 esi

; 557  : 	}
; 558  : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
$LN1@GetItemDat:

; 555  : 	default:
; 556  : 		return NULL;

  00061	33 c0		 xor	 eax, eax
  00063	5e		 pop	 esi

; 557  : 	}
; 558  : }

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ENDP ; CPythonPlayer::GetItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetItemData@CPythonPlayer@@UAEXUSItemPos@@ABUpacket_item@@@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
_pItemData$1 = 12					; size = 4
_c_rkItemInst$ = 12					; size = 4
?SetItemData@CPythonPlayer@@UAEXUSItemPos@@ABUpacket_item@@@Z PROC ; CPythonPlayer::SetItemData, COMDAT
; _this$ = ecx

; 561  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00003	8a 55 08	 mov	 dl, BYTE PTR _Cell$[ebp]
  00006	0f b6 c2	 movzx	 eax, dl
  00009	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 561  : {

  0000a	8b f9		 mov	 edi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  0000c	48		 dec	 eax
  0000d	74 13		 je	 SHORT $LN13@SetItemDat
  0000f	48		 dec	 eax
  00010	74 10		 je	 SHORT $LN13@SetItemDat
  00012	83 e8 03	 sub	 eax, 3
  00015	0f 85 01 01 00
	00		 jne	 $LN3@SetItemDat

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  0001b	b9 c0 03 00 00	 mov	 ecx, 960		; 000003c0H
  00020	eb 05		 jmp	 SHORT $LN22@SetItemDat
$LN13@SetItemDat:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  00022	b9 0d 01 00 00	 mov	 ecx, 269		; 0000010dH
$LN22@SetItemDat:
  00027	66 8b 45 09	 mov	 ax, WORD PTR _Cell$[ebp+1]
  0002b	66 3b c1	 cmp	 ax, cx
  0002e	0f 92 c1	 setb	 cl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 562  : 	if (!Cell.IsValidCell())

  00031	84 c9		 test	 cl, cl
  00033	0f 84 e3 00 00
	00		 je	 $LN3@SetItemDat

; 563  : 		return;
; 564  : 
; 565  : 	if (c_rkItemInst.vnum != 0)

  00039	56		 push	 esi
  0003a	8b 75 0c	 mov	 esi, DWORD PTR _c_rkItemInst$[ebp]
  0003d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 3e		 je	 SHORT $LN5@SetItemDat

; 566  : 	{
; 567  : 		CItemData * pItemData;
; 568  : 		if (!CItemManager::Instance().GetItemDataPointer(c_rkItemInst.vnum, &pItemData))

  00043	8d 45 0c	 lea	 eax, DWORD PTR _pItemData$1[ebp]
  00046	50		 push	 eax
  00047	51		 push	 ecx
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  0004e	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  00053	85 c0		 test	 eax, eax
  00055	75 23		 jne	 SHORT $LN20@SetItemDat

; 569  : 		{
; 570  : 			TraceError("CPythonPlayer::SetItemData(window_type : %d, dwSlotIndex=%d, itemIndex=%d) - Failed to item data\n", Cell.window_type, Cell.cell, c_rkItemInst.vnum);

  00057	ff 36		 push	 DWORD PTR [esi]
  00059	8b 45 09	 mov	 eax, DWORD PTR _Cell$[ebp+1]
  0005c	0f b7 c0	 movzx	 eax, ax
  0005f	50		 push	 eax
  00060	8b 45 08	 mov	 eax, DWORD PTR _Cell$[ebp]
  00063	0f b6 c0	 movzx	 eax, al
  00066	50		 push	 eax
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@FMCMFPCN@CPythonPlayer?3?3SetItemData?$CIwindo@
  0006c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00071	83 c4 10	 add	 esp, 16			; 00000010H
  00074	5e		 pop	 esi
  00075	5f		 pop	 edi

; 583  : 		break;
; 584  : 	}
; 585  : }

  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
$LN20@SetItemDat:

; 571  : 			return;

  0007a	66 8b 45 09	 mov	 ax, WORD PTR _Cell$[ebp+1]
  0007e	8a 55 08	 mov	 dl, BYTE PTR _Cell$[ebp]
$LN5@SetItemDat:

; 572  : 		}
; 573  : 	}
; 574  : 
; 575  : 	switch (Cell.window_type)

  00081	84 d2		 test	 dl, dl
  00083	0f 84 92 00 00
	00		 je	 $LN21@SetItemDat
  00089	80 fa 02	 cmp	 dl, 2
  0008c	76 51		 jbe	 SHORT $LN2@SetItemDat
  0008e	80 fa 05	 cmp	 dl, 5
  00091	0f 85 84 00 00
	00		 jne	 $LN21@SetItemDat

; 580  : 		break;
; 581  : 	case DRAGON_SOUL_INVENTORY:
; 582  : 		m_playerStatus.aDSItem[Cell.cell] = c_rkItemInst;

  00097	f3 0f 6f 06	 movdqu	 xmm0, XMMWORD PTR [esi]
  0009b	0f b7 c0	 movzx	 eax, ax
  0009e	6b c8 2e	 imul	 ecx, eax, 46
  000a1	03 cf		 add	 ecx, edi
  000a3	f3 0f 7f 81 c2
	30 00 00	 movdqu	 XMMWORD PTR [ecx+12482], xmm0
  000ab	f3 0f 6f 46 10	 movdqu	 xmm0, XMMWORD PTR [esi+16]
  000b0	f3 0f 7f 81 d2
	30 00 00	 movdqu	 XMMWORD PTR [ecx+12498], xmm0
  000b8	f3 0f 7e 46 20	 movq	 xmm0, QWORD PTR [esi+32]
  000bd	66 0f d6 81 e2
	30 00 00	 movq	 QWORD PTR [ecx+12514], xmm0
  000c5	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000c8	89 81 ea 30 00
	00		 mov	 DWORD PTR [ecx+12522], eax
  000ce	66 8b 46 2c	 mov	 ax, WORD PTR [esi+44]
  000d2	5e		 pop	 esi
  000d3	66 89 81 ee 30
	00 00		 mov	 WORD PTR [ecx+12526], ax
  000da	5f		 pop	 edi

; 583  : 		break;
; 584  : 	}
; 585  : }

  000db	5d		 pop	 ebp
  000dc	c2 08 00	 ret	 8
$LN2@SetItemDat:

; 576  : 	{
; 577  : 	case INVENTORY:
; 578  : 	case EQUIPMENT:
; 579  : 		m_playerStatus.aItem[Cell.cell] = c_rkItemInst;

  000df	f3 0f 6f 06	 movdqu	 xmm0, XMMWORD PTR [esi]
  000e3	0f b7 c0	 movzx	 eax, ax
  000e6	6b c8 2e	 imul	 ecx, eax, 46
  000e9	03 cf		 add	 ecx, edi
  000eb	f3 0f 7f 41 6c	 movdqu	 XMMWORD PTR [ecx+108], xmm0
  000f0	f3 0f 6f 46 10	 movdqu	 xmm0, XMMWORD PTR [esi+16]
  000f5	f3 0f 7f 41 7c	 movdqu	 XMMWORD PTR [ecx+124], xmm0
  000fa	f3 0f 7e 46 20	 movq	 xmm0, QWORD PTR [esi+32]
  000ff	66 0f d6 81 8c
	00 00 00	 movq	 QWORD PTR [ecx+140], xmm0
  00107	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0010a	89 81 94 00 00
	00		 mov	 DWORD PTR [ecx+148], eax
  00110	66 8b 46 2c	 mov	 ax, WORD PTR [esi+44]
  00114	66 89 81 98 00
	00 00		 mov	 WORD PTR [ecx+152], ax
$LN21@SetItemDat:
  0011b	5e		 pop	 esi
$LN3@SetItemDat:
  0011c	5f		 pop	 edi

; 583  : 		break;
; 584  : 	}
; 585  : }

  0011d	5d		 pop	 ebp
  0011e	c2 08 00	 ret	 8
?SetItemData@CPythonPlayer@@UAEXUSItemPos@@ABUpacket_item@@@Z ENDP ; CPythonPlayer::SetItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetItemIndex@CPythonPlayer@@UAEKUSItemPos@@@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
?GetItemIndex@CPythonPlayer@@UAEKUSItemPos@@@Z PROC	; CPythonPlayer::GetItemIndex, COMDAT
; _this$ = ecx

; 588  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00003	66 8b 55 08	 mov	 dx, WORD PTR _Cell$[ebp]
  00007	0f b6 c2	 movzx	 eax, dl
  0000a	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 588  : {

  0000b	8b f1		 mov	 esi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  0000d	48		 dec	 eax
  0000e	74 0f		 je	 SHORT $LN7@GetItemInd
  00010	48		 dec	 eax
  00011	74 0c		 je	 SHORT $LN7@GetItemInd
  00013	83 e8 03	 sub	 eax, 3
  00016	75 17		 jne	 SHORT $LN12@GetItemInd

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00018	b8 c0 03 00 00	 mov	 eax, 960		; 000003c0H
  0001d	eb 05		 jmp	 SHORT $LN13@GetItemInd
$LN7@GetItemInd:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  0001f	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
$LN13@GetItemInd:
  00024	66 39 45 09	 cmp	 WORD PTR _Cell$[ebp+1], ax
  00028	0f 92 c0	 setb	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 589  : 	if (!Cell.IsValidCell())

  0002b	84 c0		 test	 al, al
  0002d	75 07		 jne	 SHORT $LN1@GetItemInd
$LN12@GetItemInd:

; 590  : 		return 0;

  0002f	33 c0		 xor	 eax, eax

; 593  : }

  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN1@GetItemInd:

; 591  : 
; 592  : 	return GetItemData(Cell)->vnum;

  00036	8a 45 0a	 mov	 al, BYTE PTR _Cell$[ebp+2]
  00039	51		 push	 ecx
  0003a	8b cc		 mov	 ecx, esp
  0003c	66 89 11	 mov	 WORD PTR [ecx], dx
  0003f	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00042	8d 4e fc	 lea	 ecx, DWORD PTR [esi-4]
  00045	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData

; 593  : }

  0004a	5e		 pop	 esi
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
?GetItemIndex@CPythonPlayer@@UAEKUSItemPos@@@Z ENDP	; CPythonPlayer::GetItemIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetItemFlags@CPythonPlayer@@UAEKUSItemPos@@@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
?GetItemFlags@CPythonPlayer@@UAEKUSItemPos@@@Z PROC	; CPythonPlayer::GetItemFlags, COMDAT
; _this$ = ecx

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00003	66 8b 55 08	 mov	 dx, WORD PTR _Cell$[ebp]
  00007	0f b6 c2	 movzx	 eax, dl
  0000a	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 596  : {

  0000b	8b f1		 mov	 esi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  0000d	48		 dec	 eax
  0000e	74 0f		 je	 SHORT $LN7@GetItemFla
  00010	48		 dec	 eax
  00011	74 0c		 je	 SHORT $LN7@GetItemFla
  00013	83 e8 03	 sub	 eax, 3
  00016	75 17		 jne	 SHORT $LN12@GetItemFla

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00018	b8 c0 03 00 00	 mov	 eax, 960		; 000003c0H
  0001d	eb 05		 jmp	 SHORT $LN13@GetItemFla
$LN7@GetItemFla:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  0001f	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
$LN13@GetItemFla:
  00024	66 39 45 09	 cmp	 WORD PTR _Cell$[ebp+1], ax
  00028	0f 92 c0	 setb	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 597  : 	if (!Cell.IsValidCell())

  0002b	84 c0		 test	 al, al
  0002d	75 07		 jne	 SHORT $LN1@GetItemFla
$LN12@GetItemFla:

; 598  : 		return 0;

  0002f	33 c0		 xor	 eax, eax

; 600  : 	assert (pItem != NULL);
; 601  : 	return pItem->flags;
; 602  : }

  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN1@GetItemFla:

; 599  : 	const TItemData * pItem = GetItemData(Cell);

  00036	8a 45 0a	 mov	 al, BYTE PTR _Cell$[ebp+2]
  00039	51		 push	 ecx
  0003a	8b cc		 mov	 ecx, esp
  0003c	66 89 11	 mov	 WORD PTR [ecx], dx
  0003f	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00042	8d 4e fc	 lea	 ecx, DWORD PTR [esi-4]
  00045	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData

; 600  : 	assert (pItem != NULL);
; 601  : 	return pItem->flags;
; 602  : }

  0004a	5e		 pop	 esi
  0004b	8b 40 05	 mov	 eax, DWORD PTR [eax+5]
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
?GetItemFlags@CPythonPlayer@@UAEKUSItemPos@@@Z ENDP	; CPythonPlayer::GetItemFlags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetItemCount@CPythonPlayer@@UAEKUSItemPos@@@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
?GetItemCount@CPythonPlayer@@UAEKUSItemPos@@@Z PROC	; CPythonPlayer::GetItemCount, COMDAT
; _this$ = ecx

; 605  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00003	66 8b 55 08	 mov	 dx, WORD PTR _Cell$[ebp]
  00007	0f b6 c2	 movzx	 eax, dl
  0000a	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 605  : {

  0000b	8b f1		 mov	 esi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  0000d	48		 dec	 eax
  0000e	74 0f		 je	 SHORT $LN9@GetItemCou
  00010	48		 dec	 eax
  00011	74 0c		 je	 SHORT $LN9@GetItemCou
  00013	83 e8 03	 sub	 eax, 3
  00016	75 17		 jne	 SHORT $LN14@GetItemCou

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00018	b8 c0 03 00 00	 mov	 eax, 960		; 000003c0H
  0001d	eb 05		 jmp	 SHORT $LN15@GetItemCou
$LN9@GetItemCou:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  0001f	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
$LN15@GetItemCou:
  00024	66 39 45 09	 cmp	 WORD PTR _Cell$[ebp+1], ax
  00028	0f 92 c0	 setb	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 606  : 	if (!Cell.IsValidCell())

  0002b	84 c0		 test	 al, al
  0002d	75 07		 jne	 SHORT $LN3@GetItemCou
$LN14@GetItemCou:

; 607  : 		return 0;

  0002f	33 c0		 xor	 eax, eax

; 613  : }

  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN3@GetItemCou:

; 608  : 	const TItemData * pItem = GetItemData(Cell);

  00036	8a 45 0a	 mov	 al, BYTE PTR _Cell$[ebp+2]
  00039	51		 push	 ecx
  0003a	8b cc		 mov	 ecx, esp
  0003c	66 89 11	 mov	 WORD PTR [ecx], dx
  0003f	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00042	8d 4e fc	 lea	 ecx, DWORD PTR [esi-4]
  00045	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData

; 609  : 	if (pItem == NULL)

  0004a	85 c0		 test	 eax, eax
  0004c	74 e1		 je	 SHORT $LN14@GetItemCou

; 610  : 		return 0;
; 611  : 	else
; 612  : 		return pItem->count;

  0004e	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]

; 613  : }

  00052	5e		 pop	 esi
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?GetItemCount@CPythonPlayer@@UAEKUSItemPos@@@Z ENDP	; CPythonPlayer::GetItemCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetItemCountByVnum@CPythonPlayer@@QAEKK@Z
_TEXT	SEGMENT
_dwVnum$ = 8						; size = 4
?GetItemCountByVnum@CPythonPlayer@@QAEKK@Z PROC		; CPythonPlayer::GetItemCountByVnum, COMDAT
; _this$ = ecx

; 616  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 617  : 	DWORD dwCount = 0;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _dwVnum$[ebp]
  00008	33 c0		 xor	 eax, eax
  0000a	83 c1 70	 add	 ecx, 112		; 00000070H
  0000d	be 0d 01 00 00	 mov	 esi, 269		; 0000010dH
$LL4@GetItemCou:

; 620  : 	{
; 621  : 		const TItemData & c_rItemData = m_playerStatus.aItem[i];
; 622  : 		if (c_rItemData.vnum == dwVnum)

  00012	39 39		 cmp	 DWORD PTR [ecx], edi
  00014	75 06		 jne	 SHORT $LN3@GetItemCou

; 623  : 		{
; 624  : 			dwCount += c_rItemData.count;

  00016	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  0001a	03 c2		 add	 eax, edx
$LN3@GetItemCou:

; 618  : 
; 619  : 	for (int i = 0; i < c_Inventory_Count; ++i)

  0001c	83 c1 2e	 add	 ecx, 46			; 0000002eH
  0001f	4e		 dec	 esi
  00020	75 f0		 jne	 SHORT $LL4@GetItemCou
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 625  : 		}
; 626  : 	}
; 627  : 
; 628  : 	return dwCount;
; 629  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?GetItemCountByVnum@CPythonPlayer@@QAEKK@Z ENDP		; CPythonPlayer::GetItemCountByVnum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetItemMetinSocket@CPythonPlayer@@QAEKUSItemPos@@K@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
_dwMetinSocketIndex$ = 12				; size = 4
?GetItemMetinSocket@CPythonPlayer@@QAEKUSItemPos@@K@Z PROC ; CPythonPlayer::GetItemMetinSocket, COMDAT
; _this$ = ecx

; 632  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00007	66 8b 4d 08	 mov	 cx, WORD PTR _Cell$[ebp]
  0000b	0f b6 c1	 movzx	 eax, cl
  0000e	48		 dec	 eax
  0000f	74 0f		 je	 SHORT $LN8@GetItemMet
  00011	48		 dec	 eax
  00012	74 0c		 je	 SHORT $LN8@GetItemMet
  00014	83 e8 03	 sub	 eax, 3
  00017	75 17		 jne	 SHORT $LN13@GetItemMet

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00019	b8 c0 03 00 00	 mov	 eax, 960		; 000003c0H
  0001e	eb 05		 jmp	 SHORT $LN14@GetItemMet
$LN8@GetItemMet:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  00020	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
$LN14@GetItemMet:
  00025	66 39 45 09	 cmp	 WORD PTR _Cell$[ebp+1], ax
  00029	0f 92 c0	 setb	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 633  : 	if (!Cell.IsValidCell())

  0002c	84 c0		 test	 al, al
  0002e	75 08		 jne	 SHORT $LN2@GetItemMet
$LN13@GetItemMet:

; 634  : 		return 0;

  00030	33 c0		 xor	 eax, eax

; 640  : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN2@GetItemMet:

; 635  : 
; 636  : 	if (dwMetinSocketIndex >= ITEM_SOCKET_SLOT_MAX_NUM)

  00038	8b 75 0c	 mov	 esi, DWORD PTR _dwMetinSocketIndex$[ebp]
  0003b	83 fe 03	 cmp	 esi, 3
  0003e	73 f0		 jae	 SHORT $LN13@GetItemMet

; 637  : 		return 0;
; 638  : 
; 639  : 	return GetItemData(Cell)->alSockets[dwMetinSocketIndex];

  00040	51		 push	 ecx
  00041	8b d4		 mov	 edx, esp
  00043	66 89 0a	 mov	 WORD PTR [edx], cx
  00046	8a 4d 0a	 mov	 cl, BYTE PTR _Cell$[ebp+2]
  00049	88 4a 02	 mov	 BYTE PTR [edx+2], cl
  0004c	8b cf		 mov	 ecx, edi
  0004e	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData

; 640  : }

  00053	5f		 pop	 edi
  00054	8b 44 b0 0d	 mov	 eax, DWORD PTR [eax+esi*4+13]
  00058	5e		 pop	 esi
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
?GetItemMetinSocket@CPythonPlayer@@QAEKUSItemPos@@K@Z ENDP ; CPythonPlayer::GetItemMetinSocket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetItemAttribute@CPythonPlayer@@QAEXUSItemPos@@KPAEPAF@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_Cell$ = 8						; size = 3
_dwAttrSlotIndex$ = 12					; size = 4
_pbyType$ = 16						; size = 4
_psValue$ = 20						; size = 4
?GetItemAttribute@CPythonPlayer@@QAEXUSItemPos@@KPAEPAF@Z PROC ; CPythonPlayer::GetItemAttribute, COMDAT
; _this$ = ecx

; 643  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00004	66 8b 55 08	 mov	 dx, WORD PTR _Cell$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 645  : 	*psValue = 0;

  00008	33 c0		 xor	 eax, eax
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR _psValue$[ebp]
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR _pbyType$[ebp]
  00013	66 89 03	 mov	 WORD PTR [ebx], ax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00016	0f b6 c2	 movzx	 eax, dl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 643  : {

  00019	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 644  : 	*pbyType = 0;

  0001c	c6 07 00	 mov	 BYTE PTR [edi], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  0001f	48		 dec	 eax
  00020	74 0f		 je	 SHORT $LN8@GetItemAtt
  00022	48		 dec	 eax
  00023	74 0c		 je	 SHORT $LN8@GetItemAtt
  00025	83 e8 03	 sub	 eax, 3
  00028	75 45		 jne	 SHORT $LN3@GetItemAtt

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  0002a	b8 c0 03 00 00	 mov	 eax, 960		; 000003c0H
  0002f	eb 05		 jmp	 SHORT $LN13@GetItemAtt
$LN8@GetItemAtt:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  00031	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
$LN13@GetItemAtt:
  00036	66 39 45 09	 cmp	 WORD PTR _Cell$[ebp+1], ax
  0003a	0f 92 c0	 setb	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 647  : 	if (!Cell.IsValidCell())

  0003d	84 c0		 test	 al, al
  0003f	74 2e		 je	 SHORT $LN3@GetItemAtt

; 648  : 		return;
; 649  : 
; 650  : 	if (dwAttrSlotIndex >= ITEM_ATTRIBUTE_SLOT_MAX_NUM)

  00041	8b 75 0c	 mov	 esi, DWORD PTR _dwAttrSlotIndex$[ebp]
  00044	83 fe 07	 cmp	 esi, 7
  00047	73 26		 jae	 SHORT $LN3@GetItemAtt

; 651  : 		return;
; 652  : 
; 653  : 	*pbyType = GetItemData(Cell)->aAttr[dwAttrSlotIndex].bType;

  00049	8a 45 0a	 mov	 al, BYTE PTR _Cell$[ebp+2]
  0004c	51		 push	 ecx
  0004d	8b cc		 mov	 ecx, esp
  0004f	66 89 11	 mov	 WORD PTR [ecx], dx
  00052	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00058	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData
  0005d	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00060	03 c8		 add	 ecx, eax
  00062	0f b6 41 19	 movzx	 eax, BYTE PTR [ecx+25]
  00066	88 07		 mov	 BYTE PTR [edi], al

; 654  : 	*psValue = GetItemData(Cell)->aAttr[dwAttrSlotIndex].sValue;

  00068	66 8b 41 1a	 mov	 ax, WORD PTR [ecx+26]
  0006c	66 89 03	 mov	 WORD PTR [ebx], ax
$LN3@GetItemAtt:

; 655  : }

  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 10 00	 ret	 16			; 00000010H
?GetItemAttribute@CPythonPlayer@@QAEXUSItemPos@@KPAEPAF@Z ENDP ; CPythonPlayer::GetItemAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetItemCount@CPythonPlayer@@UAEXUSItemPos@@E@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
_byCount$ = 12						; size = 1
?SetItemCount@CPythonPlayer@@UAEXUSItemPos@@E@Z PROC	; CPythonPlayer::SetItemCount, COMDAT
; _this$ = ecx

; 658  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00003	66 8b 55 08	 mov	 dx, WORD PTR _Cell$[ebp]
  00007	0f b6 c2	 movzx	 eax, dl
  0000a	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 658  : {

  0000b	8b f1		 mov	 esi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  0000d	48		 dec	 eax
  0000e	74 0f		 je	 SHORT $LN7@SetItemCou
  00010	48		 dec	 eax
  00011	74 0c		 je	 SHORT $LN7@SetItemCou
  00013	83 e8 03	 sub	 eax, 3
  00016	75 4d		 jne	 SHORT $LN2@SetItemCou

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00018	b8 c0 03 00 00	 mov	 eax, 960		; 000003c0H
  0001d	eb 05		 jmp	 SHORT $LN12@SetItemCou
$LN7@SetItemCou:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  0001f	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
$LN12@SetItemCou:
  00024	66 39 45 09	 cmp	 WORD PTR _Cell$[ebp+1], ax
  00028	0f 92 c0	 setb	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 659  : 	if (!Cell.IsValidCell())

  0002b	84 c0		 test	 al, al
  0002d	74 36		 je	 SHORT $LN2@SetItemCou

; 660  : 		return;
; 661  : 
; 662  : 	(const_cast <TItemData *>(GetItemData(Cell)))->count = byCount;

  0002f	8a 45 0a	 mov	 al, BYTE PTR _Cell$[ebp+2]
  00032	51		 push	 ecx
  00033	8b cc		 mov	 ecx, esp
  00035	66 89 11	 mov	 WORD PTR [ecx], dx
  00038	88 41 02	 mov	 BYTE PTR [ecx+2], al
  0003b	8d 4e fc	 lea	 ecx, DWORD PTR [esi-4]
  0003e	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData
  00043	8a 4d 0c	 mov	 cl, BYTE PTR _byCount$[ebp]

; 663  : 	PyCallClassMemberFunc(m_ppyGameWindow, "RefreshInventory", Py_BuildValue("()"));	

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0004b	88 48 04	 mov	 BYTE PTR [eax+4], cl
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JLCHKFKI@RefreshInventory?$AA@
  0005a	ff 76 04	 push	 DWORD PTR [esi+4]
  0005d	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00062	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@SetItemCou:

; 664  : }

  00065	5e		 pop	 esi
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
?SetItemCount@CPythonPlayer@@UAEXUSItemPos@@E@Z ENDP	; CPythonPlayer::SetItemCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetItemMetinSocket@CPythonPlayer@@UAEXUSItemPos@@KK@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
_dwMetinSocketIndex$ = 12				; size = 4
_dwMetinNumber$ = 16					; size = 4
?SetItemMetinSocket@CPythonPlayer@@UAEXUSItemPos@@KK@Z PROC ; CPythonPlayer::SetItemMetinSocket, COMDAT
; _this$ = ecx

; 667  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00003	66 8b 55 08	 mov	 dx, WORD PTR _Cell$[ebp]
  00007	56		 push	 esi
  00008	0f b6 c2	 movzx	 eax, dl
  0000b	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 667  : {

  0000c	8b f9		 mov	 edi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  0000e	48		 dec	 eax
  0000f	74 0f		 je	 SHORT $LN8@SetItemMet
  00011	48		 dec	 eax
  00012	74 0c		 je	 SHORT $LN8@SetItemMet
  00014	83 e8 03	 sub	 eax, 3
  00017	75 3a		 jne	 SHORT $LN3@SetItemMet

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00019	b8 c0 03 00 00	 mov	 eax, 960		; 000003c0H
  0001e	eb 05		 jmp	 SHORT $LN13@SetItemMet
$LN8@SetItemMet:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  00020	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
$LN13@SetItemMet:
  00025	66 39 45 09	 cmp	 WORD PTR _Cell$[ebp+1], ax
  00029	0f 92 c0	 setb	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 668  : 	if (!Cell.IsValidCell())

  0002c	84 c0		 test	 al, al
  0002e	74 23		 je	 SHORT $LN3@SetItemMet

; 669  : 		return;
; 670  : 	if (dwMetinSocketIndex >= ITEM_SOCKET_SLOT_MAX_NUM)

  00030	8b 75 0c	 mov	 esi, DWORD PTR _dwMetinSocketIndex$[ebp]
  00033	83 fe 03	 cmp	 esi, 3
  00036	73 1b		 jae	 SHORT $LN3@SetItemMet

; 671  : 		return;
; 672  : 
; 673  : 	(const_cast <TItemData *>(GetItemData(Cell)))->alSockets[dwMetinSocketIndex] = dwMetinNumber;

  00038	8a 45 0a	 mov	 al, BYTE PTR _Cell$[ebp+2]
  0003b	51		 push	 ecx
  0003c	8b cc		 mov	 ecx, esp
  0003e	66 89 11	 mov	 WORD PTR [ecx], dx
  00041	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00044	8d 4f fc	 lea	 ecx, DWORD PTR [edi-4]
  00047	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData
  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _dwMetinNumber$[ebp]
  0004f	89 4c b0 0d	 mov	 DWORD PTR [eax+esi*4+13], ecx
$LN3@SetItemMet:

; 674  : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 0c 00	 ret	 12			; 0000000cH
?SetItemMetinSocket@CPythonPlayer@@UAEXUSItemPos@@KK@Z ENDP ; CPythonPlayer::SetItemMetinSocket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetItemAttribute@CPythonPlayer@@UAEXUSItemPos@@KEF@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
_dwAttrIndex$ = 12					; size = 4
_byType$ = 16						; size = 1
_sValue$ = 20						; size = 2
?SetItemAttribute@CPythonPlayer@@UAEXUSItemPos@@KEF@Z PROC ; CPythonPlayer::SetItemAttribute, COMDAT
; _this$ = ecx

; 677  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00003	66 8b 55 08	 mov	 dx, WORD PTR _Cell$[ebp]
  00007	0f b6 c2	 movzx	 eax, dl
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	48		 dec	 eax
  0000d	74 0f		 je	 SHORT $LN8@SetItemAtt
  0000f	48		 dec	 eax
  00010	74 0c		 je	 SHORT $LN8@SetItemAtt
  00012	83 e8 03	 sub	 eax, 3
  00015	75 5e		 jne	 SHORT $LN3@SetItemAtt

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00017	b8 c0 03 00 00	 mov	 eax, 960		; 000003c0H
  0001c	eb 05		 jmp	 SHORT $LN13@SetItemAtt
$LN8@SetItemAtt:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  0001e	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
$LN13@SetItemAtt:
  00023	66 39 45 09	 cmp	 WORD PTR _Cell$[ebp+1], ax
  00027	0f 92 c0	 setb	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 678  : 	if (!Cell.IsValidCell())

  0002a	84 c0		 test	 al, al
  0002c	74 47		 je	 SHORT $LN3@SetItemAtt

; 679  : 		return;
; 680  : 	if (dwAttrIndex >= ITEM_ATTRIBUTE_SLOT_MAX_NUM)

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _dwAttrIndex$[ebp]
  00031	83 f8 07	 cmp	 eax, 7
  00034	73 3f		 jae	 SHORT $LN3@SetItemAtt

; 681  : 		return;
; 682  : 
; 683  : 	(const_cast <TItemData *>(GetItemData(Cell)))->aAttr[dwAttrIndex].bType = byType;

  00036	51		 push	 ecx
  00037	8d 71 fc	 lea	 esi, DWORD PTR [ecx-4]
  0003a	8b cc		 mov	 ecx, esp
  0003c	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0003f	8a 45 0a	 mov	 al, BYTE PTR _Cell$[ebp+2]
  00042	66 89 11	 mov	 WORD PTR [ecx], dx
  00045	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData
  0004f	8a 55 10	 mov	 dl, BYTE PTR _byType$[ebp]

; 684  : 	(const_cast <TItemData *>(GetItemData(Cell)))->aAttr[dwAttrIndex].sValue = sValue;

  00052	51		 push	 ecx
  00053	8b ce		 mov	 ecx, esi
  00055	88 54 38 19	 mov	 BYTE PTR [eax+edi+25], dl
  00059	8b d4		 mov	 edx, esp
  0005b	8b 45 08	 mov	 eax, DWORD PTR _Cell$[ebp]
  0005e	66 89 02	 mov	 WORD PTR [edx], ax
  00061	8a 45 0a	 mov	 al, BYTE PTR _Cell$[ebp+2]
  00064	88 42 02	 mov	 BYTE PTR [edx+2], al
  00067	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData
  0006c	66 8b 4d 14	 mov	 cx, WORD PTR _sValue$[ebp]
  00070	66 89 4c 38 1a	 mov	 WORD PTR [eax+edi+26], cx
$LN3@SetItemAtt:

; 685  : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5d		 pop	 ebp
  00078	c2 10 00	 ret	 16			; 00000010H
?SetItemAttribute@CPythonPlayer@@UAEXUSItemPos@@KEF@Z ENDP ; CPythonPlayer::SetItemAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetQuickPage@CPythonPlayer@@QAEHXZ
_TEXT	SEGMENT
?GetQuickPage@CPythonPlayer@@QAEHXZ PROC		; CPythonPlayer::GetQuickPage, COMDAT
; _this$ = ecx

; 689  : 	return m_playerStatus.lQuickPageIndex;

  00000	8b 81 64 09 01
	00		 mov	 eax, DWORD PTR [ecx+67940]

; 690  : }

  00006	c3		 ret	 0
?GetQuickPage@CPythonPlayer@@QAEHXZ ENDP		; CPythonPlayer::GetQuickPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetQuickPage@CPythonPlayer@@QAEXH@Z
_TEXT	SEGMENT
_nQuickPageIndex$ = 8					; size = 4
?SetQuickPage@CPythonPlayer@@QAEXH@Z PROC		; CPythonPlayer::SetQuickPage, COMDAT
; _this$ = ecx

; 693  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 694  : 	if (nQuickPageIndex<0)

  00003	8b 45 08	 mov	 eax, DWORD PTR _nQuickPageIndex$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 c0		 test	 eax, eax
  0000b	79 05		 jns	 SHORT $LN4@SetQuickPa

; 695  : 		m_playerStatus.lQuickPageIndex=QUICKSLOT_MAX_LINE+nQuickPageIndex;	

  0000d	83 c0 04	 add	 eax, 4
  00010	eb 11		 jmp	 SHORT $LN2@SetQuickPa
$LN4@SetQuickPa:

; 696  : 	else if (nQuickPageIndex>=QUICKSLOT_MAX_LINE)

  00012	83 f8 04	 cmp	 eax, 4
  00015	7c 0c		 jl	 SHORT $LN2@SetQuickPa

; 697  : 		m_playerStatus.lQuickPageIndex=nQuickPageIndex%QUICKSLOT_MAX_LINE;	

  00017	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0001c	79 05		 jns	 SHORT $LN2@SetQuickPa
  0001e	48		 dec	 eax
  0001f	83 c8 fc	 or	 eax, -4			; fffffffcH
  00022	40		 inc	 eax
$LN2@SetQuickPa:

; 698  : 	else
; 699  : 		m_playerStatus.lQuickPageIndex=nQuickPageIndex;	
; 700  : 
; 701  : 	PyCallClassMemberFunc(m_ppyGameWindow, "RefreshInventory", Py_BuildValue("()"));

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00028	89 86 64 09 01
	00		 mov	 DWORD PTR [esi+67940], eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00034	50		 push	 eax
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JLCHKFKI@RefreshInventory?$AA@
  0003a	ff 76 08	 push	 DWORD PTR [esi+8]
  0003d	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00042	83 c4 10	 add	 esp, 16			; 00000010H
  00045	5e		 pop	 esi

; 702  : }

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?SetQuickPage@CPythonPlayer@@QAEXH@Z ENDP		; CPythonPlayer::SetQuickPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?LocalQuickSlotIndexToGlobalQuickSlotIndex@CPythonPlayer@@QAEKK@Z
_TEXT	SEGMENT
_dwLocalSlotIndex$ = 8					; size = 4
?LocalQuickSlotIndexToGlobalQuickSlotIndex@CPythonPlayer@@QAEKK@Z PROC ; CPythonPlayer::LocalQuickSlotIndexToGlobalQuickSlotIndex, COMDAT
; _this$ = ecx

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 706  : 	return m_playerStatus.lQuickPageIndex*QUICKSLOT_MAX_COUNT_PER_LINE+dwLocalSlotIndex;	

  00003	8b 89 64 09 01
	00		 mov	 ecx, DWORD PTR [ecx+67940]
  00009	8b 45 08	 mov	 eax, DWORD PTR _dwLocalSlotIndex$[ebp]
  0000c	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 707  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?LocalQuickSlotIndexToGlobalQuickSlotIndex@CPythonPlayer@@QAEKK@Z ENDP ; CPythonPlayer::LocalQuickSlotIndexToGlobalQuickSlotIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetGlobalQuickSlotData@CPythonPlayer@@QAEXKPAK0@Z
_TEXT	SEGMENT
_dwGlobalSlotIndex$ = 8					; size = 4
_pdwWndType$ = 12					; size = 4
_pdwWndItemPos$ = 16					; size = 4
?GetGlobalQuickSlotData@CPythonPlayer@@QAEXKPAK0@Z PROC	; CPythonPlayer::GetGlobalQuickSlotData, COMDAT
; _this$ = ecx

; 710  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 711  : 	TQuickSlot& rkQuickSlot=__RefGlobalQuickSlot(dwGlobalSlotIndex);

  00003	ff 75 08	 push	 DWORD PTR _dwGlobalSlotIndex$[ebp]
  00006	e8 00 00 00 00	 call	 ?__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z ; CPythonPlayer::__RefGlobalQuickSlot

; 712  : 	*pdwWndType=rkQuickSlot.Type;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwWndType$[ebp]
  0000e	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00011	89 11		 mov	 DWORD PTR [ecx], edx

; 713  : 	*pdwWndItemPos=rkQuickSlot.Position;

  00013	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00017	8b 45 10	 mov	 eax, DWORD PTR _pdwWndItemPos$[ebp]
  0001a	89 08		 mov	 DWORD PTR [eax], ecx

; 714  : }

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
?GetGlobalQuickSlotData@CPythonPlayer@@QAEXKPAK0@Z ENDP	; CPythonPlayer::GetGlobalQuickSlotData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetLocalQuickSlotData@CPythonPlayer@@QAEXKPAK0@Z
_TEXT	SEGMENT
_dwSlotPos$ = 8						; size = 4
_pdwWndType$ = 12					; size = 4
_pdwWndItemPos$ = 16					; size = 4
?GetLocalQuickSlotData@CPythonPlayer@@QAEXKPAK0@Z PROC	; CPythonPlayer::GetLocalQuickSlotData, COMDAT
; _this$ = ecx

; 717  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 718  : 	TQuickSlot& rkQuickSlot=__RefLocalQuickSlot(dwSlotPos);

  00003	ff 75 08	 push	 DWORD PTR _dwSlotPos$[ebp]
  00006	e8 00 00 00 00	 call	 ?__RefLocalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z ; CPythonPlayer::__RefLocalQuickSlot

; 719  : 	*pdwWndType=rkQuickSlot.Type;

  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwWndType$[ebp]
  0000e	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00011	89 11		 mov	 DWORD PTR [ecx], edx

; 720  : 	*pdwWndItemPos=rkQuickSlot.Position;

  00013	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00017	8b 45 10	 mov	 eax, DWORD PTR _pdwWndItemPos$[ebp]
  0001a	89 08		 mov	 DWORD PTR [eax], ecx

; 721  : }

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
?GetLocalQuickSlotData@CPythonPlayer@@QAEXKPAK0@Z ENDP	; CPythonPlayer::GetLocalQuickSlotData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__RefLocalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z
_TEXT	SEGMENT
_SlotIndex$ = 8						; size = 4
?__RefLocalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z PROC ; CPythonPlayer::__RefLocalQuickSlot, COMDAT
; _this$ = ecx

; 724  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return __RefGlobalQuickSlot(LocalQuickSlotIndexToGlobalQuickSlotIndex(SlotIndex));

  00003	ff 75 08	 push	 DWORD PTR _SlotIndex$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	e8 00 00 00 00	 call	 ?LocalQuickSlotIndexToGlobalQuickSlotIndex@CPythonPlayer@@QAEKK@Z ; CPythonPlayer::LocalQuickSlotIndexToGlobalQuickSlotIndex
  0000d	89 45 08	 mov	 DWORD PTR _SlotIndex$[ebp], eax
  00010	8b ca		 mov	 ecx, edx

; 726  : }

  00012	5d		 pop	 ebp

; 725  : 	return __RefGlobalQuickSlot(LocalQuickSlotIndexToGlobalQuickSlotIndex(SlotIndex));

  00013	e9 00 00 00 00	 jmp	 ?__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z ; CPythonPlayer::__RefGlobalQuickSlot
?__RefLocalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z ENDP ; CPythonPlayer::__RefLocalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z
_TEXT	SEGMENT
_SlotIndex$ = 8						; size = 4
?__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z PROC ; CPythonPlayer::__RefGlobalQuickSlot, COMDAT
; _this$ = ecx

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 730  : 	if (SlotIndex < 0 || SlotIndex >= QUICKSLOT_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _SlotIndex$[ebp]
  00006	83 f8 23	 cmp	 eax, 35			; 00000023H
  00009	77 0c		 ja	 SHORT $LN1@RefGlobalQ

; 736  : 	}
; 737  : 
; 738  : 	return m_playerStatus.aQuickSlot[SlotIndex];

  0000b	05 a3 6e 00 00	 add	 eax, 28323		; 00006ea3H
  00010	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 739  : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
$LN1@RefGlobalQ:

; 731  : 	{
; 732  : 		static TQuickSlot s_kQuickSlot;
; 733  : 		s_kQuickSlot.Type = 0;

  00017	66 c7 05 00 00
	00 00 00 00	 mov	 WORD PTR ?s_kQuickSlot@?4??__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z@4U3@A, 0

; 734  : 		s_kQuickSlot.Position = 0;
; 735  : 		return s_kQuickSlot;

  00020	b8 00 00 00 00	 mov	 eax, OFFSET ?s_kQuickSlot@?4??__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z@4U3@A

; 739  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z ENDP ; CPythonPlayer::__RefGlobalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?RemoveQuickSlotByValue@CPythonPlayer@@QAEXHH@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 1
_iType$ = 8						; size = 4
_iPosition$ = 12					; size = 4
?RemoveQuickSlotByValue@CPythonPlayer@@QAEXHH@Z PROC	; CPythonPlayer::RemoveQuickSlotByValue, COMDAT
; _this$ = ecx

; 742  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 743  : 	for (BYTE i = 0; i < QUICKSLOT_MAX_NUM; ++i)

  00006	32 db		 xor	 bl, bl
  00008	8d b1 47 dd 00
	00		 lea	 esi, DWORD PTR [ecx+56647]
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR _iPosition$[ebp]
  00012	88 5d fc	 mov	 BYTE PTR _i$1[ebp], bl
$LL5@RemoveQuic:

; 744  : 	{
; 745  : 		if (iType == m_playerStatus.aQuickSlot[i].Type)

  00015	0f b6 46 ff	 movzx	 eax, BYTE PTR [esi-1]
  00019	39 45 08	 cmp	 DWORD PTR _iType$[ebp], eax
  0001c	75 15		 jne	 SHORT $LN4@RemoveQuic

; 746  : 			if (iPosition == m_playerStatus.aQuickSlot[i].Position)

  0001e	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00021	3b f8		 cmp	 edi, eax
  00023	75 0e		 jne	 SHORT $LN4@RemoveQuic

; 747  : 				CPythonNetworkStream::Instance().SendQuickSlotDelPacket(i);

  00025	ff 75 fc	 push	 DWORD PTR _i$1[ebp]
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  0002e	e8 00 00 00 00	 call	 ?SendQuickSlotDelPacket@CPythonNetworkStream@@QAE_NE@Z ; CPythonNetworkStream::SendQuickSlotDelPacket
$LN4@RemoveQuic:

; 743  : 	for (BYTE i = 0; i < QUICKSLOT_MAX_NUM; ++i)

  00033	fe c3		 inc	 bl
  00035	83 c6 02	 add	 esi, 2
  00038	88 5d fc	 mov	 BYTE PTR _i$1[ebp], bl
  0003b	80 fb 24	 cmp	 bl, 36			; 00000024H
  0003e	72 d5		 jb	 SHORT $LL5@RemoveQuic
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx

; 748  : 	}
; 749  : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?RemoveQuickSlotByValue@CPythonPlayer@@QAEXHH@Z ENDP	; CPythonPlayer::RemoveQuickSlotByValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsItem@CPythonPlayer@@QAEDUSItemPos@@@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
?IsItem@CPythonPlayer@@QAEDUSItemPos@@@Z PROC		; CPythonPlayer::IsItem, COMDAT
; _this$ = ecx

; 752  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  00003	66 8b 55 08	 mov	 dx, WORD PTR _Cell$[ebp]
  00007	0f b6 c2	 movzx	 eax, dl
  0000a	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 752  : {

  0000b	8b f1		 mov	 esi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 206  : 		switch (window_type)

  0000d	48		 dec	 eax
  0000e	74 0f		 je	 SHORT $LN7@IsItem
  00010	48		 dec	 eax
  00011	74 0c		 je	 SHORT $LN7@IsItem
  00013	83 e8 03	 sub	 eax, 3
  00016	75 17		 jne	 SHORT $LN12@IsItem

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00018	b8 c0 03 00 00	 mov	 eax, 960		; 000003c0H
  0001d	eb 05		 jmp	 SHORT $LN13@IsItem
$LN7@IsItem:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  0001f	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
$LN13@IsItem:
  00024	66 39 45 09	 cmp	 WORD PTR _Cell$[ebp+1], ax
  00028	0f 92 c0	 setb	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 753  : 	if (!Cell.IsValidCell())

  0002b	84 c0		 test	 al, al
  0002d	75 07		 jne	 SHORT $LN1@IsItem
$LN12@IsItem:

; 754  : 		return 0;

  0002f	32 c0		 xor	 al, al

; 757  : }

  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN1@IsItem:

; 755  : 
; 756  : 	return 0 != GetItemData(Cell)->vnum;

  00036	8a 45 0a	 mov	 al, BYTE PTR _Cell$[ebp+2]
  00039	51		 push	 ecx
  0003a	8b cc		 mov	 ecx, esp
  0003c	66 89 11	 mov	 WORD PTR [ecx], dx
  0003f	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00042	8b ce		 mov	 ecx, esi
  00044	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData

; 757  : }

  00049	5e		 pop	 esi
  0004a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004d	0f 95 c0	 setne	 al
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?IsItem@CPythonPlayer@@QAEDUSItemPos@@@Z ENDP		; CPythonPlayer::IsItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?RequestMoveGlobalQuickSlotToLocalQuickSlot@CPythonPlayer@@QAEXKK@Z
_TEXT	SEGMENT
_dwGlobalSrcSlotIndex$ = 8				; size = 4
_dwLocalDstSlotIndex$ = 12				; size = 4
?RequestMoveGlobalQuickSlotToLocalQuickSlot@CPythonPlayer@@QAEXKK@Z PROC ; CPythonPlayer::RequestMoveGlobalQuickSlotToLocalQuickSlot, COMDAT
; _this$ = ecx

; 760  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 761  : 	//DWORD dwGlobalSrcSlotIndex=LocalQuickSlotIndexToGlobalQuickSlotIndex(dwLocalSrcSlotIndex);
; 762  : 	DWORD dwGlobalDstSlotIndex=LocalQuickSlotIndexToGlobalQuickSlotIndex(dwLocalDstSlotIndex);

  00003	ff 75 0c	 push	 DWORD PTR _dwLocalDstSlotIndex$[ebp]
  00006	e8 00 00 00 00	 call	 ?LocalQuickSlotIndexToGlobalQuickSlotIndex@CPythonPlayer@@QAEKK@Z ; CPythonPlayer::LocalQuickSlotIndexToGlobalQuickSlotIndex

; 763  : 
; 764  : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 765  : 	rkNetStream.SendQuickSlotMovePacket((BYTE) dwGlobalSrcSlotIndex, (BYTE)dwGlobalDstSlotIndex);

  0000b	89 45 0c	 mov	 DWORD PTR _dwLocalDstSlotIndex$[ebp], eax
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton

; 766  : }

  00014	5d		 pop	 ebp

; 763  : 
; 764  : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 765  : 	rkNetStream.SendQuickSlotMovePacket((BYTE) dwGlobalSrcSlotIndex, (BYTE)dwGlobalDstSlotIndex);

  00015	e9 00 00 00 00	 jmp	 ?SendQuickSlotMovePacket@CPythonNetworkStream@@QAE_NEE@Z ; CPythonNetworkStream::SendQuickSlotMovePacket
?RequestMoveGlobalQuickSlotToLocalQuickSlot@CPythonPlayer@@QAEXKK@Z ENDP ; CPythonPlayer::RequestMoveGlobalQuickSlotToLocalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?RequestAddLocalQuickSlot@CPythonPlayer@@QAEXKKK@Z
_TEXT	SEGMENT
_dwLocalSlotIndex$ = 8					; size = 4
_dwWndType$ = 12					; size = 4
_dwWndItemPos$ = 16					; size = 4
?RequestAddLocalQuickSlot@CPythonPlayer@@QAEXKKK@Z PROC	; CPythonPlayer::RequestAddLocalQuickSlot, COMDAT
; _this$ = ecx

; 769  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 770  : 	if (dwLocalSlotIndex>=QUICKSLOT_MAX_COUNT_PER_LINE)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwLocalSlotIndex$[ebp]
  00006	83 f8 08	 cmp	 eax, 8
  00009	73 18		 jae	 SHORT $LN2@RequestAdd

; 771  : 		return;
; 772  : 
; 773  : 	DWORD dwGlobalSlotIndex=LocalQuickSlotIndexToGlobalQuickSlotIndex(dwLocalSlotIndex);
; 774  : 
; 775  : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 776  : 	rkNetStream.SendQuickSlotAddPacket((BYTE)dwGlobalSlotIndex, (BYTE)dwWndType, (BYTE)dwWndItemPos);

  0000b	ff 75 10	 push	 DWORD PTR _dwWndItemPos$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR _dwWndType$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?LocalQuickSlotIndexToGlobalQuickSlotIndex@CPythonPlayer@@QAEKK@Z ; CPythonPlayer::LocalQuickSlotIndexToGlobalQuickSlotIndex
  00017	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?SendQuickSlotAddPacket@CPythonNetworkStream@@QAE_NEEE@Z ; CPythonNetworkStream::SendQuickSlotAddPacket
$LN2@RequestAdd:

; 777  : }

  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
?RequestAddLocalQuickSlot@CPythonPlayer@@QAEXKKK@Z ENDP	; CPythonPlayer::RequestAddLocalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?RequestAddToEmptyLocalQuickSlot@CPythonPlayer@@QAEXKK@Z
_TEXT	SEGMENT
_dwWndType$ = 8						; size = 4
_dwWndItemPos$ = 12					; size = 4
?RequestAddToEmptyLocalQuickSlot@CPythonPlayer@@QAEXKK@Z PROC ; CPythonPlayer::RequestAddToEmptyLocalQuickSlot, COMDAT
; _this$ = ecx

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 781  :     for (int i = 0; i < QUICKSLOT_MAX_COUNT_PER_LINE; ++i)

  00007	33 f6		 xor	 esi, esi
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL4@RequestAdd:

; 782  :     {
; 783  :         TQuickSlot& rkQuickSlot=__RefLocalQuickSlot(i);

  00010	56		 push	 esi
  00011	8b cf		 mov	 ecx, edi
  00013	e8 00 00 00 00	 call	 ?__RefLocalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z ; CPythonPlayer::__RefLocalQuickSlot

; 784  : 
; 785  :         if (0 == rkQuickSlot.Type)

  00018	80 38 00	 cmp	 BYTE PTR [eax], 0
  0001b	74 0c		 je	 SHORT $LN10@RequestAdd

; 781  :     for (int i = 0; i < QUICKSLOT_MAX_COUNT_PER_LINE; ++i)

  0001d	46		 inc	 esi
  0001e	83 fe 08	 cmp	 esi, 8
  00021	7c ed		 jl	 SHORT $LL4@RequestAdd
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi

; 790  :             return;
; 791  :         }
; 792  :     }
; 793  : 
; 794  : }

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN10@RequestAdd:

; 786  :         {
; 787  :             DWORD dwGlobalQuickSlotIndex=LocalQuickSlotIndexToGlobalQuickSlotIndex(i);
; 788  :             CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 789  :             rkNetStream.SendQuickSlotAddPacket((BYTE)dwGlobalQuickSlotIndex, (BYTE)dwWndType, (BYTE)dwWndItemPos);

  00029	ff 75 0c	 push	 DWORD PTR _dwWndItemPos$[ebp]
  0002c	8b cf		 mov	 ecx, edi
  0002e	ff 75 08	 push	 DWORD PTR _dwWndType$[ebp]
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?LocalQuickSlotIndexToGlobalQuickSlotIndex@CPythonPlayer@@QAEKK@Z ; CPythonPlayer::LocalQuickSlotIndexToGlobalQuickSlotIndex
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?SendQuickSlotAddPacket@CPythonNetworkStream@@QAE_NEEE@Z ; CPythonNetworkStream::SendQuickSlotAddPacket
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi

; 790  :             return;
; 791  :         }
; 792  :     }
; 793  : 
; 794  : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?RequestAddToEmptyLocalQuickSlot@CPythonPlayer@@QAEXKK@Z ENDP ; CPythonPlayer::RequestAddToEmptyLocalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?RequestDeleteGlobalQuickSlot@CPythonPlayer@@QAEXK@Z
_TEXT	SEGMENT
_dwGlobalSlotIndex$ = 8					; size = 4
?RequestDeleteGlobalQuickSlot@CPythonPlayer@@QAEXK@Z PROC ; CPythonPlayer::RequestDeleteGlobalQuickSlot, COMDAT
; _this$dead$ = ecx

; 797  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 798  : 	if (dwGlobalSlotIndex>=QUICKSLOT_MAX_COUNT)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwGlobalSlotIndex$[ebp]
  00006	83 f8 20	 cmp	 eax, 32			; 00000020H
  00009	73 0f		 jae	 SHORT $LN2@RequestDel

; 799  : 		return;
; 800  : 
; 801  : 	//if (dwLocalSlotIndex>=QUICKSLOT_MAX_SLOT_PER_LINE)
; 802  : 	//	return;
; 803  : 
; 804  : 	//DWORD dwGlobalSlotIndex=LocalQuickSlotIndexToGlobalQuickSlotIndex(dwLocalSlotIndex);
; 805  : 
; 806  : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 807  : 	rkNetStream.SendQuickSlotDelPacket((BYTE)dwGlobalSlotIndex);

  0000b	89 45 08	 mov	 DWORD PTR _dwGlobalSlotIndex$[ebp], eax
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton

; 808  : }

  00014	5d		 pop	 ebp

; 799  : 		return;
; 800  : 
; 801  : 	//if (dwLocalSlotIndex>=QUICKSLOT_MAX_SLOT_PER_LINE)
; 802  : 	//	return;
; 803  : 
; 804  : 	//DWORD dwGlobalSlotIndex=LocalQuickSlotIndexToGlobalQuickSlotIndex(dwLocalSlotIndex);
; 805  : 
; 806  : 	CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 807  : 	rkNetStream.SendQuickSlotDelPacket((BYTE)dwGlobalSlotIndex);

  00015	e9 00 00 00 00	 jmp	 ?SendQuickSlotDelPacket@CPythonNetworkStream@@QAE_NE@Z ; CPythonNetworkStream::SendQuickSlotDelPacket
$LN2@RequestDel:

; 808  : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?RequestDeleteGlobalQuickSlot@CPythonPlayer@@QAEXK@Z ENDP ; CPythonPlayer::RequestDeleteGlobalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?RequestUseLocalQuickSlot@CPythonPlayer@@QAEXK@Z
_TEXT	SEGMENT
_dwRegisteredItemPos$ = -4				; size = 4
_dwRegisteredType$ = 8					; size = 4
_dwLocalSlotIndex$ = 8					; size = 4
$T1 = 9							; size = 3
?RequestUseLocalQuickSlot@CPythonPlayer@@QAEXK@Z PROC	; CPythonPlayer::RequestUseLocalQuickSlot, COMDAT
; _this$ = ecx

; 811  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 812  : 	if (dwLocalSlotIndex>=QUICKSLOT_MAX_COUNT_PER_LINE)

  00004	8b 45 08	 mov	 eax, DWORD PTR _dwLocalSlotIndex$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	83 f8 08	 cmp	 eax, 8
  0000d	73 7a		 jae	 SHORT $LN4@RequestUse

; 813  : 		return;
; 814  : 
; 815  : 	DWORD dwRegisteredType;
; 816  : 	DWORD dwRegisteredItemPos;
; 817  : 	GetLocalQuickSlotData(dwLocalSlotIndex, &dwRegisteredType, &dwRegisteredItemPos);

  0000f	8d 4d fc	 lea	 ecx, DWORD PTR _dwRegisteredItemPos$[ebp]
  00012	51		 push	 ecx
  00013	8d 4d 08	 lea	 ecx, DWORD PTR _dwRegisteredType$[ebp]
  00016	51		 push	 ecx
  00017	50		 push	 eax
  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?GetLocalQuickSlotData@CPythonPlayer@@QAEXKPAK0@Z ; CPythonPlayer::GetLocalQuickSlotData

; 818  : 
; 819  : 	switch (dwRegisteredType)

  0001f	8b 45 08	 mov	 eax, DWORD PTR _dwRegisteredType$[ebp]
  00022	48		 dec	 eax
  00023	74 3d		 je	 SHORT $LN3@RequestUse
  00025	48		 dec	 eax
  00026	74 29		 je	 SHORT $LN2@RequestUse
  00028	48		 dec	 eax
  00029	75 5e		 jne	 SHORT $LN4@RequestUse

; 830  : 			break;
; 831  : 		}
; 832  : 		case SLOT_TYPE_EMOTION:
; 833  : 		{
; 834  : 			PyCallClassMemberFunc(m_ppyGameWindow, "BINARY_ActEmotion", Py_BuildValue("(i)", dwRegisteredItemPos));

  0002b	ff 75 fc	 push	 DWORD PTR _dwRegisteredItemPos$[ebp]
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GAEKBOHM@BINARY_ActEmotion?$AA@
  0003f	ff 76 08	 push	 DWORD PTR [esi+8]
  00042	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00047	83 c4 14	 add	 esp, 20			; 00000014H

; 835  : 			break;
; 836  : 		}
; 837  : 	}
; 838  : }

  0004a	5e		 pop	 esi
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN2@RequestUse:

; 825  : 			break;
; 826  : 		}
; 827  : 		case SLOT_TYPE_SKILL:
; 828  : 		{
; 829  : 			ClickSkillSlot(dwRegisteredItemPos);

  00051	ff 75 fc	 push	 DWORD PTR _dwRegisteredItemPos$[ebp]
  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?ClickSkillSlot@CPythonPlayer@@QAEXK@Z ; CPythonPlayer::ClickSkillSlot

; 835  : 			break;
; 836  : 		}
; 837  : 	}
; 838  : }

  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
$LN3@RequestUse:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 192  :         cell = _cell;

  00062	0f b7 45 fc	 movzx	 eax, WORD PTR _dwRegisteredItemPos$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 824  : 			rkNetStream.SendItemUsePacket(TItemPos(INVENTORY, (WORD)dwRegisteredItemPos));

  00066	51		 push	 ecx
  00067	8b cc		 mov	 ecx, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 192  :         cell = _cell;

  00069	66 89 45 0a	 mov	 WORD PTR $T1[ebp+1], ax
  0006d	c6 45 09 01	 mov	 BYTE PTR $T1[ebp], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 824  : 			rkNetStream.SendItemUsePacket(TItemPos(INVENTORY, (WORD)dwRegisteredItemPos));

  00071	0f b7 45 09	 movzx	 eax, WORD PTR $T1[ebp]
  00075	66 89 01	 mov	 WORD PTR [ecx], ax
  00078	8a 45 0b	 mov	 al, BYTE PTR $T1[ebp+2]
  0007b	88 41 02	 mov	 BYTE PTR [ecx+2], al
  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00084	e8 00 00 00 00	 call	 ?SendItemUsePacket@CPythonNetworkStream@@QAE_NUSItemPos@@@Z ; CPythonNetworkStream::SendItemUsePacket
$LN4@RequestUse:

; 835  : 			break;
; 836  : 		}
; 837  : 	}
; 838  : }

  00089	5e		 pop	 esi
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
?RequestUseLocalQuickSlot@CPythonPlayer@@QAEXK@Z ENDP	; CPythonPlayer::RequestUseLocalQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?AddQuickSlot@CPythonPlayer@@UAEXHDD@Z
_TEXT	SEGMENT
_QuickSlotIndex$ = 8					; size = 4
_IconType$ = 12						; size = 1
_IconPosition$ = 16					; size = 1
?AddQuickSlot@CPythonPlayer@@UAEXHDD@Z PROC		; CPythonPlayer::AddQuickSlot, COMDAT
; _this$ = ecx

; 841  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 842  : 	if (QuickSlotIndex < 0 || QuickSlotIndex >= QUICKSLOT_MAX_NUM)

  00003	8b 55 08	 mov	 edx, DWORD PTR _QuickSlotIndex$[ebp]
  00006	83 fa 23	 cmp	 edx, 35			; 00000023H
  00009	77 14		 ja	 SHORT $LN1@AddQuickSl

; 843  : 		return;
; 844  : 
; 845  : 	m_playerStatus.aQuickSlot[QuickSlotIndex].Type = IconType;

  0000b	8a 45 0c	 mov	 al, BYTE PTR _IconType$[ebp]
  0000e	88 84 51 42 dd
	00 00		 mov	 BYTE PTR [ecx+edx*2+56642], al

; 846  : 	m_playerStatus.aQuickSlot[QuickSlotIndex].Position = IconPosition;

  00015	8a 45 10	 mov	 al, BYTE PTR _IconPosition$[ebp]
  00018	88 84 51 43 dd
	00 00		 mov	 BYTE PTR [ecx+edx*2+56643], al
$LN1@AddQuickSl:

; 847  : }

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
?AddQuickSlot@CPythonPlayer@@UAEXHDD@Z ENDP		; CPythonPlayer::AddQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?DeleteQuickSlot@CPythonPlayer@@UAEXH@Z
_TEXT	SEGMENT
_QuickSlotIndex$ = 8					; size = 4
?DeleteQuickSlot@CPythonPlayer@@UAEXH@Z PROC		; CPythonPlayer::DeleteQuickSlot, COMDAT
; _this$ = ecx

; 850  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 851  : 	if (QuickSlotIndex < 0 || QuickSlotIndex >= QUICKSLOT_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _QuickSlotIndex$[ebp]
  00006	83 f8 23	 cmp	 eax, 35			; 00000023H
  00009	77 0a		 ja	 SHORT $LN1@DeleteQuic

; 852  : 		return;
; 853  : 
; 854  : 	m_playerStatus.aQuickSlot[QuickSlotIndex].Type = 0;

  0000b	66 c7 84 41 42
	dd 00 00 00 00	 mov	 WORD PTR [ecx+eax*2+56642], 0
$LN1@DeleteQuic:

; 855  : 	m_playerStatus.aQuickSlot[QuickSlotIndex].Position = 0;
; 856  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?DeleteQuickSlot@CPythonPlayer@@UAEXH@Z ENDP		; CPythonPlayer::DeleteQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?MoveQuickSlot@CPythonPlayer@@UAEXHH@Z
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Target$ = 12						; size = 4
?MoveQuickSlot@CPythonPlayer@@UAEXHH@Z PROC		; CPythonPlayer::MoveQuickSlot, COMDAT
; _this$ = ecx

; 859  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 860  : 	if (Source < 0 || Source >= QUICKSLOT_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _Source$[ebp]
  00006	83 f8 23	 cmp	 eax, 35			; 00000023H
  00009	77 27		 ja	 SHORT $LN1@MoveQuickS

; 861  : 		return;
; 862  : 
; 863  : 	if (Target < 0 || Target >= QUICKSLOT_MAX_NUM)

  0000b	8b 55 0c	 mov	 edx, DWORD PTR _Target$[ebp]
  0000e	83 fa 23	 cmp	 edx, 35			; 00000023H
  00011	77 1f		 ja	 SHORT $LN1@MoveQuickS

; 864  : 		return;
; 865  : 
; 866  : 	TQuickSlot& rkSrcSlot=__RefGlobalQuickSlot(Source);

  00013	56		 push	 esi
  00014	83 c1 fc	 add	 ecx, -4			; fffffffcH
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z ; CPythonPlayer::__RefGlobalQuickSlot

; 867  : 	TQuickSlot& rkDstSlot=__RefGlobalQuickSlot(Target);

  0001d	52		 push	 edx
  0001e	8b f0		 mov	 esi, eax
  00020	e8 00 00 00 00	 call	 ?__RefGlobalQuickSlot@CPythonPlayer@@IAEAAUSQuickSlot@@H@Z ; CPythonPlayer::__RefGlobalQuickSlot
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00025	66 8b 0e	 mov	 cx, WORD PTR [esi]

; 53   : 	_Left = _Move(_Right);

  00028	66 8b 10	 mov	 dx, WORD PTR [eax]
  0002b	66 89 16	 mov	 WORD PTR [esi], dx

; 54   : 	_Right = _Move(_Tmp);

  0002e	66 89 08	 mov	 WORD PTR [eax], cx
  00031	5e		 pop	 esi
$LN1@MoveQuickS:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 870  : }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?MoveQuickSlot@CPythonPlayer@@UAEXHH@Z ENDP		; CPythonPlayer::MoveQuickSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsEquipmentSlot@CPythonPlayer@@QAE_NUSItemPos@@@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
?IsEquipmentSlot@CPythonPlayer@@QAE_NUSItemPos@@@Z PROC	; CPythonPlayer::IsEquipmentSlot, COMDAT
; _this$dead$ = ecx

; 885  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 223  : 		switch (window_type)

  00003	8b 45 08	 mov	 eax, DWORD PTR _Cell$[ebp]
  00006	0f b6 c0	 movzx	 eax, al
  00009	48		 dec	 eax
  0000a	83 f8 06	 cmp	 eax, 6
  0000d	77 24		 ja	 SHORT $LN3@IsEquipmen
  0000f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN12@IsEquipmen[eax]
  00016	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@IsEquipmen[eax*4]
$LN5@IsEquipmen:

; 224  : 		{
; 225  : 		case INVENTORY:
; 226  : 		case EQUIPMENT:
; 227  : 			return (c_Equipment_Start + c_Wear_Max > cell) && (c_Equipment_Start <= cell);

  0001d	8b 45 09	 mov	 eax, DWORD PTR _Cell$[ebp+1]
  00020	b9 e1 00 00 00	 mov	 ecx, 225		; 000000e1H
  00025	66 2b c1	 sub	 ax, cx
  00028	66 83 f8 1f	 cmp	 ax, 31			; 0000001fH
  0002c	0f 96 c0	 setbe	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 887  : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN3@IsEquipmen:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 236  : 			return false;

  00033	32 c0		 xor	 al, al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 887  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
  00039	8d 49 00	 npad	 3
$LN14@IsEquipmen:
  0003c	00 00 00 00	 DD	 $LN5@IsEquipmen
  00040	00 00 00 00	 DD	 $LN3@IsEquipmen
  00044	00 00 00 00	 DD	 $LN3@IsEquipmen
$LN12@IsEquipmen:
  00048	00		 DB	 0
  00049	00		 DB	 0
  0004a	02		 DB	 2
  0004b	02		 DB	 2
  0004c	01		 DB	 1
  0004d	02		 DB	 2
  0004e	01		 DB	 1
?IsEquipmentSlot@CPythonPlayer@@QAE_NUSItemPos@@@Z ENDP	; CPythonPlayer::IsEquipmentSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsEquipItemInSlot@CPythonPlayer@@UAE_NUSItemPos@@@Z
_TEXT	SEGMENT
_Cell$ = 8						; size = 3
?IsEquipItemInSlot@CPythonPlayer@@UAE_NUSItemPos@@@Z PROC ; CPythonPlayer::IsEquipItemInSlot, COMDAT
; _this$ = ecx

; 890  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 223  : 		switch (window_type)

  00003	66 8b 55 08	 mov	 dx, WORD PTR _Cell$[ebp]
  00007	0f b6 c2	 movzx	 eax, dl
  0000a	48		 dec	 eax
  0000b	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 890  : {

  0000c	8b f1		 mov	 esi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h

; 223  : 		switch (window_type)

  0000e	83 f8 06	 cmp	 eax, 6
  00011	77 6e		 ja	 SHORT $LN7@IsEquipIte
  00013	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN20@IsEquipIte[eax]
  0001a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN22@IsEquipIte[eax*4]
$LN8@IsEquipIte:

; 224  : 		{
; 225  : 		case INVENTORY:
; 226  : 		case EQUIPMENT:
; 227  : 			return (c_Equipment_Start + c_Wear_Max > cell) && (c_Equipment_Start <= cell);

  00021	8b 45 09	 mov	 eax, DWORD PTR _Cell$[ebp+1]
  00024	b9 e1 00 00 00	 mov	 ecx, 225		; 000000e1H
  00029	66 2b c1	 sub	 ax, cx
  0002c	66 83 f8 1f	 cmp	 ax, 31			; 0000001fH
  00030	77 4f		 ja	 SHORT $LN7@IsEquipIte
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 896  : 	const TItemData * pData = GetItemData(Cell);

  00032	8a 45 0a	 mov	 al, BYTE PTR _Cell$[ebp+2]
  00035	51		 push	 ecx
  00036	8b cc		 mov	 ecx, esp
  00038	66 89 11	 mov	 WORD PTR [ecx], dx
  0003b	88 41 02	 mov	 BYTE PTR [ecx+2], al
  0003e	8d 4e fc	 lea	 ecx, DWORD PTR [esi-4]
  00041	e8 00 00 00 00	 call	 ?GetItemData@CPythonPlayer@@QBEPBUpacket_item@@USItemPos@@@Z ; CPythonPlayer::GetItemData

; 897  : 	
; 898  : 	if (NULL == pData)

  00046	85 c0		 test	 eax, eax
  00048	74 37		 je	 SHORT $LN7@IsEquipIte

; 899  : 	{
; 900  : 		return false;
; 901  : 	}
; 902  : 
; 903  : 	DWORD dwItemIndex = pData->vnum;
; 904  : 
; 905  : 	CItemManager::Instance().SelectItemData(dwItemIndex);

  0004a	ff 30		 push	 DWORD PTR [eax]
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00052	e8 00 00 00 00	 call	 ?SelectItemData@CItemManager@@QAEHK@Z ; CItemManager::SelectItemData

; 906  : 	CItemData * pItemData = CItemManager::Instance().GetSelectedItemDataPointer();

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  0005d	e8 00 00 00 00	 call	 ?GetSelectedItemDataPointer@CItemManager@@QAEPAVCItemData@@XZ ; CItemManager::GetSelectedItemDataPointer

; 907  : 	if (!pItemData)

  00062	85 c0		 test	 eax, eax
  00064	75 22		 jne	 SHORT $LN1@IsEquipIte

; 908  : 	{
; 909  : 		TraceError("Failed to find ItemData - CPythonPlayer::IsEquipItem(window_type=%d, iSlotindex=%d)\n", Cell.window_type, Cell.cell);

  00066	8b 45 09	 mov	 eax, DWORD PTR _Cell$[ebp+1]
  00069	0f b7 c0	 movzx	 eax, ax
  0006c	50		 push	 eax
  0006d	8b 45 08	 mov	 eax, DWORD PTR _Cell$[ebp]
  00070	0f b6 c0	 movzx	 eax, al
  00073	50		 push	 eax
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@PCELILMJ@Failed?5to?5find?5ItemData?5?9?5CPytho@
  00079	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@IsEquipIte:

; 891  : 	if (!Cell.IsEquipCell())
; 892  : 	{
; 893  : 		return false;

  00081	32 c0		 xor	 al, al

; 914  : }

  00083	5e		 pop	 esi
  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
$LN1@IsEquipIte:

; 910  : 		return false;
; 911  : 	}
; 912  : 
; 913  : 	return pItemData->IsEquipment() ? true : false;

  00088	8b c8		 mov	 ecx, eax
  0008a	e8 00 00 00 00	 call	 ?IsEquipment@CItemData@@QBEHXZ ; CItemData::IsEquipment
  0008f	85 c0		 test	 eax, eax

; 914  : }

  00091	5e		 pop	 esi
  00092	0f 95 c0	 setne	 al
  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
  00099	8d 49 00	 npad	 3
$LN22@IsEquipIte:
  0009c	00 00 00 00	 DD	 $LN8@IsEquipIte
  000a0	00 00 00 00	 DD	 $LN7@IsEquipIte
  000a4	00 00 00 00	 DD	 $LN7@IsEquipIte
$LN20@IsEquipIte:
  000a8	00		 DB	 0
  000a9	00		 DB	 0
  000aa	02		 DB	 2
  000ab	02		 DB	 2
  000ac	01		 DB	 1
  000ad	02		 DB	 2
  000ae	01		 DB	 1
?IsEquipItemInSlot@CPythonPlayer@@UAE_NUSItemPos@@@Z ENDP ; CPythonPlayer::IsEquipItemInSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetSkillIndex@CPythonPlayer@@QAEHK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
?GetSkillIndex@CPythonPlayer@@QAEHK@Z PROC		; CPythonPlayer::GetSkillIndex, COMDAT
; _this$ = ecx

; 927  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 928  : 	if (dwSlotIndex >= SKILL_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwSlotIndex$[ebp]
  00006	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0000b	72 06		 jb	 SHORT $LN1@GetSkillIn

; 929  : 		return 0;

  0000d	33 c0		 xor	 eax, eax

; 932  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
$LN1@GetSkillIn:

; 930  : 
; 931  : 	return m_playerStatus.aSkill[dwSlotIndex].dwIndex;

  00013	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00016	8b 84 c1 90 dd
	00 00		 mov	 eax, DWORD PTR [ecx+eax*8+56720]

; 932  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?GetSkillIndex@CPythonPlayer@@QAEHK@Z ENDP		; CPythonPlayer::GetSkillIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetSkillGrade@CPythonPlayer@@QAEHK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
?GetSkillGrade@CPythonPlayer@@QAEHK@Z PROC		; CPythonPlayer::GetSkillGrade, COMDAT
; _this$ = ecx

; 948  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 949  : 	if (dwSlotIndex >= SKILL_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwSlotIndex$[ebp]
  00006	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0000b	72 06		 jb	 SHORT $LN1@GetSkillGr

; 950  : 		return 0;

  0000d	33 c0		 xor	 eax, eax

; 953  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
$LN1@GetSkillGr:

; 951  : 
; 952  : 	return m_playerStatus.aSkill[dwSlotIndex].iGrade;

  00013	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00016	8b 84 c1 98 dd
	00 00		 mov	 eax, DWORD PTR [ecx+eax*8+56728]

; 953  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?GetSkillGrade@CPythonPlayer@@QAEHK@Z ENDP		; CPythonPlayer::GetSkillGrade
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetSkillLevel@CPythonPlayer@@QAEHK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
?GetSkillLevel@CPythonPlayer@@QAEHK@Z PROC		; CPythonPlayer::GetSkillLevel, COMDAT
; _this$ = ecx

; 956  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 957  : 	if (dwSlotIndex >= SKILL_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwSlotIndex$[ebp]
  00006	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0000b	72 06		 jb	 SHORT $LN1@GetSkillLe

; 958  : 		return 0;

  0000d	33 c0		 xor	 eax, eax

; 961  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
$LN1@GetSkillLe:

; 959  : 
; 960  : 	return m_playerStatus.aSkill[dwSlotIndex].iLevel;

  00013	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00016	8b 84 c1 9c dd
	00 00		 mov	 eax, DWORD PTR [ecx+eax*8+56732]

; 961  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?GetSkillLevel@CPythonPlayer@@QAEHK@Z ENDP		; CPythonPlayer::GetSkillLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetSkillCurrentEfficientPercentage@CPythonPlayer@@QAEMK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
?GetSkillCurrentEfficientPercentage@CPythonPlayer@@QAEMK@Z PROC ; CPythonPlayer::GetSkillCurrentEfficientPercentage, COMDAT
; _this$ = ecx

; 964  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 965  : 	if (dwSlotIndex >= SKILL_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwSlotIndex$[ebp]
  00006	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0000b	72 07		 jb	 SHORT $LN1@GetSkillCu
  0000d	0f 57 c0	 xorps	 xmm0, xmm0

; 969  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
$LN1@GetSkillCu:

; 966  : 		return 0;
; 967  : 
; 968  : 	return m_playerStatus.aSkill[dwSlotIndex].fcurEfficientPercentage;

  00014	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00017	f3 0f 10 84 c1
	a0 dd 00 00	 movss	 xmm0, DWORD PTR [ecx+eax*8+56736]

; 969  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?GetSkillCurrentEfficientPercentage@CPythonPlayer@@QAEMK@Z ENDP ; CPythonPlayer::GetSkillCurrentEfficientPercentage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetSkillNextEfficientPercentage@CPythonPlayer@@QAEMK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
?GetSkillNextEfficientPercentage@CPythonPlayer@@QAEMK@Z PROC ; CPythonPlayer::GetSkillNextEfficientPercentage, COMDAT
; _this$ = ecx

; 972  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 973  : 	if (dwSlotIndex >= SKILL_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwSlotIndex$[ebp]
  00006	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0000b	72 07		 jb	 SHORT $LN1@GetSkillNe
  0000d	0f 57 c0	 xorps	 xmm0, xmm0

; 977  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
$LN1@GetSkillNe:

; 974  : 		return 0;
; 975  : 
; 976  : 	return m_playerStatus.aSkill[dwSlotIndex].fnextEfficientPercentage;

  00014	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00017	f3 0f 10 84 c1
	a4 dd 00 00	 movss	 xmm0, DWORD PTR [ecx+eax*8+56740]

; 977  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?GetSkillNextEfficientPercentage@CPythonPlayer@@QAEMK@Z ENDP ; CPythonPlayer::GetSkillNextEfficientPercentage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetSkillCoolTime@CPythonPlayer@@QAEMK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
?GetSkillCoolTime@CPythonPlayer@@QAEMK@Z PROC		; CPythonPlayer::GetSkillCoolTime, COMDAT
; _this$ = ecx

; 1075 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1076 : 	if (dwSlotIndex >= SKILL_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwSlotIndex$[ebp]
  00006	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0000b	72 07		 jb	 SHORT $LN1@GetSkillCo
  0000d	0f 57 c0	 xorps	 xmm0, xmm0

; 1080 : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
$LN1@GetSkillCo:

; 1077 : 		return 0.0f;
; 1078 : 
; 1079 : 	return m_playerStatus.aSkill[dwSlotIndex].fCoolTime;

  00014	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00017	f3 0f 10 84 c1
	ac dd 00 00	 movss	 xmm0, DWORD PTR [ecx+eax*8+56748]

; 1080 : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?GetSkillCoolTime@CPythonPlayer@@QAEMK@Z ENDP		; CPythonPlayer::GetSkillCoolTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetSkillElapsedCoolTime@CPythonPlayer@@QAEMK@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
_dwSlotIndex$ = 8					; size = 4
?GetSkillElapsedCoolTime@CPythonPlayer@@QAEMK@Z PROC	; CPythonPlayer::GetSkillElapsedCoolTime, COMDAT
; _this$ = ecx

; 1083 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1084 : 	if (dwSlotIndex >= SKILL_MAX_NUM)

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwSlotIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  00010	72 09		 jb	 SHORT $LN1@GetSkillEl
  00012	5f		 pop	 edi
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	5e		 pop	 esi

; 1088 : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN1@GetSkillEl:

; 1085 : 		return 0.0f;
; 1086 : 
; 1087 : 	return CTimer::Instance().GetCurrentSecond() - m_playerStatus.aSkill[dwSlotIndex].fLastUsedTime;

  0001b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  00021	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
  00026	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00029	d8 a4 c7 b0 dd
	00 00		 fsub	 DWORD PTR [edi+eax*8+56752]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  00035	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR tv73[ebp]

; 1088 : }

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?GetSkillElapsedCoolTime@CPythonPlayer@@QAEMK@Z ENDP	; CPythonPlayer::GetSkillElapsedCoolTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__ActivateSkillSlot@CPythonPlayer@@IAEXK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
?__ActivateSkillSlot@CPythonPlayer@@IAEXK@Z PROC	; CPythonPlayer::__ActivateSkillSlot, COMDAT
; _this$ = ecx

; 1091 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1092 : 	if (dwSlotIndex>=SKILL_MAX_NUM)

  00003	8b 55 08	 mov	 edx, DWORD PTR _dwSlotIndex$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  0000f	72 18		 jb	 SHORT $LN1@ActivateSk

; 1093 : 	{
; 1094 : 		Tracenf("CPythonPlayer::ActivavteSkill(dwSlotIndex=%d/%d) - OUT OF RANGE", dwSlotIndex, SKILL_MAX_NUM);

  00011	68 ff 00 00 00	 push	 255			; 000000ffH
  00016	52		 push	 edx
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@BNHLOMGN@CPythonPlayer?3?3ActivavteSkill?$CIdw@
  0001c	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	5e		 pop	 esi

; 1100 : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN1@ActivateSk:

; 1095 : 		return;
; 1096 : 	}
; 1097 : 
; 1098 : 	m_playerStatus.aSkill[dwSlotIndex].bActive = TRUE;
; 1099 : 	PyCallClassMemberFunc(m_ppyGameWindow, "ActivateSkillSlot", Py_BuildValue("(i)", dwSlotIndex));

  00029	52		 push	 edx
  0002a	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00032	c7 84 c6 b4 dd
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax*8+56756], 1
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00043	50		 push	 eax
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GDFCJBCP@ActivateSkillSlot?$AA@
  00049	ff 76 08	 push	 DWORD PTR [esi+8]
  0004c	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00051	83 c4 14	 add	 esp, 20			; 00000014H
  00054	5e		 pop	 esi

; 1100 : }

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?__ActivateSkillSlot@CPythonPlayer@@IAEXK@Z ENDP	; CPythonPlayer::__ActivateSkillSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__DeactivateSkillSlot@CPythonPlayer@@IAEXK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
?__DeactivateSkillSlot@CPythonPlayer@@IAEXK@Z PROC	; CPythonPlayer::__DeactivateSkillSlot, COMDAT
; _this$ = ecx

; 1103 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1104 : 	if (dwSlotIndex>=SKILL_MAX_NUM)

  00003	8b 55 08	 mov	 edx, DWORD PTR _dwSlotIndex$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  0000f	72 18		 jb	 SHORT $LN1@Deactivate

; 1105 : 	{
; 1106 : 		Tracenf("CPythonPlayer::DeactivavteSkill(dwSlotIndex=%d/%d) - OUT OF RANGE", dwSlotIndex, SKILL_MAX_NUM);

  00011	68 ff 00 00 00	 push	 255			; 000000ffH
  00016	52		 push	 edx
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@BHLLACII@CPythonPlayer?3?3DeactivavteSkill?$CI@
  0001c	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	5e		 pop	 esi

; 1112 : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN1@Deactivate:

; 1107 : 		return;
; 1108 : 	}
; 1109 : 
; 1110 : 	m_playerStatus.aSkill[dwSlotIndex].bActive = FALSE;
; 1111 : 	PyCallClassMemberFunc(m_ppyGameWindow, "DeactivateSkillSlot", Py_BuildValue("(i)", dwSlotIndex));

  00029	52		 push	 edx
  0002a	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00032	c7 84 c6 b4 dd
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax*8+56756], 0
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00043	50		 push	 eax
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@HIMJCBBG@DeactivateSkillSlot?$AA@
  00049	ff 76 08	 push	 DWORD PTR [esi+8]
  0004c	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00051	83 c4 14	 add	 esp, 20			; 00000014H
  00054	5e		 pop	 esi

; 1112 : }

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?__DeactivateSkillSlot@CPythonPlayer@@IAEXK@Z ENDP	; CPythonPlayer::__DeactivateSkillSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsSkillCoolTime@CPythonPlayer@@QAEHK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
?IsSkillCoolTime@CPythonPlayer@@QAEHK@Z PROC		; CPythonPlayer::IsSkillCoolTime, COMDAT
; _this$ = ecx

; 1115 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1116 : 	if (!__CheckRestSkillCoolTime(dwSlotIndex))

  00003	ff 75 08	 push	 DWORD PTR _dwSlotIndex$[ebp]
  00006	e8 00 00 00 00	 call	 ?__CheckRestSkillCoolTime@CPythonPlayer@@IAE_NK@Z ; CPythonPlayer::__CheckRestSkillCoolTime
  0000b	33 c9		 xor	 ecx, ecx
  0000d	84 c0		 test	 al, al
  0000f	0f 95 c1	 setne	 cl
  00012	8b c1		 mov	 eax, ecx

; 1117 : 		return FALSE;
; 1118 : 
; 1119 : 	return TRUE;
; 1120 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?IsSkillCoolTime@CPythonPlayer@@QAEHK@Z ENDP		; CPythonPlayer::IsSkillCoolTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsSkillActive@CPythonPlayer@@QAEHK@Z
_TEXT	SEGMENT
_dwSlotIndex$ = 8					; size = 4
?IsSkillActive@CPythonPlayer@@QAEHK@Z PROC		; CPythonPlayer::IsSkillActive, COMDAT
; _this$ = ecx

; 1123 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1124 : 	if (dwSlotIndex >= SKILL_MAX_NUM)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwSlotIndex$[ebp]
  00006	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0000b	72 06		 jb	 SHORT $LN1@IsSkillAct

; 1125 : 		return FALSE;

  0000d	33 c0		 xor	 eax, eax

; 1128 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
$LN1@IsSkillAct:

; 1126 : 
; 1127 : 	return m_playerStatus.aSkill[dwSlotIndex].bActive;

  00013	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00016	8b 84 c1 b4 dd
	00 00		 mov	 eax, DWORD PTR [ecx+eax*8+56756]

; 1128 : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?IsSkillActive@CPythonPlayer@@QAEHK@Z ENDP		; CPythonPlayer::IsSkillActive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetPlayTime@CPythonPlayer@@QAEXK@Z
_TEXT	SEGMENT
_dwPlayTime$ = 8					; size = 4
?SetPlayTime@CPythonPlayer@@QAEXK@Z PROC		; CPythonPlayer::SetPlayTime, COMDAT
; _this$ = ecx

; 1145 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1146 : 	m_dwPlayTime = dwPlayTime;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwPlayTime$[ebp]
  00006	89 81 1c 0a 01
	00		 mov	 DWORD PTR [ecx+68124], eax

; 1147 : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetPlayTime@CPythonPlayer@@QAEXK@Z ENDP		; CPythonPlayer::SetPlayTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetPlayTime@CPythonPlayer@@QAEKXZ
_TEXT	SEGMENT
?GetPlayTime@CPythonPlayer@@QAEKXZ PROC			; CPythonPlayer::GetPlayTime, COMDAT
; _this$ = ecx

; 1151 : 	return m_dwPlayTime;

  00000	8b 81 1c 0a 01
	00		 mov	 eax, DWORD PTR [ecx+68124]

; 1152 : }

  00006	c3		 ret	 0
?GetPlayTime@CPythonPlayer@@QAEKXZ ENDP			; CPythonPlayer::GetPlayTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SendClickItemPacket@CPythonPlayer@@QAEXK@Z
_TEXT	SEGMENT
_c_szOwnerName$1 = -4					; size = 4
tv80 = 8						; size = 4
_pItemData$2 = 8					; size = 4
_dwIID$ = 8						; size = 4
?SendClickItemPacket@CPythonPlayer@@QAEXK@Z PROC	; CPythonPlayer::SendClickItemPacket, COMDAT
; _this$ = ecx

; 1155 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 1156 : 	if (IsObserverMode())

  00007	e8 00 00 00 00	 call	 ?IsObserverMode@CPythonPlayer@@QAE_NXZ ; CPythonPlayer::IsObserverMode
  0000c	84 c0		 test	 al, al
  0000e	0f 85 0c 01 00
	00		 jne	 $LN7@SendClickI

; 1157 : 		return;
; 1158 : 
; 1159 : 	static DWORD s_dwNextTCPTime = 0;
; 1160 : 
; 1161 : 	DWORD dwCurTime=ELTimer_GetMSec();

  00014	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 1162 : 
; 1163 : 	if (dwCurTime >= s_dwNextTCPTime)

  00019	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?s_dwNextTCPTime@?3??SendClickItemPacket@CPythonPlayer@@QAEXK@Z@4KA
  0001f	0f 82 fb 00 00
	00		 jb	 $LN7@SendClickI

; 1164 : 	{
; 1165 : 		s_dwNextTCPTime=dwCurTime + 500;
; 1166 : 
; 1167 : 		const char * c_szOwnerName;
; 1168 : 		if (!CPythonItem::Instance().GetOwnership(dwIID, &c_szOwnerName))

  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonItem@@@@0PAVCPythonItem@@A ; CSingleton<CPythonItem>::ms_singleton
  0002b	05 f4 01 00 00	 add	 eax, 500		; 000001f4H
  00030	56		 push	 esi
  00031	8b 75 08	 mov	 esi, DWORD PTR _dwIID$[ebp]
  00034	a3 00 00 00 00	 mov	 DWORD PTR ?s_dwNextTCPTime@?3??SendClickItemPacket@CPythonPlayer@@QAEXK@Z@4KA, eax
  00039	8d 45 fc	 lea	 eax, DWORD PTR _c_szOwnerName$1[ebp]
  0003c	50		 push	 eax
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 ?GetOwnership@CPythonItem@@QAE_NKPAPBD@Z ; CPythonItem::GetOwnership
  00043	84 c0		 test	 al, al
  00045	0f 84 d4 00 00
	00		 je	 $LN24@SendClickI

; 1169 : 			return;
; 1170 : 
; 1171 : 		if (strlen(c_szOwnerName) > 0)

  0004b	53		 push	 ebx
  0004c	8b 5d fc	 mov	 ebx, DWORD PTR _c_szOwnerName$1[ebp]
  0004f	8b cb		 mov	 ecx, ebx
  00051	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL19@SendClickI:
  00054	8a 01		 mov	 al, BYTE PTR [ecx]
  00056	41		 inc	 ecx
  00057	84 c0		 test	 al, al
  00059	75 f9		 jne	 SHORT $LL19@SendClickI
  0005b	2b ca		 sub	 ecx, edx
  0005d	0f 84 af 00 00
	00		 je	 $LN2@SendClickI

; 1172 : 		if (0 != strcmp(c_szOwnerName, GetName()))

  00063	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00066	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00069	ff 50 14	 call	 DWORD PTR [eax+20]
  0006c	8b cb		 mov	 ecx, ebx
  0006e	8b ff		 npad	 2
$LL20@SendClickI:
  00070	8a 11		 mov	 dl, BYTE PTR [ecx]
  00072	3a 10		 cmp	 dl, BYTE PTR [eax]
  00074	75 1a		 jne	 SHORT $LN21@SendClickI
  00076	84 d2		 test	 dl, dl
  00078	74 12		 je	 SHORT $LN22@SendClickI
  0007a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0007d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00080	75 0e		 jne	 SHORT $LN21@SendClickI
  00082	83 c1 02	 add	 ecx, 2
  00085	83 c0 02	 add	 eax, 2
  00088	84 d2		 test	 dl, dl
  0008a	75 e4		 jne	 SHORT $LL20@SendClickI
$LN22@SendClickI:
  0008c	33 c0		 xor	 eax, eax
  0008e	eb 05		 jmp	 SHORT $LN23@SendClickI
$LN21@SendClickI:
  00090	1b c0		 sbb	 eax, eax
  00092	83 c8 01	 or	 eax, 1
$LN23@SendClickI:
  00095	85 c0		 test	 eax, eax
  00097	74 79		 je	 SHORT $LN2@SendClickI

; 1173 : 		{
; 1174 : 			CItemData * pItemData;
; 1175 : 			if (!CItemManager::Instance().GetItemDataPointer(CPythonItem::Instance().GetVirtualNumberOfGroundItem(dwIID), &pItemData))

  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonItem@@@@0PAVCPythonItem@@A ; CSingleton<CPythonItem>::ms_singleton
  0009f	8d 45 08	 lea	 eax, DWORD PTR _pItemData$2[ebp]
  000a2	50		 push	 eax
  000a3	56		 push	 esi
  000a4	e8 00 00 00 00	 call	 ?GetVirtualNumberOfGroundItem@CPythonItem@@QAEKK@Z ; CPythonItem::GetVirtualNumberOfGroundItem
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  000b5	85 c0		 test	 eax, eax
  000b7	75 17		 jne	 SHORT $LN3@SendClickI

; 1176 : 			{
; 1177 : 				Tracenf("CPythonPlayer::SendClickItemPacket(dwIID=%d) : Non-exist item.", dwIID);

  000b9	56		 push	 esi
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@MLLABPNJ@CPythonPlayer?3?3SendClickItemPack@
  000bf	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  000c4	83 c4 08	 add	 esp, 8
  000c7	5b		 pop	 ebx
  000c8	5e		 pop	 esi
  000c9	5f		 pop	 edi

; 1189 : 	}
; 1190 : }

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 04 00	 ret	 4
$LN3@SendClickI:

; 1178 : 				return;
; 1179 : 			}
; 1180 : 			if (!IsPartyMemberByName(c_szOwnerName) || pItemData->IsAntiFlag(CItemData::ITEM_ANTIFLAG_DROP | CItemData::ITEM_ANTIFLAG_GIVE))

  000d0	53		 push	 ebx
  000d1	8b cf		 mov	 ecx, edi
  000d3	e8 00 00 00 00	 call	 ?IsPartyMemberByName@CPythonPlayer@@QAE_NPBD@Z ; CPythonPlayer::IsPartyMemberByName
  000d8	84 c0		 test	 al, al
  000da	74 11		 je	 SHORT $LN1@SendClickI
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _pItemData$2[ebp]
  000df	68 80 20 00 00	 push	 8320			; 00002080H
  000e4	e8 00 00 00 00	 call	 ?IsAntiFlag@CItemData@@QBEHK@Z ; CItemData::IsAntiFlag
  000e9	85 c0		 test	 eax, eax
  000eb	74 25		 je	 SHORT $LN2@SendClickI
$LN1@SendClickI:

; 1181 : 			{
; 1182 : 				PyCallClassMemberFunc(m_ppyGameWindow, "OnCannotPickItem", Py_BuildValue("()"));

  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000f8	50		 push	 eax
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DNNBDACF@OnCannotPickItem?$AA@
  000fe	ff 77 08	 push	 DWORD PTR [edi+8]
  00101	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00106	83 c4 10	 add	 esp, 16			; 00000010H
  00109	5b		 pop	 ebx
  0010a	5e		 pop	 esi
  0010b	5f		 pop	 edi

; 1189 : 	}
; 1190 : }

  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c2 04 00	 ret	 4
$LN2@SendClickI:

; 1183 : 				return;
; 1184 : 			}
; 1185 : 		}
; 1186 : 
; 1187 : 		CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 1188 : 		rkNetStream.SendItemPickUpPacket(dwIID);

  00112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00118	56		 push	 esi
  00119	e8 00 00 00 00	 call	 ?SendItemPickUpPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendItemPickUpPacket
  0011e	5b		 pop	 ebx
$LN24@SendClickI:
  0011f	5e		 pop	 esi
$LN7@SendClickI:
  00120	5f		 pop	 edi

; 1189 : 	}
; 1190 : }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?SendClickItemPacket@CPythonPlayer@@QAEXK@Z ENDP	; CPythonPlayer::SendClickItemPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__SendClickActorPacket@CPythonPlayer@@IAEXAAVCInstanceBase@@@Z
_TEXT	SEGMENT
_rkInstVictim$ = 8					; size = 4
?__SendClickActorPacket@CPythonPlayer@@IAEXAAVCInstanceBase@@@Z PROC ; CPythonPlayer::__SendClickActorPacket, COMDAT
; _this$ = ecx

; 1193 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1194 : 	//        
; 1195 : 	CInstanceBase* pkInstMain=NEW_GetMainActorPtr();

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000c	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]
  00012	8b c8		 mov	 ecx, eax

; 1196 : 	if (pkInstMain)

  00014	85 c9		 test	 ecx, ecx
  00016	74 3f		 je	 SHORT $LN2@SendClickA

; 1197 : 	if (pkInstMain->IsHoldingPickAxe())

  00018	e8 00 00 00 00	 call	 ?IsHoldingPickAxe@CInstanceBase@@QAEHXZ ; CInstanceBase::IsHoldingPickAxe
  0001d	85 c0		 test	 eax, eax
  0001f	74 36		 je	 SHORT $LN2@SendClickA

; 1198 : 	if (pkInstMain->IsMountingHorse())

  00021	e8 00 00 00 00	 call	 ?IsMountingHorse@CInstanceBase@@QAEHXZ ; CInstanceBase::IsMountingHorse
  00026	85 c0		 test	 eax, eax
  00028	74 2d		 je	 SHORT $LN2@SendClickA

; 1199 : 	if (rkInstVictim.IsResource())

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0002d	e8 00 00 00 00	 call	 ?IsResource@CInstanceBase@@QAEHXZ ; CInstanceBase::IsResource
  00032	85 c0		 test	 eax, eax
  00034	74 21		 je	 SHORT $LN2@SendClickA

; 1200 : 	{
; 1201 : 		PyCallClassMemberFunc(m_ppyGameWindow, "OnCannotMining", Py_BuildValue("()"));

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	50		 push	 eax
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CGBLDLHF@OnCannotMining?$AA@
  00047	ff 76 08	 push	 DWORD PTR [esi+8]
  0004a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	5e		 pop	 esi

; 1217 : 	}
; 1218 : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN2@SendClickA:

; 1202 : 		return;
; 1203 : 	}
; 1204 : 
; 1205 : 	static DWORD s_dwNextTCPTime = 0;
; 1206 : 
; 1207 : 	DWORD dwCurTime=ELTimer_GetMSec();

  00057	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 1208 : 
; 1209 : 	if (dwCurTime >= s_dwNextTCPTime)

  0005c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?s_dwNextTCPTime@?L@??__SendClickActorPacket@CPythonPlayer@@IAEXAAVCInstanceBase@@@Z@4KA
  00062	72 20		 jb	 SHORT $LN1@SendClickA

; 1210 : 	{
; 1211 : 		s_dwNextTCPTime=dwCurTime+1000;
; 1212 : 
; 1213 : 		CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 1214 : 
; 1215 : 		DWORD dwVictimVID=rkInstVictim.GetVirtualID();

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  00067	05 e8 03 00 00	 add	 eax, 1000		; 000003e8H
  0006c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00072	a3 00 00 00 00	 mov	 DWORD PTR ?s_dwNextTCPTime@?L@??__SendClickActorPacket@CPythonPlayer@@IAEXAAVCInstanceBase@@@Z@4KA, eax
  00077	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID

; 1216 : 		rkNetStream.SendOnClickPacket(dwVictimVID);

  0007c	50		 push	 eax
  0007d	8b ce		 mov	 ecx, esi
  0007f	e8 00 00 00 00	 call	 ?SendOnClickPacket@CPythonNetworkStream@@QAE_NK@Z ; CPythonNetworkStream::SendOnClickPacket
$LN1@SendClickA:
  00084	5e		 pop	 esi

; 1217 : 	}
; 1218 : }

  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
?__SendClickActorPacket@CPythonPlayer@@IAEXAAVCInstanceBase@@@Z ENDP ; CPythonPlayer::__SendClickActorPacket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?ActEmotion@CPythonPlayer@@QAEXK@Z
_TEXT	SEGMENT
_dwEmotionID$dead$ = 8					; size = 4
?ActEmotion@CPythonPlayer@@QAEXK@Z PROC			; CPythonPlayer::ActEmotion, COMDAT
; _this$ = ecx

; 1221 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1222 : 	CInstanceBase * pkInstTarget = __GetAliveTargetInstancePtr();

  00003	e8 00 00 00 00	 call	 ?__GetAliveTargetInstancePtr@CPythonPlayer@@IAEPAVCInstanceBase@@XZ ; CPythonPlayer::__GetAliveTargetInstancePtr

; 1223 : 	if (!pkInstTarget)

  00008	85 c0		 test	 eax, eax
  0000a	75 2f		 jne	 SHORT $LN1@ActEmotion

; 1224 : 	{
; 1225 : 		PyCallClassMemberFunc(m_ppyGameWindow, "OnCannotShotError", Py_BuildValue("(is)", GetMainCharacterIndex(), "NEED_TARGET"));

  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HCIEKIGP@NEED_TARGET?$AA@
  00017	ff 50 04	 call	 DWORD PTR [eax+4]
  0001a	50		 push	 eax
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00026	50		 push	 eax
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FKINMGLI@OnCannotShotError?$AA@
  0002c	ff 76 08	 push	 DWORD PTR [esi+8]
  0002f	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00034	83 c4 18	 add	 esp, 24			; 00000018H
  00037	5e		 pop	 esi

; 1230 : }

  00038	c2 04 00	 ret	 4
$LN1@ActEmotion:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 27   : 		return (*ms_singleton);

  0003b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1229 : 	CPythonNetworkStream::Instance().SendChatPacket(_getf("/kiss %s", pkInstTarget->GetNameString()));

  00041	8b c8		 mov	 ecx, eax
  00043	6a 00		 push	 0
  00045	e8 00 00 00 00	 call	 ?GetNameString@CInstanceBase@@QAEPBDXZ ; CInstanceBase::GetNameString
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_08HOHDPHII@?1kiss?5?$CFs?$AA@
  00050	e8 00 00 00 00	 call	 ?_getf@@YAPBDPBDZZ	; _getf
  00055	83 c4 08	 add	 esp, 8
  00058	8b ce		 mov	 ecx, esi
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ?SendChatPacket@CPythonNetworkStream@@QAE_NPBDE@Z ; CPythonNetworkStream::SendChatPacket
  00060	5e		 pop	 esi

; 1230 : }

  00061	c2 04 00	 ret	 4
?ActEmotion@CPythonPlayer@@QAEXK@Z ENDP			; CPythonPlayer::ActEmotion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?StartEmotionProcess@CPythonPlayer@@UAEXXZ
_TEXT	SEGMENT
?StartEmotionProcess@CPythonPlayer@@UAEXXZ PROC		; CPythonPlayer::StartEmotionProcess, COMDAT
; _this$ = ecx

; 1233 : {

  00000	8b d1		 mov	 edx, ecx

; 1234 : 	__ClearReservedAction();

  00002	8d 4a fc	 lea	 ecx, DWORD PTR [edx-4]
  00005	e8 00 00 00 00	 call	 ?__ClearReservedAction@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__ClearReservedAction

; 1235 : 	__ClearAutoAttackTargetActorID();

  0000a	e8 00 00 00 00	 call	 ?__ClearAutoAttackTargetActorID@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__ClearAutoAttackTargetActorID

; 1236 : 
; 1237 : 	m_bisProcessingEmotion = TRUE;

  0000f	c7 82 94 09 01
	00 01 00 00 00	 mov	 DWORD PTR [edx+67988], 1

; 1238 : }

  00019	c3		 ret	 0
?StartEmotionProcess@CPythonPlayer@@UAEXXZ ENDP		; CPythonPlayer::StartEmotionProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?EndEmotionProcess@CPythonPlayer@@UAEXXZ
_TEXT	SEGMENT
?EndEmotionProcess@CPythonPlayer@@UAEXXZ PROC		; CPythonPlayer::EndEmotionProcess, COMDAT
; _this$ = ecx

; 1242 : 	m_bisProcessingEmotion = FALSE;

  00000	c7 81 94 09 01
	00 00 00 00 00	 mov	 DWORD PTR [ecx+67988], 0

; 1243 : }

  0000a	c3		 ret	 0
?EndEmotionProcess@CPythonPlayer@@UAEXXZ ENDP		; CPythonPlayer::EndEmotionProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__IsProcessingEmotion@CPythonPlayer@@IAEHXZ
_TEXT	SEGMENT
?__IsProcessingEmotion@CPythonPlayer@@IAEHXZ PROC	; CPythonPlayer::__IsProcessingEmotion, COMDAT
; _this$ = ecx

; 1247 : 	return m_bisProcessingEmotion;

  00000	8b 81 98 09 01
	00		 mov	 eax, DWORD PTR [ecx+67992]

; 1248 : }

  00006	c3		 ret	 0
?__IsProcessingEmotion@CPythonPlayer@@IAEHXZ ENDP	; CPythonPlayer::__IsProcessingEmotion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?AlarmHaveToGo@CPythonPlayer@@QAEXXZ
_TEXT	SEGMENT
tv201 = -40						; size = 8
_PixelPosition$ = -28					; size = 12
_v3Rotation$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?AlarmHaveToGo@CPythonPlayer@@QAEXXZ PROC		; CPythonPlayer::AlarmHaveToGo, COMDAT
; _this$ = ecx

; 1261 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 28	 mov	 DWORD PTR __$ArrayPad$[esp+44], eax
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx

; 1262 : 	m_iLastAlarmTime = CTimer::Instance().GetCurrentMillisecond();

  00017	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  0001d	e8 00 00 00 00	 call	 ?GetCurrentMillisecond@CTimer@@QAEKXZ ; CTimer::GetCurrentMillisecond

; 1263 : 
; 1264 : 	/////
; 1265 : 
; 1266 : 	CInstanceBase * pInstance = NEW_GetMainActorPtr();

  00022	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00025	89 86 a8 09 01
	00		 mov	 DWORD PTR [esi+68008], eax
  0002b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002d	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 1267 : 	if (!pInstance)

  00033	85 c0		 test	 eax, eax
  00035	0f 84 c7 00 00
	00		 je	 $LN2@AlarmHaveT

; 1268 : 		return;
; 1269 : 
; 1270 : 	TPixelPosition PixelPosition;
; 1271 : 	pInstance->NEW_GetPixelPosition(&PixelPosition);

  0003b	8d 4c 24 14	 lea	 ecx, DWORD PTR _PixelPosition$[esp+48]
  0003f	51		 push	 ecx
  00040	8b c8		 mov	 ecx, eax
  00042	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition
  00047	66 0f 6e 86 a4
	09 01 00	 movd	 xmm0, DWORD PTR [esi+68004]

; 1272 : 
; 1273 : 	float fAngle = GetDegreeFromPosition2(PixelPosition.x, PixelPosition.y, float(m_ixDestPos), float(m_iyDestPos));

  0004f	83 ec 10	 sub	 esp, 16			; 00000010H
  00052	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00055	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  0005b	66 0f 6e 86 a0
	09 01 00	 movd	 xmm0, DWORD PTR [esi+68000]
  00063	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00066	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0006c	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR _PixelPosition$[esp+68]
  00072	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00078	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR _PixelPosition$[esp+64]
  0007e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00083	e8 00 00 00 00	 call	 ?GetDegreeFromPosition2@@YAMMMMM@Z ; GetDegreeFromPosition2

; 1274 : 	fAngle = fmod(540.0f - fAngle, 360.0f);

  00088	d8 2d 00 00 00
	00		 fsubr	 DWORD PTR __real@44070000
  0008e	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 706  :     return (float)fmod(_X, _Y);

  00091	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4076800000000000
  00097	e8 00 00 00 00	 call	 __CIfmod
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1277 : 	PixelPosition.y *= -1.0f;

  0009c	f3 0f 10 44 24
	18		 movss	 xmm0, DWORD PTR _PixelPosition$[esp+52]
  000a2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@bf800000

; 1279 : 	CEffectManager::Instance().RegisterEffect("d:/ymir work/effect/etc/compass/appear_middle.mse");

  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 706  :     return (float)fmod(_X, _Y);

  000b0	dd 5c 24 08	 fstp	 QWORD PTR tv201[esp+48]
  000b4	f2 0f 10 4c 24
	08		 movsd	 xmm1, QWORD PTR tv201[esp+48]
  000ba	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1279 : 	CEffectManager::Instance().RegisterEffect("d:/ymir work/effect/etc/compass/appear_middle.mse");

  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@MDCBLGBM@d?3?1ymir?5work?1effect?1etc?1compass?1@
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 180  :     x = fx;

  000c7	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _v3Rotation$[esp+60], 0

; 181  :     y = fy;

  000cf	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _v3Rotation$[esp+64], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1277 : 	PixelPosition.y *= -1.0f;

  000d7	f3 0f 11 44 24
	24		 movss	 DWORD PTR _PixelPosition$[esp+64], xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 182  :     z = fz;

  000dd	f3 0f 11 4c 24
	34		 movss	 DWORD PTR _v3Rotation$[esp+68], xmm1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1279 : 	CEffectManager::Instance().RegisterEffect("d:/ymir work/effect/etc/compass/appear_middle.mse");

  000e3	e8 00 00 00 00	 call	 ?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z ; CEffectManager::RegisterEffect

; 1280 : 	CEffectManager::Instance().CreateEffect("d:/ymir work/effect/etc/compass/appear_middle.mse", PixelPosition, v3Rotation);

  000e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  000ee	8d 44 24 20	 lea	 eax, DWORD PTR _v3Rotation$[esp+48]
  000f2	50		 push	 eax
  000f3	8d 44 24 18	 lea	 eax, DWORD PTR _PixelPosition$[esp+52]
  000f7	50		 push	 eax
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@MDCBLGBM@d?3?1ymir?5work?1effect?1etc?1compass?1@
  000fd	e8 00 00 00 00	 call	 ?CreateEffect@CEffectManager@@QAEHPBDABUD3DXVECTOR3@@1@Z ; CEffectManager::CreateEffect
$LN2@AlarmHaveT:

; 1281 : }

  00102	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+48]
  00106	5e		 pop	 esi
  00107	33 cc		 xor	 ecx, esp
  00109	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
?AlarmHaveToGo@CPythonPlayer@@QAEXXZ ENDP		; CPythonPlayer::AlarmHaveToGo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?ExitParty@CPythonPlayer@@QAEXXZ
_TEXT	SEGMENT
?ExitParty@CPythonPlayer@@QAEXXZ PROC			; CPythonPlayer::ExitParty, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1540 : 		_Erase(_Root());

  00000	8b 81 ac 09 01
	00		 mov	 eax, DWORD PTR [ecx+68012]
  00006	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1286 : 	m_PartyMemberMap.clear();

  00007	8d b1 ac 09 01
	00		 lea	 esi, DWORD PTR [ecx+68012]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1540 : 		_Erase(_Root());

  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 70 04	 push	 DWORD PTR [eax+4]
  00012	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Erase

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1288 : 	CPythonCharacterManager::Instance().RefreshAllPCTextTail();

  00019	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1541 : 		_Root() = this->_Myhead;

  0001f	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1542 : 		_Lmost() = this->_Myhead;

  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	89 00		 mov	 DWORD PTR [eax], eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00026	8b 06		 mov	 eax, DWORD PTR [esi]

; 1543 : 		_Rmost() = this->_Myhead;

  00028	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1544 : 		this->_Mysize = 0;

  0002b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00032	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1288 : 	CPythonCharacterManager::Instance().RefreshAllPCTextTail();

  00033	e9 00 00 00 00	 jmp	 ?RefreshAllPCTextTail@CPythonCharacterManager@@QAEXXZ ; CPythonCharacterManager::RefreshAllPCTextTail
?ExitParty@CPythonPlayer@@QAEXXZ ENDP			; CPythonPlayer::ExitParty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??1SPartyMemberInfo@CPythonPlayer@@QAE@XZ
_TEXT	SEGMENT
??1SPartyMemberInfo@CPythonPlayer@@QAE@XZ PROC		; CPythonPlayer::SPartyMemberInfo::~SPartyMemberInfo, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00003	83 7e 1c 10	 cmp	 DWORD PTR [esi+28], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN23@SPartyMemb
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	ff 76 08	 push	 DWORD PTR [esi+8]
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN23@SPartyMemb:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00014	c7 46 1c 0f 00
	00 00		 mov	 DWORD PTR [esi+28], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001b	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00022	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
  00026	5e		 pop	 esi
  00027	c3		 ret	 0
??1SPartyMemberInfo@CPythonPlayer@@QAE@XZ ENDP		; CPythonPlayer::SPartyMemberInfo::~SPartyMemberInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??1?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@XZ PROC ; std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo>::~pair<unsigned long,CPythonPlayer::SPartyMemberInfo>, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00003	83 7e 20 10	 cmp	 DWORD PTR [esi+32], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN25@pair
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	ff 76 0c	 push	 DWORD PTR [esi+12]
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN25@pair:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00014	c7 46 20 0f 00
	00 00		 mov	 DWORD PTR [esi+32], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001b	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00022	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  00026	5e		 pop	 esi
  00027	c3		 ret	 0
??1?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@XZ ENDP ; std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo>::~pair<unsigned long,CPythonPlayer::SPartyMemberInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?RemovePartyMember@CPythonPlayer@@QAEXK@Z
_TEXT	SEGMENT
__Where$1 = -8						; size = 8
_pPartyMemberInfo$ = -4					; size = 4
$T2 = 8							; size = 4
_dwPID$ = 8						; size = 4
?RemovePartyMember@CPythonPlayer@@QAEXK@Z PROC		; CPythonPlayer::RemovePartyMember, COMDAT
; _this$ = ecx

; 1356 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1357 : 	DWORD dwVID = 0;
; 1358 : 	TPartyMemberInfo * pPartyMemberInfo;
; 1359 : 	if (GetPartyMemberPtr(dwPID, &pPartyMemberInfo))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwPID$[ebp]
  0000f	8b f1		 mov	 esi, ecx
  00011	33 ff		 xor	 edi, edi
  00013	e8 00 00 00 00	 call	 ?GetPartyMemberPtr@CPythonPlayer@@QAE_NKPAPAUSPartyMemberInfo@1@@Z ; CPythonPlayer::GetPartyMemberPtr
  00018	84 c0		 test	 al, al
  0001a	74 05		 je	 SHORT $LN3@RemovePart

; 1360 : 	{
; 1361 : 		dwVID = pPartyMemberInfo->dwVID;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _pPartyMemberInfo$[ebp]
  0001f	8b 38		 mov	 edi, DWORD PTR [eax]
$LN3@RemovePart:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1595 : 		return (_Eqrange(_Keyval));

  00021	8d 45 08	 lea	 eax, DWORD PTR _dwPID$[ebp]
  00024	50		 push	 eax
  00025	8d 45 f8	 lea	 eax, DWORD PTR __Where$1[ebp]
  00028	50		 push	 eax
  00029	8d 8e ac 09 01
	00		 lea	 ecx, DWORD PTR [esi+68012]
  0002f	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Eqrange

; 1530 : 		erase(_Where.first, _Where.second);

  00034	ff 75 fc	 push	 DWORD PTR __Where$1[ebp+4]
  00037	8d 45 08	 lea	 eax, DWORD PTR $T2[ebp]
  0003a	ff 75 f8	 push	 DWORD PTR __Where$1[ebp]
  0003d	8d 8e ac 09 01
	00		 lea	 ecx, DWORD PTR [esi+68012]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1366 : 	if (dwVID > 0)

  00049	85 ff		 test	 edi, edi
  0004b	74 11		 je	 SHORT $LN1@RemovePart

; 1367 : 	{
; 1368 : 		CInstanceBase * pInstance = NEW_FindActorPtr(dwVID);

  0004d	57		 push	 edi
  0004e	e8 00 00 00 00	 call	 ?NEW_FindActorPtr@CPythonPlayer@@QAEPAVCInstanceBase@@K@Z ; CPythonPlayer::NEW_FindActorPtr

; 1369 : 		if (pInstance)

  00053	85 c0		 test	 eax, eax
  00055	74 07		 je	 SHORT $LN1@RemovePart

; 1370 : 			pInstance->RefreshTextTail();

  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?RefreshTextTail@CInstanceBase@@QAEXXZ ; CInstanceBase::RefreshTextTail
$LN1@RemovePart:
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 1371 : 	}
; 1372 : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?RemovePartyMember@CPythonPlayer@@QAEXK@Z ENDP		; CPythonPlayer::RemovePartyMember
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsPartyMemberByVID@CPythonPlayer@@UAE_NK@Z
_TEXT	SEGMENT
_dwVID$ = 8						; size = 4
?IsPartyMemberByVID@CPythonPlayer@@UAE_NK@Z PROC	; CPythonPlayer::IsPartyMemberByVID, COMDAT
; _this$ = ecx

; 1375 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 91 a8 09 01
	00		 mov	 edx, DWORD PTR [ecx+68008]
  00009	56		 push	 esi

; 44   : 		{	// construct with node pointer _Pnode

  0000a	8b 02		 mov	 eax, DWORD PTR [edx]

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0000c	3b c2		 cmp	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1377 : 	for (; itor != m_PartyMemberMap.end(); ++itor)

  0000e	74 4c		 je	 SHORT $LN2@IsPartyMem
  00010	8b 75 08	 mov	 esi, DWORD PTR _dwVID$[ebp]
$LL27@IsPartyMem:

; 1378 : 	{
; 1379 : 		TPartyMemberInfo & rPartyMemberInfo = itor->second;
; 1380 : 		if (dwVID == rPartyMemberInfo.dwVID)

  00013	3b 70 14	 cmp	 esi, DWORD PTR [eax+20]
  00016	74 4b		 je	 SHORT $LN86@IsPartyMem
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00018	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001c	75 3a		 jne	 SHORT $LN89@IsPartyMem

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0001e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00021	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00025	75 16		 jne	 SHORT $LN85@IsPartyMem

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00027	8b c1		 mov	 eax, ecx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00029	8b 08		 mov	 ecx, DWORD PTR [eax]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0002b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0002f	75 27		 jne	 SHORT $LN89@IsPartyMem
$LL42@IsPartyMem:

; 617  : 			_Pnode = _Left(_Pnode);

  00031	8b c1		 mov	 eax, ecx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00033	8b 08		 mov	 ecx, DWORD PTR [eax]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00035	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00039	74 f6		 je	 SHORT $LL42@IsPartyMem

; 65   : 		else

  0003b	eb 1b		 jmp	 SHORT $LN89@IsPartyMem
$LN85@IsPartyMem:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00044	75 10		 jne	 SHORT $LN96@IsPartyMem
$LL26@IsPartyMem:
  00046	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00049	75 0b		 jne	 SHORT $LN96@IsPartyMem

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0004b	8b c1		 mov	 eax, ecx
  0004d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00050	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00054	74 f0		 je	 SHORT $LL26@IsPartyMem
$LN96@IsPartyMem:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00056	8b c1		 mov	 eax, ecx
$LN89@IsPartyMem:

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00058	3b c2		 cmp	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1377 : 	for (; itor != m_PartyMemberMap.end(); ++itor)

  0005a	75 b7		 jne	 SHORT $LL27@IsPartyMem
$LN2@IsPartyMem:

; 1382 : 	}
; 1383 : 
; 1384 : 	return false;

  0005c	32 c0		 xor	 al, al
  0005e	5e		 pop	 esi

; 1385 : }

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN86@IsPartyMem:

; 1381 : 			return true;

  00063	b0 01		 mov	 al, 1
  00065	5e		 pop	 esi

; 1385 : }

  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?IsPartyMemberByVID@CPythonPlayer@@UAE_NK@Z ENDP	; CPythonPlayer::IsPartyMemberByVID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsPartyMemberByName@CPythonPlayer@@QAE_NPBD@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv461 = -1						; size = 1
_c_szName$ = 8						; size = 4
?IsPartyMemberByName@CPythonPlayer@@QAE_NPBD@Z PROC	; CPythonPlayer::IsPartyMemberByName, COMDAT
; _this$ = ecx

; 1388 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00006	8b 81 ac 09 01
	00		 mov	 eax, DWORD PTR [ecx+68012]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 44   : 		{	// construct with node pointer _Pnode

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00014	3b f0		 cmp	 esi, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1390 : 	for (; itor != m_PartyMemberMap.end(); ++itor)

  00016	0f 84 b1 00 00
	00		 je	 $LN123@IsPartyMem
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0001c	8b 55 08	 mov	 edx, DWORD PTR _c_szName$[ebp]
  0001f	8a 02		 mov	 al, BYTE PTR [edx]
  00021	88 45 ff	 mov	 BYTE PTR tv461[ebp], al
$LL27@IsPartyMem:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1393 : 		if (0 == rPartyMemberInfo.strName.compare(c_szName))

  00024	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00027	84 c0		 test	 al, al
  00029	75 04		 jne	 SHORT $LN87@IsPartyMem
  0002b	33 ff		 xor	 edi, edi
  0002d	eb 11		 jmp	 SHORT $LN88@IsPartyMem
$LN87@IsPartyMem:
  0002f	8b fa		 mov	 edi, edx
  00031	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
$LL124@IsPartyMem:
  00034	8a 07		 mov	 al, BYTE PTR [edi]
  00036	47		 inc	 edi
  00037	84 c0		 test	 al, al
  00039	75 f9		 jne	 SHORT $LL124@IsPartyMem
  0003b	2b fa		 sub	 edi, edx
  0003d	8b 55 08	 mov	 edx, DWORD PTR _c_szName$[ebp]
$LN88@IsPartyMem:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00040	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  00044	8b 59 10	 mov	 ebx, DWORD PTR [ecx+16]

; 520  : 			: this->_Bx._Buf);

  00047	72 02		 jb	 SHORT $LN102@IsPartyMem
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00049	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN102@IsPartyMem:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2182 : 			_N0 < _Count ? _N0 : _Count);

  0004b	3b df		 cmp	 ebx, edi
  0004d	8b c7		 mov	 eax, edi
  0004f	0f 42 c3	 cmovb	 eax, ebx
  00052	50		 push	 eax
  00053	52		 push	 edx
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);

  0005d	85 c0		 test	 eax, eax
  0005f	75 0d		 jne	 SHORT $LN122@IsPartyMem
  00061	3b df		 cmp	 ebx, edi
  00063	72 09		 jb	 SHORT $LN122@IsPartyMem
  00065	3b df		 cmp	 ebx, edi
  00067	0f 95 c0	 setne	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1393 : 		if (0 == rPartyMemberInfo.strName.compare(c_szName))

  0006a	85 c0		 test	 eax, eax
  0006c	74 54		 je	 SHORT $LN112@IsPartyMem
$LN122@IsPartyMem:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  0006e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00072	75 3e		 jne	 SHORT $LN115@IsPartyMem

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00074	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00077	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0007b	75 16		 jne	 SHORT $LN110@IsPartyMem

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0007d	8b f0		 mov	 esi, eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0007f	8b 06		 mov	 eax, DWORD PTR [esi]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00081	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00085	75 2b		 jne	 SHORT $LN115@IsPartyMem
$LL42@IsPartyMem:

; 617  : 			_Pnode = _Left(_Pnode);

  00087	8b f0		 mov	 esi, eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00089	8b 06		 mov	 eax, DWORD PTR [esi]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0008b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0008f	74 f6		 je	 SHORT $LL42@IsPartyMem

; 65   : 		else

  00091	eb 1f		 jmp	 SHORT $LN115@IsPartyMem
$LN110@IsPartyMem:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00093	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00096	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0009a	75 14		 jne	 SHORT $LN125@IsPartyMem
  0009c	8d 64 24 00	 npad	 4
$LL26@IsPartyMem:
  000a0	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  000a3	75 0b		 jne	 SHORT $LN125@IsPartyMem

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  000a5	8b f0		 mov	 esi, eax
  000a7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000aa	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000ae	74 f0		 je	 SHORT $LL26@IsPartyMem
$LN125@IsPartyMem:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  000b0	8b f0		 mov	 esi, eax
$LN115@IsPartyMem:

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  000b2	3b 75 f8	 cmp	 esi, DWORD PTR $T1[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1390 : 	for (; itor != m_PartyMemberMap.end(); ++itor)

  000b5	74 16		 je	 SHORT $LN123@IsPartyMem
  000b7	8b 55 08	 mov	 edx, DWORD PTR _c_szName$[ebp]
  000ba	8a 45 ff	 mov	 al, BYTE PTR tv461[ebp]
  000bd	e9 62 ff ff ff	 jmp	 $LL27@IsPartyMem
$LN112@IsPartyMem:
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi

; 1394 : 			return true;

  000c4	b0 01		 mov	 al, 1
  000c6	5b		 pop	 ebx

; 1398 : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 04 00	 ret	 4
$LN123@IsPartyMem:
  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi

; 1395 : 	}
; 1396 : 
; 1397 : 	return false;

  000cf	32 c0		 xor	 al, al
  000d1	5b		 pop	 ebx

; 1398 : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c2 04 00	 ret	 4
?IsPartyMemberByName@CPythonPlayer@@QAE_NPBD@Z ENDP	; CPythonPlayer::IsPartyMemberByName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?PartyMemberVIDToPID@CPythonPlayer@@UAE_NKPAK@Z
_TEXT	SEGMENT
_dwVID$ = 8						; size = 4
_pdwPID$ = 12						; size = 4
?PartyMemberVIDToPID@CPythonPlayer@@UAE_NKPAK@Z PROC	; CPythonPlayer::PartyMemberVIDToPID, COMDAT
; _this$ = ecx

; 1426 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 91 a8 09 01
	00		 mov	 edx, DWORD PTR [ecx+68008]
  00009	56		 push	 esi

; 44   : 		{	// construct with node pointer _Pnode

  0000a	8b 02		 mov	 eax, DWORD PTR [edx]

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0000c	3b c2		 cmp	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1428 : 	for (; itor != m_PartyMemberMap.end(); ++itor)

  0000e	74 4c		 je	 SHORT $LN2@PartyMembe
  00010	8b 75 08	 mov	 esi, DWORD PTR _dwVID$[ebp]
$LL27@PartyMembe:

; 1429 : 	{
; 1430 : 		TPartyMemberInfo & rPartyMemberInfo = itor->second;
; 1431 : 		if (dwVID == rPartyMemberInfo.dwVID)

  00013	3b 70 14	 cmp	 esi, DWORD PTR [eax+20]
  00016	74 4b		 je	 SHORT $LN86@PartyMembe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00018	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001c	75 3a		 jne	 SHORT $LN89@PartyMembe

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0001e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00021	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00025	75 16		 jne	 SHORT $LN85@PartyMembe

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00027	8b c1		 mov	 eax, ecx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00029	8b 08		 mov	 ecx, DWORD PTR [eax]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0002b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0002f	75 27		 jne	 SHORT $LN89@PartyMembe
$LL42@PartyMembe:

; 617  : 			_Pnode = _Left(_Pnode);

  00031	8b c1		 mov	 eax, ecx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00033	8b 08		 mov	 ecx, DWORD PTR [eax]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00035	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00039	74 f6		 je	 SHORT $LL42@PartyMembe

; 65   : 		else

  0003b	eb 1b		 jmp	 SHORT $LN89@PartyMembe
$LN85@PartyMembe:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00044	75 10		 jne	 SHORT $LN96@PartyMembe
$LL26@PartyMembe:
  00046	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00049	75 0b		 jne	 SHORT $LN96@PartyMembe

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0004b	8b c1		 mov	 eax, ecx
  0004d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00050	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00054	74 f0		 je	 SHORT $LL26@PartyMembe
$LN96@PartyMembe:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00056	8b c1		 mov	 eax, ecx
$LN89@PartyMembe:

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00058	3b c2		 cmp	 eax, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1428 : 	for (; itor != m_PartyMemberMap.end(); ++itor)

  0005a	75 b7		 jne	 SHORT $LL27@PartyMembe
$LN2@PartyMembe:

; 1435 : 		}
; 1436 : 	}
; 1437 : 
; 1438 : 	return false;

  0005c	32 c0		 xor	 al, al
  0005e	5e		 pop	 esi

; 1439 : }

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
$LN86@PartyMembe:

; 1432 : 		{
; 1433 : 			*pdwPID = rPartyMemberInfo.dwPID;

  00063	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00066	8b 45 0c	 mov	 eax, DWORD PTR _pdwPID$[ebp]
  00069	5e		 pop	 esi
  0006a	89 08		 mov	 DWORD PTR [eax], ecx

; 1434 : 			return true;

  0006c	b0 01		 mov	 al, 1

; 1439 : }

  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
?PartyMemberVIDToPID@CPythonPlayer@@UAE_NKPAK@Z ENDP	; CPythonPlayer::PartyMemberVIDToPID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsSamePartyMember@CPythonPlayer@@UAE_NKK@Z
_TEXT	SEGMENT
_dwVID1$ = 8						; size = 4
_dwVID2$ = 12						; size = 4
?IsSamePartyMember@CPythonPlayer@@UAE_NKK@Z PROC	; CPythonPlayer::IsSamePartyMember, COMDAT
; _this$ = ecx

; 1442 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1443 : 	return (IsPartyMemberByVID(dwVID1) && IsPartyMemberByVID(dwVID2));

  00004	ff 75 08	 push	 DWORD PTR _dwVID1$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0000e	ff d0		 call	 eax
  00010	84 c0		 test	 al, al
  00012	74 17		 je	 SHORT $LN3@IsSamePart
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	8b ce		 mov	 ecx, esi
  00018	ff 75 0c	 push	 DWORD PTR _dwVID2$[ebp]
  0001b	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0001e	ff d0		 call	 eax
  00020	84 c0		 test	 al, al
  00022	74 07		 je	 SHORT $LN3@IsSamePart
  00024	b0 01		 mov	 al, 1
  00026	5e		 pop	 esi

; 1444 : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN3@IsSamePart:

; 1443 : 	return (IsPartyMemberByVID(dwVID1) && IsPartyMemberByVID(dwVID2));

  0002b	32 c0		 xor	 al, al
  0002d	5e		 pop	 esi

; 1444 : }

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?IsSamePartyMember@CPythonPlayer@@UAE_NKK@Z ENDP	; CPythonPlayer::IsSamePartyMember
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsChallengeInstance@CPythonPlayer@@QAE_NK@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
$T2 = 8							; size = 4
_dwVID$ = 8						; size = 4
?IsChallengeInstance@CPythonPlayer@@QAE_NK@Z PROC	; CPythonPlayer::IsChallengeInstance, COMDAT
; _this$ = ecx

; 1469 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2109 : 		while (!this->_Isnil(_Pnode))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwVID$[ebp]
  00007	57		 push	 edi

; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00008	8b b9 b4 09 01
	00		 mov	 edi, DWORD PTR [ecx+68020]

; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  0000e	8b d7		 mov	 edx, edi
  00010	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 2109 : 		while (!this->_Isnil(_Pnode))

  00013	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00017	75 1b		 jne	 SHORT $LN11@IsChalleng
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL12@IsChalleng:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00020	39 70 10	 cmp	 DWORD PTR [eax+16], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00023	73 05		 jae	 SHORT $LN10@IsChalleng

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  00028	eb 04		 jmp	 SHORT $LN9@IsChalleng
$LN10@IsChalleng:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0002a	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@IsChalleng:

; 2109 : 		while (!this->_Isnil(_Pnode))

  0002e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00032	74 ec		 je	 SHORT $LL12@IsChalleng
$LN11@IsChalleng:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00034	3b d7		 cmp	 edx, edi

; 1553 : 					? end() : _Where);

  00036	74 08		 je	 SHORT $LN5@IsChalleng
  00038	89 55 08	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0003b	3b 72 10	 cmp	 esi, DWORD PTR [edx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  0003e	73 03		 jae	 SHORT $LN90@IsChalleng
$LN5@IsChalleng:

; 44   : 		{	// construct with node pointer _Pnode

  00040	89 7d 08	 mov	 DWORD PTR $T2[ebp], edi
$LN90@IsChalleng:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00043	8b cf		 mov	 ecx, edi

; 1553 : 					? end() : _Where);

  00045	8d 55 08	 lea	 edx, DWORD PTR $T2[ebp]

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));

  00048	33 c0		 xor	 eax, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0004a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0004c	5f		 pop	 edi

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));

  0004d	0f 95 c0	 setne	 al
  00050	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1471 : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?IsChallengeInstance@CPythonPlayer@@QAE_NK@Z ENDP	; CPythonPlayer::IsChallengeInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsRevengeInstance@CPythonPlayer@@QAE_NK@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
$T2 = 8							; size = 4
_dwVID$ = 8						; size = 4
?IsRevengeInstance@CPythonPlayer@@QAE_NK@Z PROC		; CPythonPlayer::IsRevengeInstance, COMDAT
; _this$ = ecx

; 1473 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2109 : 		while (!this->_Isnil(_Pnode))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwVID$[ebp]
  00007	57		 push	 edi

; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00008	8b b9 bc 09 01
	00		 mov	 edi, DWORD PTR [ecx+68028]

; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  0000e	8b d7		 mov	 edx, edi
  00010	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 2109 : 		while (!this->_Isnil(_Pnode))

  00013	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00017	75 1b		 jne	 SHORT $LN11@IsRevengeI
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL12@IsRevengeI:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00020	39 70 10	 cmp	 DWORD PTR [eax+16], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00023	73 05		 jae	 SHORT $LN10@IsRevengeI

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  00028	eb 04		 jmp	 SHORT $LN9@IsRevengeI
$LN10@IsRevengeI:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0002a	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@IsRevengeI:

; 2109 : 		while (!this->_Isnil(_Pnode))

  0002e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00032	74 ec		 je	 SHORT $LL12@IsRevengeI
$LN11@IsRevengeI:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00034	3b d7		 cmp	 edx, edi

; 1553 : 					? end() : _Where);

  00036	74 08		 je	 SHORT $LN5@IsRevengeI
  00038	89 55 08	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0003b	3b 72 10	 cmp	 esi, DWORD PTR [edx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  0003e	73 03		 jae	 SHORT $LN90@IsRevengeI
$LN5@IsRevengeI:

; 44   : 		{	// construct with node pointer _Pnode

  00040	89 7d 08	 mov	 DWORD PTR $T2[ebp], edi
$LN90@IsRevengeI:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00043	8b cf		 mov	 ecx, edi

; 1553 : 					? end() : _Where);

  00045	8d 55 08	 lea	 edx, DWORD PTR $T2[ebp]

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));

  00048	33 c0		 xor	 eax, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0004a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0004c	5f		 pop	 edi

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));

  0004d	0f 95 c0	 setne	 al
  00050	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1475 : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?IsRevengeInstance@CPythonPlayer@@QAE_NK@Z ENDP		; CPythonPlayer::IsRevengeInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsCantFightInstance@CPythonPlayer@@QAE_NK@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
$T2 = 8							; size = 4
_dwVID$ = 8						; size = 4
?IsCantFightInstance@CPythonPlayer@@QAE_NK@Z PROC	; CPythonPlayer::IsCantFightInstance, COMDAT
; _this$ = ecx

; 1477 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2109 : 		while (!this->_Isnil(_Pnode))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwVID$[ebp]
  00007	57		 push	 edi

; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00008	8b b9 c4 09 01
	00		 mov	 edi, DWORD PTR [ecx+68036]

; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  0000e	8b d7		 mov	 edx, edi
  00010	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 2109 : 		while (!this->_Isnil(_Pnode))

  00013	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00017	75 1b		 jne	 SHORT $LN11@IsCantFigh
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL12@IsCantFigh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00020	39 70 10	 cmp	 DWORD PTR [eax+16], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00023	73 05		 jae	 SHORT $LN10@IsCantFigh

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  00028	eb 04		 jmp	 SHORT $LN9@IsCantFigh
$LN10@IsCantFigh:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0002a	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@IsCantFigh:

; 2109 : 		while (!this->_Isnil(_Pnode))

  0002e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00032	74 ec		 je	 SHORT $LL12@IsCantFigh
$LN11@IsCantFigh:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00034	3b d7		 cmp	 edx, edi

; 1553 : 					? end() : _Where);

  00036	74 08		 je	 SHORT $LN5@IsCantFigh
  00038	89 55 08	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0003b	3b 72 10	 cmp	 esi, DWORD PTR [edx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  0003e	73 03		 jae	 SHORT $LN90@IsCantFigh
$LN5@IsCantFigh:

; 44   : 		{	// construct with node pointer _Pnode

  00040	89 7d 08	 mov	 DWORD PTR $T2[ebp], edi
$LN90@IsCantFigh:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00043	8b cf		 mov	 ecx, edi

; 1553 : 					? end() : _Where);

  00045	8d 55 08	 lea	 edx, DWORD PTR $T2[ebp]

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));

  00048	33 c0		 xor	 eax, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0004a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0004c	5f		 pop	 edi

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));

  0004d	0f 95 c0	 setne	 al
  00050	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp

; 1479 : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?IsCantFightInstance@CPythonPlayer@@QAE_NK@Z ENDP	; CPythonPlayer::IsCantFightInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?IsOpenPrivateShop@CPythonPlayer@@QAE_NXZ
_TEXT	SEGMENT
?IsOpenPrivateShop@CPythonPlayer@@QAE_NXZ PROC		; CPythonPlayer::IsOpenPrivateShop, COMDAT
; _this$ = ecx

; 1492 : 	return m_isOpenPrivateShop;

  00000	8a 81 cc 09 01
	00		 mov	 al, BYTE PTR [ecx+68044]

; 1493 : }

  00006	c3		 ret	 0
?IsOpenPrivateShop@CPythonPlayer@@QAE_NXZ ENDP		; CPythonPlayer::IsOpenPrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetObserverMode@CPythonPlayer@@UAEX_N@Z
_TEXT	SEGMENT
_isEnable$ = 8						; size = 1
?SetObserverMode@CPythonPlayer@@UAEX_N@Z PROC		; CPythonPlayer::SetObserverMode, COMDAT
; _this$ = ecx

; 1496 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1497 : 	m_isObserverMode=isEnable;

  00003	8a 45 08	 mov	 al, BYTE PTR _isEnable$[ebp]
  00006	88 81 c9 09 01
	00		 mov	 BYTE PTR [ecx+68041], al

; 1498 : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetObserverMode@CPythonPlayer@@UAEX_N@Z ENDP		; CPythonPlayer::SetObserverMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__ToggleCoolTime@CPythonPlayer@@QAEHXZ
_TEXT	SEGMENT
?__ToggleCoolTime@CPythonPlayer@@QAEHXZ PROC		; CPythonPlayer::__ToggleCoolTime, COMDAT
; _this$ = ecx

; 1508 : 	m_sysIsCoolTime = 1 - m_sysIsCoolTime;

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	2b 81 e4 09 01
	00		 sub	 eax, DWORD PTR [ecx+68068]
  0000b	89 81 e4 09 01
	00		 mov	 DWORD PTR [ecx+68068], eax

; 1509 : 	return m_sysIsCoolTime;
; 1510 : }

  00011	c3		 ret	 0
?__ToggleCoolTime@CPythonPlayer@@QAEHXZ ENDP		; CPythonPlayer::__ToggleCoolTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?__ToggleLevelLimit@CPythonPlayer@@QAEHXZ
_TEXT	SEGMENT
?__ToggleLevelLimit@CPythonPlayer@@QAEHXZ PROC		; CPythonPlayer::__ToggleLevelLimit, COMDAT
; _this$ = ecx

; 1514 : 	m_sysIsLevelLimit = 1 - m_sysIsLevelLimit;

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	2b 81 e8 09 01
	00		 sub	 eax, DWORD PTR [ecx+68072]
  0000b	89 81 e8 09 01
	00		 mov	 DWORD PTR [ecx+68072], eax

; 1515 : 	return m_sysIsLevelLimit;
; 1516 : }

  00011	c3		 ret	 0
?__ToggleLevelLimit@CPythonPlayer@@QAEHXZ ENDP		; CPythonPlayer::__ToggleLevelLimit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?StartStaminaConsume@CPythonPlayer@@UAEXKK@Z
_TEXT	SEGMENT
_dwConsumePerSec$ = 8					; size = 4
_dwCurrentStamina$ = 12					; size = 4
?StartStaminaConsume@CPythonPlayer@@UAEXKK@Z PROC	; CPythonPlayer::StartStaminaConsume, COMDAT
; _this$ = ecx

; 1519 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	m_isConsumingStamina = TRUE;
; 1521 : 	m_fConsumeStaminaPerSec = float(dwConsumePerSec);

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwConsumePerSec$[ebp]
  00006	8b d1		 mov	 edx, ecx

; 1522 : 	m_fCurrentStamina = float(dwCurrentStamina);

  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _dwCurrentStamina$[ebp]
  0000b	66 0f 6e c0	 movd	 xmm0, eax
  0000f	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00013	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00016	c7 82 cc 09 01
	00 01 00 00 00	 mov	 DWORD PTR [edx+68044], 1
  00020	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00029	8b c1		 mov	 eax, ecx
  0002b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002e	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00032	f3 0f 11 82 d4
	09 01 00	 movss	 DWORD PTR [edx+68052], xmm0
  0003a	66 0f 6e c1	 movd	 xmm0, ecx
  0003e	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00042	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0004b	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0004f	f3 0f 11 82 d0
	09 01 00	 movss	 DWORD PTR [edx+68048], xmm0

; 1523 : 
; 1524 : 	SetStatus(POINT_STAMINA, dwCurrentStamina);

  00057	89 4d 0c	 mov	 DWORD PTR _dwCurrentStamina$[ebp], ecx
  0005a	c7 45 08 09 00
	00 00		 mov	 DWORD PTR _dwConsumePerSec$[ebp], 9
  00061	8d 4a fc	 lea	 ecx, DWORD PTR [edx-4]

; 1525 : }

  00064	5d		 pop	 ebp

; 1523 : 
; 1524 : 	SetStatus(POINT_STAMINA, dwCurrentStamina);

  00065	e9 00 00 00 00	 jmp	 ?SetStatus@CPythonPlayer@@QAEXKJ@Z ; CPythonPlayer::SetStatus
?StartStaminaConsume@CPythonPlayer@@UAEXKK@Z ENDP	; CPythonPlayer::StartStaminaConsume
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?StopStaminaConsume@CPythonPlayer@@UAEXK@Z
_TEXT	SEGMENT
_dwCurrentStamina$ = 8					; size = 4
?StopStaminaConsume@CPythonPlayer@@UAEXK@Z PROC		; CPythonPlayer::StopStaminaConsume, COMDAT
; _this$ = ecx

; 1528 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1529 : 	m_isConsumingStamina = FALSE;
; 1530 : 	m_fConsumeStaminaPerSec = 0.0f;
; 1531 : 	m_fCurrentStamina = float(dwCurrentStamina);

  00003	8b 55 08	 mov	 edx, DWORD PTR _dwCurrentStamina$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	c1 e8 1f	 shr	 eax, 31			; 0000001fH

; 1532 : 
; 1533 : 	SetStatus(POINT_STAMINA, dwCurrentStamina);

  0000b	52		 push	 edx
  0000c	c7 81 cc 09 01
	00 00 00 00 00	 mov	 DWORD PTR [ecx+68044], 0
  00016	66 0f 6e c2	 movd	 xmm0, edx
  0001a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0001e	c7 81 d4 09 01
	00 00 00 00 00	 mov	 DWORD PTR [ecx+68052], 0
  00028	6a 09		 push	 9
  0002a	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00033	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00037	f3 0f 11 81 d0
	09 01 00	 movss	 DWORD PTR [ecx+68048], xmm0
  0003f	83 c1 fc	 add	 ecx, -4			; fffffffcH
  00042	e8 00 00 00 00	 call	 ?SetStatus@CPythonPlayer@@QAEXKJ@Z ; CPythonPlayer::SetStatus

; 1534 : }

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?StopStaminaConsume@CPythonPlayer@@UAEXK@Z ENDP		; CPythonPlayer::StopStaminaConsume
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?GetPKMode@CPythonPlayer@@QAEKXZ
_TEXT	SEGMENT
?GetPKMode@CPythonPlayer@@QAEKXZ PROC			; CPythonPlayer::GetPKMode, COMDAT
; _this$ = ecx

; 1538 : 	CInstanceBase * pInstance = NEW_GetMainActorPtr();

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c1 04	 add	 ecx, 4
  00006	ff 90 88 00 00
	00		 call	 DWORD PTR [eax+136]

; 1539 : 	if (!pInstance)

  0000c	85 c0		 test	 eax, eax
  0000e	75 01		 jne	 SHORT $LN1@GetPKMode

; 1543 : }

  00010	c3		 ret	 0
$LN1@GetPKMode:

; 1540 : 		return 0;
; 1541 : 
; 1542 : 	return pInstance->GetPKMode();

  00011	8b c8		 mov	 ecx, eax
  00013	e8 00 00 00 00	 call	 ?GetPKMode@CInstanceBase@@QAEEXZ ; CInstanceBase::GetPKMode
  00018	0f b6 c0	 movzx	 eax, al

; 1543 : }

  0001b	c3		 ret	 0
?GetPKMode@CPythonPlayer@@QAEKXZ ENDP			; CPythonPlayer::GetPKMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetMobileFlag@CPythonPlayer@@UAEXH@Z
_TEXT	SEGMENT
_bFlag$ = 8						; size = 4
?SetMobileFlag@CPythonPlayer@@UAEXH@Z PROC		; CPythonPlayer::SetMobileFlag, COMDAT
; _this$ = ecx

; 1546 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 : 	m_bMobileFlag = bFlag;

  00003	8b 45 08	 mov	 eax, DWORD PTR _bFlag$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1548 : 	PyCallClassMemberFunc(m_ppyGameWindow, "RefreshMobile", Py_BuildValue("()"));

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0000e	89 86 dc 09 01
	00		 mov	 DWORD PTR [esi+68060], eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001a	50		 push	 eax
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@EHNHNBIB@RefreshMobile?$AA@
  00020	ff 76 04	 push	 DWORD PTR [esi+4]
  00023	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00028	83 c4 10	 add	 esp, 16			; 00000010H
  0002b	5e		 pop	 esi

; 1549 : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SetMobileFlag@CPythonPlayer@@UAEXH@Z ENDP		; CPythonPlayer::SetMobileFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?HasMobilePhoneNumber@CPythonPlayer@@QAEHXZ
_TEXT	SEGMENT
?HasMobilePhoneNumber@CPythonPlayer@@QAEHXZ PROC	; CPythonPlayer::HasMobilePhoneNumber, COMDAT
; _this$ = ecx

; 1553 : 	return m_bMobileFlag;

  00000	8b 81 e0 09 01
	00		 mov	 eax, DWORD PTR [ecx+68064]

; 1554 : }

  00006	c3		 ret	 0
?HasMobilePhoneNumber@CPythonPlayer@@QAEHXZ ENDP	; CPythonPlayer::HasMobilePhoneNumber
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?SetGameWindow@CPythonPlayer@@QAEXPAU_object@@@Z
_TEXT	SEGMENT
_ppyObject$ = 8						; size = 4
?SetGameWindow@CPythonPlayer@@QAEXPAU_object@@@Z PROC	; CPythonPlayer::SetGameWindow, COMDAT
; _this$ = ecx

; 1557 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1558 : 	m_ppyGameWindow = ppyObject;

  00003	8b 45 08	 mov	 eax, DWORD PTR _ppyObject$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1559 : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetGameWindow@CPythonPlayer@@QAEXPAU_object@@@Z ENDP	; CPythonPlayer::SetGameWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonplayer.cpp
;	COMDAT ?ClearSkillDict@CPythonPlayer@@QAEXXZ
_TEXT	SEGMENT
?ClearSkillDict@CPythonPlayer@@QAEXXZ PROC		; CPythonPlayer::ClearSkillDict, COMDAT
; _this$ = ecx

; 1591 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1592 : 	// ClearSkillDict
; 1593 : 	m_skillSlotDict.clear();

  00003	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00006	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::clear

; 1594 : 
; 1595 : 	// Game End - Player Data Reset
; 1596 : 	m_isOpenPrivateShop = false;

  0000b	66 c7 86 cc 09
	01 00 00 00	 mov	 WORD PTR [esi+68044], 0

; 1597 : 	m_isObserverMode = false;
; 1598 : 
; 1599 : 	m_isConsumingStamina = FALSE;
; 1600 : 	m_fConsumeStaminaPerSec = 0.0f;
; 1601 : 	m_fCurrentStamina = 0.0f;
; 1602 : 
; 1603 : 	m_bMobileFlag = FALSE;
; 1604 : 
; 1605 : 	__ClearAutoAttackTargetActorID();

  00014	8b ce		 mov	 ecx, esi
  00016	c7 86 d0 09 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+68048], 0
  00020	c7 86 d8 09 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+68056], 0
  0002a	c7 86 d4 09 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+68052], 0
  00034	c7 86 e0 09 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+68064], 0
  0003e	5e		 pop	 esi
  0003f	e9 00 00 00 00	 jmp	 ?__ClearAutoAttackTargetActorID@CPythonPlayer@@IAEXXZ ; CPythonPlayer::__ClearAutoAttackTargetActorID
?ClearSkillDict@CPythonPlayer@@QAEXXZ ENDP		; CPythonPlayer::ClearSkillDict
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCPythonPlayer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPythonPlayer@@UAEPAXI@Z PROC			; CPythonPlayer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPythonPlayer@@UAE@XZ ; CPythonPlayer::~CPythonPlayer
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCPythonPlayer@@UAEPAXI@Z ENDP			; CPythonPlayer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$map@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$map@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::~map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$map@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::~map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??A?$map@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEAAKABK@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
$T2 = 8							; size = 4
__Keyval$ = 8						; size = 4
??A?$map@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEAAKABK@Z PROC ; std::map<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::operator[], COMDAT
; _this$ = ecx

; 225  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2109 : 		while (!this->_Isnil(_Pnode))

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0000b	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 1187 : 		}
; 1188 : 
; 1189 : 
; 1190 : 	~_Tree() _NOEXCEPT
; 1191 : 		{	// destroy tree
; 1192 : 		_Tidy();
; 1193 : 		}
; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  0000d	8b f7		 mov	 esi, edi
  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 2109 : 		while (!this->_Isnil(_Pnode))

  00012	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00016	75 1c		 jne	 SHORT $LN9@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL10@operator:
  00020	39 50 10	 cmp	 DWORD PTR [eax+16], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00023	73 05		 jae	 SHORT $LN8@operator

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  00028	eb 04		 jmp	 SHORT $LN7@operator
$LN8@operator:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0002a	8b f0		 mov	 esi, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@operator:

; 2109 : 		while (!this->_Isnil(_Pnode))

  0002e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00032	74 ec		 je	 SHORT $LL10@operator
$LN9@operator:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00034	3b f7		 cmp	 esi, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 228  : 			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

  00036	74 11		 je	 SHORT $LN1@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00038	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003a	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 228  : 			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

  0003d	72 0a		 jb	 SHORT $LN1@operator

; 234  : 
; 235  : 
; 236  : 		return (_Where->second);

  0003f	5f		 pop	 edi
  00040	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 237  : 		}

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN1@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

  00049	51		 push	 ecx
  0004a	8d 45 08	 lea	 eax, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  0004d	89 4d 08	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

  00050	50		 push	 eax
  00051	51		 push	 ecx
  00052	8b cb		 mov	 ecx, ebx
  00054	e8 00 00 00 00	 call	 ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  00059	50		 push	 eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  0005a	83 c0 10	 add	 eax, 16			; 00000010H

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  0005d	8b cb		 mov	 ecx, ebx
  0005f	50		 push	 eax
  00060	56		 push	 esi
  00061	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_hint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 233  : 				tuple<>());

  0006a	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 234  : 
; 235  : 
; 236  : 		return (_Where->second);

  0006f	83 c0 14	 add	 eax, 20			; 00000014H
  00072	5b		 pop	 ebx

; 237  : 		}

  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
??A?$map@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEAAKABK@Z ENDP ; std::map<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
;	COMDAT ??0?$TAbstractSingleton@VIAbstractPlayer@@@@QAE@XZ
_TEXT	SEGMENT
??0?$TAbstractSingleton@VIAbstractPlayer@@@@QAE@XZ PROC	; TAbstractSingleton<IAbstractPlayer>::TAbstractSingleton<IAbstractPlayer>, COMDAT
; _this$ = ecx

; 9    : 	TAbstractSingleton()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$TAbstractSingleton@VIAbstractPlayer@@@@6B@

; 10   : 	{ 
; 11   : 		assert(!ms_singleton);
; 12   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 
; 13   : 		ms_singleton = (T*) ((int) this + offset);
; 14   : 	} 

  00006	8b c1		 mov	 eax, ecx
  00008	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A, ecx ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  0000e	c3		 ret	 0
??0?$TAbstractSingleton@VIAbstractPlayer@@@@QAE@XZ ENDP	; TAbstractSingleton<IAbstractPlayer>::TAbstractSingleton<IAbstractPlayer>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
;	COMDAT ??1?$TAbstractSingleton@VIAbstractPlayer@@@@UAE@XZ
_TEXT	SEGMENT
??1?$TAbstractSingleton@VIAbstractPlayer@@@@UAE@XZ PROC	; TAbstractSingleton<IAbstractPlayer>::~TAbstractSingleton<IAbstractPlayer>, COMDAT
; _this$ = ecx

; 17   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$TAbstractSingleton@VIAbstractPlayer@@@@6B@

; 18   : 		assert(ms_singleton);
; 19   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A, 0 ; TAbstractSingleton<IAbstractPlayer>::ms_singleton

; 20   : 	}

  00010	c3		 ret	 0
??1?$TAbstractSingleton@VIAbstractPlayer@@@@UAE@XZ ENDP	; TAbstractSingleton<IAbstractPlayer>::~TAbstractSingleton<IAbstractPlayer>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??0?$CSingleton@VCPythonPlayer@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CSingleton@VCPythonPlayer@@@@QAE@XZ PROC		; CSingleton<CPythonPlayer>::CSingleton<CPythonPlayer>, COMDAT
; _this$ = ecx

; 11   : 	CSingleton()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCPythonPlayer@@@@6B@

; 12   : 	{ 
; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 
; 15   : 		ms_singleton = (T*) ((int) this + offset);
; 16   : 	} 

  00006	8b c1		 mov	 eax, ecx
  00008	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A, ecx ; CSingleton<CPythonPlayer>::ms_singleton
  0000e	c3		 ret	 0
??0?$CSingleton@VCPythonPlayer@@@@QAE@XZ ENDP		; CSingleton<CPythonPlayer>::CSingleton<CPythonPlayer>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??1?$CSingleton@VCPythonPlayer@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CSingleton@VCPythonPlayer@@@@UAE@XZ PROC		; CSingleton<CPythonPlayer>::~CSingleton<CPythonPlayer>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCPythonPlayer@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A, 0 ; CSingleton<CPythonPlayer>::ms_singleton

; 22   : 	}

  00010	c3		 ret	 0
??1?$CSingleton@VCPythonPlayer@@@@UAE@XZ ENDP		; CSingleton<CPythonPlayer>::~CSingleton<CPythonPlayer>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??0?$map@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >, COMDAT
; _this$ = ecx

; 95   : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 96   : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c3		 ret	 0
??0?$map@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::map<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >, COMDAT
; _this$ = ecx

; 1191 : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1193 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::begin, COMDAT
; _this$ = ecx

; 1211 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 44   : 		{	// construct with node pointer _Pnode

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::end, COMDAT
; _this$ = ecx

; 1221 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAEIABK@Z
_TEXT	SEGMENT
__Where$ = -8						; size = 8
$T1 = -4						; size = 4
$T2 = 8							; size = 1
__Num$ = 8						; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAEIABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase, COMDAT
; _this$ = ecx

; 1526 : 		{	// erase and count all that match _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));

  00007	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000a	8d 45 f8	 lea	 eax, DWORD PTR __Where$[ebp]

; 1526 : 		{	// erase and count all that match _Keyval

  0000d	8b d9		 mov	 ebx, ecx

; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));

  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Eqrange

; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;

  00015	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Num$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  0001c	8d 4d 08	 lea	 ecx, DWORD PTR __Num$[ebp]
  0001f	ff 75 08	 push	 DWORD PTR $T2[ebp]
  00022	ff 75 fc	 push	 DWORD PTR __Where$[ebp+4]
  00025	ff 75 f8	 push	 DWORD PTR __Where$[ebp]
  00028	e8 00 00 00 00	 call	 ??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,unsigned int>
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1530 : 		erase(_Where.first, _Where.second);

  00030	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00033	8b cb		 mov	 ecx, ebx
  00035	ff 75 fc	 push	 DWORD PTR __Where$[ebp+4]
  00038	ff 75 f8	 push	 DWORD PTR __Where$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase

; 1531 : 		return (_Num);

  00041	8b 45 08	 mov	 eax, DWORD PTR __Num$[ebp]
  00044	5b		 pop	 ebx

; 1532 : 		}

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAEIABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::clear, COMDAT
; _this$ = ecx

; 1535 : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Erase

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0000d	8b 06		 mov	 eax, DWORD PTR [esi]

; 1541 : 		_Root() = this->_Myhead;

  0000f	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1542 : 		_Lmost() = this->_Myhead;

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	89 00		 mov	 DWORD PTR [eax], eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]

; 1543 : 		_Rmost() = this->_Myhead;

  00018	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1544 : 		this->_Mysize = 0;

  0001b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00022	5e		 pop	 esi

; 1545 : 		}

  00023	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::find, COMDAT
; _this$ = ecx

; 1548 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00004	8b 31		 mov	 esi, DWORD PTR [ecx]

; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00006	8b ce		 mov	 ecx, esi
  00008	57		 push	 edi

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00013	75 16		 jne	 SHORT $LN9@find
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00015	8b 17		 mov	 edx, DWORD PTR [edi]
$LL10@find:
  00017	39 50 10	 cmp	 DWORD PTR [eax+16], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  0001a	73 05		 jae	 SHORT $LN8@find

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001f	eb 04		 jmp	 SHORT $LN7@find
$LN8@find:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  00021	8b c8		 mov	 ecx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find:

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00025	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00029	74 ec		 je	 SHORT $LL10@find
$LN9@find:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0002b	3b ce		 cmp	 ecx, esi

; 1553 : 					? end() : _Where);

  0002d	74 0a		 je	 SHORT $LN3@find
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  00031	89 4d 0c	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00034	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  00037	73 03		 jae	 SHORT $LN82@find
$LN3@find:

; 44   : 		{	// construct with node pointer _Pnode

  00039	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
$LN82@find:

; 1553 : 					? end() : _Where);

  0003c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003f	8d 4d 0c	 lea	 ecx, DWORD PTR $T2[ebp]
  00042	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	89 08		 mov	 DWORD PTR [eax], ecx

; 1554 : 		}

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator->, COMDAT
; _this$ = ecx

; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator++, COMDAT
; _this$ = ecx

; 411  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 271  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator++

; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 414  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator==, COMDAT
; _this$ = ecx

; 322  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 337  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 342  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
;	COMDAT ??_G?$TAbstractSingleton@VIAbstractPlayer@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$TAbstractSingleton@VIAbstractPlayer@@@@UAEPAXI@Z PROC ; TAbstractSingleton<IAbstractPlayer>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 19   : 		ms_singleton = 0; 

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A, 0 ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$TAbstractSingleton@VIAbstractPlayer@@@@6B@
  0001a	74 09		 je	 SHORT $LN6@scalar
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_G?$TAbstractSingleton@VIAbstractPlayer@@@@UAEPAXI@Z ENDP ; TAbstractSingleton<IAbstractPlayer>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??_G?$CSingleton@VCPythonPlayer@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CSingleton@VCPythonPlayer@@@@UAEPAXI@Z PROC	; CSingleton<CPythonPlayer>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 21   : 		ms_singleton = 0; 

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A, 0 ; CSingleton<CPythonPlayer>::ms_singleton
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCPythonPlayer@@@@6B@
  0001a	74 09		 je	 SHORT $LN6@scalar
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_G?$CSingleton@VCPythonPlayer@@@@UAEPAXI@Z ENDP	; CSingleton<CPythonPlayer>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::~_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >, COMDAT
; _this$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::~_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAE@XZ PROC ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::~_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >, COMDAT
; _this$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAE@XZ ENDP ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::~_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >, COMDAT
; _this$ = ecx

; 1066 : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 1067 : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase, COMDAT
; _this$ = ecx

; 1511 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]

; 1512 : 		if (_First == begin() && _Last == end())

  00007	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0000d	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0000f	3b 01		 cmp	 eax, DWORD PTR [ecx]

; 1512 : 		if (_First == begin() && _Last == end())

  00011	75 33		 jne	 SHORT $LN115@erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00013	3b d1		 cmp	 edx, ecx

; 1512 : 		if (_First == begin() && _Last == end())

  00015	75 2f		 jne	 SHORT $LN115@erase

; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());

  00017	ff 71 04	 push	 DWORD PTR [ecx+4]
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Erase

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00021	8b 06		 mov	 eax, DWORD PTR [esi]

; 1541 : 		_Root() = this->_Myhead;

  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1542 : 		_Lmost() = this->_Myhead;

  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	89 00		 mov	 DWORD PTR [eax], eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]

; 1543 : 		_Rmost() = this->_Myhead;

  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]

; 1544 : 		this->_Mysize = 0;

  00031	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00038	5e		 pop	 esi

; 44   : 		{	// construct with node pointer _Pnode

  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003e	89 08		 mov	 DWORD PTR [eax], ecx

; 1522 : 			}
; 1523 : 		}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 0c 00	 ret	 12			; 0000000cH
$LN115@erase:

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00046	3b c2		 cmp	 eax, edx

; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

  00048	74 65		 je	 SHORT $LN1@erase
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL2@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00050	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;

  00054	8b c8		 mov	 ecx, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00056	75 43		 jne	 SHORT $LN77@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00058	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0005b	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0005f	75 1b		 jne	 SHORT $LN117@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00061	8b 02		 mov	 eax, DWORD PTR [edx]

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00063	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00067	75 2f		 jne	 SHORT $LN127@erase
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL92@erase:

; 617  : 			_Pnode = _Left(_Pnode);

  00070	8b d0		 mov	 edx, eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00072	8b 02		 mov	 eax, DWORD PTR [edx]

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00074	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00078	74 f6		 je	 SHORT $LL92@erase

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else

  0007a	eb 1c		 jmp	 SHORT $LN127@erase
$LN117@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0007c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0007f	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00083	75 13		 jne	 SHORT $LN127@erase
$LL76@erase:
  00085	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00088	75 0e		 jne	 SHORT $LN127@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0008a	8b c2		 mov	 eax, edx
  0008c	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
  0008f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00092	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00096	74 ed		 je	 SHORT $LL76@erase
$LN127@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00098	89 55 0c	 mov	 DWORD PTR __First$[ebp], edx
$LN77@erase:

; 1520 : 				erase(_First++);

  0009b	51		 push	 ecx
  0009c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0009f	8b ce		 mov	 ecx, esi
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  000a7	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  000aa	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]

; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

  000ad	75 a1		 jne	 SHORT $LL2@erase
$LN1@erase:

; 44   : 		{	// construct with node pointer _Pnode

  000af	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000b2	5e		 pop	 esi
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1521 : 			return (iterator(_First._Ptr, this));

  000b5	8b c1		 mov	 eax, ecx

; 1522 : 			}
; 1523 : 		}

  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();

  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 19		 jne	 SHORT $LN42@lower_boun
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL6@lower_boun:
  00013	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00016	73 05		 jae	 SHORT $LN4@lower_boun

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001b	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0001d	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun:

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00021	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00025	74 ec		 je	 SHORT $LL6@lower_boun
$LN42@lower_boun:

; 44   : 		{	// construct with node pointer _Pnode

  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	89 10		 mov	 DWORD PTR [eax], edx

; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::equal_range, COMDAT
; _this$ = ecx

; 1594 : 		{	// find range equivalent to _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1595 : 		return (_Eqrange(_Keyval));

  00003	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Eqrange
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1596 : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?equal_range@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2074 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;

  00005	8b 75 08	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b fe		 mov	 edi, esi

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000d	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00011	75 40		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));

  00013	ff 77 08	 push	 DWORD PTR [edi+8]
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0001d	83 7e 30 10	 cmp	 DWORD PTR [esi+48], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2079 : 			_Pnode = this->_Left(_Pnode);

  00021	8b 3f		 mov	 edi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00023	72 0b		 jb	 SHORT $LN51@Erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00025	ff 76 1c	 push	 DWORD PTR [esi+28]
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	83 c4 04	 add	 esp, 4
$LN51@Erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00030	c7 46 30 0f 00
	00 00		 mov	 DWORD PTR [esi+48], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00037	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0003e	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0003f	c6 46 1c 00	 mov	 BYTE PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00043	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00048	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0004b	8b f7		 mov	 esi, edi
  0004d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00051	74 c0		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2123 : 		return (this->_Left(this->_Myhead));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2124 : 		}

  00002	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}

  00005	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Root, COMDAT
; _this$ = ecx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4

; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}

  00005	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2229 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2230 : 		erase(begin(), end());

  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	50		 push	 eax
  00007	ff 30		 push	 DWORD PTR [eax]
  00009	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase

; 2231 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEABKPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEABKPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Key, COMDAT
; _this$dead$ = ecx

; 2239 : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2241 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Key@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEABKPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Getcomp, COMDAT
; _this$dead$ = ecx

; 1006 : 		{	// get ordering predicate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1007 : 		return (key_compare());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1008 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 779  : 		}

  00008	c3		 ret	 0
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 385  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator*, COMDAT
; _this$ = ecx

; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator++, COMDAT
; _this$ = ecx

; 256  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 273  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 124  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@SAPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@AAU32@@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@SAPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> *>::pointer_to, COMDAT
; __Val$ = ecx

; 234  : 		return (_STD addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 235  : 		}

  00002	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@SAPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv973 = -8						; size = 4
tv952 = -8						; size = 4
__Pnode$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase, COMDAT
; _this$ = ecx

; 1328 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	56		 push	 esi

; 1328 : 		{	// erase element at _Where

  0000b	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  0000e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00011	57		 push	 edi
  00012	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00017	8b 13		 mov	 edx, DWORD PTR [ebx]

; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00019	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0001d	74 05		 je	 SHORT $LN39@erase

; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  0001f	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00022	eb 1e		 jmp	 SHORT $LN353@erase
$LN39@erase:
  00024	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00027	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002b	74 04		 je	 SHORT $LN37@erase

; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  0002d	8b fa		 mov	 edi, edx

; 1349 : 		else

  0002f	eb 11		 jmp	 SHORT $LN353@erase
$LN37@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  00031	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00034	89 4d f8	 mov	 DWORD PTR __Pnode$1$[ebp], ecx

; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00037	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)

  0003a	3b cb		 cmp	 ecx, ebx
  0003c	0f 85 7e 00 00
	00		 jne	 $LN35@erase
$LN353@erase:

; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))

  00042	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00046	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00049	75 03		 jne	 SHORT $LN34@erase

; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  0004b	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0004e	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]

; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)

  00053	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00056	75 05		 jne	 SHORT $LN33@erase

; 1362 : 				_Root() = _Fixnode;	// link down from root

  00058	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  0005b	eb 0b		 jmp	 SHORT $LN30@erase
$LN33@erase:
  0005d	39 1e		 cmp	 DWORD PTR [esi], ebx
  0005f	75 04		 jne	 SHORT $LN31@erase

; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00061	89 3e		 mov	 DWORD PTR [esi], edi

; 1365 : 			else

  00063	eb 03		 jmp	 SHORT $LN30@erase
$LN31@erase:

; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right

  00065	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00068	8b 02		 mov	 eax, DWORD PTR [edx]

; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)

  0006a	39 18		 cmp	 DWORD PTR [eax], ebx
  0006c	75 22		 jne	 SHORT $LN29@erase

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0006e	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00072	74 04		 je	 SHORT $LN42@erase
  00074	8b ce		 mov	 ecx, esi
  00076	eb 16		 jmp	 SHORT $LN43@erase
$LN42@erase:

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00078	8b 07		 mov	 eax, DWORD PTR [edi]

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007a	8b cf		 mov	 ecx, edi

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0007c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00080	75 0a		 jne	 SHORT $LN92@erase
$LL93@erase:

; 617  : 			_Pnode = _Left(_Pnode);

  00082	8b c8		 mov	 ecx, eax

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00084	8b 01		 mov	 eax, DWORD PTR [ecx]

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00086	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0008a	74 f6		 je	 SHORT $LL93@erase
$LN92@erase:
  0008c	8b 02		 mov	 eax, DWORD PTR [edx]
$LN43@erase:

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0008e	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00090	8b 02		 mov	 eax, DWORD PTR [edx]
  00092	89 45 f8	 mov	 DWORD PTR tv952[ebp], eax

; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)

  00095	39 58 08	 cmp	 DWORD PTR [eax+8], ebx
  00098	0f 85 81 00 00
	00		 jne	 $LN170@erase

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  0009e	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000a2	74 0a		 je	 SHORT $LN44@erase
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR tv952[ebp]
  000a7	8b c6		 mov	 eax, esi
  000a9	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1378 : 			}
; 1379 : 		else

  000ac	eb 71		 jmp	 SHORT $LN170@erase
$LN44@erase:

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000ae	8b cf		 mov	 ecx, edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Max
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR tv952[ebp]
  000b8	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1378 : 			}
; 1379 : 		else

  000be	eb 5f		 jmp	 SHORT $LN170@erase
$LN35@erase:

; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up

  000c0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c5	89 01		 mov	 DWORD PTR [ecx], eax

; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 4b 08	 cmp	 ecx, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase

; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f1		 mov	 esi, ecx

; 1388 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase
$LN26@erase:

; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000d4	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000d7	75 03		 jne	 SHORT $LN24@erase

; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase:

; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000e1	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up

  000e4	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000e7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN25@erase:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000ea	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
  000ed	8b 02		 mov	 eax, DWORD PTR [edx]

; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)

  000ef	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  000f2	75 05		 jne	 SHORT $LN23@erase

; 1402 : 				_Root() = _Pnode;	// link down from root

  000f4	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f7	eb 0e		 jmp	 SHORT $LN20@erase
$LN23@erase:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  000f9	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000fc	39 18		 cmp	 DWORD PTR [eax], ebx
  000fe	75 04		 jne	 SHORT $LN21@erase

; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left

  00100	89 08		 mov	 DWORD PTR [eax], ecx

; 1406 : 			else

  00102	eb 03		 jmp	 SHORT $LN20@erase
$LN21@erase:

; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right

  00104	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN20@erase:

; 1411 : 				this->_Parent(_Erasednode);	// link successor up

  00107	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0010a	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1411 : 				this->_Parent(_Erasednode);	// link successor up

  0010d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00110	8a 43 0c	 mov	 al, BYTE PTR [ebx+12]
  00113	8a 49 0c	 mov	 cl, BYTE PTR [ecx+12]
  00116	88 42 0c	 mov	 BYTE PTR [edx+12], al
  00119	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]

; 54   : 	_Right = _Move(_Tmp);

  0011c	88 4b 0c	 mov	 BYTE PTR [ebx+12], cl
$LN170@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011f	80 7b 0c 01	 cmp	 BYTE PTR [ebx+12], 1
  00123	0f 85 25 01 00
	00		 jne	 $LN356@erase

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00129	8b 02		 mov	 eax, DWORD PTR [edx]
  0012b	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  0012e	0f 84 d3 00 00
	00		 je	 $LN358@erase
$LL18@erase:
  00134	80 7f 0c 01	 cmp	 BYTE PTR [edi+12], 1
  00138	0f 85 c9 00 00
	00		 jne	 $LN358@erase

; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  0013e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00140	3b f9		 cmp	 edi, ecx
  00142	75 7d		 jne	 SHORT $LN15@erase

; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);

  00144	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1424 : 					if (this->_Color(_Pnode) == this->_Red)

  00147	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0014b	75 16		 jne	 SHORT $LN14@erase

; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;

  0014d	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);

  00151	8b ca		 mov	 ecx, edx
  00153	56		 push	 esi
  00154	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  00158	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lrotate

; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00160	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN14@erase:

; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))

  00163	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00167	0f 85 8a 00 00
	00		 jne	 $LN359@erase

; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  0016d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016f	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00173	75 09		 jne	 SHORT $LN11@erase
  00175	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00178	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  0017c	74 75		 je	 SHORT $LN360@erase
$LN11@erase:

; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)

  0017e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00181	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00185	75 15		 jne	 SHORT $LN9@erase

; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  00187	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);

  00189	51		 push	 ecx
  0018a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0018e	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00192	8b ca		 mov	 ecx, edx
  00194	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Rrotate

; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);

  00199	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN9@erase:

; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0019c	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  0019f	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;

  001a2	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  001a6	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1454 : 						_Lrotate(_Fixnodeparent);

  001a9	56		 push	 esi
  001aa	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  001ad	8b ce		 mov	 ecx, esi
  001af	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  001b3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lrotate

; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  001b8	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
  001bc	e9 90 00 00 00	 jmp	 $LN19@erase
$LN15@erase:

; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)

  001c1	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001c5	75 15		 jne	 SHORT $LN7@erase

; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;

  001c7	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);

  001cb	8b ca		 mov	 ecx, edx
  001cd	56		 push	 esi
  001ce	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  001d2	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Rrotate

; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);

  001d7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001d9	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN7@erase:

; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))

  001dc	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001e0	75 15		 jne	 SHORT $LN359@erase

; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001e2	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001e5	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001e9	75 25		 jne	 SHORT $LN4@erase
  001eb	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ed	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001f1	75 1d		 jne	 SHORT $LN4@erase
$LN360@erase:

; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;

  001f3	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
$LN359@erase:

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001f7	8b 02		 mov	 eax, DWORD PTR [edx]

; 1476 : 						_Fixnode = _Fixnodeparent;

  001f9	8b fe		 mov	 edi, esi
  001fb	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001fe	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00201	0f 85 2d ff ff
	ff		 jne	 $LL18@erase
$LN358@erase:
  00207	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]

; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0020a	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
  0020e	eb 41		 jmp	 SHORT $LN19@erase
$LN4@erase:

; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00210	8b 01		 mov	 eax, DWORD PTR [ecx]
  00212	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00216	75 15		 jne	 SHORT $LN2@erase

; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00218	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);

  0021b	51		 push	 ecx
  0021c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00220	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00224	8b ca		 mov	 ecx, edx
  00226	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lrotate

; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);

  0022b	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN2@erase:

; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0022d	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  00230	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00233	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00237	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1491 : 						_Rrotate(_Fixnodeparent);

  00239	56		 push	 esi
  0023a	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  0023d	8b ce		 mov	 ecx, esi
  0023f	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00243	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Rrotate

; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00248	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
  0024c	eb 03		 jmp	 SHORT $LN19@erase
$LN356@erase:
  0024e	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
$LN19@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00251	83 7b 30 10	 cmp	 DWORD PTR [ebx+48], 16	; 00000010H
  00255	72 0b		 jb	 SHORT $LN319@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00257	ff 73 1c	 push	 DWORD PTR [ebx+28]
  0025a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0025f	83 c4 04	 add	 esp, 4
$LN319@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00262	c7 43 30 0f 00
	00 00		 mov	 DWORD PTR [ebx+48], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00269	c7 43 2c 00 00
	00 00		 mov	 DWORD PTR [ebx+44], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00270	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00271	c6 43 1c 00	 mov	 BYTE PTR [ebx+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00275	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1504 : 		if (0 < this->_Mysize)

  0027a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0027d	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

  00280	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]

; 1504 : 		if (0 < this->_Mysize)

  00283	85 c0		 test	 eax, eax
  00285	74 04		 je	 SHORT $LN355@erase

; 1505 : 			--this->_Mysize;

  00287	48		 dec	 eax
  00288	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN355@erase:

; 44   : 		{	// construct with node pointer _Pnode

  0028b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0028e	5f		 pop	 edi
  0028f	5e		 pop	 esi
  00290	5b		 pop	 ebx
  00291	89 08		 mov	 DWORD PTR [eax], ecx

; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}

  00293	8b e5		 mov	 esp, ebp
  00295	5d		 pop	 ebp
  00296	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Eqrange@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?_Eqrange@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Eqrange, COMDAT
; _this$ = ecx

; 2039 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00004	8b 19		 mov	 ebx, DWORD PTR [ecx]

; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails

  00006	8b d3		 mov	 edx, ebx
  00008	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0000b	8b c8		 mov	 ecx, eax

; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))

  0000d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00011	75 30		 jne	 SHORT $LN8@Eqrange
  00013	56		 push	 esi
  00014	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00015	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00018	8b 3f		 mov	 edi, DWORD PTR [edi]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL9@Eqrange:
  00020	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00023	3b f7		 cmp	 esi, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00025	73 05		 jae	 SHORT $LN7@Eqrange

; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00027	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 2047 : 			else

  0002a	eb 0f		 jmp	 SHORT $LN6@Eqrange
$LN7@Eqrange:

; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

  0002c	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00030	74 05		 je	 SHORT $LN5@Eqrange
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00032	3b fe		 cmp	 edi, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

  00034	0f 42 d1	 cmovb	 edx, ecx
$LN5@Eqrange:

; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;

  00037	8b d9		 mov	 ebx, ecx

; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN6@Eqrange:

; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))

  0003b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0003f	74 df		 je	 SHORT $LL9@Eqrange
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
$LN8@Eqrange:

; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound

  00043	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00047	75 02		 jne	 SHORT $LN13@Eqrange
  00049	8b 02		 mov	 eax, DWORD PTR [edx]
$LN13@Eqrange:

; 2059 : 		while (!this->_Isnil(_Pnode))

  0004b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004f	75 19		 jne	 SHORT $LN3@Eqrange
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00051	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00054	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL4@Eqrange:
  00056	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))

  00059	73 06		 jae	 SHORT $LN2@Eqrange

; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;

  0005b	8b d0		 mov	 edx, eax

; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0005d	8b 00		 mov	 eax, DWORD PTR [eax]

; 2064 : 				}
; 2065 : 			else

  0005f	eb 03		 jmp	 SHORT $LN1@Eqrange
$LN2@Eqrange:

; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00061	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN1@Eqrange:

; 2059 : 		while (!this->_Isnil(_Pnode))

  00064	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00068	74 ec		 je	 SHORT $LL4@Eqrange
$LN3@Eqrange:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0006a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0006d	89 18		 mov	 DWORD PTR [eax], ebx
  0006f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00072	5b		 pop	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2071 : 		}

  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
?_Eqrange@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Eqrange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 2105 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2106 : 		_Nodeptr _Pnode = _Root();

  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 19		 jne	 SHORT $LN32@Lbound
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL4@Lbound:
  00013	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00016	73 05		 jae	 SHORT $LN2@Lbound

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001b	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0001d	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Lbound:

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00021	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00025	74 ec		 je	 SHORT $LL4@Lbound
$LN32@Lbound:

; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate

  00027	8b c2		 mov	 eax, edx

; 2119 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lbound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEABKABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEABKABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Kfn, COMDAT
; _this$dead$ = ecx

; 2234 : 		{	// get key from value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2235 : 		return (_Traits::_Kfn(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 2236 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Kfn@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IBEABKABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >, COMDAT
; _this$ = ecx

; 1002 : 		{	// construct ordering predicate

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 1003 : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 08 00	 ret	 8
??0?$_Tree_comp@$0A@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Tree_comp<0,std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Freeheadnode, COMDAT
; _this$dead$ = ecx

; 857  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 865  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Getal, COMDAT
; _this$dead$ = ecx

; 868  : 		{	// get allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 870  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Isnil, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8d 41 0d	 lea	 eax, DWORD PTR [ecx+13]

; 585  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Left, COMDAT
; __Pnode$ = ecx

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00000	8b c1		 mov	 eax, ecx

; 590  : 		}

  00002	c3		 ret	 0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Parent, COMDAT
; __Pnode$ = ecx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 595  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Right, COMDAT
; __Pnode$ = ecx

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 600  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Myval, COMDAT
; __Pnode$ = ecx

; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 605  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@2@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 215  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator*, COMDAT
; _this$ = ecx

; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator++, COMDAT
; _this$ = ecx

; 276  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 277  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 271  : 		++(*(_Mybase *)this);

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator++

; 278  : 		++*this;
; 279  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 280  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

  00000	8b d1		 mov	 edx, ecx

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	75 42		 jne	 SHORT $LN41@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00011	75 1c		 jne	 SHORT $LN34@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	75 0f		 jne	 SHORT $LN17@operator
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator:

; 617  : 			_Pnode = _Left(_Pnode);

  00020	8b c8		 mov	 ecx, eax

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00022	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 f6		 je	 SHORT $LL18@operator
$LN17@operator:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0002a	89 0a		 mov	 DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

  0002c	8b c2		 mov	 eax, edx

; 74   : 		}

  0002e	c3		 ret	 0
$LN34@operator:

; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00036	75 12		 jne	 SHORT $LN1@operator
$LL2@operator:
  00038	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003a	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0003d	75 0b		 jne	 SHORT $LN1@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003f	89 02		 mov	 DWORD PTR [edx], eax
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00048	74 ee		 je	 SHORT $LL2@operator
$LN1@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  0004a	89 02		 mov	 DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

  0004c	8b c2		 mov	 eax, edx

; 74   : 		}

  0004e	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2127 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi

; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00007	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Lrotate:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0d		 jne	 SHORT $LN4@Lrotate

; 2136 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0002a	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0002c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002f	5e		 pop	 esi

; 2144 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@Lrotate:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00037	3b 10		 cmp	 edx, DWORD PTR [eax]
  00039	75 0c		 jne	 SHORT $LN2@Lrotate

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003b	89 30		 mov	 DWORD PTR [eax], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0003d	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0003f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00042	5e		 pop	 esi

; 2144 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0004f	5e		 pop	 esi

; 2144 : 		}

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2157 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Rrotate:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0e		 jne	 SHORT $LN4@Rrotate

; 2166 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0002a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  0002d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00030	5e		 pop	 esi

; 2174 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Rrotate:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00038	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003b	75 0e		 jne	 SHORT $LN2@Rrotate

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00043	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00046	5e		 pop	 esi

; 2174 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00053	5e		 pop	 esi

; 2174 : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??0?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >, COMDAT
; _this$ = ecx

; 889  : 		{	// construct from allocator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 890  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Color, COMDAT
; __Pnode$ = ecx

; 579  : 		return ((char&)_Pnode->_Color);

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]

; 580  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Max, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00003	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00007	75 12		 jne	 SHORT $LN15@Max
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL2@Max:

; 610  : 			_Pnode = _Right(_Pnode);

  00010	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN15@Max:

; 611  : 		return (_Pnode);

  0001b	8b c1		 mov	 eax, ecx

; 612  : 		}

  0001d	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Min, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00002	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00006	75 0a		 jne	 SHORT $LN15@Min
$LL2@Min:

; 617  : 			_Pnode = _Left(_Pnode);

  00008	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0000c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00010	74 f6		 je	 SHORT $LL2@Min
$LN15@Min:

; 618  : 		return (_Pnode);

  00012	8b c1		 mov	 eax, ecx

; 619  : 		}

  00014	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >, COMDAT
; _this$ = ecx

; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 774  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@1@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Buyheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 44		 push	 68			; 00000044H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 00 00 00
	00		 je	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00012	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	85 c9		 test	 ecx, ecx
  00019	74 02		 je	 SHORT $LN61@Buyheadnod
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
$LN61@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0001d	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00020	85 c9		 test	 ecx, ecx
  00022	74 02		 je	 SHORT $LN83@Buyheadnod
  00024	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 851  : 		this->_Color(_Pnode) = this->_Black;

  00026	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}

  0002c	c3		 ret	 0
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >, COMDAT
; _this$ = ecx

; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 570  : 		this->_Mysize = 0;
; 571  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 44		 push	 68			; 00000044H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN15@allocate

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

  0000e	c2 04 00	 ret	 4
$LN15@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN17@allocate:
$LN14@allocate:
  00016	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 44		 push	 68			; 00000044H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN12@allocate

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

  0000e	c2 04 00	 ret	 4
$LN12@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN14@allocate:
$LN11@allocate:
  00016	cc		 int	 3
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$swap@USQuickSlot@@@std@@YAXAAUSQuickSlot@@0@Z
_TEXT	SEGMENT
??$swap@USQuickSlot@@@std@@YAXAAUSQuickSlot@@0@Z PROC	; std::swap<SQuickSlot>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 52   : 	_Ty _Tmp = _Move(_Left);

  00000	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00003	56		 push	 esi

; 53   : 	_Left = _Move(_Right);

  00004	66 8b 32	 mov	 si, WORD PTR [edx]
  00007	66 89 31	 mov	 WORD PTR [ecx], si

; 54   : 	_Right = _Move(_Tmp);

  0000a	66 89 02	 mov	 WORD PTR [edx], ax
  0000d	5e		 pop	 esi

; 55   : 	}

  0000e	c3		 ret	 0
??$swap@USQuickSlot@@@std@@YAXAAUSQuickSlot@@0@Z ENDP	; std::swap<SQuickSlot>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$make_pair@AAKUSPartyMemberInfo@CPythonPlayer@@@std@@YA?AU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@0@AAK$$QAUSPartyMemberInfo@CPythonPlayer@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Val2$ = 8						; size = 4
??$make_pair@AAKUSPartyMemberInfo@CPythonPlayer@@@std@@YA?AU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@0@AAK$$QAUSPartyMemberInfo@CPythonPlayer@@@Z PROC ; std::make_pair<unsigned long &,CPythonPlayer::SPartyMemberInfo>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val1$ = edx

; 268  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 144  : 		{	// construct from moved values

  00004	8b 02		 mov	 eax, DWORD PTR [edx]
  00006	56		 push	 esi
  00007	ff 75 08	 push	 DWORD PTR __Val2$[ebp]

; 268  : 	{	// return pair composed from arguments

  0000a	8b f1		 mov	 esi, ecx
  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 144  : 		{	// construct from moved values

  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	e8 00 00 00 00	 call	 ??0SPartyMemberInfo@CPythonPlayer@@QAE@ABU01@@Z

; 269  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 270  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 271  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 272  : 		_STD forward<_Ty2>(_Val2)));
; 273  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$make_pair@AAKUSPartyMemberInfo@CPythonPlayer@@@std@@YA?AU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@0@AAK$$QAUSPartyMemberInfo@CPythonPlayer@@@Z ENDP ; std::make_pair<unsigned long &,CPythonPlayer::SPartyMemberInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::insert<std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >, COMDAT
; _this$ = ecx

; 1154 : 		typename enable_if<is_convertible<_Valty, value_type>::value,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1155 : 			_Pairib>::type
; 1156 : 		insert(_Valty&& _Val)
; 1157 : 		{	// try to insert node with value _Val, favoring right side
; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00004	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Buynode<std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0000e	50		 push	 eax

; 604  : 		return ((reference)_Pnode->_Myval);

  0000f	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00012	50		 push	 eax
  00013	51		 push	 ecx
  00014	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Insert_nohint<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00021	5f		 pop	 edi

; 1161 : 		}

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
??$insert@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::insert<std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QAH0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QAH0@Z PROC	; std::make_pair<int,int>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val1$ = edx

; 268  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 144  : 		{	// construct from moved values

  00003	8b 02		 mov	 eax, DWORD PTR [edx]
  00005	89 01		 mov	 DWORD PTR [ecx], eax
  00007	8b 45 08	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 269  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 270  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 271  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  0000f	8b c1		 mov	 eax, ecx

; 272  : 		_STD forward<_Ty2>(_Val2)));
; 273  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$make_pair@HH@std@@YA?AU?$pair@HH@0@$$QAH0@Z ENDP	; std::make_pair<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
_<_Val_0>$dead$ = 16					; size = 4
_<_Val_1>$ = 20						; size = 4
_<_Val_2>$dead$ = 24					; size = 4
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 1182 : 		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1183 : 		{	// insert value_type(_Val...) at _Where
; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

  00004	51		 push	 ecx
  00005	ff 75 14	 push	 DWORD PTR _<_Val_1>$[ebp]
  00008	8b f9		 mov	 edi, ecx
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  00010	50		 push	 eax

; 604  : 		return ((reference)_Pnode->_Myval);

  00011	83 c0 10	 add	 eax, 16			; 00000010H

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  00014	8b cf		 mov	 ecx, edi
  00016	50		 push	 eax
  00017	ff 75 0c	 push	 DWORD PTR __Where$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_hint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	5f		 pop	 edi

; 1187 : 		}

  00026	5d		 pop	 ebp
  00027	c2 14 00	 ret	 20			; 00000014H
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@0AAI@Z PROC ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,unsigned int>, COMDAT
; __Off$ = ecx

; 765  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00004	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,unsigned int>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 767  : 	}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YAPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YAPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YAPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >, COMDAT
; _this$dead$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00007	83 7e 20 10	 cmp	 DWORD PTR [esi+32], 16	; 00000010H
  0000b	72 0b		 jb	 SHORT $LN34@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 76 0c	 push	 DWORD PTR [esi+12]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN34@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00018	c7 46 20 0f 00
	00 00		 mov	 DWORD PTR [esi+32], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001f	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00026	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  0002a	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 880  : 		}

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@0@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@0@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBKUSPartyMemberInfo@CPythonPlayer@@@?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBKUSPartyMemberInfo@CPythonPlayer@@@?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z PROC ; std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0>::_Kfn<unsigned long const ,CPythonPlayer::SPartyMemberInfo>, COMDAT
; __Val$ = ecx

; 58   : 		{	// extract key from element value
; 59   : 		return (_Val.first);

  00000	8b c1		 mov	 eax, ecx

; 60   : 		}

  00002	c3		 ret	 0
??$_Kfn@$$CBKUSPartyMemberInfo@CPythonPlayer@@@?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z ENDP ; std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0>::_Kfn<unsigned long const ,CPythonPlayer::SPartyMemberInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>, COMDAT
; _this$dead$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
??$_Allocate@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >, COMDAT
; __Count$ = ecx

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	81 f9 c3 c3 c3
	03		 cmp	 ecx, 63161283		; 03c3c3c3H
  00006	77 17		 ja	 SHORT $LN1@Allocate
  00008	8b c1		 mov	 eax, ecx
  0000a	c1 e0 04	 shl	 eax, 4
  0000d	03 c1		 add	 eax, ecx
  0000f	c1 e0 02	 shl	 eax, 2
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00018	83 c4 04	 add	 esp, 4
  0001b	85 c0		 test	 eax, eax
  0001d	75 05		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0001f	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00024	c3		 ret	 0
??$_Allocate@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Move@AAUSQuickSlot@@@std@@YA$$QAUSQuickSlot@@AAU1@@Z
_TEXT	SEGMENT
??$_Move@AAUSQuickSlot@@@std@@YA$$QAUSQuickSlot@@AAU1@@Z PROC ; std::_Move<SQuickSlot &>, COMDAT
; __Arg$ = ecx

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1529 : 	}

  00002	c3		 ret	 0
??$_Move@AAUSQuickSlot@@@std@@YA$$QAUSQuickSlot@@AAU1@@Z ENDP ; std::_Move<SQuickSlot &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@USPartyMemberInfo@CPythonPlayer@@@std@@YA$$QAUSPartyMemberInfo@CPythonPlayer@@AAU12@@Z
_TEXT	SEGMENT
??$forward@USPartyMemberInfo@CPythonPlayer@@@std@@YA$$QAUSPartyMemberInfo@CPythonPlayer@@AAU12@@Z PROC ; std::forward<CPythonPlayer::SPartyMemberInfo>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@USPartyMemberInfo@CPythonPlayer@@@std@@YA$$QAUSPartyMemberInfo@CPythonPlayer@@AAU12@@Z ENDP ; std::forward<CPythonPlayer::SPartyMemberInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0AAKUSPartyMemberInfo@CPythonPlayer@@X@?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@AAK$$QAUSPartyMemberInfo@CPythonPlayer@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAKUSPartyMemberInfo@CPythonPlayer@@X@?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@AAK$$QAUSPartyMemberInfo@CPythonPlayer@@@Z PROC ; std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo>::pair<unsigned long,CPythonPlayer::SPartyMemberInfo><unsigned long &,CPythonPlayer::SPartyMemberInfo,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	56		 push	 esi
  00007	ff 75 0c	 push	 DWORD PTR __Val2$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00011	89 06		 mov	 DWORD PTR [esi], eax
  00013	e8 00 00 00 00	 call	 ??0SPartyMemberInfo@CPythonPlayer@@QAE@ABU01@@Z

; 145  : 		}

  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$?0AAKUSPartyMemberInfo@CPythonPlayer@@X@?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@AAK$$QAUSPartyMemberInfo@CPythonPlayer@@@Z ENDP ; std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo>::pair<unsigned long,CPythonPlayer::SPartyMemberInfo><unsigned long &,CPythonPlayer::SPartyMemberInfo,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YA$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YA$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YA$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
__Ptr$ = -24						; size = 4
__Pnode$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_<_Val_0>$ = 8						; size = 4
??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z PROC ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Buynode<std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >, COMDAT
; _this$ = ecx

; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();

  0002b	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Buynode0
  00030	8b f0		 mov	 esi, eax

; 928  : 		this->_Isnil(_Pnode) = false;
; 929  : 
; 930  : 		_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	89 75 ec	 mov	 DWORD PTR __Pnode$[ebp], esi

; 604  : 		return ((reference)_Pnode->_Myval);

  0003c	8d 56 10	 lea	 edx, DWORD PTR [esi+16]

; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;

  0003f	66 c7 46 0c 00
	00		 mov	 WORD PTR [esi+12], 0

; 931  : 		this->_Getal().construct(
; 932  : 			_STD addressof(this->_Myval(_Pnode)),
; 933  : 				_STD forward<_Valty>(_Val)...);

  00045	89 55 e8	 mov	 DWORD PTR __Ptr$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00048	89 55 e4	 mov	 DWORD PTR $T2[ebp], edx
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004f	85 d2		 test	 edx, edx
  00051	74 13		 je	 SHORT $LN30@Buynode
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00053	8b 4d 08	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
  00056	8b 01		 mov	 eax, DWORD PTR [ecx]
  00058	89 02		 mov	 DWORD PTR [edx], eax
  0005a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  0005d	50		 push	 eax
  0005e	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
  00061	e8 00 00 00 00	 call	 ??0SPartyMemberInfo@CPythonPlayer@@QAE@ABU01@@Z
$LN30@Buynode:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 939  : 		return (_Pnode);

  00066	8b c6		 mov	 eax, esi

; 940  : 		}

  00068	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0006b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00072	59		 pop	 ecx
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 04 00	 ret	 4
__catch$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007c	ff 75 ec	 push	 DWORD PTR __Pnode$[ebp]
  0007f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00084	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 936  : 		_RERAISE;

  00087	6a 00		 push	 0
  00089	6a 00		 push	 0
  0008b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN72@Buynode:
$LN71@Buynode:
  00090	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$2:
  00000	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ENDP ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Buynode<std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -28						; size = 4
__Addleft$2 = -24					; size = 1
__Where$3 = -20						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Leftish$dead$ = 12					; size = 1
$T4 = 16						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Insert_nohint<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>, COMDAT
; _this$ = ecx

; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	89 4d e4	 mov	 DWORD PTR _this$1$[ebp], ecx

; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty

  00035	b2 01		 mov	 dl, 1

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00037	8b 19		 mov	 ebx, DWORD PTR [ecx]

; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;

  00039	8b fb		 mov	 edi, ebx

; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty

  0003b	88 55 e8	 mov	 BYTE PTR __Addleft$2[ebp], dl
  0003e	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))

  00041	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00045	75 28		 jne	 SHORT $LN11@Insert_noh
  00047	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	8d 64 24 00	 npad	 4
$LL12@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00050	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1787 : 			_Wherenode = _Trynode;

  00053	8b f8		 mov	 edi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00055	0f 92 c2	 setb	 dl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

  00058	88 55 e8	 mov	 BYTE PTR __Addleft$2[ebp], dl

; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);

  0005b	84 d2		 test	 dl, dl
  0005d	74 04		 je	 SHORT $LN16@Insert_noh
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	eb 03		 jmp	 SHORT $LN17@Insert_noh
$LN16@Insert_noh:
  00063	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN17@Insert_noh:

; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))

  00066	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0006a	74 e4		 je	 SHORT $LL12@Insert_noh
  0006c	8b 4d e4	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN11@Insert_noh:

; 44   : 		{	// construct with node pointer _Pnode

  0006f	8b f7		 mov	 esi, edi
  00071	89 75 ec	 mov	 DWORD PTR __Where$3[ebp], esi

; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)

  00074	84 d2		 test	 dl, dl
  00076	74 3e		 je	 SHORT $LN106@Insert_noh

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00078	3b 3b		 cmp	 edi, DWORD PTR [ebx]

; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())

  0007a	75 2f		 jne	 SHORT $LN4@Insert_noh

; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,

  0007c	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0007f	51		 push	 ecx
  00080	57		 push	 edi
  00081	6a 01		 push	 1
$LN207@Insert_noh:
  00083	8d 45 10	 lea	 eax, DWORD PTR $T4[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Insert_at<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00091	89 08		 mov	 DWORD PTR [eax], ecx
  00093	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1829 : 		}

  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 10 00	 ret	 16			; 00000010H
$LN4@Insert_noh:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  000ab	8d 4d ec	 lea	 ecx, DWORD PTR __Where$3[ebp]
  000ae	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator--
  000b3	8b 75 ec	 mov	 esi, DWORD PTR __Where$3[ebp]
$LN106@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000b6	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  000b9	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000bc	3b 01		 cmp	 eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

  000be	73 1e		 jae	 SHORT $LN2@Insert_noh

; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  000c0	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000c3	51		 push	 ecx
  000c4	8b 4d e4	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000c7	57		 push	 edi
  000c8	ff 75 e8	 push	 DWORD PTR __Addleft$2[ebp]
  000cb	eb b6		 jmp	 SHORT $LN207@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z$0:

; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);

  000cd	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000d0	e8 00 00 00 00	 call	 ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Destroy_if_not_nil

; 1827 : 		_RERAISE;

  000d5	6a 00		 push	 0
  000d7	6a 00		 push	 0
  000d9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN208@Insert_noh:
$LN2@Insert_noh:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  000de	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000e1	83 7f 30 10	 cmp	 DWORD PTR [edi+48], 16	; 00000010H
  000e5	72 0b		 jb	 SHORT $LN175@Insert_noh
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000e7	ff 77 1c	 push	 DWORD PTR [edi+28]
  000ea	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ef	83 c4 04	 add	 esp, 4
$LN175@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  000f2	c7 47 30 0f 00
	00 00		 mov	 DWORD PTR [edi+48], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000f9	c7 47 2c 00 00
	00 00		 mov	 DWORD PTR [edi+44], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00100	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00101	c6 47 1c 00	 mov	 BYTE PTR [edi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00105	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0010a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0010d	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00110	89 30		 mov	 DWORD PTR [eax], esi
  00112	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1829 : 		}

  00116	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00119	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00120	59		 pop	 ecx
  00121	5f		 pop	 edi
  00122	5e		 pop	 esi
  00123	5b		 pop	 ebx
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 10 00	 ret	 16			; 00000010H
$LN205@Insert_noh:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Insert_nohint<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0HHX@?$pair@HH@std@@QAE@$$QAH0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HHX@?$pair@HH@std@@QAE@$$QAH0@Z PROC		; std::pair<int,int>::pair<int,int><int,int,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0HHX@?$pair@HH@std@@QAE@$$QAH0@Z ENDP		; std::pair<int,int>::pair<int,int><int,int,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
_<_Val_0>$dead$ = 8					; size = 4
_<_Val_1>$ = 12						; size = 4
_<_Val_2>$dead$ = 16					; size = 4
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();

  00003	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode0

; 604  : 		return ((reference)_Pnode->_Myval);

  00008	8d 50 10	 lea	 edx, DWORD PTR [eax+16]

; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;

  0000b	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00011	85 d2		 test	 edx, edx
  00013	74 10		 je	 SHORT $LN42@Buynode
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_1>$[ebp]
  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001c	89 0a		 mov	 DWORD PTR [edx], ecx
  0001e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN42@Buynode:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 940  : 		}

  00025	5d		 pop	 ebp
  00026	c2 0c 00	 ret	 12			; 0000000cH
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBKK@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::_Tree_buy<std::pair<unsigned long const ,unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 8
tv1139 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_hint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>, COMDAT
; _this$ = ecx

; 1661 : 		iterator _Insert_hint(const_iterator _Where,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx

; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN

  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)

  00034	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00038	75 27		 jne	 SHORT $LN33@Insert_hin

; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree

  0003a	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0003d	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00040	51		 push	 ecx
  00041	ff 33		 push	 DWORD PTR [ebx]
  00043	6a 01		 push	 1
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@AAU?$pair@$$CBKK@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_at<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  0004b	8b c6		 mov	 eax, esi

; 1773 : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 10 00	 ret	 16			; 00000010H
$LN33@Insert_hin:

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00061	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00063	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00066	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00069	3b 37		 cmp	 esi, DWORD PTR [edi]

; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())

  0006b	75 33		 jne	 SHORT $LN14@Insert_hin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0006d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006f	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  00072	0f 83 65 01 00
	00		 jae	 $LN1@Insert_hin

; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));

  00078	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0007b	51		 push	 ecx
  0007c	56		 push	 esi
  0007d	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00080	8b cb		 mov	 ecx, ebx
  00082	6a 01		 push	 1
  00084	56		 push	 esi
  00085	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@AAU?$pair@$$CBKK@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_at<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  0008a	8b c6		 mov	 eax, esi

; 1773 : 		}

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00096	59		 pop	 ecx
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 10 00	 ret	 16			; 00000010H
$LN14@Insert_hin:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  000a0	3b f7		 cmp	 esi, edi

; 1731 : 				}
; 1732 : 			else if (_Where == end())

  000a2	75 36		 jne	 SHORT $LN11@Insert_hin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  000a4	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000a7	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000aa	3b 01		 cmp	 eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  000ac	0f 83 2b 01 00
	00		 jae	 $LN1@Insert_hin

; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));

  000b2	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000b5	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000b8	51		 push	 ecx
  000b9	52		 push	 edx
  000ba	6a 00		 push	 0
  000bc	56		 push	 esi
  000bd	8b cb		 mov	 ecx, ebx
  000bf	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@AAU?$pair@$$CBKK@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_at<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  000c4	8b c6		 mov	 eax, esi

; 1773 : 		}

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d0	59		 pop	 ecx
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 10 00	 ret	 16			; 00000010H
$LN11@Insert_hin:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000da	8b 01		 mov	 eax, DWORD PTR [ecx]
  000dc	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000df	89 45 e8	 mov	 DWORD PTR tv1139[ebp], eax
  000e2	3b c8		 cmp	 ecx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  000e4	76 70		 jbe	 SHORT $LN452@Insert_hin

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  000e6	8d 4d ec	 lea	 ecx, DWORD PTR __Next$[ebp]

; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  000e9	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  000ec	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,unsigned long> > >,std::_Iterator_base0>::operator--
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000f1	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  000f4	8b 4d e8	 mov	 ecx, DWORD PTR tv1139[ebp]
  000f7	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  000fa	73 53		 jae	 SHORT $LN449@Insert_hin

; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  000fc	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));

  000ff	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00102	51		 push	 ecx
  00103	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00107	8b cb		 mov	 ecx, ebx
  00109	74 22		 je	 SHORT $LN7@Insert_hin
  0010b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0010e	50		 push	 eax
  0010f	6a 00		 push	 0
  00111	56		 push	 esi
  00112	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@AAU?$pair@$$CBKK@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_at<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  00117	8b c6		 mov	 eax, esi

; 1773 : 		}

  00119	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0011c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00123	59		 pop	 ecx
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	5b		 pop	 ebx
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 10 00	 ret	 16			; 00000010H
$LN7@Insert_hin:

; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));

  0012d	56		 push	 esi
  0012e	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00131	6a 01		 push	 1
  00133	56		 push	 esi
  00134	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@AAU?$pair@$$CBKK@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_at<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  00139	8b c6		 mov	 eax, esi

; 1773 : 		}

  0013b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0013e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00145	59		 pop	 ecx
  00146	5f		 pop	 edi
  00147	5e		 pop	 esi
  00148	5b		 pop	 ebx
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 10 00	 ret	 16			; 00000010H
$LN449@Insert_hin:
  0014f	8b c1		 mov	 eax, ecx
  00151	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00154	3b c8		 cmp	 ecx, eax
$LN452@Insert_hin:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  00156	0f 83 81 00 00
	00		 jae	 $LN1@Insert_hin

; 271  : 		++(*(_Mybase *)this);

  0015c	8d 4d ec	 lea	 ecx, DWORD PTR __Next$[ebp]

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  0015f	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi

; 271  : 		++(*(_Mybase *)this);

  00162	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,unsigned long> > >,std::_Iterator_base0>::operator++

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00167	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  0016a	3b c7		 cmp	 eax, edi

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  0016c	74 08		 je	 SHORT $LN3@Insert_hin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0016e	8b 4d e8	 mov	 ecx, DWORD PTR tv1139[ebp]
  00171	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  00174	73 67		 jae	 SHORT $LN1@Insert_hin
$LN3@Insert_hin:

; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  00176	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));

  00179	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0017c	51		 push	 ecx
  0017d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00181	8b cb		 mov	 ecx, ebx
  00183	74 22		 je	 SHORT $LN2@Insert_hin
  00185	56		 push	 esi
  00186	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00189	6a 00		 push	 0
  0018b	56		 push	 esi
  0018c	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@AAU?$pair@$$CBKK@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_at<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  00191	8b c6		 mov	 eax, esi

; 1773 : 		}

  00193	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00196	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019d	59		 pop	 ecx
  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	5b		 pop	 ebx
  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c2 10 00	 ret	 16			; 00000010H
$LN2@Insert_hin:

; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));

  001a7	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  001aa	50		 push	 eax
  001ab	6a 01		 push	 1
  001ad	56		 push	 esi
  001ae	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@AAU?$pair@$$CBKK@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_at<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  001b3	8b c6		 mov	 eax, esi

; 1773 : 		}

  001b5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001b8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bf	59		 pop	 ecx
  001c0	5f		 pop	 edi
  001c1	5e		 pop	 esi
  001c2	5b		 pop	 ebx
  001c3	8b e5		 mov	 esp, ebp
  001c5	5d		 pop	 ebp
  001c6	c2 10 00	 ret	 16			; 00000010H
__catch$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001c9	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  001cc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d1	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1768 : 		_RERAISE;

  001d4	6a 00		 push	 0
  001d6	6a 00		 push	 0
  001d8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN453@Insert_hin:
$LN1@Insert_hin:

; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);

  001dd	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  001e0	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  001e3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001ea	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  001ed	51		 push	 ecx
  001ee	50		 push	 eax
  001ef	8b cb		 mov	 ecx, ebx
  001f1	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_nohint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  001f6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001fb	89 08		 mov	 DWORD PTR [eax], ecx

; 1773 : 		}

  001fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00200	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00207	59		 pop	 ecx
  00208	5f		 pop	 edi
  00209	5e		 pop	 esi
  0020a	5b		 pop	 ebx
  0020b	8b e5		 mov	 esp, ebp
  0020d	5d		 pop	 ebp
  0020e	c2 10 00	 ret	 16			; 00000010H
$LN451@Insert_hin:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_hint@AAU?$pair@$$CBKK@std@@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@@1@AAU?$pair@$$CBKK@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Insert_hint<std::pair<unsigned long const ,unsigned long> &,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > >, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

  00000	8b c1		 mov	 eax, ecx

; 408  : 	}

  00002	c3		 ret	 0
??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,unsigned int>, COMDAT
; __Off$ = ecx

; 732  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 732  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  0000a	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  0000c	3b c2		 cmp	 eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 733  : 	for (; _First != _Last; ++_First)

  0000e	74 54		 je	 SHORT $LN1@Distance2
  00010	56		 push	 esi
  00011	8b 37		 mov	 esi, DWORD PTR [edi]
$LL12@Distance2:

; 734  : 		++_Off;

  00013	46		 inc	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00014	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00018	75 43		 jne	 SHORT $LN51@Distance2

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0001d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00021	75 19		 jne	 SHORT $LN48@Distance2

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00023	8b c1		 mov	 eax, ecx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00025	8b 08		 mov	 ecx, DWORD PTR [eax]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00027	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0002b	75 2d		 jne	 SHORT $LN26@Distance2
  0002d	8d 49 00	 npad	 3
$LL27@Distance2:

; 617  : 			_Pnode = _Left(_Pnode);

  00030	8b c1		 mov	 eax, ecx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00032	8b 08		 mov	 ecx, DWORD PTR [eax]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00034	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00038	74 f6		 je	 SHORT $LL27@Distance2

; 65   : 		else

  0003a	eb 1e		 jmp	 SHORT $LN26@Distance2
$LN48@Distance2:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0003c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003f	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00043	75 13		 jne	 SHORT $LN58@Distance2
$LL11@Distance2:
  00045	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00048	75 0e		 jne	 SHORT $LN58@Distance2

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0004a	8b c1		 mov	 eax, ecx
  0004c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
  0004f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00052	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00056	74 ed		 je	 SHORT $LL11@Distance2
$LN58@Distance2:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00058	8b c1		 mov	 eax, ecx
$LN26@Distance2:
  0005a	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN51@Distance2:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  0005d	3b c2		 cmp	 eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 733  : 	for (; _First != _Last; ++_First)

  0005f	75 b2		 jne	 SHORT $LL12@Distance2
  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	5e		 pop	 esi
$LN1@Distance2:
  00064	5f		 pop	 edi

; 735  : 	}

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00003	83 7e 20 10	 cmp	 DWORD PTR [esi+32], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN32@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	ff 76 0c	 push	 DWORD PTR [esi+12]
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN32@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00014	c7 46 20 0f 00
	00 00		 mov	 DWORD PTR [esi+32], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001b	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00022	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  00026	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 731  : 		}

  00027	c3		 ret	 0
??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z
_TEXT	SEGMENT
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 07		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 02		 mov	 DWORD PTR [edx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0SPartyMemberInfo@CPythonPlayer@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0SPartyMemberInfo@CPythonPlayer@@QAE@ABU01@@Z PROC	; CPythonPlayer::SPartyMemberInfo::SPartyMemberInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 726  : 		assign(_Right, 0, npos);

  0000a	6a ff		 push	 -1
  0000c	8b 06		 mov	 eax, DWORD PTR [esi]
  0000e	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00011	6a 00		 push	 0
  00013	89 07		 mov	 DWORD PTR [edi], eax
  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001b	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0001e	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00025	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 726  : 		assign(_Right, 0, npos);

  0002c	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0002d	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

  00030	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00035	0f b6 46 20	 movzx	 eax, BYTE PTR [esi+32]
  00039	88 47 20	 mov	 BYTE PTR [edi+32], al
  0003c	0f b6 46 21	 movzx	 eax, BYTE PTR [esi+33]
  00040	88 47 21	 mov	 BYTE PTR [edi+33], al
  00043	f3 0f 7e 46 22	 movq	 xmm0, QWORD PTR [esi+34]
  00048	66 0f d6 47 22	 movq	 QWORD PTR [edi+34], xmm0
  0004d	8b 46 2a	 mov	 eax, DWORD PTR [esi+42]
  00050	89 47 2a	 mov	 DWORD PTR [edi+42], eax
  00053	66 8b 46 2e	 mov	 ax, WORD PTR [esi+46]
  00057	66 89 47 2e	 mov	 WORD PTR [edi+46], ax
  0005b	8b c7		 mov	 eax, edi
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
??0SPartyMemberInfo@CPythonPlayer@@QAE@ABU01@@Z ENDP	; CPythonPlayer::SPartyMemberInfo::SPartyMemberInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$dead$ = ecx

; 1648 : 		{	// node exists, destroy it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 604  : 		return ((reference)_Pnode->_Myval);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newnode$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00007	83 7e 30 10	 cmp	 DWORD PTR [esi+48], 16	; 00000010H
  0000b	72 0b		 jb	 SHORT $LN42@Destroy_if
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 76 1c	 push	 DWORD PTR [esi+28]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN42@Destroy_if:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00018	c7 46 30 0f 00
	00 00		 mov	 DWORD PTR [esi+48], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001f	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00026	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00027	c6 46 1c 00	 mov	 BYTE PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0002b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00030	83 c4 04	 add	 esp, 4
  00033	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1653 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ PROC ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Buynode0, COMDAT
; _this$ = ecx

; 893  : 		{	// allocate a non-value node

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00001	6a 44		 push	 68			; 00000044H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 893  : 		{	// allocate a non-value node

  00003	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	8b d0		 mov	 edx, eax
  0000c	83 c4 04	 add	 esp, 4
  0000f	85 d2		 test	 edx, edx
  00011	74 1e		 je	 SHORT $LN96@Buynode0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00015	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00018	89 02		 mov	 DWORD PTR [edx], eax
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 04		 je	 SHORT $LN61@Buynode0
  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	89 01		 mov	 DWORD PTR [ecx], eax
$LN61@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00022	8d 4a 08	 lea	 ecx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00025	85 c9		 test	 ecx, ecx
  00027	74 04		 je	 SHORT $LN83@Buynode0
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 908  : 		return (_Pnode);

  0002d	8b c2		 mov	 eax, edx
  0002f	5e		 pop	 esi

; 909  : 		}

  00030	c3		 ret	 0
$LN96@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN98@Buynode0:
$LN95@Buynode0:
  00036	cc		 int	 3
?_Buynode0@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@XZ ENDP ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z PROC ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Freenode0, COMDAT
; _this$dead$ = ecx

; 912  : 		{	// free non-value node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 920  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freenode0@?$_Tree_buy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ENDP ; std::_Tree_buy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator--

; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 427  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator--, COMDAT
; _this$ = ecx

; 283  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator--

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 312  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

  00000	8b d1		 mov	 edx, ecx

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	74 08		 je	 SHORT $LN8@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	89 02		 mov	 DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

  0000f	8b c2		 mov	 eax, edx

; 102  : 		}

  00011	c3		 ret	 0
$LN8@operator:

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00014	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00018	75 19		 jne	 SHORT $LN40@operator

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0001a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  0001d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00021	75 36		 jne	 SHORT $LN21@operator
$LL22@operator:

; 610  : 			_Pnode = _Right(_Pnode);

  00023	8b c8		 mov	 ecx, eax

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00025	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00028	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002c	74 f5		 je	 SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002e	89 0a		 mov	 DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

  00030	8b c2		 mov	 eax, edx

; 102  : 		}

  00032	c3		 ret	 0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0003a	75 15		 jne	 SHORT $LN3@operator
  0003c	8d 64 24 00	 npad	 4
$LL4@operator:
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00044	75 0b		 jne	 SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00046	89 0a		 mov	 DWORD PTR [edx], ecx
  00048	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0004f	74 ef		 je	 SHORT $LL4@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00057	75 02		 jne	 SHORT $LN47@operator
$LN21@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  00059	89 0a		 mov	 DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

  0005b	8b c2		 mov	 eax, edx

; 102  : 		}

  0005d	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00026	89 55 f0	 mov	 DWORD PTR $T2[ebp], edx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 d2		 test	 edx, edx
  00032	74 13		 je	 SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00037	8b 01		 mov	 eax, DWORD PTR [ecx]
  00039	89 02		 mov	 DWORD PTR [edx], eax
  0003b	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  0003e	50		 push	 eax
  0003f	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
  00042	e8 00 00 00 00	 call	 ??0SPartyMemberInfo@CPythonPlayer@@QAE@ABU01@@Z
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 873  : 		}

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YAAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YAAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@YAAAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$dead$ = 20					; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Insert_at<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>, COMDAT
; _this$ = ecx

; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)

  00008	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000b	3d c2 c3 c3 03	 cmp	 eax, 63161282		; 03c3c3c2H
  00010	72 12		 jb	 SHORT $LN17@Insert_at

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00012	8b 75 18	 mov	 esi, DWORD PTR __Node$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00015	83 7e 30 10	 cmp	 DWORD PTR [esi+48], 16	; 00000010H
  00019	0f 82 b6 01 00
	00		 jb	 $LN71@Insert_at
  0001f	e9 a6 01 00 00	 jmp	 $LN392@Insert_at
$LN17@Insert_at:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1845 : 		_Newnode->_Parent = _Wherenode;

  00024	8b 5d 18	 mov	 ebx, DWORD PTR __Node$[ebp]
  00027	40		 inc	 eax
  00028	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0002b	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0002e	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)

  00031	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00033	3b c1		 cmp	 eax, ecx
  00035	75 0e		 jne	 SHORT $LN16@Insert_at

; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;

  00037	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0003a	8b 07		 mov	 eax, DWORD PTR [edi]

; 1850 : 			_Lmost() = _Newnode;

  0003c	89 18		 mov	 DWORD PTR [eax], ebx

; 1851 : 			_Rmost() = _Newnode;

  0003e	8b 07		 mov	 eax, DWORD PTR [edi]
  00040	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00043	eb 1f		 jmp	 SHORT $LN11@Insert_at
$LN16@Insert_at:

; 1852 : 			}
; 1853 : 		else if (_Addleft)

  00045	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00049	74 0c		 je	 SHORT $LN14@Insert_at

; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;

  0004b	89 18		 mov	 DWORD PTR [eax], ebx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0004d	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1856 : 			if (_Wherenode == _Lmost())

  0004f	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00051	75 11		 jne	 SHORT $LN11@Insert_at

; 1857 : 				_Lmost() = _Newnode;

  00053	89 19		 mov	 DWORD PTR [ecx], ebx

; 1858 : 			}
; 1859 : 		else

  00055	eb 0d		 jmp	 SHORT $LN11@Insert_at
$LN14@Insert_at:

; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;

  00057	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0005a	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1862 : 			if (_Wherenode == _Rmost())

  0005c	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0005f	75 03		 jne	 SHORT $LN11@Insert_at

; 1863 : 				_Rmost() = _Newnode;

  00061	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00064	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00067	8b f3		 mov	 esi, ebx
  00069	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0006d	0f 85 42 01 00
	00		 jne	 $LN9@Insert_at
$LL10@Insert_at:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00073	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00076	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00079	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0007b	3b c1		 cmp	 eax, ecx
  0007d	0f 85 a8 00 00
	00		 jne	 $LN8@Insert_at

; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00083	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]

; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)

  00086	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0008a	0f 84 a1 00 00
	00		 je	 $LN391@Insert_at

; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  00090	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00093	75 3a		 jne	 SHORT $LN172@Insert_at

; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);

  00095	8b f0		 mov	 esi, eax

; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00097	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0009a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009c	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0009f	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  000a1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000a5	75 03		 jne	 SHORT $LN171@Insert_at

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  000a7	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN171@Insert_at:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  000aa	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ad	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000b0	8b 07		 mov	 eax, DWORD PTR [edi]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  000b2	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  000b5	75 05		 jne	 SHORT $LN170@Insert_at

; 2136 : 			_Root() = _Pnode;

  000b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000ba	eb 0e		 jmp	 SHORT $LN167@Insert_at
$LN170@Insert_at:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  000bc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000bf	3b 30		 cmp	 esi, DWORD PTR [eax]
  000c1	75 04		 jne	 SHORT $LN168@Insert_at

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000c3	89 08		 mov	 DWORD PTR [eax], ecx

; 2139 : 		else

  000c5	eb 03		 jmp	 SHORT $LN167@Insert_at
$LN168@Insert_at:

; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000c7	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN167@Insert_at:

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  000ca	89 31		 mov	 DWORD PTR [ecx], esi

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  000cc	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN172@Insert_at:

; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up

  000cf	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000d2	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;

  000d6	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  000e0	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  000e6	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  000e8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000eb	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  000ed	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  000f0	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f4	75 03		 jne	 SHORT $LN234@Insert_at

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  000f6	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN234@Insert_at:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  000f9	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fc	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000ff	8b 07		 mov	 eax, DWORD PTR [edi]

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  00101	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00104	75 0b		 jne	 SHORT $LN233@Insert_at

; 2166 : 			_Root() = _Pnode;

  00106	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00109	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  0010c	e9 94 00 00 00	 jmp	 $LN390@Insert_at
$LN233@Insert_at:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00111	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00114	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00117	75 0b		 jne	 SHORT $LN231@Insert_at

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00119	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0011c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  0011f	e9 81 00 00 00	 jmp	 $LN390@Insert_at
$LN231@Insert_at:

; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00124	89 10		 mov	 DWORD PTR [eax], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00126	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  00129	eb 7a		 jmp	 SHORT $LN390@Insert_at
$LN8@Insert_at:

; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)

  0012b	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0012f	75 1a		 jne	 SHORT $LN3@Insert_at
$LN391@Insert_at:

; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00131	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1902 : 					this->_Color(_Wherenode) = this->_Black;

  00135	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;

  00139	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0013c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013f	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00143	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00146	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 1906 : 					}
; 1907 : 				else

  00149	eb 5d		 jmp	 SHORT $LN328@Insert_at
$LN3@Insert_at:

; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  0014b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0014d	75 0a		 jne	 SHORT $LN1@Insert_at

; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);

  0014f	8b f0		 mov	 esi, eax

; 1912 : 						_Rrotate(_Pnode);

  00151	8b cf		 mov	 ecx, edi
  00153	56		 push	 esi
  00154	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Rrotate
$LN1@Insert_at:

; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up

  00159	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0015c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;

  00160	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00163	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00166	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  0016a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0016d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00170	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  00173	8b 02		 mov	 eax, DWORD PTR [edx]
  00175	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00178	8b 02		 mov	 eax, DWORD PTR [edx]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0017a	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0017e	75 03		 jne	 SHORT $LN327@Insert_at

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00180	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN327@Insert_at:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00183	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00186	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00189	8b 07		 mov	 eax, DWORD PTR [edi]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  0018b	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0018e	75 05		 jne	 SHORT $LN326@Insert_at

; 2136 : 			_Root() = _Pnode;

  00190	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00193	eb 0e		 jmp	 SHORT $LN323@Insert_at
$LN326@Insert_at:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00195	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00198	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0019a	75 04		 jne	 SHORT $LN324@Insert_at

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0019c	89 10		 mov	 DWORD PTR [eax], edx

; 2139 : 		else

  0019e	eb 03		 jmp	 SHORT $LN323@Insert_at
$LN324@Insert_at:

; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  001a0	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN323@Insert_at:

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  001a3	89 0a		 mov	 DWORD PTR [edx], ecx
$LN390@Insert_at:

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  001a5	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN328@Insert_at:

; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  001a8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001ab	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001af	0f 84 be fe ff
	ff		 je	 $LL10@Insert_at
$LN9@Insert_at:

; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  001b5	8b 07		 mov	 eax, DWORD PTR [edi]
  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001bc	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 44   : 		{	// construct with node pointer _Pnode

  001c0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001c3	89 18		 mov	 DWORD PTR [eax], ebx
  001c5	5b		 pop	 ebx

; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}

  001c6	5d		 pop	 ebp
  001c7	c2 14 00	 ret	 20			; 00000014H
$LN392@Insert_at:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001ca	ff 76 1c	 push	 DWORD PTR [esi+28]
  001cd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d2	83 c4 04	 add	 esp, 4
$LN71@Insert_at:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  001d5	c7 46 30 0f 00
	00 00		 mov	 DWORD PTR [esi+48], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  001dc	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001e3	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  001e4	c6 46 1c 00	 mov	 BYTE PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001e8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001ed	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1839 : 			_Xlength_error("map/set<T> too long");

  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  001f5	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN394@Insert_at:
$LN389@Insert_at:
  001fa	cc		 int	 3
??$_Insert_at@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Insert_at<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > &,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 10		 je	 SHORT $LN19@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 01		 mov	 DWORD PTR [ecx], eax
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN19@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 873  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 10 00	 ret	 16			; 00000010H
??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::destroy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >, COMDAT
; _this$dead$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00007	83 7e 20 10	 cmp	 DWORD PTR [esi+32], 16	; 00000010H
  0000b	72 0b		 jb	 SHORT $LN30@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 76 0c	 push	 DWORD PTR [esi+12]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN30@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00018	c7 46 20 0f 00
	00 00		 mov	 DWORD PTR [esi+32], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001f	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00026	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  0002a	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 608  : 		}

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::destroy<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::destroy<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>, COMDAT
; _this$dead$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::destroy<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::construct<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::construct<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??_G?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_G?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAEPAXI@Z PROC ; std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00003	83 7e 20 10	 cmp	 DWORD PTR [esi+32], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN28@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	ff 76 0c	 push	 DWORD PTR [esi+12]
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN28@scalar:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00014	c7 46 20 0f 00
	00 00		 mov	 DWORD PTR [esi+32], 15	; 0000000fH
  0001b	8b c6		 mov	 eax, esi

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001d	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00024	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  00028	5e		 pop	 esi
  00029	c2 04 00	 ret	 4
??_G?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAEPAXI@Z ENDP ; std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??1?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@XZ PROC ; std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>::~pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00003	83 7e 20 10	 cmp	 DWORD PTR [esi+32], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN25@pair
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	ff 76 0c	 push	 DWORD PTR [esi+12]
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN25@pair:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00014	c7 46 20 0f 00
	00 00		 mov	 DWORD PTR [esi+32], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001b	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00022	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  00026	5e		 pop	 esi
  00027	c3		 ret	 0
??1?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@XZ ENDP ; std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>::~pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1277 : 		return (this->_Getal().max_size());

  00000	b8 c3 c3 c3 03	 mov	 eax, 63161283		; 03c3c3c3H

; 1278 : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::max_size, COMDAT
; _this$dead$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 c3 c3 c3 03	 mov	 eax, 63161283		; 03c3c3c3H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 735  : 		return (_Al.max_size());

  00000	b8 c3 c3 c3 03	 mov	 eax, 63161283		; 03c3c3c3H

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::max_size, COMDAT
; _this$dead$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 c3 c3 c3 03	 mov	 eax, 63161283		; 03c3c3c3H

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
__Ptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_<_Args_0>$ = 8						; size = 4
??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 55 f0	 mov	 DWORD PTR __Ptr$[ebp], edx

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00028	89 55 ec	 mov	 DWORD PTR $T2[ebp], edx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 d2		 test	 edx, edx
  00034	74 13		 je	 SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00039	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003b	89 02		 mov	 DWORD PTR [edx], eax
  0003d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00040	50		 push	 eax
  00041	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
  00044	e8 00 00 00 00	 call	 ??0SPartyMemberInfo@CPythonPlayer@@QAE@ABU01@@Z
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 724  : 		}

  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> > >::construct<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PAU21@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PAU21@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Buynode_if_nil<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &>, COMDAT
; _this$dead$ = ecx

; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Node$[ebp]

; 1639 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
??$_Buynode_if_nil@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@?$_Tree@V?$_Tmap_traits@KUSPartyMemberInfo@CPythonPlayer@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@1@PAU21@AAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CPythonPlayer::SPartyMemberInfo,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> >,0> >::_Buynode_if_nil<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > >, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
_<_Args_0>$dead$ = 8					; size = 4
_<_Args_1>$ = 12					; size = 4
_<_Args_2>$dead$ = 16					; size = 4
??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 10		 je	 SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  00007	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 724  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::construct<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00026	89 55 f0	 mov	 DWORD PTR $T2[ebp], edx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 d2		 test	 edx, edx
  00032	74 13		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00037	8b 01		 mov	 eax, DWORD PTR [ecx]
  00039	89 02		 mov	 DWORD PTR [edx], eax
  0003b	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  0003e	50		 push	 eax
  0003f	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
  00042	e8 00 00 00 00	 call	 ??0SPartyMemberInfo@CPythonPlayer@@QAE@ABU01@@Z
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 601  : 		}

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@U?$pair@KUSPartyMemberInfo@CPythonPlayer@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@1@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,void *> >::construct<std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>,std::pair<unsigned long,CPythonPlayer::SPartyMemberInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 10		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 01		 mov	 DWORD PTR [ecx], eax
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 601  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 10 00	 ret	 16			; 00000010H
??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0KUSPartyMemberInfo@CPythonPlayer@@X@?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0KUSPartyMemberInfo@CPythonPlayer@@X@?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z PROC ; std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo><unsigned long,CPythonPlayer::SPartyMemberInfo,void>, COMDAT
; _this$ = ecx

; 157  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	89 06		 mov	 DWORD PTR [esi], eax
  0000d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00010	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??0SPartyMemberInfo@CPythonPlayer@@QAE@ABU01@@Z

; 158  : 		}

  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??$?0KUSPartyMemberInfo@CPythonPlayer@@X@?$pair@$$CBKUSPartyMemberInfo@CPythonPlayer@@@std@@QAE@$$QAU?$pair@KUSPartyMemberInfo@CPythonPlayer@@@1@@Z ENDP ; std::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo>::pair<unsigned long const ,CPythonPlayer::SPartyMemberInfo><unsigned long,CPythonPlayer::SPartyMemberInfo,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0ABK$$$V@?$pair@$$CBKK@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABK@1@V?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0ABK$$$V@?$pair@$$CBKK@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABK@1@V?$tuple@$$$V@1@@Z PROC ; std::pair<unsigned long const ,unsigned long>::pair<unsigned long const ,unsigned long><unsigned long const &>, COMDAT
; _this$ = ecx

; 762  : 		{	// construct from pair of tuples

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 746  : 		{	// construct from pair of tuples

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 763  : 		}

  0000a	8b c1		 mov	 eax, ecx

; 746  : 		{	// construct from pair of tuples

  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 763  : 		}

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABK$$$V@?$pair@$$CBKK@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABK@1@V?$tuple@$$$V@1@@Z ENDP ; std::pair<unsigned long const ,unsigned long>::pair<unsigned long const ,unsigned long><unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0V?$tuple@ABK@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBKK@std@@QAE@AAV?$tuple@ABK@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$?0V?$tuple@ABK@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBKK@std@@QAE@AAV?$tuple@ABK@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z PROC ; std::pair<unsigned long const ,unsigned long>::pair<unsigned long const ,unsigned long><std::tuple<unsigned long const &>,std::tuple<>,0>, COMDAT
; _this$ = ecx

; 746  : 		{	// construct from pair of tuples

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 746  : 		{	// construct from pair of tuples

  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	89 01		 mov	 DWORD PTR [ecx], eax

; 747  : 		}

  0000c	8b c1		 mov	 eax, ecx
  0000e	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00015	5d		 pop	 ebp
  00016	c2 10 00	 ret	 16			; 00000010H
??$?0V?$tuple@ABK@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBKK@std@@QAE@AAV?$tuple@ABK@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z ENDP ; std::pair<unsigned long const ,unsigned long>::pair<unsigned long const ,unsigned long><std::tuple<unsigned long const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_ECPythonPlayer@@W3AEPAXI@Z
_TEXT	SEGMENT
??_ECPythonPlayer@@W3AEPAXI@Z PROC			; [thunk]:CPythonPlayer::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_ECPythonPlayer@@UAEPAXI@Z
??_ECPythonPlayer@@W3AEPAXI@Z ENDP			; [thunk]:CPythonPlayer::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\gametype.h
;	COMDAT ?IsValidCell@SItemPos@@QAE_NXZ
_TEXT	SEGMENT
?IsValidCell@SItemPos@@QAE_NXZ PROC			; SItemPos::IsValidCell, COMDAT
; _this$ = ecx

; 206  : 		switch (window_type)

  00000	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00003	48		 dec	 eax
  00004	74 19		 je	 SHORT $LN4@IsValidCel
  00006	48		 dec	 eax
  00007	74 16		 je	 SHORT $LN4@IsValidCel
  00009	83 e8 03	 sub	 eax, 3
  0000c	74 03		 je	 SHORT $LN2@IsValidCel

; 216  : 			break;
; 217  : 		default:
; 218  : 			return false;

  0000e	32 c0		 xor	 al, al

; 219  : 		}
; 220  : 	}

  00010	c3		 ret	 0
$LN2@IsValidCel:

; 210  : 			break;
; 211  : 		case EQUIPMENT:
; 212  : 			return cell < c_DragonSoul_Equip_End;
; 213  : 			break;
; 214  : 		case DRAGON_SOUL_INVENTORY:
; 215  : 			return cell < (DS_INVENTORY_MAX_NUM);

  00011	b8 c0 03 00 00	 mov	 eax, 960		; 000003c0H
  00016	66 39 41 01	 cmp	 WORD PTR [ecx+1], ax
  0001a	1b c0		 sbb	 eax, eax
  0001c	f7 d8		 neg	 eax

; 219  : 		}
; 220  : 	}

  0001e	c3		 ret	 0
$LN4@IsValidCel:

; 207  : 		{
; 208  : 		case INVENTORY:
; 209  : 			return cell < c_Inventory_Count;

  0001f	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
  00024	66 39 41 01	 cmp	 WORD PTR [ecx+1], ax
  00028	1b c0		 sbb	 eax, eax
  0002a	f7 d8		 neg	 eax

; 219  : 		}
; 220  : 	}

  0002c	c3		 ret	 0
?IsValidCell@SItemPos@@QAE_NXZ ENDP			; SItemPos::IsValidCell
_TEXT	ENDS
END
