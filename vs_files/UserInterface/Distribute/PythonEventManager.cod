; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonEventManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_01GLPGHMHM@z?$AA@				; `string'
PUBLIC	??_C@_04CHADEDPO@view?$AA@			; `string'
PUBLIC	??_C@_02HNLLPFKA@up?$AA@			; `string'
PUBLIC	??_C@_08LHFODBFO@distance?$AA@			; `string'
PUBLIC	??_C@_05HCKPILGO@cross?$AA@			; `string'
PUBLIC	??_C@_05NCNFOFLM@pitch?$AA@			; `string'
PUBLIC	??_C@_03BHFFHIBL@rot?$AA@			; `string'
PUBLIC	??_C@_0EK@NAEFMGNK@CPythonEventManager?3?3SetRestrict@ ; `string'
PUBLIC	??_C@_05MFEJDJP@value?$AA@			; `string'
PUBLIC	??_C@_01JEJKBAGA@g?$AA@				; `string'
PUBLIC	??_C@_0EH@KHNDFHCA@CPythonEventManager?3?3SetEventHan@ ; `string'
PUBLIC	??_C@_09DIPEHMLE@DoneEvent?$AA@			; `string'
PUBLIC	??_C@_01OJONOECF@b?$AA@				; `string'
PUBLIC	??_C@_0M@MHNDOIJH@OnLeftImage?$AA@		; `string'
PUBLIC	??_C@_03LOJEKLML@src?$AA@			; `string'
PUBLIC	??_C@_0BC@OIPDJOGL@OnBackgroundImage?$AA@	; `string'
PUBLIC	??_C@_0L@ELIGNPMG@OnTopImage?$AA@		; `string'
PUBLIC	??_C@_07COJEPNBG@OnImage?$AA@			; `string'
PUBLIC	??_C@_05GFDPDNFA@?$CIiis?$CJ?$AA@		; `string'
PUBLIC	??_C@_05PHLGJONK@title?$AA@			; `string'
PUBLIC	??_C@_0L@NDIFBCJA@image_name?$AA@		; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_04EBPADADD@desc?$AA@			; `string'
PUBLIC	??_C@_0L@HIIGNCOA@image_type?$AA@		; `string'
PUBLIC	??_C@_05KBOMEDGA@total?$AA@			; `string'
PUBLIC	??_C@_08GKIEGGBC@?$CIsissii?$CJ?$AA@		; `string'
PUBLIC	??_C@_03DAKNAIGI@idx?$AA@			; `string'
PUBLIC	??_C@_08KJCKKFJC@?$CIssssii?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BB@FCLBKNGH@OnInsertItemIcon?$AA@	; `string'
PUBLIC	??_C@_0BC@HCOLHKJD@BINARY_ClearQuest?$AA@	; `string'
PUBLIC	??_C@_0O@LBIBFC@OnInsertImage?$AA@		; `string'
PUBLIC	??_C@_09IGOOKEAE@icon_name?$AA@			; `string'
PUBLIC	??_C@_09CNONGEHE@icon_type?$AA@			; `string'
PUBLIC	??_C@_0BD@MDDAOGBD@?A?$LG?$LA?$KC?$LD?$KN?5?$LP?k?H?$KF?$LM?$KO?$DP?4?4?4?4?$AA@ ; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_06GEDDNFGH@?$CIisss?$CJ?$AA@		; `string'
PUBLIC	??_C@_09MIAHMBP@highlight?$AA@			; `string'
PUBLIC	??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BB@JCGLEGP@BINARY_RecvQuest?$AA@		; `string'
PUBLIC	??_C@_09LBCONMEI@blendtime?$AA@			; `string'
PUBLIC	??_C@_09IBEAJOHJ@RecvQuest?$AA@			; `string'
PUBLIC	??_C@_03LDCBIPEL@?$CIf?$CJ?$AA@			; `string'
PUBLIC	??_C@_05HJCMGBKF@speed?$AA@			; `string'
PUBLIC	??_C@_06GCJPJKOH@FadeIn?$AA@			; `string'
PUBLIC	??_C@_07EAEHEHPO@FadeOut?$AA@			; `string'
PUBLIC	??_C@_07NGADDHAB@WhiteIn?$AA@			; `string'
PUBLIC	??_C@_08JJKJMBO@WhiteOut?$AA@			; `string'
PUBLIC	??_C@_0BA@FCPOOKJM@killstone_count?$AA@		; `string'
PUBLIC	??_C@_0N@CCHILNPP@OnTitleImage?$AA@		; `string'
PUBLIC	??_C@_0M@NAENPPOP@find_hidden?$AA@		; `string'
PUBLIC	??_C@_0O@DDDIKPAP@killmob_count?$AA@		; `string'
PUBLIC	??_C@_0L@HLMCPCKO@use_potion?$AA@		; `string'
PUBLIC	??_C@_0N@MAFIFFGH@hidden_total?$AA@		; `string'
PUBLIC	??_C@_0L@CEFFAPEL@killallmob?$AA@		; `string'
PUBLIC	??_C@_0L@HAAPAAPF@is_revived?$AA@		; `string'
PUBLIC	??_C@_09HPFMCAOO@bonus_exp?$AA@			; `string'
PUBLIC	??_C@_0L@OIFGKHMH@total_time?$AA@		; `string'
PUBLIC	??_C@_0BC@GLAGHMFL@ShowDungeonResult?$AA@	; `string'
PUBLIC	??_C@_0M@EDIBAKKL@?$CIiiiiiiiii?$CJ?$AA@	; `string'
PUBLIC	??_C@_06LNLHEAAG@height?$AA@			; `string'
PUBLIC	??_C@_05IGKADHGO@width?$AA@			; `string'
PUBLIC	??_C@_07MNOKODDC@OnInput?$AA@			; `string'
PUBLIC	??_C@_06JKFPDEMN@OnSize?$AA@			; `string'
PUBLIC	??_C@_09FOPMPDJN@CloseSelf?$AA@			; `string'
PUBLIC	??_C@_07DDHNKDGP@timeout?$AA@			; `string'
PUBLIC	??_C@_0P@FONAKFHL@MakeNextButton?$AA@		; `string'
PUBLIC	??_C@_0BM@GFGEFDCO@BINARY_OpenSelectItemWindow?$AA@ ; `string'
PUBLIC	??_C@_04LCKGAMBB@?$CIsi?$CJ?$AA@		; `string'
PUBLIC	??_C@_0N@NKMOFENJ@MakeQuestion?$AA@		; `string'
PUBLIC	??_C@_0DL@PFMMJDKG@CPythonEventManager?3?3InsertLine?5@ ; `string'
PUBLIC	??_C@_0P@EGMAHDDO@AppendQuestion?$AA@		; `string'
PUBLIC	??_C@_0CK@JOIMEHF@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Strange?5Comm@ ; `string'
PUBLIC	??_C@_0DD@ENOBDFJN@CPythonEventManager?3?3InsertLine?5@ ; `string'
PUBLIC	??_C@_06MJINCFFA@LETTER?$AA@			; `string'
PUBLIC	??_C@_0BB@GNKEGEMJ@?$LD?$LC?$MA?$LK?5?$LN?C?$LA?$KD?5?3?5?$CFd?C?J?$AA@ ; `string'
PUBLIC	??_C@_05IBAECHHA@DELAY?$AA@			; `string'
PUBLIC	??_C@_05DPNLPLKI@COLOR?$AA@			; `string'
PUBLIC	??_C@_04DBNKAKHO@WAIT?$AA@			; `string'
PUBLIC	??_C@_05EMNIMLKD@ENTER?$AA@			; `string'
PUBLIC	??_C@_08MDIDLFIL@QUESTION?$AA@			; `string'
PUBLIC	??_C@_05PONODPI@CLEAR?$AA@			; `string'
PUBLIC	??_C@_04KANDKFIK@DONE?$AA@			; `string'
PUBLIC	??_C@_04MOKMKBJN@NEXT?$AA@			; `string'
PUBLIC	??_C@_08LGGHBKNM@TOPIMAGE?$AA@			; `string'
PUBLIC	??_C@_09GHNJOICA@LEFTIMAGE?$AA@			; `string'
PUBLIC	??_C@_05BNHKIGFN@IMAGE?$AA@			; `string'
PUBLIC	??_C@_07CDIOHGPA@BGIMAGE?$AA@			; `string'
PUBLIC	??_C@_0P@MCDNLKLH@CLEARMAPSIGNAL?$AA@		; `string'
PUBLIC	??_C@_0N@LEAJJLAE@ADDMAPSIGNAL?$AA@		; `string'
PUBLIC	??_C@_09DCGGFGEI@ADJMSGPOS?$AA@			; `string'
PUBLIC	??_C@_09GPHHDAMH@SETMSGPOS?$AA@			; `string'
PUBLIC	??_C@_0M@NLCKLGGC@QUESTBUTTON?$AA@		; `string'
PUBLIC	??_C@_0L@HNINCFNF@SETCMAPPOS?$AA@		; `string'
PUBLIC	??_C@_05DJAECLDN@SLEEP?$AA@			; `string'
PUBLIC	??_C@_0BC@HFDJPBHI@QUESTBUTTON_CLOSE?$AA@	; `string'
PUBLIC	??_C@_0N@LDDFAHD@BLEND_CAMERA?$AA@		; `string'
PUBLIC	??_C@_0L@JFBLMOIC@SET_CAMERA?$AA@		; `string'
PUBLIC	??_C@_08HDAMPNGA@FADE_OUT?$AA@			; `string'
PUBLIC	??_C@_0P@JLFCBANF@RESTORE_CAMERA?$AA@		; `string'
PUBLIC	??_C@_09FBLOEAGA@WHITE_OUT?$AA@			; `string'
PUBLIC	??_C@_07BBFGMBEC@FADE_IN?$AA@			; `string'
PUBLIC	??_C@_0L@LKNFDGAI@CLEAR_TEXT?$AA@		; `string'
PUBLIC	??_C@_08KBPNHIPE@WHITE_IN?$AA@			; `string'
PUBLIC	??_C@_0M@HJKMCEHO@TITLE_IMAGE?$AA@		; `string'
PUBLIC	??_C@_0BN@MHHHIBEN@TEXT_HORIZONTAL_ALIGN_CENTER?$AA@ ; `string'
PUBLIC	??_C@_0P@FFIDJBND@DUNGEON_RESULT?$AA@		; `string'
PUBLIC	??_C@_0L@PGFMEELF@RUN_CINEMA?$AA@		; `string'
PUBLIC	??_C@_03OEMEHHJ@MOB?$AA@			; `string'
PUBLIC	??_C@_04BLNHNEEM@ITEM?$AA@			; `string'
PUBLIC	??_C@_0M@PMFMMHLB@WINDOW_SIZE?$AA@		; `string'
PUBLIC	??_C@_08MALMLJOJ@COLOR256?$AA@			; `string'
PUBLIC	??_C@_0N@BAJAMEHH@CONFIRM_WAIT?$AA@		; `string'
PUBLIC	??_C@_05POAEJIHJ@INPUT?$AA@			; `string'
PUBLIC	??_C@_0N@IBBMOEIC@INSERT_IMAGE?$AA@		; `string'
PUBLIC	??_C@_0BB@EAAHJLBE@END_CONFIRM_WAIT?$AA@	; `string'
PUBLIC	??_C@_0M@NHAJMLIB@SELECT_ITEM?$AA@		; `string'
PUBLIC	??_R2?$CDynamicPool@USEventSet@CPythonEventManager@@@@8 ; CDynamicPool<CPythonEventManager::SEventSet>::`RTTI Base Class Array'
PUBLIC	??_R2CPythonEventManager@@8			; CPythonEventManager::`RTTI Base Class Array'
PUBLIC	??_R2SEventSet@CPythonEventManager@@8		; CPythonEventManager::SEventSet::`RTTI Base Class Array'
PUBLIC	??_R2?$CSingleton@VCPythonEventManager@@@@8	; CSingleton<CPythonEventManager>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@USEventSet@CPythonEventManager@@@@8 ; CDynamicPool<CPythonEventManager::SEventSet>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CPythonEventManager@@8		; CPythonEventManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@SEventSet@CPythonEventManager@@8	; CPythonEventManager::SEventSet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCPythonEventManager@@@@8 ; CSingleton<CPythonEventManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$CDynamicPool@USEventSet@CPythonEventManager@@@@@8 ; CDynamicPool<CPythonEventManager::SEventSet> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@USEventSet@CPythonEventManager@@@@8 ; CDynamicPool<CPythonEventManager::SEventSet>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AUSEventSet@CPythonEventManager@@@8	; CPythonEventManager::SEventSet `RTTI Type Descriptor'
PUBLIC	??_R3SEventSet@CPythonEventManager@@8		; CPythonEventManager::SEventSet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$CSingleton@VCPythonEventManager@@@@@8	; CSingleton<CPythonEventManager> `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VCPythonEventManager@@@@8	; CSingleton<CPythonEventManager>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCPythonEventManager@@@8			; CPythonEventManager `RTTI Type Descriptor'
PUBLIC	??_R3CPythonEventManager@@8			; CPythonEventManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@ ; CDynamicPool<CPythonEventManager::SEventSet>::`RTTI Complete Object Locator'
PUBLIC	??_R4SEventSet@CPythonEventManager@@6B@		; CPythonEventManager::SEventSet::`RTTI Complete Object Locator'
PUBLIC	??_R4CPythonEventManager@@6B@			; CPythonEventManager::`RTTI Complete Object Locator'
PUBLIC	??_R4?$CSingleton@VCPythonEventManager@@@@6B@	; CSingleton<CPythonEventManager>::`RTTI Complete Object Locator'
PUBLIC	??_7?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@ ; CDynamicPool<CPythonEventManager::SEventSet>::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCPythonEventManager@@@@0PAVCPythonEventManager@@A ; CSingleton<CPythonEventManager>::ms_singleton
PUBLIC	??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8 ; CDynamicPool<CGraphicTextInstance> `RTTI Type Descriptor'
PUBLIC	??_7?$CSingleton@VCPythonEventManager@@@@6B@	; CSingleton<CPythonEventManager>::`vftable'
PUBLIC	??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8	; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8 ; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@ ; CDynamicPool<CGraphicTextInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8	; CDynamicPool<CGraphicTextInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@	; CDynamicPool<CGraphicTextInstance>::`vftable'
PUBLIC	??_7CPythonEventManager@@6B@			; CPythonEventManager::`vftable'
PUBLIC	??_7SEventSet@CPythonEventManager@@6B@		; CPythonEventManager::SEventSet::`vftable'
EXTRN	?GetDefaultCodePage@@YAKXZ:PROC			; GetDefaultCodePage
EXTRN	?GetTextSize@CGraphicTextInstance@@QAEXPAH0@Z:PROC ; CGraphicTextInstance::GetTextSize
EXTRN	?GetHorizontalAlign@CGraphicTextInstance@@QAEHXZ:PROC ; CGraphicTextInstance::GetHorizontalAlign
EXTRN	?SetColor@CGraphicTextInstance@@QAEXMMMM@Z:PROC	; CGraphicTextInstance::SetColor
EXTRN	?SetValueString@CGraphicTextInstance@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CGraphicTextInstance::SetValueString
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	?GetCmd@Group@script@@QAE_NAAUSCmd@2@@Z:PROC	; script::Group::GetCmd
EXTRN	?ReadCmd@Group@script@@QAE_NAAUSCmd@2@@Z:PROC	; script::Group::ReadCmd
EXTRN	?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z:PROC ; CGraphicTextInstance::SetHorizonalAlign
EXTRN	?Read@CMappedFile@@QAEHPAXH@Z:PROC		; CMappedFile::Read
EXTRN	?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; script::Group::Create
EXTRN	??1Group@script@@QAE@XZ:PROC			; script::Group::~Group
EXTRN	??0Group@script@@QAE@XZ:PROC			; script::Group::Group
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonEventManager@@@@0PAVCPythonEventManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonEventManager@@@@0PAVCPythonEventManager@@A DD 01H DUP (?) ; CSingleton<CPythonEventManager>::ms_singleton
_BSS	ENDS
;	COMDAT ??_7SEventSet@CPythonEventManager@@6B@
CONST	SEGMENT
??_7SEventSet@CPythonEventManager@@6B@ DD FLAT:??_R4SEventSet@CPythonEventManager@@6B@ ; CPythonEventManager::SEventSet::`vftable'
	DD	FLAT:??_ESEventSet@CPythonEventManager@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CPythonEventManager@@6B@
CONST	SEGMENT
??_7CPythonEventManager@@6B@ DD FLAT:??_R4CPythonEventManager@@6B@ ; CPythonEventManager::`vftable'
	DD	FLAT:??_ECPythonEventManager@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@ ; CDynamicPool<CGraphicTextInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8 DD 00H	; CDynamicPool<CGraphicTextInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@ DD 00H	; CDynamicPool<CGraphicTextInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8 ; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8 ; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7?$CSingleton@VCPythonEventManager@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCPythonEventManager@@@@6B@ DD FLAT:??_R4?$CSingleton@VCPythonEventManager@@@@6B@ ; CSingleton<CPythonEventManager>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCPythonEventManager@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CGraphicTextInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCGraphicTextInstance@@@@', 00H
data$r	ENDS
;	COMDAT ??_7?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@ DD FLAT:??_R4?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@ ; CDynamicPool<CPythonEventManager::SEventSet>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@USEventSet@CPythonEventManager@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$CSingleton@VCPythonEventManager@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCPythonEventManager@@@@6B@ DD 00H	; CSingleton<CPythonEventManager>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCPythonEventManager@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCPythonEventManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R4CPythonEventManager@@6B@
rdata$r	SEGMENT
??_R4CPythonEventManager@@6B@ DD 00H			; CPythonEventManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPythonEventManager@@@8
	DD	FLAT:??_R3CPythonEventManager@@8
rdata$r	ENDS
;	COMDAT ??_R4SEventSet@CPythonEventManager@@6B@
rdata$r	SEGMENT
??_R4SEventSet@CPythonEventManager@@6B@ DD 00H		; CPythonEventManager::SEventSet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUSEventSet@CPythonEventManager@@@8
	DD	FLAT:??_R3SEventSet@CPythonEventManager@@8
rdata$r	ENDS
;	COMDAT ??_R4?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@ DD 00H ; CDynamicPool<CPythonEventManager::SEventSet>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@USEventSet@CPythonEventManager@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@USEventSet@CPythonEventManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R3CPythonEventManager@@8
rdata$r	SEGMENT
??_R3CPythonEventManager@@8 DD 00H			; CPythonEventManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CPythonEventManager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPythonEventManager@@@8
data$r	SEGMENT
??_R0?AVCPythonEventManager@@@8 DD FLAT:??_7type_info@@6B@ ; CPythonEventManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPythonEventManager@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCPythonEventManager@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCPythonEventManager@@@@8 DD 00H	; CSingleton<CPythonEventManager>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCPythonEventManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCPythonEventManager@@@@@8
data$r	SEGMENT
??_R0?AV?$CSingleton@VCPythonEventManager@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CPythonEventManager> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCPythonEventManager@@@@', 00H
data$r	ENDS
;	COMDAT ??_R3SEventSet@CPythonEventManager@@8
rdata$r	SEGMENT
??_R3SEventSet@CPythonEventManager@@8 DD 00H		; CPythonEventManager::SEventSet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SEventSet@CPythonEventManager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUSEventSet@CPythonEventManager@@@8
data$r	SEGMENT
??_R0?AUSEventSet@CPythonEventManager@@@8 DD FLAT:??_7type_info@@6B@ ; CPythonEventManager::SEventSet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSEventSet@CPythonEventManager@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@USEventSet@CPythonEventManager@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@USEventSet@CPythonEventManager@@@@8 DD 00H ; CDynamicPool<CPythonEventManager::SEventSet>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@USEventSet@CPythonEventManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@USEventSet@CPythonEventManager@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPool@USEventSet@CPythonEventManager@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CPythonEventManager::SEventSet> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@USEventSet@CPythonEventManager@@@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCPythonEventManager@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCPythonEventManager@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCPythonEventManager@@@@@8 ; CSingleton<CPythonEventManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCPythonEventManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SEventSet@CPythonEventManager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SEventSet@CPythonEventManager@@8 DD FLAT:??_R0?AUSEventSet@CPythonEventManager@@@8 ; CPythonEventManager::SEventSet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SEventSet@CPythonEventManager@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPythonEventManager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPythonEventManager@@8 DD FLAT:??_R0?AVCPythonEventManager@@@8 ; CPythonEventManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPythonEventManager@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@USEventSet@CPythonEventManager@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@USEventSet@CPythonEventManager@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@USEventSet@CPythonEventManager@@@@@8 ; CDynamicPool<CPythonEventManager::SEventSet>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@USEventSet@CPythonEventManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCPythonEventManager@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCPythonEventManager@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonEventManager@@@@8 ; CSingleton<CPythonEventManager>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2SEventSet@CPythonEventManager@@8
rdata$r	SEGMENT
??_R2SEventSet@CPythonEventManager@@8 DD FLAT:??_R1A@?0A@EA@SEventSet@CPythonEventManager@@8 ; CPythonEventManager::SEventSet::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CPythonEventManager@@8
rdata$r	SEGMENT
??_R2CPythonEventManager@@8 DD FLAT:??_R1A@?0A@EA@CPythonEventManager@@8 ; CPythonEventManager::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonEventManager@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@USEventSet@CPythonEventManager@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@USEventSet@CPythonEventManager@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@USEventSet@CPythonEventManager@@@@8 ; CDynamicPool<CPythonEventManager::SEventSet>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_C@_0M@NHAJMLIB@SELECT_ITEM?$AA@
CONST	SEGMENT
??_C@_0M@NHAJMLIB@SELECT_ITEM?$AA@ DB 'SELECT_ITEM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EAAHJLBE@END_CONFIRM_WAIT?$AA@
CONST	SEGMENT
??_C@_0BB@EAAHJLBE@END_CONFIRM_WAIT?$AA@ DB 'END_CONFIRM_WAIT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IBBMOEIC@INSERT_IMAGE?$AA@
CONST	SEGMENT
??_C@_0N@IBBMOEIC@INSERT_IMAGE?$AA@ DB 'INSERT_IMAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05POAEJIHJ@INPUT?$AA@
CONST	SEGMENT
??_C@_05POAEJIHJ@INPUT?$AA@ DB 'INPUT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BAJAMEHH@CONFIRM_WAIT?$AA@
CONST	SEGMENT
??_C@_0N@BAJAMEHH@CONFIRM_WAIT?$AA@ DB 'CONFIRM_WAIT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MALMLJOJ@COLOR256?$AA@
CONST	SEGMENT
??_C@_08MALMLJOJ@COLOR256?$AA@ DB 'COLOR256', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PMFMMHLB@WINDOW_SIZE?$AA@
CONST	SEGMENT
??_C@_0M@PMFMMHLB@WINDOW_SIZE?$AA@ DB 'WINDOW_SIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BLNHNEEM@ITEM?$AA@
CONST	SEGMENT
??_C@_04BLNHNEEM@ITEM?$AA@ DB 'ITEM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OEMEHHJ@MOB?$AA@
CONST	SEGMENT
??_C@_03OEMEHHJ@MOB?$AA@ DB 'MOB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGFMEELF@RUN_CINEMA?$AA@
CONST	SEGMENT
??_C@_0L@PGFMEELF@RUN_CINEMA?$AA@ DB 'RUN_CINEMA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FFIDJBND@DUNGEON_RESULT?$AA@
CONST	SEGMENT
??_C@_0P@FFIDJBND@DUNGEON_RESULT?$AA@ DB 'DUNGEON_RESULT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MHHHIBEN@TEXT_HORIZONTAL_ALIGN_CENTER?$AA@
CONST	SEGMENT
??_C@_0BN@MHHHIBEN@TEXT_HORIZONTAL_ALIGN_CENTER?$AA@ DB 'TEXT_HORIZONTAL_'
	DB	'ALIGN_CENTER', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HJKMCEHO@TITLE_IMAGE?$AA@
CONST	SEGMENT
??_C@_0M@HJKMCEHO@TITLE_IMAGE?$AA@ DB 'TITLE_IMAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBPNHIPE@WHITE_IN?$AA@
CONST	SEGMENT
??_C@_08KBPNHIPE@WHITE_IN?$AA@ DB 'WHITE_IN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LKNFDGAI@CLEAR_TEXT?$AA@
CONST	SEGMENT
??_C@_0L@LKNFDGAI@CLEAR_TEXT?$AA@ DB 'CLEAR_TEXT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BBFGMBEC@FADE_IN?$AA@
CONST	SEGMENT
??_C@_07BBFGMBEC@FADE_IN?$AA@ DB 'FADE_IN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FBLOEAGA@WHITE_OUT?$AA@
CONST	SEGMENT
??_C@_09FBLOEAGA@WHITE_OUT?$AA@ DB 'WHITE_OUT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLFCBANF@RESTORE_CAMERA?$AA@
CONST	SEGMENT
??_C@_0P@JLFCBANF@RESTORE_CAMERA?$AA@ DB 'RESTORE_CAMERA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HDAMPNGA@FADE_OUT?$AA@
CONST	SEGMENT
??_C@_08HDAMPNGA@FADE_OUT?$AA@ DB 'FADE_OUT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JFBLMOIC@SET_CAMERA?$AA@
CONST	SEGMENT
??_C@_0L@JFBLMOIC@SET_CAMERA?$AA@ DB 'SET_CAMERA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LDDFAHD@BLEND_CAMERA?$AA@
CONST	SEGMENT
??_C@_0N@LDDFAHD@BLEND_CAMERA?$AA@ DB 'BLEND_CAMERA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HFDJPBHI@QUESTBUTTON_CLOSE?$AA@
CONST	SEGMENT
??_C@_0BC@HFDJPBHI@QUESTBUTTON_CLOSE?$AA@ DB 'QUESTBUTTON_CLOSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05DJAECLDN@SLEEP?$AA@
CONST	SEGMENT
??_C@_05DJAECLDN@SLEEP?$AA@ DB 'SLEEP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HNINCFNF@SETCMAPPOS?$AA@
CONST	SEGMENT
??_C@_0L@HNINCFNF@SETCMAPPOS?$AA@ DB 'SETCMAPPOS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NLCKLGGC@QUESTBUTTON?$AA@
CONST	SEGMENT
??_C@_0M@NLCKLGGC@QUESTBUTTON?$AA@ DB 'QUESTBUTTON', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPHHDAMH@SETMSGPOS?$AA@
CONST	SEGMENT
??_C@_09GPHHDAMH@SETMSGPOS?$AA@ DB 'SETMSGPOS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DCGGFGEI@ADJMSGPOS?$AA@
CONST	SEGMENT
??_C@_09DCGGFGEI@ADJMSGPOS?$AA@ DB 'ADJMSGPOS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LEAJJLAE@ADDMAPSIGNAL?$AA@
CONST	SEGMENT
??_C@_0N@LEAJJLAE@ADDMAPSIGNAL?$AA@ DB 'ADDMAPSIGNAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MCDNLKLH@CLEARMAPSIGNAL?$AA@
CONST	SEGMENT
??_C@_0P@MCDNLKLH@CLEARMAPSIGNAL?$AA@ DB 'CLEARMAPSIGNAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CDIOHGPA@BGIMAGE?$AA@
CONST	SEGMENT
??_C@_07CDIOHGPA@BGIMAGE?$AA@ DB 'BGIMAGE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BNHKIGFN@IMAGE?$AA@
CONST	SEGMENT
??_C@_05BNHKIGFN@IMAGE?$AA@ DB 'IMAGE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GHNJOICA@LEFTIMAGE?$AA@
CONST	SEGMENT
??_C@_09GHNJOICA@LEFTIMAGE?$AA@ DB 'LEFTIMAGE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGGHBKNM@TOPIMAGE?$AA@
CONST	SEGMENT
??_C@_08LGGHBKNM@TOPIMAGE?$AA@ DB 'TOPIMAGE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MOKMKBJN@NEXT?$AA@
CONST	SEGMENT
??_C@_04MOKMKBJN@NEXT?$AA@ DB 'NEXT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KANDKFIK@DONE?$AA@
CONST	SEGMENT
??_C@_04KANDKFIK@DONE?$AA@ DB 'DONE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PONODPI@CLEAR?$AA@
CONST	SEGMENT
??_C@_05PONODPI@CLEAR?$AA@ DB 'CLEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MDIDLFIL@QUESTION?$AA@
CONST	SEGMENT
??_C@_08MDIDLFIL@QUESTION?$AA@ DB 'QUESTION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EMNIMLKD@ENTER?$AA@
CONST	SEGMENT
??_C@_05EMNIMLKD@ENTER?$AA@ DB 'ENTER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBNKAKHO@WAIT?$AA@
CONST	SEGMENT
??_C@_04DBNKAKHO@WAIT?$AA@ DB 'WAIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DPNLPLKI@COLOR?$AA@
CONST	SEGMENT
??_C@_05DPNLPLKI@COLOR?$AA@ DB 'COLOR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IBAECHHA@DELAY?$AA@
CONST	SEGMENT
??_C@_05IBAECHHA@DELAY?$AA@ DB 'DELAY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GNKEGEMJ@?$LD?$LC?$MA?$LK?5?$LN?C?$LA?$KD?5?3?5?$CFd?C?J?$AA@
CONST	SEGMENT
??_C@_0BB@GNKEGEMJ@?$LD?$LC?$MA?$LK?5?$LN?C?$LA?$KD?5?3?5?$CFd?C?J?$AA@ DB 0b3H
	DB	0b2H, 0c0H, 0baH, ' ', 0bdH, 0c3H, 0b0H, 0a3H, ' : %d', 0c3H, 0caH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJINCFFA@LETTER?$AA@
CONST	SEGMENT
??_C@_06MJINCFFA@LETTER?$AA@ DB 'LETTER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@ENOBDFJN@CPythonEventManager?3?3InsertLine?5@
CONST	SEGMENT
??_C@_0DD@ENOBDFJN@CPythonEventManager?3?3InsertLine?5@ DB 'CPythonEventM'
	DB	'anager::InsertLine - OUT_OF_TEXT_LINE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JOIMEHF@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Strange?5Comm@
CONST	SEGMENT
??_C@_0CK@JOIMEHF@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Strange?5Comm@ DB ' !! '
	DB	'PARSING ERROR - Strange Command : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EGMAHDDO@AppendQuestion?$AA@
CONST	SEGMENT
??_C@_0P@EGMAHDDO@AppendQuestion?$AA@ DB 'AppendQuestion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@PFMMJDKG@CPythonEventManager?3?3InsertLine?5@
CONST	SEGMENT
??_C@_0DL@PFMMJDKG@CPythonEventManager?3?3InsertLine?5@ DB 'CPythonEventM'
	DB	'anager::InsertLine - CANNOT_FIND_DEFAULT_FONT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKMOFENJ@MakeQuestion?$AA@
CONST	SEGMENT
??_C@_0N@NKMOFENJ@MakeQuestion?$AA@ DB 'MakeQuestion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LCKGAMBB@?$CIsi?$CJ?$AA@
CONST	SEGMENT
??_C@_04LCKGAMBB@?$CIsi?$CJ?$AA@ DB '(si)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GFGEFDCO@BINARY_OpenSelectItemWindow?$AA@
CONST	SEGMENT
??_C@_0BM@GFGEFDCO@BINARY_OpenSelectItemWindow?$AA@ DB 'BINARY_OpenSelect'
	DB	'ItemWindow', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FONAKFHL@MakeNextButton?$AA@
CONST	SEGMENT
??_C@_0P@FONAKFHL@MakeNextButton?$AA@ DB 'MakeNextButton', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DDHNKDGP@timeout?$AA@
CONST	SEGMENT
??_C@_07DDHNKDGP@timeout?$AA@ DB 'timeout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FOPMPDJN@CloseSelf?$AA@
CONST	SEGMENT
??_C@_09FOPMPDJN@CloseSelf?$AA@ DB 'CloseSelf', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JKFPDEMN@OnSize?$AA@
CONST	SEGMENT
??_C@_06JKFPDEMN@OnSize?$AA@ DB 'OnSize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MNOKODDC@OnInput?$AA@
CONST	SEGMENT
??_C@_07MNOKODDC@OnInput?$AA@ DB 'OnInput', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IGKADHGO@width?$AA@
CONST	SEGMENT
??_C@_05IGKADHGO@width?$AA@ DB 'width', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNLHEAAG@height?$AA@
CONST	SEGMENT
??_C@_06LNLHEAAG@height?$AA@ DB 'height', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EDIBAKKL@?$CIiiiiiiiii?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@EDIBAKKL@?$CIiiiiiiiii?$CJ?$AA@ DB '(iiiiiiiii)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GLAGHMFL@ShowDungeonResult?$AA@
CONST	SEGMENT
??_C@_0BC@GLAGHMFL@ShowDungeonResult?$AA@ DB 'ShowDungeonResult', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OIFGKHMH@total_time?$AA@
CONST	SEGMENT
??_C@_0L@OIFGKHMH@total_time?$AA@ DB 'total_time', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HPFMCAOO@bonus_exp?$AA@
CONST	SEGMENT
??_C@_09HPFMCAOO@bonus_exp?$AA@ DB 'bonus_exp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HAAPAAPF@is_revived?$AA@
CONST	SEGMENT
??_C@_0L@HAAPAAPF@is_revived?$AA@ DB 'is_revived', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CEFFAPEL@killallmob?$AA@
CONST	SEGMENT
??_C@_0L@CEFFAPEL@killallmob?$AA@ DB 'killallmob', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MAFIFFGH@hidden_total?$AA@
CONST	SEGMENT
??_C@_0N@MAFIFFGH@hidden_total?$AA@ DB 'hidden_total', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HLMCPCKO@use_potion?$AA@
CONST	SEGMENT
??_C@_0L@HLMCPCKO@use_potion?$AA@ DB 'use_potion', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DDDIKPAP@killmob_count?$AA@
CONST	SEGMENT
??_C@_0O@DDDIKPAP@killmob_count?$AA@ DB 'killmob_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NAENPPOP@find_hidden?$AA@
CONST	SEGMENT
??_C@_0M@NAENPPOP@find_hidden?$AA@ DB 'find_hidden', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CCHILNPP@OnTitleImage?$AA@
CONST	SEGMENT
??_C@_0N@CCHILNPP@OnTitleImage?$AA@ DB 'OnTitleImage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FCPOOKJM@killstone_count?$AA@
CONST	SEGMENT
??_C@_0BA@FCPOOKJM@killstone_count?$AA@ DB 'killstone_count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JJKJMBO@WhiteOut?$AA@
CONST	SEGMENT
??_C@_08JJKJMBO@WhiteOut?$AA@ DB 'WhiteOut', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NGADDHAB@WhiteIn?$AA@
CONST	SEGMENT
??_C@_07NGADDHAB@WhiteIn?$AA@ DB 'WhiteIn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EAEHEHPO@FadeOut?$AA@
CONST	SEGMENT
??_C@_07EAEHEHPO@FadeOut?$AA@ DB 'FadeOut', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GCJPJKOH@FadeIn?$AA@
CONST	SEGMENT
??_C@_06GCJPJKOH@FadeIn?$AA@ DB 'FadeIn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HJCMGBKF@speed?$AA@
CONST	SEGMENT
??_C@_05HJCMGBKF@speed?$AA@ DB 'speed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LDCBIPEL@?$CIf?$CJ?$AA@
CONST	SEGMENT
??_C@_03LDCBIPEL@?$CIf?$CJ?$AA@ DB '(f)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IBEAJOHJ@RecvQuest?$AA@
CONST	SEGMENT
??_C@_09IBEAJOHJ@RecvQuest?$AA@ DB 'RecvQuest', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LBCONMEI@blendtime?$AA@
CONST	SEGMENT
??_C@_09LBCONMEI@blendtime?$AA@ DB 'blendtime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JCGLEGP@BINARY_RecvQuest?$AA@
CONST	SEGMENT
??_C@_0BB@JCGLEGP@BINARY_RecvQuest?$AA@ DB 'BINARY_RecvQuest', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
CONST	SEGMENT
??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@ DB '(is)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MIAHMBP@highlight?$AA@
CONST	SEGMENT
??_C@_09MIAHMBP@highlight?$AA@ DB 'highlight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GEDDNFGH@?$CIisss?$CJ?$AA@
CONST	SEGMENT
??_C@_06GEDDNFGH@?$CIisss?$CJ?$AA@ DB '(isss)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MDDAOGBD@?A?$LG?$LA?$KC?$LD?$KN?5?$LP?k?H?$KF?$LM?$KO?$DP?4?4?4?4?$AA@
CONST	SEGMENT
??_C@_0BD@MDDAOGBD@?A?$LG?$LA?$KC?$LD?$KN?5?$LP?k?H?$KF?$LM?$KO?$DP?4?4?4?4?$AA@ DB 0c1H
	DB	0b6H, 0b0H, 0a2H, 0b3H, 0adH, ' ', 0bfH, 0ebH, 0c8H, 0a5H, 0bcH
	DB	0aeH, '?....', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09CNONGEHE@icon_type?$AA@
CONST	SEGMENT
??_C@_09CNONGEHE@icon_type?$AA@ DB 'icon_type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IGOOKEAE@icon_name?$AA@
CONST	SEGMENT
??_C@_09IGOOKEAE@icon_name?$AA@ DB 'icon_name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LBIBFC@OnInsertImage?$AA@
CONST	SEGMENT
??_C@_0O@LBIBFC@OnInsertImage?$AA@ DB 'OnInsertImage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HCOLHKJD@BINARY_ClearQuest?$AA@
CONST	SEGMENT
??_C@_0BC@HCOLHKJD@BINARY_ClearQuest?$AA@ DB 'BINARY_ClearQuest', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCLBKNGH@OnInsertItemIcon?$AA@
CONST	SEGMENT
??_C@_0BB@FCLBKNGH@OnInsertItemIcon?$AA@ DB 'OnInsertItemIcon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KJCKKFJC@?$CIssssii?$CJ?$AA@
CONST	SEGMENT
??_C@_08KJCKKFJC@?$CIssssii?$CJ?$AA@ DB '(ssssii)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAKNAIGI@idx?$AA@
CONST	SEGMENT
??_C@_03DAKNAIGI@idx?$AA@ DB 'idx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08GKIEGGBC@?$CIsissii?$CJ?$AA@
CONST	SEGMENT
??_C@_08GKIEGGBC@?$CIsissii?$CJ?$AA@ DB '(sissii)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KBOMEDGA@total?$AA@
CONST	SEGMENT
??_C@_05KBOMEDGA@total?$AA@ DB 'total', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HIIGNCOA@image_type?$AA@
CONST	SEGMENT
??_C@_0L@HIIGNCOA@image_type?$AA@ DB 'image_type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBPADADD@desc?$AA@
CONST	SEGMENT
??_C@_04EBPADADD@desc?$AA@ DB 'desc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDIFBCJA@image_name?$AA@
CONST	SEGMENT
??_C@_0L@NDIFBCJA@image_name?$AA@ DB 'image_name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PHLGJONK@title?$AA@
CONST	SEGMENT
??_C@_05PHLGJONK@title?$AA@ DB 'title', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFDPDNFA@?$CIiis?$CJ?$AA@
CONST	SEGMENT
??_C@_05GFDPDNFA@?$CIiis?$CJ?$AA@ DB '(iis)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07COJEPNBG@OnImage?$AA@
CONST	SEGMENT
??_C@_07COJEPNBG@OnImage?$AA@ DB 'OnImage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ELIGNPMG@OnTopImage?$AA@
CONST	SEGMENT
??_C@_0L@ELIGNPMG@OnTopImage?$AA@ DB 'OnTopImage', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OIPDJOGL@OnBackgroundImage?$AA@
CONST	SEGMENT
??_C@_0BC@OIPDJOGL@OnBackgroundImage?$AA@ DB 'OnBackgroundImage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LOJEKLML@src?$AA@
CONST	SEGMENT
??_C@_03LOJEKLML@src?$AA@ DB 'src', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MHNDOIJH@OnLeftImage?$AA@
CONST	SEGMENT
??_C@_0M@MHNDOIJH@OnLeftImage?$AA@ DB 'OnLeftImage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01OJONOECF@b?$AA@
CONST	SEGMENT
??_C@_01OJONOECF@b?$AA@ DB 'b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DIPEHMLE@DoneEvent?$AA@
CONST	SEGMENT
??_C@_09DIPEHMLE@DoneEvent?$AA@ DB 'DoneEvent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KHNDFHCA@CPythonEventManager?3?3SetEventHan@
CONST	SEGMENT
??_C@_0EH@KHNDFHCA@CPythonEventManager?3?3SetEventHan@ DB 'CPythonEventMa'
	DB	'nager::SetEventHandler m_EventSetVector[iIndex=%d]==NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01JEJKBAGA@g?$AA@
CONST	SEGMENT
??_C@_01JEJKBAGA@g?$AA@ DB 'g', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFEJDJP@value?$AA@
CONST	SEGMENT
??_C@_05MFEJDJP@value?$AA@ DB 'value', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@NAEFMGNK@CPythonEventManager?3?3SetRestrict@
CONST	SEGMENT
??_C@_0EK@NAEFMGNK@CPythonEventManager?3?3SetRestrict@ DB 'CPythonEventMa'
	DB	'nager::SetRestrictedCount m_EventSetVector[iIndex=%d]==NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHFFHIBL@rot?$AA@
CONST	SEGMENT
??_C@_03BHFFHIBL@rot?$AA@ DB 'rot', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCNFOFLM@pitch?$AA@
CONST	SEGMENT
??_C@_05NCNFOFLM@pitch?$AA@ DB 'pitch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HCKPILGO@cross?$AA@
CONST	SEGMENT
??_C@_05HCKPILGO@cross?$AA@ DB 'cross', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LHFODBFO@distance?$AA@
CONST	SEGMENT
??_C@_08LHFODBFO@distance?$AA@ DB 'distance', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HNLLPFKA@up?$AA@
CONST	SEGMENT
??_C@_02HNLLPFKA@up?$AA@ DB 'up', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CHADEDPO@view?$AA@
CONST	SEGMENT
??_C@_04CHADEDPO@view?$AA@ DB 'view', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GLPGHMHM@z?$AA@
CONST	SEGMENT
??_C@_01GLPGHMHM@z?$AA@ DB 'z', 00H			; `string'
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ ; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>
PUBLIC	??1?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::~vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >
PUBLIC	?_Tidy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Tidy
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> > >::_Getal
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >
PUBLIC	??0?$allocator@PAVCGraphicTextInstance@@@std@@QAE@XZ ; std::allocator<CGraphicTextInstance *>::allocator<CGraphicTextInstance *>
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::deallocate
PUBLIC	?deallocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@I@Z ; std::allocator<CGraphicTextInstance *>::deallocate
PUBLIC	?_Destroy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXPAPAVCGraphicTextInstance@@0@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Destroy
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >
PUBLIC	??$_Ptr_cat@PAVCGraphicTextInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicTextInstance@@0@Z ; std::_Ptr_cat<CGraphicTextInstance *,CGraphicTextInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >
PUBLIC	??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z ; CDynamicPool<CGraphicTextInstance>::`scalar deleting destructor'
PUBLIC	??$get@$0A@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::get<0,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>
PUBLIC	??$move@AAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z ; std::move<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&> &>
PUBLIC	??$?0V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@AAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int><std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<>,0>
PUBLIC	??$forward@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>
PUBLIC	?_Get_rest@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEAAV?$tuple@$$$V@2@XZ ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::_Get_rest
PUBLIC	??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$$V@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>
PUBLIC	??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAX@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV01@@Z ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&,void * *>
PUBLIC	??$construct@USTextLine@CPythonEventManager@@ABU12@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@ABU23@@Z ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::construct<CPythonEventManager::STextLine,CPythonEventManager::STextLine const &>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > > &>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > > >
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
PUBLIC	??$_Uninit_move@PAVCGraphicTextInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CGraphicTextInstance *,CGraphicTextInstance *,CGraphicTextInstance *>
PUBLIC	??$_Val_type@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@@Z ; std::_Val_type<CGraphicTextInstance * *>
PUBLIC	??$_Uninit_move@PAUSEventSet@CPythonEventManager@@PAU12@PAU12@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>
PUBLIC	??$_Val_type@PAPAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@@Z ; std::_Val_type<CPythonEventManager::SEventSet * *>
PUBLIC	??$construct@USTextLine@CPythonEventManager@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAUSTextLine@CPythonEventManager@@ABU34@@Z ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<CPythonEventManager::STextLine,CPythonEventManager::STextLine const &>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > > &,bool,void>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool,void>
PUBLIC	??$_Buynode_if_nil@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Buynode_if_nil<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &>
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::max_size
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator--
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::max_size
PUBLIC	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>
PUBLIC	??1SArgumet@script@@QAE@XZ			; script::SArgumet::~SArgumet
PUBLIC	??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAEPAXI@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::`scalar deleting destructor'
PUBLIC	??_GSArgumet@script@@QAEPAXI@Z			; script::SArgumet::`scalar deleting destructor'
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>
PUBLIC	??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU21@@Z ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::construct<std::_List_node<CPythonEventManager::STextLine,void *> *,std::_List_node<CPythonEventManager::STextLine,void *> * &>
PUBLIC	??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU21@@Z ; std::allocator<std::_List_node<script::SArgumet,void *> >::construct<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
PUBLIC	??$_Rechecked@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicTextInstance@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CGraphicTextInstance * *,CGraphicTextInstance * *>
PUBLIC	??$_Uninit_move@PAPAVCGraphicTextInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z ; std::_Uninit_move<CGraphicTextInstance * *,CGraphicTextInstance * *,std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >
PUBLIC	??$_Unchecked@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@@Z ; std::_Unchecked<CGraphicTextInstance * *>
PUBLIC	??$_Rechecked@PAPAUSEventSet@CPythonEventManager@@PAPAU12@@std@@YAAAPAPAUSEventSet@CPythonEventManager@@AAPAPAU12@PAPAU12@@Z ; std::_Rechecked<CPythonEventManager::SEventSet * *,CPythonEventManager::SEventSet * *>
PUBLIC	??$_Uninit_move@PAPAUSEventSet@CPythonEventManager@@PAPAU12@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z ; std::_Uninit_move<CPythonEventManager::SEventSet * *,CPythonEventManager::SEventSet * *,std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >
PUBLIC	??$_Unchecked@PAPAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@@Z ; std::_Unchecked<CPythonEventManager::SEventSet * *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
PUBLIC	??$destroy@USArgumet@script@@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAUSArgumet@script@@@Z ; std::allocator<std::_List_node<script::SArgumet,void *> >::destroy<script::SArgumet>
PUBLIC	??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@@Z ; std::allocator<std::_List_node<script::SArgumet,void *> >::destroy<std::_List_node<script::SArgumet,void *> *>
PUBLIC	??$destroy@PAUSEventSet@CPythonEventManager@@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@@Z ; std::allocator<CPythonEventManager::SEventSet *>::destroy<CPythonEventManager::SEventSet *>
PUBLIC	??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@AAPAU23@@Z ; std::allocator<CPythonEventManager::SEventSet *>::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * &>
PUBLIC	??$destroy@USTextLine@CPythonEventManager@@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@@Z ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::destroy<CPythonEventManager::STextLine>
PUBLIC	??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::destroy<std::_List_node<CPythonEventManager::STextLine,void *> *>
PUBLIC	??$destroy@PAVCGraphicTextInstance@@@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@@Z ; std::allocator<CGraphicTextInstance *>::destroy<CGraphicTextInstance *>
PUBLIC	??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@AAPAV2@@Z ; std::allocator<CGraphicTextInstance *>::construct<CGraphicTextInstance *,CGraphicTextInstance * &>
PUBLIC	??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@$$QAPAU23@@Z ; std::allocator<CPythonEventManager::SEventSet *>::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>
PUBLIC	??$construct@USTextLine@CPythonEventManager@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@ABU23@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<CPythonEventManager::STextLine,CPythonEventManager::STextLine const &>
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
PUBLIC	??$forward@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@YAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@AAU10@@Z ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &>
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tuple_val@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator--
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEPAPAUSEventSet@CPythonEventManager@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::_Unchecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicTextInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::_Unchecked
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator--
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >
PUBLIC	?construct@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@ABQAU34@@Z ; std::allocator<CPythonEventManager::SEventSet *>::construct
PUBLIC	?_Freenode0@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Freenode0
PUBLIC	?_Buynode0@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode0
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Destroy_if_not_nil
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::size
PUBLIC	?construct@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@ABQAV3@@Z ; std::allocator<CGraphicTextInstance *>::construct
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>
PUBLIC	??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<std::_List_node<CPythonEventManager::STextLine,void *> *,std::_List_node<CPythonEventManager::STextLine,void *> * &>
PUBLIC	??$forward@AAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<CPythonEventManager::STextLine,void *> * &>
PUBLIC	??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_List_node<script::SArgumet,void *> > >::construct<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
PUBLIC	??$forward@AAPAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAAAPAU?$_List_node@USArgumet@script@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<script::SArgumet,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
PUBLIC	??$_Uninitialized_move@PAPAVCGraphicTextInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance * *,CGraphicTextInstance * *,std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >
PUBLIC	??$_Uninitialized_move@PAPAUSEventSet@CPythonEventManager@@PAPAU12@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z ; std::_Uninitialized_move<CPythonEventManager::SEventSet * *,CPythonEventManager::SEventSet * *,std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
PUBLIC	??$destroy@USArgumet@script@@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAUSArgumet@script@@@Z ; std::allocator_traits<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<script::SArgumet>
PUBLIC	??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAPAU?$_List_node@USArgumet@script@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<std::_List_node<script::SArgumet,void *> *>
PUBLIC	??$move@AAP6AXPAUSEventSet@CPythonEventManager@@@Z@std@@YA$$QAP6AXPAUSEventSet@CPythonEventManager@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(CPythonEventManager::SEventSet *)>
PUBLIC	??$_For_each@PAPAUSEventSet@CPythonEventManager@@P6AXPAU12@@Z@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAP6AXPAU12@@Z@Z ; std::_For_each<CPythonEventManager::SEventSet * *,void (__cdecl*)(CPythonEventManager::SEventSet *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >
PUBLIC	??$_Ptr_cat@PAUSEventSet@CPythonEventManager@@PAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSEventSet@CPythonEventManager@@0@Z ; std::_Ptr_cat<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>
PUBLIC	??$destroy@PAUSEventSet@CPythonEventManager@@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@@Z ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::destroy<CPythonEventManager::SEventSet *>
PUBLIC	??$construct@PAUSEventSet@CPythonEventManager@@ABQAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@ABQAU34@@Z ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * const &>
PUBLIC	??$forward@ABQAUSEventSet@CPythonEventManager@@@std@@YAABQAUSEventSet@CPythonEventManager@@ABQAU12@@Z ; std::forward<CPythonEventManager::SEventSet * const &>
PUBLIC	??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@AAPAU34@@Z ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * &>
PUBLIC	??$forward@AAPAUSEventSet@CPythonEventManager@@@std@@YAAAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z ; std::forward<CPythonEventManager::SEventSet * &>
PUBLIC	??$destroy@USTextLine@CPythonEventManager@@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAUSTextLine@CPythonEventManager@@@Z ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<CPythonEventManager::STextLine>
PUBLIC	??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<std::_List_node<CPythonEventManager::STextLine,void *> *>
PUBLIC	??$destroy@PAVCGraphicTextInstance@@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@@Z ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::destroy<CGraphicTextInstance *>
PUBLIC	??$construct@PAVCGraphicTextInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * const &>
PUBLIC	??$forward@ABQAVCGraphicTextInstance@@@std@@YAABQAVCGraphicTextInstance@@ABQAV1@@Z ; std::forward<CGraphicTextInstance * const &>
PUBLIC	??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * &>
PUBLIC	??$forward@AAPAVCGraphicTextInstance@@@std@@YAAAPAVCGraphicTextInstance@@AAPAV1@@Z ; std::forward<CGraphicTextInstance * &>
PUBLIC	??$move@AAP6AXPAVCGraphicTextInstance@@@Z@std@@YA$$QAP6AXPAVCGraphicTextInstance@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(CGraphicTextInstance *)>
PUBLIC	??$_For_each@PAPAVCGraphicTextInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCGraphicTextInstance@@0AAP6AXPAV1@@Z@Z ; std::_For_each<CGraphicTextInstance * *,void (__cdecl*)(CGraphicTextInstance *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >
PUBLIC	??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@$$QAPAU34@@Z ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>
PUBLIC	??$_Buynode@ABUSTextLine@CPythonEventManager@@@?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PAU21@0ABUSTextLine@CPythonEventManager@@@Z ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Buynode<CPythonEventManager::STextLine const &>
PUBLIC	??$forward@ABUSTextLine@CPythonEventManager@@@std@@YAABUSTextLine@CPythonEventManager@@ABU12@@Z ; std::forward<CPythonEventManager::STextLine const &>
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_hint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
PUBLIC	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
PUBLIC	??$forward@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z ; std::forward<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&> >
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$$VPAPAX@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void * *>
PUBLIC	?max_size@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::max_size
PUBLIC	?max_size@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QBEIXZ ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::max_size
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >,std::_Iterator_base0>::_Mynode
PUBLIC	?_Incsize@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXI@Z ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Incsize
PUBLIC	??$_Allocate@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >
PUBLIC	??$_Allocate@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_List_node<CPythonEventManager::STextLine,void *> >
PUBLIC	??$_Allocate@U?$_List_node@USArgumet@script@@PAX@std@@@std@@YAPAU?$_List_node@USArgumet@script@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_List_node<script::SArgumet,void *> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>
PUBLIC	??$_Allocate@PAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@IPAPAV1@@Z ; std::_Allocate<CGraphicTextInstance *>
PUBLIC	??$_Allocate@PAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@IPAPAU12@@Z ; std::_Allocate<CPythonEventManager::SEventSet *>
PUBLIC	??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<std::_List_node<CPythonEventManager::STextLine,void *> *,std::_List_node<CPythonEventManager::STextLine,void *> * &>
PUBLIC	??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::construct<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
PUBLIC	??$_Umove@PAPAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEPAPAVCGraphicTextInstance@@PAPAV2@00@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Umove<CGraphicTextInstance * *>
PUBLIC	??$_Umove@PAPAUSEventSet@CPythonEventManager@@@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEPAPAUSEventSet@CPythonEventManager@@PAPAU23@00@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Umove<CPythonEventManager::SEventSet * *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
PUBLIC	??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>
PUBLIC	??$destroy@USArgumet@script@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAUSArgumet@script@@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<script::SArgumet>
PUBLIC	??$addressof@USArgumet@script@@@std@@YAPAUSArgumet@script@@AAU12@@Z ; std::addressof<script::SArgumet>
PUBLIC	??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<std::_List_node<script::SArgumet,void *> *>
PUBLIC	??$addressof@PAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAPAPAU?$_List_node@USArgumet@script@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<script::SArgumet,void *> *>
PUBLIC	??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@AAU10@@Z ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@P6AXPAUSEventSet@CPythonEventManager@@@Z@std@@YAP6AXPAUSEventSet@CPythonEventManager@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >,void (__cdecl*)(CPythonEventManager::SEventSet *)>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >
PUBLIC	??$destroy@PAUSEventSet@CPythonEventManager@@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@@Z ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::destroy<CPythonEventManager::SEventSet *>
PUBLIC	??$construct@PAUSEventSet@CPythonEventManager@@ABQAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@ABQAU23@@Z ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * const &>
PUBLIC	??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@AAPAU23@@Z ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * &>
PUBLIC	??$addressof@QAUSEventSet@CPythonEventManager@@@std@@YAPBQAUSEventSet@CPythonEventManager@@ABQAU12@@Z ; std::addressof<CPythonEventManager::SEventSet * const>
PUBLIC	??$destroy@USTextLine@CPythonEventManager@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<CPythonEventManager::STextLine>
PUBLIC	??$addressof@USTextLine@CPythonEventManager@@@std@@YAPAUSTextLine@CPythonEventManager@@AAU12@@Z ; std::addressof<CPythonEventManager::STextLine>
PUBLIC	??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<std::_List_node<CPythonEventManager::STextLine,void *> *>
PUBLIC	??$addressof@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<CPythonEventManager::STextLine,void *> *>
PUBLIC	??$destroy@PAVCGraphicTextInstance@@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@@Z ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::destroy<CGraphicTextInstance *>
PUBLIC	??$construct@PAVCGraphicTextInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * const &>
PUBLIC	??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * &>
PUBLIC	??$addressof@QAVCGraphicTextInstance@@@std@@YAPBQAVCGraphicTextInstance@@ABQAV1@@Z ; std::addressof<CGraphicTextInstance * const>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@P6AXPAVCGraphicTextInstance@@@Z@std@@YAP6AXPAVCGraphicTextInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >,void (__cdecl*)(CGraphicTextInstance *)>
PUBLIC	??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@$$QAPAU23@@Z ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>
PUBLIC	??$forward@PAUSEventSet@CPythonEventManager@@@std@@YA$$QAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z ; std::forward<CPythonEventManager::SEventSet *>
PUBLIC	??$addressof@PAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z ; std::addressof<CPythonEventManager::SEventSet *>
PUBLIC	??$_Insert@ABUSTextLine@CPythonEventManager@@@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@1@ABUSTextLine@CPythonEventManager@@@Z ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Insert<CPythonEventManager::STextLine const &>
PUBLIC	??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
PUBLIC	??$forward_as_tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::forward_as_tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::allocate
PUBLIC	?allocate@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::allocate
PUBLIC	?allocate@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@I@Z ; std::allocator<std::_List_node<script::SArgumet,void *> >::allocate
PUBLIC	?max_size@?$allocator@PAVCGraphicTextInstance@@@std@@QBEIXZ ; std::allocator<CGraphicTextInstance *>::max_size
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator+=
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator++
PUBLIC	?max_size@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QBEIXZ ; std::allocator<CPythonEventManager::SEventSet *>::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::allocate
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >
PUBLIC	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Buyheadnode
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicTextInstance@@@2@@Z ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::max_size
PUBLIC	?allocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEPAPAVCGraphicTextInstance@@I@Z ; std::allocator<CGraphicTextInstance *>::allocate
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@PAPAUSEventSet@CPythonEventManager@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicTextInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator+=
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator++
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAIABV?$allocator@PAUSEventSet@CPythonEventManager@@@2@@Z ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::max_size
PUBLIC	?allocate@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEPAPAUSEventSet@CPythonEventManager@@I@Z ; std::allocator<CPythonEventManager::SEventSet *>::allocate
PUBLIC	??0?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >
PUBLIC	?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buynode0
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Min
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Max
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Color
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
PUBLIC	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Rrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Rmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lrotate
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Erase
PUBLIC	?deallocate@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@I@Z ; std::allocator<std::_List_node<script::SArgumet,void *> >::deallocate
PUBLIC	?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buynode0
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::allocate
PUBLIC	?capacity@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::capacity
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEABQAUSEventSet@CPythonEventManager@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator*
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator-=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@PAPAUSEventSet@CPythonEventManager@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEABQAVCGraphicTextInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator*
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator-=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicTextInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator!=
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator++
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >,std::_Iterator_base0>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0>
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEPAPAUSEventSet@CPythonEventManager@@I@Z ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::allocate
PUBLIC	?deallocate@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@I@Z ; std::allocator<CPythonEventManager::SEventSet *>::deallocate
PUBLIC	?capacity@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::capacity
PUBLIC	??0?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >
PUBLIC	?deallocate@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >
PUBLIC	?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@XZ ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buyheadnode
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Right
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Parent
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Left
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Isnil
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::deallocate
PUBLIC	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Getal
PUBLIC	??0?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Root
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lmost
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::clear
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase
PUBLIC	??0?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_List_val<std::_List_simple_types<script::SArgumet> >
PUBLIC	??0?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<script::SArgumet,void *> >::allocator<std::_List_node<script::SArgumet,void *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::deallocate
PUBLIC	?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@XZ ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buyheadnode
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> >::_Vector_val<std::_Simple_types<CGraphicTextInstance *> >
PUBLIC	?_Xlen@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlen
PUBLIC	?_Reallocate@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reallocate
PUBLIC	?_Grow_to@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEII@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Grow_to
PUBLIC	?max_size@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::max_size
PUBLIC	?size@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::size
PUBLIC	?_Unused_capacity@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Unused_capacity
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator-
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEAAPAUSEventSet@CPythonEventManager@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator*
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator-
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicTextInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator*
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator*
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >
PUBLIC	?Delete@?$CDynamicPool@USEventSet@CPythonEventManager@@@@KAXPAUSEventSet@CPythonEventManager@@@Z ; CDynamicPool<CPythonEventManager::SEventSet>::Delete
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> >::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@I@Z ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >
PUBLIC	?_Xlen@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEXXZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Xlen
PUBLIC	?_Reallocate@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reallocate
PUBLIC	?_Grow_to@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEII@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Grow_to
PUBLIC	?max_size@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::max_size
PUBLIC	?end@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@2@XZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::end
PUBLIC	?begin@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@2@XZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::begin
PUBLIC	?_Unused_capacity@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Unused_capacity
PUBLIC	?_Myval@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAUSTextLine@CPythonEventManager@@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_Myval
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::deallocate
PUBLIC	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Getal
PUBLIC	?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Freeheadnode
PUBLIC	??0?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@ABV?$allocator@USTextLine@CPythonEventManager@@@1@@Z ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Myval
PUBLIC	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Freeheadnode
PUBLIC	??0?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Kfn
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lbound
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::begin
PUBLIC	?_Myval@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAUSArgumet@script@@PAU?$_List_node@USArgumet@script@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_Myval
PUBLIC	?_Prevnode@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_Prevnode
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >
PUBLIC	?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@@Z ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Freeheadnode
PUBLIC	??0?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAE@ABV?$allocator@USArgumet@script@@@1@@Z ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >
PUBLIC	?_Freenode@?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@@Z ; std::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >::_Freenode
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicTextInstance@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> > >
PUBLIC	?_Orphan_range@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEXPAPAVCGraphicTextInstance@@0@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reserve
PUBLIC	?_Inside@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBE_NPBQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Inside
PUBLIC	?clear@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::clear
PUBLIC	?end@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::end
PUBLIC	?begin@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::begin
PUBLIC	?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z ; CDynamicPool<CGraphicTextInstance>::Delete
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@SAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@AAU32@@Z ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> *>::pointer_to
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator*
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator==
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator++
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBEABUSTextLine@CPythonEventManager@@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator*
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator==
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator++
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBEABUSArgumet@script@@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator*
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >
PUBLIC	?Destroy@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXXZ ; CDynamicPool<CPythonEventManager::SEventSet>::Destroy
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> > >::_Getal
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUSEventSet@CPythonEventManager@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> > >::_Vector_alloc<0,std::_Vec_base_types<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> > >
PUBLIC	??0?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAE@XZ ; std::allocator<CPythonEventManager::SEventSet *>::allocator<CPythonEventManager::SEventSet *>
PUBLIC	?_Orphan_range@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEXPAPAUSEventSet@CPythonEventManager@@0@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Orphan_range
PUBLIC	?_Tidy@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXXZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Tidy
PUBLIC	?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reserve
PUBLIC	?_Inside@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBE_NPBQAUSEventSet@CPythonEventManager@@@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Inside
PUBLIC	?_Destroy@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXPAPAUSEventSet@CPythonEventManager@@0@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Destroy
PUBLIC	?pop_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXXZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::pop_back
PUBLIC	?push_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXABQAUSEventSet@CPythonEventManager@@@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::push_back
PUBLIC	?back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEAAPAUSEventSet@CPythonEventManager@@XZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::back
PUBLIC	?empty@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBE_NXZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::empty
PUBLIC	?_Prevnode@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_Prevnode
PUBLIC	?_Nextnode@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_Nextnode
PUBLIC	??1?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@XZ ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::~_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >
PUBLIC	??0?$allocator@USTextLine@CPythonEventManager@@@std@@QAE@XZ ; std::allocator<CPythonEventManager::STextLine>::allocator<CPythonEventManager::STextLine>
PUBLIC	?_Freenode@?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Freenode
PUBLIC	??0?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@ABV?$allocator@USTextLine@CPythonEventManager@@@1@@Z ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >
PUBLIC	?_Tidy@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXXZ ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Tidy
PUBLIC	?_Unchecked_end@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Unchecked_end
PUBLIC	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >
PUBLIC	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@XZ ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
PUBLIC	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBE?AU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Getcomp
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Key
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Tidy
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
PUBLIC	?_Nextnode@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_Nextnode
PUBLIC	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Getal
PUBLIC	??1?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAE@XZ ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::~_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >
PUBLIC	??0?$allocator@USArgumet@script@@@std@@QAE@XZ	; std::allocator<script::SArgumet>::allocator<script::SArgumet>
PUBLIC	??0?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@ABV?$allocator@USArgumet@script@@@1@@Z ; std::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >
PUBLIC	?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy
PUBLIC	?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear
PUBLIC	?pop_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::pop_back
PUBLIC	?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::push_back
PUBLIC	?back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEAAPAVCGraphicTextInstance@@XZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::back
PUBLIC	?empty@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBE_NXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::empty
PUBLIC	??0?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >
PUBLIC	?Destroy@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ ; CDynamicPool<CGraphicTextInstance>::Destroy
PUBLIC	??1?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
PUBLIC	??_G?$CDynamicPool@USEventSet@CPythonEventManager@@@@UAEPAXI@Z ; CDynamicPool<CPythonEventManager::SEventSet>::`scalar deleting destructor'
PUBLIC	??1?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::~_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >
PUBLIC	??1?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::~_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
PUBLIC	??_G?$CSingleton@VCPythonEventManager@@@@UAEPAXI@Z ; CSingleton<CPythonEventManager>::`scalar deleting destructor'
PUBLIC	??1?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ; std::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >::~_List_buy<script::SArgumet,std::allocator<script::SArgumet> >
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator==
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator->
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator!=
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator++
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBEAAUSTextLine@CPythonEventManager@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator*
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator!=
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator++
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBEAAUSArgumet@script@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator*
PUBLIC	?Free@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXPAUSEventSet@CPythonEventManager@@@Z ; CDynamicPool<CPythonEventManager::SEventSet>::Free
PUBLIC	?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ ; CDynamicPool<CPythonEventManager::SEventSet>::Alloc
PUBLIC	?Clear@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXXZ ; CDynamicPool<CPythonEventManager::SEventSet>::Clear
PUBLIC	??1?$CDynamicPool@USEventSet@CPythonEventManager@@@@UAE@XZ ; CDynamicPool<CPythonEventManager::SEventSet>::~CDynamicPool<CPythonEventManager::SEventSet>
PUBLIC	??0?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAE@XZ ; CDynamicPool<CPythonEventManager::SEventSet>::CDynamicPool<CPythonEventManager::SEventSet>
PUBLIC	?clear@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXXZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::clear
PUBLIC	??A?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEAAPAUSEventSet@CPythonEventManager@@I@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::operator[]
PUBLIC	?size@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::size
PUBLIC	??1?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::~vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >
PUBLIC	?push_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEX$$QAPAUSEventSet@CPythonEventManager@@@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::push_back
PUBLIC	??0?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >
PUBLIC	?clear@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXXZ ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::clear
PUBLIC	?push_back@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXABUSTextLine@CPythonEventManager@@@Z ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::push_back
PUBLIC	?size@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QBEIXZ ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::size
PUBLIC	?end@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::end
PUBLIC	?begin@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::begin
PUBLIC	??1?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::~list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >
PUBLIC	??0?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::find
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
PUBLIC	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
PUBLIC	??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
PUBLIC	??1?$CSingleton@VCPythonEventManager@@@@UAE@XZ	; CSingleton<CPythonEventManager>::~CSingleton<CPythonEventManager>
PUBLIC	??0?$CSingleton@VCPythonEventManager@@@@QAE@XZ	; CSingleton<CPythonEventManager>::CSingleton<CPythonEventManager>
PUBLIC	?empty@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QBE_NXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::empty
PUBLIC	?size@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QBEIXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::size
PUBLIC	?end@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@2@XZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::end
PUBLIC	?begin@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@2@XZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::begin
PUBLIC	??1?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::~list<script::SArgumet,std::allocator<script::SArgumet> >
PUBLIC	??0?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::list<script::SArgumet,std::allocator<script::SArgumet> >
PUBLIC	?Free@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXPAVCGraphicTextInstance@@@Z ; CDynamicPool<CGraphicTextInstance>::Free
PUBLIC	?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ ; CDynamicPool<CGraphicTextInstance>::Alloc
PUBLIC	?Clear@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ ; CDynamicPool<CGraphicTextInstance>::Clear
PUBLIC	??0?$CDynamicPool@VCGraphicTextInstance@@@@QAE@XZ ; CDynamicPool<CGraphicTextInstance>::CDynamicPool<CGraphicTextInstance>
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
PUBLIC	??_GCPythonEventManager@@UAEPAXI@Z		; CPythonEventManager::`scalar deleting destructor'
PUBLIC	?SetLeftTimeString@CPythonEventManager@@QAEXPBD@Z ; CPythonEventManager::SetLeftTimeString
PUBLIC	?SetInterfaceWindow@CPythonEventManager@@QAEXPAU_object@@@Z ; CPythonEventManager::SetInterfaceWindow
PUBLIC	?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
PUBLIC	?GetScriptEventIndex@CPythonEventManager@@IAE_NPBDPAH1@Z ; CPythonEventManager::GetScriptEventIndex
PUBLIC	?__AddSpace@CPythonEventManager@@IAEXAAUSEventSet@1@H@Z ; CPythonEventManager::__AddSpace
PUBLIC	?RefreshLinePosition@CPythonEventManager@@IAEXPAUSEventSet@1@@Z ; CPythonEventManager::RefreshLinePosition
PUBLIC	?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z ; CPythonEventManager::__InsertLine
PUBLIC	?ClearLine@CPythonEventManager@@IAEXPAUSEventSet@1@@Z ; CPythonEventManager::ClearLine
PUBLIC	?GetLineCount@CPythonEventManager@@QAEHH@Z	; CPythonEventManager::GetLineCount
PUBLIC	?GetVisibleStartLine@CPythonEventManager@@QAEHH@Z ; CPythonEventManager::GetVisibleStartLine
PUBLIC	?SetVisibleLineCount@CPythonEventManager@@QAEXHH@Z ; CPythonEventManager::SetVisibleLineCount
PUBLIC	?SetVisibleStartLine@CPythonEventManager@@QAEXHH@Z ; CPythonEventManager::SetVisibleStartLine
PUBLIC	?SelectAnswer@CPythonEventManager@@QAEXHH@Z	; CPythonEventManager::SelectAnswer
PUBLIC	?MakeQuestion@CPythonEventManager@@IAEXPAUSEventSet@1@AAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; CPythonEventManager::MakeQuestion
PUBLIC	?MakeNextButton@CPythonEventManager@@IAEXPAUSEventSet@1@H@Z ; CPythonEventManager::MakeNextButton
PUBLIC	?EndEventProcess@CPythonEventManager@@QAEXH@Z	; CPythonEventManager::EndEventProcess
PUBLIC	?IsWait@CPythonEventManager@@QAE_NH@Z		; CPythonEventManager::IsWait
PUBLIC	?Skip@CPythonEventManager@@QAEXH@Z		; CPythonEventManager::Skip
PUBLIC	?RenderEventSet@CPythonEventManager@@QAEXH@Z	; CPythonEventManager::RenderEventSet
PUBLIC	?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z ; CPythonEventManager::ProcessEventSet
PUBLIC	?SetEventSetWidth@CPythonEventManager@@QAEXHH@Z	; CPythonEventManager::SetEventSetWidth
PUBLIC	?UpdateEventSet@CPythonEventManager@@QAEXHHH@Z	; CPythonEventManager::UpdateEventSet
PUBLIC	?InsertText@CPythonEventManager@@QAEXHPBDH@Z	; CPythonEventManager::InsertText
PUBLIC	?AddEventSetLocalYPosition@CPythonEventManager@@QAEXHH@Z ; CPythonEventManager::AddEventSetLocalYPosition
PUBLIC	?GetEventSetLocalYPosition@CPythonEventManager@@QAEHH@Z ; CPythonEventManager::GetEventSetLocalYPosition
PUBLIC	?SetEventHandler@CPythonEventManager@@QAEXHPAU_object@@@Z ; CPythonEventManager::SetEventHandler
PUBLIC	?SetRestrictedCount@CPythonEventManager@@QAEXHH@Z ; CPythonEventManager::SetRestrictedCount
PUBLIC	?GetEmptyEventSetSlot@CPythonEventManager@@IAEKXZ ; CPythonEventManager::GetEmptyEventSetSlot
PUBLIC	?__ClearEventSetp@CPythonEventManager@@QAEXPAUSEventSet@1@@Z ; CPythonEventManager::__ClearEventSetp
PUBLIC	?ClearEventSeti@CPythonEventManager@@QAEXH@Z	; CPythonEventManager::ClearEventSeti
PUBLIC	??1SCmd@script@@QAE@XZ				; script::SCmd::~SCmd
PUBLIC	?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPythonEventManager::RegisterEventSetFromString
PUBLIC	?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z ; CPythonEventManager::RegisterEventSet
PUBLIC	?__InitEventSet@CPythonEventManager@@IAEXAAUSEventSet@1@@Z ; CPythonEventManager::__InitEventSet
PUBLIC	?GetCameraSettingFromArgList@@YAXAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@PAUSCameraSetting@IAbstractApplication@@@Z ; GetCameraSettingFromArgList
PUBLIC	?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
PUBLIC	?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z ; GetArgumentString
PUBLIC	??_GSEventSet@CPythonEventManager@@UAEPAXI@Z	; CPythonEventManager::SEventSet::`scalar deleting destructor'
PUBLIC	??1SEventSet@CPythonEventManager@@UAE@XZ	; CPythonEventManager::SEventSet::~SEventSet
PUBLIC	??0SEventSet@CPythonEventManager@@QAE@XZ	; CPythonEventManager::SEventSet::SEventSet
PUBLIC	??0SCmd@script@@QAE@XZ				; script::SCmd::SCmd
PUBLIC	??0CPythonEventManager@@QAE@XZ			; CPythonEventManager::CPythonEventManager
PUBLIC	??1CPythonEventManager@@UAE@XZ			; CPythonEventManager::~CPythonEventManager
PUBLIC	?Destroy@CPythonEventManager@@QAEXXZ		; CPythonEventManager::Destroy
EXTRN	??_E?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CGraphicTextInstance>::`vector deleting destructor'
EXTRN	??_ECPythonEventManager@@UAEPAXI@Z:PROC		; CPythonEventManager::`vector deleting destructor'
EXTRN	??_E?$CSingleton@VCPythonEventManager@@@@UAEPAXI@Z:PROC ; CSingleton<CPythonEventManager>::`vector deleting destructor'
EXTRN	??_ESEventSet@CPythonEventManager@@UAEPAXI@Z:PROC ; CPythonEventManager::SEventSet::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@USEventSet@CPythonEventManager@@@@UAEPAXI@Z:PROC ; CDynamicPool<CPythonEventManager::SEventSet>::`vector deleting destructor'
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?$S1@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4IA
_BSS	SEGMENT
?$S1@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4IA DD 01H DUP (?) ; S1<`template-parameter-6',tArgumentString,std::D::ar_traits,sic_string::allocator<char> >
_BSS	ENDS
;	COMDAT ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A
_BSS	SEGMENT
?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A DB 018H DUP (?) ; `GetArgumentString'::`6'::strEmptyValue
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CPythonEventManager@@QAE@XZ DD 019930522H
	DD	030H
	DD	FLAT:__unwindtable$??0CPythonEventManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0CPythonEventManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$6
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$7
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$8
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$9
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$10
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$11
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$12
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$13
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$14
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$15
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$16
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$17
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$18
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$19
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$20
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$21
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$22
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$23
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$24
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$25
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$26
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$27
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$28
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$29
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$30
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$31
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$32
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$33
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$34
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$35
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$36
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$37
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$38
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$39
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$40
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$41
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$42
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$43
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$44
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$45
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$46
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonEventManager@@QAE@XZ$47
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0SCmd@script@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SCmd@script@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SCmd@script@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SCmd@script@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0SEventSet@CPythonEventManager@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SEventSet@CPythonEventManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SEventSet@CPythonEventManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SEventSet@CPythonEventManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SEventSet@CPythonEventManager@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1SEventSet@CPythonEventManager@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1SEventSet@CPythonEventManager@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1SEventSet@CPythonEventManager@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1SEventSet@CPythonEventManager@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1SEventSet@CPythonEventManager@@UAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z$2
__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z$2
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z$0
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?Destroy@CPythonEventManager@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@CPythonEventManager@@QAEXXZ PROC		; CPythonEventManager::Destroy, COMDAT
; _this$ = ecx

; 1132 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00004	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00007	33 d2		 xor	 edx, edx
  00009	53		 push	 ebx
  0000a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000d	8b 59 24	 mov	 ebx, DWORD PTR [ecx+36]
  00010	56		 push	 esi

; 1025 : 		return (iterator(this->_Myfirst, this));

  00011	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  00014	2b de		 sub	 ebx, esi
  00016	83 c3 03	 add	 ebx, 3
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1132 : {

  00019	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0001c	c1 eb 02	 shr	 ebx, 2
  0001f	57		 push	 edi
  00020	33 ff		 xor	 edi, edi
  00022	3b 71 24	 cmp	 esi, DWORD PTR [ecx+36]
  00025	0f 47 da	 cmova	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00028	85 db		 test	 ebx, ebx
  0002a	74 19		 je	 SHORT $LN37@Destroy
  0002c	8d 64 24 00	 npad	 4
$LL39@Destroy:

; 24   : 		_Func(*_First);

  00030	ff 36		 push	 DWORD PTR [esi]
  00032	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@USEventSet@CPythonEventManager@@@@KAXPAUSEventSet@CPythonEventManager@@@Z ; CDynamicPool<CPythonEventManager::SEventSet>::Delete
  00037	47		 inc	 edi
  00038	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0003b	83 c4 04	 add	 esp, 4
  0003e	3b fb		 cmp	 edi, ebx
  00040	75 ee		 jne	 SHORT $LL39@Destroy
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN37@Destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00045	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00048	33 d2		 xor	 edx, edx
  0004a	89 41 24	 mov	 DWORD PTR [ecx+36], eax
  0004d	33 ff		 xor	 edi, edi
  0004f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00052	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 1025 : 		return (iterator(this->_Myfirst, this));

  00055	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  00058	8b 59 48	 mov	 ebx, DWORD PTR [ecx+72]
  0005b	2b de		 sub	 ebx, esi
  0005d	83 c3 03	 add	 ebx, 3
  00060	c1 eb 02	 shr	 ebx, 2
  00063	3b 71 48	 cmp	 esi, DWORD PTR [ecx+72]
  00066	0f 47 da	 cmova	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00069	85 db		 test	 ebx, ebx
  0006b	74 18		 je	 SHORT $LN82@Destroy
  0006d	8d 49 00	 npad	 3
$LL84@Destroy:

; 24   : 		_Func(*_First);

  00070	ff 36		 push	 DWORD PTR [esi]
  00072	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z ; CDynamicPool<CGraphicTextInstance>::Delete
  00077	47		 inc	 edi
  00078	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0007b	83 c4 04	 add	 esp, 4
  0007e	3b fb		 cmp	 edi, ebx
  00080	75 ee		 jne	 SHORT $LL84@Destroy
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN82@Destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00085	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00088	5f		 pop	 edi
  00089	89 41 48	 mov	 DWORD PTR [ecx+72], eax
  0008c	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  0008f	5e		 pop	 esi
  00090	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00093	5b		 pop	 ebx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1136 : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?Destroy@CPythonEventManager@@QAEXXZ ENDP		; CPythonEventManager::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ??1CPythonEventManager@@UAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1CPythonEventManager@@UAE@XZ PROC			; CPythonEventManager::~CPythonEventManager, COMDAT
; _this$ = ecx

; 1210 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CPythonEventManager@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0000e	83 7f 7c 10	 cmp	 DWORD PTR [edi+124], 16	; 00000010H
  00012	72 0b		 jb	 SHORT $LN23@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00014	ff 77 68	 push	 DWORD PTR [edi+104]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
$LN23@CPythonEve:
  0001f	c7 47 7c 0f 00
	00 00		 mov	 DWORD PTR [edi+124], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00026	c7 47 78 00 00
	00 00		 mov	 DWORD PTR [edi+120], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0002d	c6 47 68 00	 mov	 BYTE PTR [edi+104], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 18   : 		{

  00031	c7 47 40 00 00
	00 00		 mov	 DWORD PTR [edi+64], OFFSET ??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00038	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  0003b	85 c0		 test	 eax, eax
  0003d	74 1e		 je	 SHORT $LN39@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00045	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00048	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0

; 1630 : 			this->_Mylast = pointer();

  0004f	c7 47 54 00 00
	00 00		 mov	 DWORD PTR [edi+84], 0

; 1631 : 			this->_Myend = pointer();

  00056	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0
$LN39@CPythonEve:

; 1623 : 		if (this->_Myfirst != pointer())

  0005d	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00060	85 c0		 test	 eax, eax
  00062	74 1e		 je	 SHORT $LN52@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006a	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0006d	c7 47 44 00 00
	00 00		 mov	 DWORD PTR [edi+68], 0

; 1630 : 			this->_Mylast = pointer();

  00074	c7 47 48 00 00
	00 00		 mov	 DWORD PTR [edi+72], 0

; 1631 : 			this->_Myend = pointer();

  0007b	c7 47 4c 00 00
	00 00		 mov	 DWORD PTR [edi+76], 0
$LN52@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 18   : 		{

  00082	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], OFFSET ??_7?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00089	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0008c	85 c0		 test	 eax, eax
  0008e	74 1e		 je	 SHORT $LN67@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00096	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00099	c7 47 2c 00 00
	00 00		 mov	 DWORD PTR [edi+44], 0

; 1630 : 			this->_Mylast = pointer();

  000a0	c7 47 30 00 00
	00 00		 mov	 DWORD PTR [edi+48], 0

; 1631 : 			this->_Myend = pointer();

  000a7	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
$LN67@CPythonEve:

; 1623 : 		if (this->_Myfirst != pointer())

  000ae	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000b1	85 c0		 test	 eax, eax
  000b3	74 1e		 je	 SHORT $LN80@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000bb	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000be	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0

; 1630 : 			this->_Mylast = pointer();

  000c5	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0

; 1631 : 			this->_Myend = pointer();

  000cc	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
$LN80@CPythonEve:

; 1623 : 		if (this->_Myfirst != pointer())

  000d3	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000d6	85 c0		 test	 eax, eax
  000d8	74 1e		 je	 SHORT $LN93@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e0	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000e3	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 1630 : 			this->_Mylast = pointer();

  000ea	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 1631 : 			this->_Myend = pointer();

  000f1	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
$LN93@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  000f8	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000fb	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000fe	50		 push	 eax
  000ff	ff 30		 push	 DWORD PTR [eax]
  00101	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0010a	ff 77 04	 push	 DWORD PTR [edi+4]
  0010d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00112	83 c4 04	 add	 esp, 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 19   : 	{ 

  00115	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CSingleton@VCPythonEventManager@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  0011b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonEventManager@@@@0PAVCPythonEventManager@@A, 0 ; CSingleton<CPythonEventManager>::ms_singleton
  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1211 : }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
??1CPythonEventManager@@UAE@XZ ENDP			; CPythonEventManager::~CPythonEventManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ??0CPythonEventManager@@QAE@XZ
_TEXT	SEGMENT
_this$GSCopy$ = -44					; size = 4
$T2 = -40						; size = 24
$T3 = -40						; size = 24
$T4 = -40						; size = 24
$T5 = -40						; size = 24
$T6 = -40						; size = 24
$T7 = -40						; size = 24
$T8 = -40						; size = 24
$T9 = -40						; size = 24
$T10 = -40						; size = 24
$T11 = -40						; size = 24
$T12 = -40						; size = 24
$T13 = -40						; size = 24
$T14 = -40						; size = 24
$T15 = -40						; size = 24
$T16 = -40						; size = 24
$T17 = -40						; size = 24
$T18 = -40						; size = 24
$T19 = -40						; size = 24
$T20 = -40						; size = 24
$T21 = -40						; size = 24
$T22 = -40						; size = 24
$T23 = -40						; size = 24
$T24 = -40						; size = 24
$T25 = -40						; size = 24
$T26 = -40						; size = 24
$T27 = -40						; size = 24
$T28 = -40						; size = 24
$T29 = -40						; size = 24
$T30 = -40						; size = 24
$T31 = -40						; size = 24
$T32 = -40						; size = 24
$T33 = -40						; size = 24
$T34 = -40						; size = 24
$T35 = -40						; size = 24
$T36 = -40						; size = 24
$T37 = -40						; size = 24
$T38 = -40						; size = 24
$T39 = -40						; size = 24
$T40 = -40						; size = 24
$T41 = -40						; size = 24
$T42 = -40						; size = 24
$T43 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0CPythonEventManager@@QAE@XZ PROC			; CPythonEventManager::CPythonEventManager, COMDAT
; _this$ = ecx

; 1150 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CPythonEventManager@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx
  0002c	89 7d d4	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  0002f	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonEventManager@@@@0PAVCPythonEventManager@@A, edi ; CSingleton<CPythonEventManager>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1150 : {

  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CPythonEventManager@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00042	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 570  : 		this->_Mysize = 0;

  00049	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00050	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Buyheadnode
  00055	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00058	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 483  : 		_Mylast = pointer();

  0005f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 484  : 		_Myend = pointer();

  00066	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 11   : 		CDynamicPool()

  0006d	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], OFFSET ??_7?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00074	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0

; 483  : 		_Mylast = pointer();

  0007b	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0

; 484  : 		_Myend = pointer();

  00082	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0

; 482  : 		_Myfirst = pointer();

  00089	c7 47 2c 00 00
	00 00		 mov	 DWORD PTR [edi+44], 0

; 483  : 		_Mylast = pointer();

  00090	c7 47 30 00 00
	00 00		 mov	 DWORD PTR [edi+48], 0

; 484  : 		_Myend = pointer();

  00097	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 14   : 			m_uInitCapacity=0;

  0009e	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0

; 15   : 			m_uUsedCapacity=0;

  000a5	c7 47 3c 00 00
	00 00		 mov	 DWORD PTR [edi+60], 0

; 11   : 		CDynamicPool()

  000ac	c7 47 40 00 00
	00 00		 mov	 DWORD PTR [edi+64], OFFSET ??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  000b3	c7 47 44 00 00
	00 00		 mov	 DWORD PTR [edi+68], 0

; 483  : 		_Mylast = pointer();

  000ba	c7 47 48 00 00
	00 00		 mov	 DWORD PTR [edi+72], 0

; 484  : 		_Myend = pointer();

  000c1	c7 47 4c 00 00
	00 00		 mov	 DWORD PTR [edi+76], 0

; 482  : 		_Myfirst = pointer();

  000c8	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0

; 483  : 		_Mylast = pointer();

  000cf	c7 47 54 00 00
	00 00		 mov	 DWORD PTR [edi+84], 0

; 484  : 		_Myend = pointer();

  000d6	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 14   : 			m_uInitCapacity=0;

  000dd	c7 47 5c 00 00
	00 00		 mov	 DWORD PTR [edi+92], 0

; 15   : 			m_uUsedCapacity=0;

  000e4	c7 47 60 00 00
	00 00		 mov	 DWORD PTR [edi+96], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1150 : {

  000eb	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000ef	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]
  000f2	c7 47 64 00 00
	00 00		 mov	 DWORD PTR [edi+100], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  000f9	6a 10		 push	 16			; 00000010H

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  000fb	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00102	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00109	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GNKEGEMJ@?$LD?$LC?$MA?$LK?5?$LN?C?$LA?$KD?5?3?5?$CFd?C?J?$AA@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0010e	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00111	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1150 : {

  00116	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0011a	8d 4d d8	 lea	 ecx, DWORD PTR $T43[ebp]
  0011d	6a 06		 push	 6
  0011f	68 00 00 00 00	 push	 OFFSET ??_C@_06MJINCFFA@LETTER?$AA@

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00124	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T43[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0012b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T43[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00132	c6 45 d8 00	 mov	 BYTE PTR $T43[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00136	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1151 : 	EventTypeMap["LETTER"]=EVENT_TYPE_LETTER;

  0013b	8d 45 d8	 lea	 eax, DWORD PTR $T43[ebp]
  0013e	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00142	50		 push	 eax
  00143	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00146	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0014b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0014f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00155	83 7d ec 10	 cmp	 DWORD PTR $T43[ebp+20], 16 ; 00000010H
  00159	72 0b		 jb	 SHORT $LN223@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0015b	ff 75 d8	 push	 DWORD PTR $T43[ebp]
  0015e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00163	83 c4 04	 add	 esp, 4
$LN223@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00166	6a 05		 push	 5
  00168	68 00 00 00 00	 push	 OFFSET ??_C@_05DPNLPLKI@COLOR?$AA@
  0016d	8d 4d d8	 lea	 ecx, DWORD PTR $T42[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00170	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T42[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00177	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T42[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0017e	c6 45 d8 00	 mov	 BYTE PTR $T42[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00182	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1152 : 	EventTypeMap["COLOR"]=EVENT_TYPE_COLOR;

  00187	8d 45 d8	 lea	 eax, DWORD PTR $T42[ebp]
  0018a	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0018e	50		 push	 eax
  0018f	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00192	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00197	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0019b	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  001a1	83 7d ec 10	 cmp	 DWORD PTR $T42[ebp+20], 16 ; 00000010H
  001a5	72 0b		 jb	 SHORT $LN299@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001a7	ff 75 d8	 push	 DWORD PTR $T42[ebp]
  001aa	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001af	83 c4 04	 add	 esp, 4
$LN299@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  001b2	6a 05		 push	 5
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_05IBAECHHA@DELAY?$AA@
  001b9	8d 4d d8	 lea	 ecx, DWORD PTR $T41[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  001bc	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T41[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  001c3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T41[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  001ca	c6 45 d8 00	 mov	 BYTE PTR $T41[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  001ce	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1153 : 	EventTypeMap["DELAY"]=EVENT_TYPE_DELAY;

  001d3	8d 45 d8	 lea	 eax, DWORD PTR $T41[ebp]
  001d6	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  001da	50		 push	 eax
  001db	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  001de	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  001e3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  001e7	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  001ed	83 7d ec 10	 cmp	 DWORD PTR $T41[ebp+20], 16 ; 00000010H
  001f1	72 0b		 jb	 SHORT $LN375@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001f3	ff 75 d8	 push	 DWORD PTR $T41[ebp]
  001f6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001fb	83 c4 04	 add	 esp, 4
$LN375@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  001fe	6a 05		 push	 5
  00200	68 00 00 00 00	 push	 OFFSET ??_C@_05EMNIMLKD@ENTER?$AA@
  00205	8d 4d d8	 lea	 ecx, DWORD PTR $T40[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00208	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T40[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0020f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T40[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00216	c6 45 d8 00	 mov	 BYTE PTR $T40[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0021a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1154 : 	EventTypeMap["ENTER"]=EVENT_TYPE_ENTER;

  0021f	8d 45 d8	 lea	 eax, DWORD PTR $T40[ebp]
  00222	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00226	50		 push	 eax
  00227	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0022a	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0022f	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00233	c7 00 03 00 00
	00		 mov	 DWORD PTR [eax], 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00239	83 7d ec 10	 cmp	 DWORD PTR $T40[ebp+20], 16 ; 00000010H
  0023d	72 0b		 jb	 SHORT $LN451@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0023f	ff 75 d8	 push	 DWORD PTR $T40[ebp]
  00242	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00247	83 c4 04	 add	 esp, 4
$LN451@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0024a	6a 04		 push	 4
  0024c	68 00 00 00 00	 push	 OFFSET ??_C@_04DBNKAKHO@WAIT?$AA@
  00251	8d 4d d8	 lea	 ecx, DWORD PTR $T39[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00254	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T39[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0025b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T39[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00262	c6 45 d8 00	 mov	 BYTE PTR $T39[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00266	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1155 : 	EventTypeMap["WAIT"]=EVENT_TYPE_WAIT;

  0026b	8d 45 d8	 lea	 eax, DWORD PTR $T39[ebp]
  0026e	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00272	50		 push	 eax
  00273	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00276	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0027b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0027f	c7 00 04 00 00
	00		 mov	 DWORD PTR [eax], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00285	83 7d ec 10	 cmp	 DWORD PTR $T39[ebp+20], 16 ; 00000010H
  00289	72 0b		 jb	 SHORT $LN527@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0028b	ff 75 d8	 push	 DWORD PTR $T39[ebp]
  0028e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00293	83 c4 04	 add	 esp, 4
$LN527@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00296	6a 05		 push	 5
  00298	68 00 00 00 00	 push	 OFFSET ??_C@_05PONODPI@CLEAR?$AA@
  0029d	8d 4d d8	 lea	 ecx, DWORD PTR $T38[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  002a0	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T38[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  002a7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T38[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  002ae	c6 45 d8 00	 mov	 BYTE PTR $T38[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  002b2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1156 : 	EventTypeMap["CLEAR"]=EVENT_TYPE_CLEAR;

  002b7	8d 45 d8	 lea	 eax, DWORD PTR $T38[ebp]
  002ba	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  002be	50		 push	 eax
  002bf	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  002c2	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  002c7	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  002cb	c7 00 05 00 00
	00		 mov	 DWORD PTR [eax], 5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  002d1	83 7d ec 10	 cmp	 DWORD PTR $T38[ebp+20], 16 ; 00000010H
  002d5	72 0b		 jb	 SHORT $LN603@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  002d7	ff 75 d8	 push	 DWORD PTR $T38[ebp]
  002da	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002df	83 c4 04	 add	 esp, 4
$LN603@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  002e2	6a 08		 push	 8
  002e4	68 00 00 00 00	 push	 OFFSET ??_C@_08MDIDLFIL@QUESTION?$AA@
  002e9	8d 4d d8	 lea	 ecx, DWORD PTR $T37[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  002ec	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T37[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  002f3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T37[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  002fa	c6 45 d8 00	 mov	 BYTE PTR $T37[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  002fe	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1157 : 	EventTypeMap["QUESTION"]=EVENT_TYPE_QUESTION;

  00303	8d 45 d8	 lea	 eax, DWORD PTR $T37[ebp]
  00306	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  0030a	50		 push	 eax
  0030b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0030e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00313	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00317	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0031d	83 7d ec 10	 cmp	 DWORD PTR $T37[ebp+20], 16 ; 00000010H
  00321	72 0b		 jb	 SHORT $LN679@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00323	ff 75 d8	 push	 DWORD PTR $T37[ebp]
  00326	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0032b	83 c4 04	 add	 esp, 4
$LN679@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0032e	6a 04		 push	 4
  00330	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT?$AA@
  00335	8d 4d d8	 lea	 ecx, DWORD PTR $T36[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00338	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T36[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0033f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T36[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00346	c6 45 d8 00	 mov	 BYTE PTR $T36[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0034a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1158 : 	EventTypeMap["NEXT"]=EVENT_TYPE_NEXT;

  0034f	8d 45 d8	 lea	 eax, DWORD PTR $T36[ebp]
  00352	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00356	50		 push	 eax
  00357	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0035a	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0035f	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00363	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00369	83 7d ec 10	 cmp	 DWORD PTR $T36[ebp+20], 16 ; 00000010H
  0036d	72 0b		 jb	 SHORT $LN755@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0036f	ff 75 d8	 push	 DWORD PTR $T36[ebp]
  00372	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00377	83 c4 04	 add	 esp, 4
$LN755@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0037a	6a 04		 push	 4
  0037c	68 00 00 00 00	 push	 OFFSET ??_C@_04KANDKFIK@DONE?$AA@
  00381	8d 4d d8	 lea	 ecx, DWORD PTR $T35[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00384	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T35[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0038b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T35[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00392	c6 45 d8 00	 mov	 BYTE PTR $T35[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00396	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1159 : 	EventTypeMap["DONE"]=EVENT_TYPE_DONE;

  0039b	8d 45 d8	 lea	 eax, DWORD PTR $T35[ebp]
  0039e	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  003a2	50		 push	 eax
  003a3	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  003a6	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  003ab	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  003af	c7 00 08 00 00
	00		 mov	 DWORD PTR [eax], 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  003b5	83 7d ec 10	 cmp	 DWORD PTR $T35[ebp+20], 16 ; 00000010H
  003b9	72 0b		 jb	 SHORT $LN831@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  003bb	ff 75 d8	 push	 DWORD PTR $T35[ebp]
  003be	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003c3	83 c4 04	 add	 esp, 4
$LN831@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  003c6	6a 09		 push	 9
  003c8	68 00 00 00 00	 push	 OFFSET ??_C@_09GHNJOICA@LEFTIMAGE?$AA@
  003cd	8d 4d d8	 lea	 ecx, DWORD PTR $T34[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  003d0	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T34[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  003d7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T34[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  003de	c6 45 d8 00	 mov	 BYTE PTR $T34[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  003e2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1161 : 	EventTypeMap["LEFTIMAGE"]=EVENT_TYPE_LEFT_IMAGE;

  003e7	8d 45 d8	 lea	 eax, DWORD PTR $T34[ebp]
  003ea	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  003ee	50		 push	 eax
  003ef	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  003f2	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  003f7	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  003fb	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00401	83 7d ec 10	 cmp	 DWORD PTR $T34[ebp+20], 16 ; 00000010H
  00405	72 0b		 jb	 SHORT $LN907@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00407	ff 75 d8	 push	 DWORD PTR $T34[ebp]
  0040a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0040f	83 c4 04	 add	 esp, 4
$LN907@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00412	6a 08		 push	 8
  00414	68 00 00 00 00	 push	 OFFSET ??_C@_08LGGHBKNM@TOPIMAGE?$AA@
  00419	8d 4d d8	 lea	 ecx, DWORD PTR $T33[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0041c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T33[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00423	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T33[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0042a	c6 45 d8 00	 mov	 BYTE PTR $T33[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0042e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1162 : 	EventTypeMap["TOPIMAGE"]=EVENT_TYPE_TOP_IMAGE;

  00433	8d 45 d8	 lea	 eax, DWORD PTR $T33[ebp]
  00436	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  0043a	50		 push	 eax
  0043b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0043e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00443	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00447	c7 00 0a 00 00
	00		 mov	 DWORD PTR [eax], 10	; 0000000aH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0044d	83 7d ec 10	 cmp	 DWORD PTR $T33[ebp+20], 16 ; 00000010H
  00451	72 0b		 jb	 SHORT $LN983@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00453	ff 75 d8	 push	 DWORD PTR $T33[ebp]
  00456	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0045b	83 c4 04	 add	 esp, 4
$LN983@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0045e	6a 07		 push	 7
  00460	68 00 00 00 00	 push	 OFFSET ??_C@_07CDIOHGPA@BGIMAGE?$AA@
  00465	8d 4d d8	 lea	 ecx, DWORD PTR $T32[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00468	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T32[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0046f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T32[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00476	c6 45 d8 00	 mov	 BYTE PTR $T32[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0047a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1163 : 	EventTypeMap["BGIMAGE"]=EVENT_TYPE_BACKGROUND_IMAGE;

  0047f	8d 45 d8	 lea	 eax, DWORD PTR $T32[ebp]
  00482	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  00486	50		 push	 eax
  00487	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0048a	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0048f	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00493	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00499	83 7d ec 10	 cmp	 DWORD PTR $T32[ebp+20], 16 ; 00000010H
  0049d	72 0b		 jb	 SHORT $LN1059@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0049f	ff 75 d8	 push	 DWORD PTR $T32[ebp]
  004a2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004a7	83 c4 04	 add	 esp, 4
$LN1059@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  004aa	6a 05		 push	 5
  004ac	68 00 00 00 00	 push	 OFFSET ??_C@_05BNHKIGFN@IMAGE?$AA@
  004b1	8d 4d d8	 lea	 ecx, DWORD PTR $T31[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  004b4	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T31[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  004bb	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T31[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  004c2	c6 45 d8 00	 mov	 BYTE PTR $T31[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  004c6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1164 : 	EventTypeMap["IMAGE"]=EVENT_TYPE_IMAGE;

  004cb	8d 45 d8	 lea	 eax, DWORD PTR $T31[ebp]
  004ce	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  004d2	50		 push	 eax
  004d3	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  004d6	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  004db	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  004df	c7 00 0c 00 00
	00		 mov	 DWORD PTR [eax], 12	; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  004e5	83 7d ec 10	 cmp	 DWORD PTR $T31[ebp+20], 16 ; 00000010H
  004e9	72 0b		 jb	 SHORT $LN1135@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  004eb	ff 75 d8	 push	 DWORD PTR $T31[ebp]
  004ee	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004f3	83 c4 04	 add	 esp, 4
$LN1135@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  004f6	6a 0c		 push	 12			; 0000000cH
  004f8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LEAJJLAE@ADDMAPSIGNAL?$AA@
  004fd	8d 4d d8	 lea	 ecx, DWORD PTR $T30[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00500	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T30[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00507	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T30[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0050e	c6 45 d8 00	 mov	 BYTE PTR $T30[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00512	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1166 : 	EventTypeMap["ADDMAPSIGNAL"]=EVENT_TYPE_ADD_MAP_SIGNAL;

  00517	8d 45 d8	 lea	 eax, DWORD PTR $T30[ebp]
  0051a	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  0051e	50		 push	 eax
  0051f	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00522	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00527	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0052b	c7 00 0d 00 00
	00		 mov	 DWORD PTR [eax], 13	; 0000000dH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00531	83 7d ec 10	 cmp	 DWORD PTR $T30[ebp+20], 16 ; 00000010H
  00535	72 0b		 jb	 SHORT $LN1211@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00537	ff 75 d8	 push	 DWORD PTR $T30[ebp]
  0053a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0053f	83 c4 04	 add	 esp, 4
$LN1211@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00542	6a 0e		 push	 14			; 0000000eH
  00544	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MCDNLKLH@CLEARMAPSIGNAL?$AA@
  00549	8d 4d d8	 lea	 ecx, DWORD PTR $T29[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0054c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T29[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00553	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T29[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0055a	c6 45 d8 00	 mov	 BYTE PTR $T29[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0055e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1167 : 	EventTypeMap["CLEARMAPSIGNAL"]=EVENT_TYPE_CLEAR_MAP_SIGNAL;

  00563	8d 45 d8	 lea	 eax, DWORD PTR $T29[ebp]
  00566	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  0056a	50		 push	 eax
  0056b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0056e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00573	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00577	c7 00 0e 00 00
	00		 mov	 DWORD PTR [eax], 14	; 0000000eH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0057d	83 7d ec 10	 cmp	 DWORD PTR $T29[ebp+20], 16 ; 00000010H
  00581	72 0b		 jb	 SHORT $LN1287@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00583	ff 75 d8	 push	 DWORD PTR $T29[ebp]
  00586	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0058b	83 c4 04	 add	 esp, 4
$LN1287@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0058e	6a 09		 push	 9
  00590	68 00 00 00 00	 push	 OFFSET ??_C@_09GPHHDAMH@SETMSGPOS?$AA@
  00595	8d 4d d8	 lea	 ecx, DWORD PTR $T28[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00598	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T28[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0059f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T28[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  005a6	c6 45 d8 00	 mov	 BYTE PTR $T28[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  005aa	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1169 : 	EventTypeMap["SETMSGPOS"]=EVENT_TYPE_SET_MESSAGE_POSITION;

  005af	8d 45 d8	 lea	 eax, DWORD PTR $T28[ebp]
  005b2	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  005b6	50		 push	 eax
  005b7	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  005ba	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  005bf	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  005c3	c7 00 0f 00 00
	00		 mov	 DWORD PTR [eax], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  005c9	83 7d ec 10	 cmp	 DWORD PTR $T28[ebp+20], 16 ; 00000010H
  005cd	72 0b		 jb	 SHORT $LN1363@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  005cf	ff 75 d8	 push	 DWORD PTR $T28[ebp]
  005d2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  005d7	83 c4 04	 add	 esp, 4
$LN1363@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  005da	6a 09		 push	 9
  005dc	68 00 00 00 00	 push	 OFFSET ??_C@_09DCGGFGEI@ADJMSGPOS?$AA@
  005e1	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  005e4	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T27[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  005eb	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T27[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  005f2	c6 45 d8 00	 mov	 BYTE PTR $T27[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  005f6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1170 : 	EventTypeMap["ADJMSGPOS"]=EVENT_TYPE_ADJUST_MESSAGE_POSITION;

  005fb	8d 45 d8	 lea	 eax, DWORD PTR $T27[ebp]
  005fe	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  00602	50		 push	 eax
  00603	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00606	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0060b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0060f	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00615	83 7d ec 10	 cmp	 DWORD PTR $T27[ebp+20], 16 ; 00000010H
  00619	72 0b		 jb	 SHORT $LN1439@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0061b	ff 75 d8	 push	 DWORD PTR $T27[ebp]
  0061e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00623	83 c4 04	 add	 esp, 4
$LN1439@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00626	6a 0a		 push	 10			; 0000000aH
  00628	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HNINCFNF@SETCMAPPOS?$AA@
  0062d	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00630	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T26[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00637	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T26[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0063e	c6 45 d8 00	 mov	 BYTE PTR $T26[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00642	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1171 : 	EventTypeMap["SETCMAPPOS"]=EVENT_TYPE_SET_CENTER_MAP_POSITION;

  00647	8d 45 d8	 lea	 eax, DWORD PTR $T26[ebp]
  0064a	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
  0064e	50		 push	 eax
  0064f	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00652	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00657	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0065b	c7 00 11 00 00
	00		 mov	 DWORD PTR [eax], 17	; 00000011H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00661	83 7d ec 10	 cmp	 DWORD PTR $T26[ebp+20], 16 ; 00000010H
  00665	72 0b		 jb	 SHORT $LN1515@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00667	ff 75 d8	 push	 DWORD PTR $T26[ebp]
  0066a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0066f	83 c4 04	 add	 esp, 4
$LN1515@CPythonEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00672	6a 0b		 push	 11			; 0000000bH
  00674	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NLCKLGGC@QUESTBUTTON?$AA@
  00679	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0067c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T25[ebp+20], 15 ; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00683	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T25[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0068a	c6 45 d8 00	 mov	 BYTE PTR $T25[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0068e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1173 : 	EventTypeMap["QUESTBUTTON"]=EVENT_TYPE_QUEST_BUTTON;

  00693	8d 45 d8	 lea	 eax, DWORD PTR $T25[ebp]
  00696	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  0069a	50		 push	 eax
  0069b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0069e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  006a3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  006a7	c7 00 12 00 00
	00		 mov	 DWORD PTR [eax], 18	; 00000012H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  006ad	83 7d ec 10	 cmp	 DWORD PTR $T25[ebp+20], 16 ; 00000010H
  006b1	72 0b		 jb	 SHORT $LN1591@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  006b3	ff 75 d8	 push	 DWORD PTR $T25[ebp]
  006b6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  006bb	83 c4 04	 add	 esp, 4
$LN1591@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1176 : 	EventTypeMap["QUESTBUTTON_CLOSE"]=EVENT_TYPE_QUEST_BUTTON_CLOSE;

  006be	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HFDJPBHI@QUESTBUTTON_CLOSE?$AA@
  006c3	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  006c6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  006cb	8d 45 d8	 lea	 eax, DWORD PTR $T24[ebp]
  006ce	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H
  006d2	50		 push	 eax
  006d3	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  006d6	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  006db	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  006df	c7 00 13 00 00
	00		 mov	 DWORD PTR [eax], 19	; 00000013H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  006e5	83 7d ec 10	 cmp	 DWORD PTR $T24[ebp+20], 16 ; 00000010H
  006e9	72 0b		 jb	 SHORT $LN1623@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  006eb	ff 75 d8	 push	 DWORD PTR $T24[ebp]
  006ee	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  006f3	83 c4 04	 add	 esp, 4
$LN1623@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1179 : 	EventTypeMap["SLEEP"]=EVENT_TYPE_SLEEP;

  006f6	68 00 00 00 00	 push	 OFFSET ??_C@_05DJAECLDN@SLEEP?$AA@
  006fb	8d 4d d8	 lea	 ecx, DWORD PTR $T23[ebp]
  006fe	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00703	8d 45 d8	 lea	 eax, DWORD PTR $T23[ebp]
  00706	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  0070a	50		 push	 eax
  0070b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0070e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00713	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00717	c7 00 14 00 00
	00		 mov	 DWORD PTR [eax], 20	; 00000014H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0071d	83 7d ec 10	 cmp	 DWORD PTR $T23[ebp+20], 16 ; 00000010H
  00721	72 0b		 jb	 SHORT $LN1655@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00723	ff 75 d8	 push	 DWORD PTR $T23[ebp]
  00726	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0072b	83 c4 04	 add	 esp, 4
$LN1655@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1180 : 	EventTypeMap["SET_CAMERA"]=EVENT_TYPE_SET_CAMERA;

  0072e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JFBLMOIC@SET_CAMERA?$AA@
  00733	8d 4d d8	 lea	 ecx, DWORD PTR $T22[ebp]
  00736	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0073b	8d 45 d8	 lea	 eax, DWORD PTR $T22[ebp]
  0073e	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
  00742	50		 push	 eax
  00743	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00746	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0074b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0074f	c7 00 15 00 00
	00		 mov	 DWORD PTR [eax], 21	; 00000015H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00755	83 7d ec 10	 cmp	 DWORD PTR $T22[ebp+20], 16 ; 00000010H
  00759	72 0b		 jb	 SHORT $LN1687@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0075b	ff 75 d8	 push	 DWORD PTR $T22[ebp]
  0075e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00763	83 c4 04	 add	 esp, 4
$LN1687@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1181 : 	EventTypeMap["BLEND_CAMERA"]=EVENT_TYPE_BLEND_CAMERA;

  00766	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LDDFAHD@BLEND_CAMERA?$AA@
  0076b	8d 4d d8	 lea	 ecx, DWORD PTR $T21[ebp]
  0076e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00773	8d 45 d8	 lea	 eax, DWORD PTR $T21[ebp]
  00776	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  0077a	50		 push	 eax
  0077b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0077e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00783	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00787	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0078d	83 7d ec 10	 cmp	 DWORD PTR $T21[ebp+20], 16 ; 00000010H
  00791	72 0b		 jb	 SHORT $LN1719@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00793	ff 75 d8	 push	 DWORD PTR $T21[ebp]
  00796	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0079b	83 c4 04	 add	 esp, 4
$LN1719@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1182 : 	EventTypeMap["RESTORE_CAMERA"]=EVENT_TYPE_RESTORE_CAMERA;

  0079e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JLFCBANF@RESTORE_CAMERA?$AA@
  007a3	8d 4d d8	 lea	 ecx, DWORD PTR $T20[ebp]
  007a6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  007ab	8d 45 d8	 lea	 eax, DWORD PTR $T20[ebp]
  007ae	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+8], 29 ; 0000001dH
  007b2	50		 push	 eax
  007b3	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  007b6	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  007bb	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  007bf	c7 00 17 00 00
	00		 mov	 DWORD PTR [eax], 23	; 00000017H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  007c5	83 7d ec 10	 cmp	 DWORD PTR $T20[ebp+20], 16 ; 00000010H
  007c9	72 0b		 jb	 SHORT $LN1751@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  007cb	ff 75 d8	 push	 DWORD PTR $T20[ebp]
  007ce	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007d3	83 c4 04	 add	 esp, 4
$LN1751@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1183 : 	EventTypeMap["FADE_OUT"]=EVENT_TYPE_FADE_OUT;

  007d6	68 00 00 00 00	 push	 OFFSET ??_C@_08HDAMPNGA@FADE_OUT?$AA@
  007db	8d 4d d8	 lea	 ecx, DWORD PTR $T19[ebp]
  007de	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  007e3	8d 45 d8	 lea	 eax, DWORD PTR $T19[ebp]
  007e6	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+8], 30 ; 0000001eH
  007ea	50		 push	 eax
  007eb	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  007ee	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  007f3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  007f7	c7 00 18 00 00
	00		 mov	 DWORD PTR [eax], 24	; 00000018H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  007fd	83 7d ec 10	 cmp	 DWORD PTR $T19[ebp+20], 16 ; 00000010H
  00801	72 0b		 jb	 SHORT $LN1783@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00803	ff 75 d8	 push	 DWORD PTR $T19[ebp]
  00806	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0080b	83 c4 04	 add	 esp, 4
$LN1783@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1184 : 	EventTypeMap["FADE_IN"]=EVENT_TYPE_FADE_IN;

  0080e	68 00 00 00 00	 push	 OFFSET ??_C@_07BBFGMBEC@FADE_IN?$AA@
  00813	8d 4d d8	 lea	 ecx, DWORD PTR $T18[ebp]
  00816	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0081b	8d 45 d8	 lea	 eax, DWORD PTR $T18[ebp]
  0081e	c6 45 fc 1f	 mov	 BYTE PTR __$EHRec$[ebp+8], 31 ; 0000001fH
  00822	50		 push	 eax
  00823	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00826	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0082b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0082f	c7 00 19 00 00
	00		 mov	 DWORD PTR [eax], 25	; 00000019H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00835	83 7d ec 10	 cmp	 DWORD PTR $T18[ebp+20], 16 ; 00000010H
  00839	72 0b		 jb	 SHORT $LN1815@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0083b	ff 75 d8	 push	 DWORD PTR $T18[ebp]
  0083e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00843	83 c4 04	 add	 esp, 4
$LN1815@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1185 : 	EventTypeMap["WHITE_OUT"]=EVENT_TYPE_WHITE_OUT;

  00846	68 00 00 00 00	 push	 OFFSET ??_C@_09FBLOEAGA@WHITE_OUT?$AA@
  0084b	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  0084e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00853	8d 45 d8	 lea	 eax, DWORD PTR $T17[ebp]
  00856	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
  0085a	50		 push	 eax
  0085b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0085e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00863	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00867	c7 00 1a 00 00
	00		 mov	 DWORD PTR [eax], 26	; 0000001aH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0086d	83 7d ec 10	 cmp	 DWORD PTR $T17[ebp+20], 16 ; 00000010H
  00871	72 0b		 jb	 SHORT $LN1847@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00873	ff 75 d8	 push	 DWORD PTR $T17[ebp]
  00876	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0087b	83 c4 04	 add	 esp, 4
$LN1847@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1186 : 	EventTypeMap["WHITE_IN"]=EVENT_TYPE_WHITE_IN;

  0087e	68 00 00 00 00	 push	 OFFSET ??_C@_08KBPNHIPE@WHITE_IN?$AA@
  00883	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  00886	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0088b	8d 45 d8	 lea	 eax, DWORD PTR $T16[ebp]
  0088e	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
  00892	50		 push	 eax
  00893	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00896	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0089b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0089f	c7 00 1b 00 00
	00		 mov	 DWORD PTR [eax], 27	; 0000001bH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  008a5	83 7d ec 10	 cmp	 DWORD PTR $T16[ebp+20], 16 ; 00000010H
  008a9	72 0b		 jb	 SHORT $LN1879@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  008ab	ff 75 d8	 push	 DWORD PTR $T16[ebp]
  008ae	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  008b3	83 c4 04	 add	 esp, 4
$LN1879@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1187 : 	EventTypeMap["CLEAR_TEXT"]=EVENT_TYPE_CLEAR_TEXT;

  008b6	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LKNFDGAI@CLEAR_TEXT?$AA@
  008bb	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  008be	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  008c3	8d 45 d8	 lea	 eax, DWORD PTR $T15[ebp]
  008c6	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
  008ca	50		 push	 eax
  008cb	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  008ce	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  008d3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  008d7	c7 00 1c 00 00
	00		 mov	 DWORD PTR [eax], 28	; 0000001cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  008dd	83 7d ec 10	 cmp	 DWORD PTR $T15[ebp+20], 16 ; 00000010H
  008e1	72 0b		 jb	 SHORT $LN1911@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  008e3	ff 75 d8	 push	 DWORD PTR $T15[ebp]
  008e6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  008eb	83 c4 04	 add	 esp, 4
$LN1911@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1188 : 	EventTypeMap["TEXT_HORIZONTAL_ALIGN_CENTER"]=EVENT_TYPE_TEXT_HORIZONTAL_ALIGN_CENTER;

  008ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MHHHIBEN@TEXT_HORIZONTAL_ALIGN_CENTER?$AA@
  008f3	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  008f6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  008fb	8d 45 d8	 lea	 eax, DWORD PTR $T14[ebp]
  008fe	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+8], 35 ; 00000023H
  00902	50		 push	 eax
  00903	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00906	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0090b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0090f	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00915	83 7d ec 10	 cmp	 DWORD PTR $T14[ebp+20], 16 ; 00000010H
  00919	72 0b		 jb	 SHORT $LN1943@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0091b	ff 75 d8	 push	 DWORD PTR $T14[ebp]
  0091e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00923	83 c4 04	 add	 esp, 4
$LN1943@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1189 : 	EventTypeMap["TITLE_IMAGE"]=EVENT_TYPE_TITLE_IMAGE;

  00926	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HJKMCEHO@TITLE_IMAGE?$AA@
  0092b	8d 4d d8	 lea	 ecx, DWORD PTR $T13[ebp]
  0092e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00933	8d 45 d8	 lea	 eax, DWORD PTR $T13[ebp]
  00936	c6 45 fc 24	 mov	 BYTE PTR __$EHRec$[ebp+8], 36 ; 00000024H
  0093a	50		 push	 eax
  0093b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0093e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00943	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00947	c7 00 1e 00 00
	00		 mov	 DWORD PTR [eax], 30	; 0000001eH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0094d	83 7d ec 10	 cmp	 DWORD PTR $T13[ebp+20], 16 ; 00000010H
  00951	72 0b		 jb	 SHORT $LN1975@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00953	ff 75 d8	 push	 DWORD PTR $T13[ebp]
  00956	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0095b	83 c4 04	 add	 esp, 4
$LN1975@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1191 : 	EventTypeMap["RUN_CINEMA"]=EVENT_TYPE_RUN_CINEMA;

  0095e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PGFMEELF@RUN_CINEMA?$AA@
  00963	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  00966	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0096b	8d 45 d8	 lea	 eax, DWORD PTR $T12[ebp]
  0096e	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+8], 37 ; 00000025H
  00972	50		 push	 eax
  00973	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00976	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  0097b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0097f	c7 00 1f 00 00
	00		 mov	 DWORD PTR [eax], 31	; 0000001fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00985	83 7d ec 10	 cmp	 DWORD PTR $T12[ebp+20], 16 ; 00000010H
  00989	72 0b		 jb	 SHORT $LN2007@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0098b	ff 75 d8	 push	 DWORD PTR $T12[ebp]
  0098e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00993	83 c4 04	 add	 esp, 4
$LN2007@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1192 : 	EventTypeMap["DUNGEON_RESULT"]=EVENT_TYPE_DUNGEON_RESULT;

  00996	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FFIDJBND@DUNGEON_RESULT?$AA@
  0099b	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  0099e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  009a3	8d 45 d8	 lea	 eax, DWORD PTR $T11[ebp]
  009a6	c6 45 fc 26	 mov	 BYTE PTR __$EHRec$[ebp+8], 38 ; 00000026H
  009aa	50		 push	 eax
  009ab	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  009ae	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  009b3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  009b7	c7 00 20 00 00
	00		 mov	 DWORD PTR [eax], 32	; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  009bd	83 7d ec 10	 cmp	 DWORD PTR $T11[ebp+20], 16 ; 00000010H
  009c1	72 0b		 jb	 SHORT $LN2039@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  009c3	ff 75 d8	 push	 DWORD PTR $T11[ebp]
  009c6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  009cb	83 c4 04	 add	 esp, 4
$LN2039@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1194 : 	EventTypeMap["ITEM"]=EVENT_TYPE_ITEM_NAME;

  009ce	68 00 00 00 00	 push	 OFFSET ??_C@_04BLNHNEEM@ITEM?$AA@
  009d3	8d 4d d8	 lea	 ecx, DWORD PTR $T10[ebp]
  009d6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  009db	8d 45 d8	 lea	 eax, DWORD PTR $T10[ebp]
  009de	c6 45 fc 27	 mov	 BYTE PTR __$EHRec$[ebp+8], 39 ; 00000027H
  009e2	50		 push	 eax
  009e3	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  009e6	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  009eb	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  009ef	c7 00 21 00 00
	00		 mov	 DWORD PTR [eax], 33	; 00000021H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  009f5	83 7d ec 10	 cmp	 DWORD PTR $T10[ebp+20], 16 ; 00000010H
  009f9	72 0b		 jb	 SHORT $LN2071@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  009fb	ff 75 d8	 push	 DWORD PTR $T10[ebp]
  009fe	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a03	83 c4 04	 add	 esp, 4
$LN2071@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1195 : 	EventTypeMap["MOB"]=EVENT_TYPE_MONSTER_NAME;

  00a06	68 00 00 00 00	 push	 OFFSET ??_C@_03OEMEHHJ@MOB?$AA@
  00a0b	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  00a0e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a13	8d 45 d8	 lea	 eax, DWORD PTR $T9[ebp]
  00a16	c6 45 fc 28	 mov	 BYTE PTR __$EHRec$[ebp+8], 40 ; 00000028H
  00a1a	50		 push	 eax
  00a1b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00a1e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00a23	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00a27	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00a2d	83 7d ec 10	 cmp	 DWORD PTR $T9[ebp+20], 16 ; 00000010H
  00a31	72 0b		 jb	 SHORT $LN2103@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00a33	ff 75 d8	 push	 DWORD PTR $T9[ebp]
  00a36	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a3b	83 c4 04	 add	 esp, 4
$LN2103@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1197 : 	EventTypeMap["COLOR256"]=EVENT_TYPE_COLOR256;

  00a3e	68 00 00 00 00	 push	 OFFSET ??_C@_08MALMLJOJ@COLOR256?$AA@
  00a43	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  00a46	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a4b	8d 45 d8	 lea	 eax, DWORD PTR $T8[ebp]
  00a4e	c6 45 fc 29	 mov	 BYTE PTR __$EHRec$[ebp+8], 41 ; 00000029H
  00a52	50		 push	 eax
  00a53	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00a56	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00a5b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00a5f	c7 00 23 00 00
	00		 mov	 DWORD PTR [eax], 35	; 00000023H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00a65	83 7d ec 10	 cmp	 DWORD PTR $T8[ebp+20], 16 ; 00000010H
  00a69	72 0b		 jb	 SHORT $LN2135@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00a6b	ff 75 d8	 push	 DWORD PTR $T8[ebp]
  00a6e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a73	83 c4 04	 add	 esp, 4
$LN2135@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1198 : 	EventTypeMap["WINDOW_SIZE"]=EVENT_TYPE_WINDOW_SIZE;

  00a76	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PMFMMHLB@WINDOW_SIZE?$AA@
  00a7b	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  00a7e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a83	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
  00a86	c6 45 fc 2a	 mov	 BYTE PTR __$EHRec$[ebp+8], 42 ; 0000002aH
  00a8a	50		 push	 eax
  00a8b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00a8e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00a93	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00a97	c7 00 24 00 00
	00		 mov	 DWORD PTR [eax], 36	; 00000024H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00a9d	83 7d ec 10	 cmp	 DWORD PTR $T7[ebp+20], 16 ; 00000010H
  00aa1	72 0b		 jb	 SHORT $LN2167@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00aa3	ff 75 d8	 push	 DWORD PTR $T7[ebp]
  00aa6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00aab	83 c4 04	 add	 esp, 4
$LN2167@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1200 : 	EventTypeMap["INPUT"]=EVENT_TYPE_INPUT;

  00aae	68 00 00 00 00	 push	 OFFSET ??_C@_05POAEJIHJ@INPUT?$AA@
  00ab3	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  00ab6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00abb	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]
  00abe	c6 45 fc 2b	 mov	 BYTE PTR __$EHRec$[ebp+8], 43 ; 0000002bH
  00ac2	50		 push	 eax
  00ac3	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00ac6	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00acb	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00acf	c7 00 25 00 00
	00		 mov	 DWORD PTR [eax], 37	; 00000025H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00ad5	83 7d ec 10	 cmp	 DWORD PTR $T6[ebp+20], 16 ; 00000010H
  00ad9	72 0b		 jb	 SHORT $LN2199@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00adb	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  00ade	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ae3	83 c4 04	 add	 esp, 4
$LN2199@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1201 : 	EventTypeMap["CONFIRM_WAIT"]=EVENT_TYPE_CONFIRM_WAIT;

  00ae6	68 00 00 00 00	 push	 OFFSET ??_C@_0N@BAJAMEHH@CONFIRM_WAIT?$AA@
  00aeb	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00aee	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00af3	8d 45 d8	 lea	 eax, DWORD PTR $T5[ebp]
  00af6	c6 45 fc 2c	 mov	 BYTE PTR __$EHRec$[ebp+8], 44 ; 0000002cH
  00afa	50		 push	 eax
  00afb	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00afe	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00b03	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00b07	c7 00 26 00 00
	00		 mov	 DWORD PTR [eax], 38	; 00000026H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00b0d	83 7d ec 10	 cmp	 DWORD PTR $T5[ebp+20], 16 ; 00000010H
  00b11	72 0b		 jb	 SHORT $LN2231@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00b13	ff 75 d8	 push	 DWORD PTR $T5[ebp]
  00b16	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00b1b	83 c4 04	 add	 esp, 4
$LN2231@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1202 : 	EventTypeMap["END_CONFIRM_WAIT"]=EVENT_TYPE_END_CONFIRM_WAIT;

  00b1e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EAAHJLBE@END_CONFIRM_WAIT?$AA@
  00b23	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00b26	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b2b	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  00b2e	c6 45 fc 2d	 mov	 BYTE PTR __$EHRec$[ebp+8], 45 ; 0000002dH
  00b32	50		 push	 eax
  00b33	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00b36	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00b3b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00b3f	c7 00 27 00 00
	00		 mov	 DWORD PTR [eax], 39	; 00000027H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00b45	83 7d ec 10	 cmp	 DWORD PTR $T4[ebp+20], 16 ; 00000010H
  00b49	72 0b		 jb	 SHORT $LN2263@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00b4b	ff 75 d8	 push	 DWORD PTR $T4[ebp]
  00b4e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00b53	83 c4 04	 add	 esp, 4
$LN2263@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1204 : 	EventTypeMap["INSERT_IMAGE"]=EVENT_TYPE_INSERT_IMAGE;

  00b56	68 00 00 00 00	 push	 OFFSET ??_C@_0N@IBBMOEIC@INSERT_IMAGE?$AA@
  00b5b	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00b5e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b63	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00b66	c6 45 fc 2e	 mov	 BYTE PTR __$EHRec$[ebp+8], 46 ; 0000002eH
  00b6a	50		 push	 eax
  00b6b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00b6e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00b73	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00b77	c7 00 28 00 00
	00		 mov	 DWORD PTR [eax], 40	; 00000028H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00b7d	83 7d ec 10	 cmp	 DWORD PTR $T3[ebp+20], 16 ; 00000010H
  00b81	72 0b		 jb	 SHORT $LN2295@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00b83	ff 75 d8	 push	 DWORD PTR $T3[ebp]
  00b86	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00b8b	83 c4 04	 add	 esp, 4
$LN2295@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1206 : 	EventTypeMap["SELECT_ITEM"]=EVENT_TYPE_SELECT_ITEM;

  00b8e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NHAJMLIB@SELECT_ITEM?$AA@
  00b93	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00b96	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b9b	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  00b9e	c6 45 fc 2f	 mov	 BYTE PTR __$EHRec$[ebp+8], 47 ; 0000002fH
  00ba2	50		 push	 eax
  00ba3	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00ba6	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
  00bab	c7 00 29 00 00
	00		 mov	 DWORD PTR [eax], 41	; 00000029H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00bb1	83 7d ec 10	 cmp	 DWORD PTR $T2[ebp+20], 16 ; 00000010H
  00bb5	72 0b		 jb	 SHORT $LN2339@CPythonEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00bb7	ff 75 d8	 push	 DWORD PTR $T2[ebp]
  00bba	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00bbf	83 c4 04	 add	 esp, 4
$LN2339@CPythonEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1207 : }

  00bc2	8b c7		 mov	 eax, edi
  00bc4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00bc7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00bce	59		 pop	 ecx
  00bcf	5f		 pop	 edi
  00bd0	5e		 pop	 esi
  00bd1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bd4	33 cd		 xor	 ecx, ebp
  00bd6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bdb	8b e5		 mov	 esp, ebp
  00bdd	5d		 pop	 ebp
  00bde	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$0:
  00000	8b 4d d4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCPythonEventManager@@@@UAE@XZ ; CSingleton<CPythonEventManager>::~CSingleton<CPythonEventManager>
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$1:
  00008	8b 4d d4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$2:
  00013	8b 4d d4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::~vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$3:
  0001e	8b 4d d4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00021	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00024	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@USEventSet@CPythonEventManager@@@@UAE@XZ ; CDynamicPool<CPythonEventManager::SEventSet>::~CDynamicPool<CPythonEventManager::SEventSet>
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$4:
  00029	8b 4d d4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0002c	83 c1 40	 add	 ecx, 64			; 00000040H
  0002f	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ ; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$5:
  00034	8b 4d d4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00037	83 c1 68	 add	 ecx, 104		; 00000068H
  0003a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$6:
  0003f	8d 4d d8	 lea	 ecx, DWORD PTR $T43[ebp]
  00042	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$7:
  00047	8d 4d d8	 lea	 ecx, DWORD PTR $T42[ebp]
  0004a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$8:
  0004f	8d 4d d8	 lea	 ecx, DWORD PTR $T41[ebp]
  00052	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$9:
  00057	8d 4d d8	 lea	 ecx, DWORD PTR $T40[ebp]
  0005a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$10:
  0005f	8d 4d d8	 lea	 ecx, DWORD PTR $T39[ebp]
  00062	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$11:
  00067	8d 4d d8	 lea	 ecx, DWORD PTR $T38[ebp]
  0006a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$12:
  0006f	8d 4d d8	 lea	 ecx, DWORD PTR $T37[ebp]
  00072	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$13:
  00077	8d 4d d8	 lea	 ecx, DWORD PTR $T36[ebp]
  0007a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$14:
  0007f	8d 4d d8	 lea	 ecx, DWORD PTR $T35[ebp]
  00082	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$15:
  00087	8d 4d d8	 lea	 ecx, DWORD PTR $T34[ebp]
  0008a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$16:
  0008f	8d 4d d8	 lea	 ecx, DWORD PTR $T33[ebp]
  00092	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$17:
  00097	8d 4d d8	 lea	 ecx, DWORD PTR $T32[ebp]
  0009a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$18:
  0009f	8d 4d d8	 lea	 ecx, DWORD PTR $T31[ebp]
  000a2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$19:
  000a7	8d 4d d8	 lea	 ecx, DWORD PTR $T30[ebp]
  000aa	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$20:
  000af	8d 4d d8	 lea	 ecx, DWORD PTR $T29[ebp]
  000b2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$21:
  000b7	8d 4d d8	 lea	 ecx, DWORD PTR $T28[ebp]
  000ba	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$22:
  000bf	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]
  000c2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$23:
  000c7	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]
  000ca	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$24:
  000cf	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  000d2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$25:
  000d7	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  000da	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$26:
  000df	8d 4d d8	 lea	 ecx, DWORD PTR $T23[ebp]
  000e2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$27:
  000e7	8d 4d d8	 lea	 ecx, DWORD PTR $T22[ebp]
  000ea	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$28:
  000ef	8d 4d d8	 lea	 ecx, DWORD PTR $T21[ebp]
  000f2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$29:
  000f7	8d 4d d8	 lea	 ecx, DWORD PTR $T20[ebp]
  000fa	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$30:
  000ff	8d 4d d8	 lea	 ecx, DWORD PTR $T19[ebp]
  00102	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$31:
  00107	8d 4d d8	 lea	 ecx, DWORD PTR $T18[ebp]
  0010a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$32:
  0010f	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  00112	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$33:
  00117	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  0011a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$34:
  0011f	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  00122	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$35:
  00127	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  0012a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$36:
  0012f	8d 4d d8	 lea	 ecx, DWORD PTR $T13[ebp]
  00132	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$37:
  00137	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  0013a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$38:
  0013f	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  00142	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$39:
  00147	8d 4d d8	 lea	 ecx, DWORD PTR $T10[ebp]
  0014a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$40:
  0014f	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  00152	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$41:
  00157	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  0015a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$42:
  0015f	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  00162	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$43:
  00167	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0016a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$44:
  0016f	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00172	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$45:
  00177	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  0017a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$46:
  0017f	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00182	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CPythonEventManager@@QAE@XZ$47:
  00187	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0018a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0CPythonEventManager@@QAE@XZ:
  0018f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00193	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00196	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00199	33 c8		 xor	 ecx, eax
  0019b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a0	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  001a3	33 c8		 xor	 ecx, eax
  001a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001aa	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CPythonEventManager@@QAE@XZ
  001af	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CPythonEventManager@@QAE@XZ ENDP			; CPythonEventManager::CPythonEventManager
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\parser.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\parser.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\parser.h
;	COMDAT ??0SCmd@script@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0SCmd@script@@QAE@XZ PROC				; script::SCmd::SCmd, COMDAT
; _this$ = ecx

; 37   : 		SCmd()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SCmd@script@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0002a	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00031	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00038	c6 07 00	 mov	 BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0003b	6a 00		 push	 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\parser.h

; 37   : 		SCmd()

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00044	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00047	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  00049	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0

; 528  : 		this->_Mysize = 0;

  00050	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], 0

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00057	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buynode0

; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  0005c	89 47 18	 mov	 DWORD PTR [edi+24], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\parser.h

; 37   : 		SCmd()

  0005f	8b c7		 mov	 eax, edi
  00061	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00064	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006b	59		 pop	 ecx
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SCmd@script@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0SCmd@script@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SCmd@script@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SCmd@script@@QAE@XZ ENDP				; script::SCmd::SCmd
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.h
;	COMDAT ??0SEventSet@CPythonEventManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0SEventSet@CPythonEventManager@@QAE@XZ PROC		; CPythonEventManager::SEventSet::SEventSet, COMDAT
; _this$ = ecx

; 143  : 			SEventSet() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SEventSet@CPythonEventManager@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SEventSet@CPythonEventManager@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0002f	c7 46 44 0f 00
	00 00		 mov	 DWORD PTR [esi+68], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00036	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0003d	c6 46 30 00	 mov	 BYTE PTR [esi+48], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00041	6a 00		 push	 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.h

; 143  : 			SEventSet() {}

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0004a	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  0004c	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0

; 528  : 		this->_Mysize = 0;

  00053	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0005a	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buynode0

; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  0005f	89 46 4c	 mov	 DWORD PTR [esi+76], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.h

; 143  : 			SEventSet() {}

  00062	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  00065	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00069	e8 00 00 00 00	 call	 ??0Group@script@@QAE@XZ	; script::Group::Group
  0006e	8b c6		 mov	 eax, esi
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5e		 pop	 esi
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SEventSet@CPythonEventManager@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 30	 add	 ecx, 48			; 00000030H
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0SEventSet@CPythonEventManager@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00011	e9 00 00 00 00	 jmp	 ??1?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::~list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >
__ehhandler$??0SEventSet@CPythonEventManager@@QAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SEventSet@CPythonEventManager@@QAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SEventSet@CPythonEventManager@@QAE@XZ ENDP		; CPythonEventManager::SEventSet::SEventSet
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.h
;	COMDAT ??1SEventSet@CPythonEventManager@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1SEventSet@CPythonEventManager@@UAE@XZ PROC		; CPythonEventManager::SEventSet::~SEventSet, COMDAT
; _this$ = ecx

; 144  : 			virtual ~SEventSet() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1SEventSet@CPythonEventManager@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7SEventSet@CPythonEventManager@@6B@
  00030	8d 4f 60	 lea	 ecx, DWORD PTR [edi+96]
  00033	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0003a	e8 00 00 00 00	 call	 ??1Group@script@@QAE@XZ	; script::Group::~Group
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0003f	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]

; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();
; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 768  : 		}
; 769  : 
; 770  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 771  : 		{	// free head node using current allocator
; 772  : 		this->_Getal().destroy(
; 773  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 774  : 		this->_Getal().destroy(
; 775  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 776  : 		this->_Getal().deallocate(_Pnode, 1);
; 777  : 		}
; 778  : 
; 779  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 780  : 		_Nodeptr _Prev)
; 781  : 		{	// allocate a node and set links
; 782  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 783  : 
; 784  : 		if (_Next == _Nodeptr())
; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;
; 787  : 			_Prev = _Pnode;
; 788  : 			}
; 789  : 		_TRY_BEGIN
; 790  : 		this->_Getal().construct(
; 791  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 792  : 		this->_Getal().construct(
; 793  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 794  : 		_CATCH_ALL
; 795  : 		this->_Getal().deallocate(_Pnode, 1);
; 796  : 		_RERAISE;
; 797  : 		_CATCH_END
; 798  : 
; 799  : 		return (_Pnode);
; 800  : 		}
; 801  : 
; 802  : 	_Alty _Getal() const
; 803  : 		{	// get reference to allocator
; 804  : 		return (_Alty());
; 805  : 		}
; 806  : 	};
; 807  : 
; 808  : 		// TEMPLATE CLASS _List_buy
; 809  : template<class _Ty,
; 810  : 	class _Alloc>
; 811  : 	class _List_buy
; 812  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 813  : 			_List_base_types<_Ty, _Alloc> >
; 814  : 	{	// base class for list to hold buynode/freenode functions
; 815  : public:
; 816  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 817  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 818  : 	typedef typename _Mybase::_Alty _Alty;
; 819  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 820  : 
; 821  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 822  : 		: _Mybase(_Al)
; 823  : 		{	// construct from allocator
; 824  : 		}
; 825  : 
; 826  : 	template<class... _Valty>
; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 831  : 
; 832  : 		_TRY_BEGIN
; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);
; 836  : 		_CATCH_ALL
; 837  : 		this->_Getal().deallocate(_Pnode, 1);
; 838  : 		_RERAISE;
; 839  : 		_CATCH_END
; 840  : 
; 841  : 		return (_Pnode);
; 842  : 		}
; 843  : 
; 844  : 
; 845  : 	void _Freenode(_Nodeptr _Pnode)
; 846  : 		{	// give node back
; 847  : 		this->_Getal().destroy(
; 848  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Myval(_Pnode)));
; 853  : 		this->_Getal().deallocate(_Pnode, 1);
; 854  : 		}
; 855  : 	};
; 856  : 
; 857  : 		// TEMPLATE CLASS list
; 858  : template<class _Ty,
; 859  : 	class _Alloc = allocator<_Ty> >
; 860  : 	class list
; 861  : 		: public _List_buy<_Ty, _Alloc>
; 862  : 	{	// bidirectional linked list
; 863  : public:
; 864  : 	typedef list<_Ty, _Alloc> _Myt;
; 865  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 866  : 	typedef typename _Mybase::_Node _Node;
; 867  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 868  : 	typedef typename _Mybase::_Alty _Alty;
; 869  : 
; 870  : 	typedef _Alloc allocator_type;
; 871  : 	typedef typename _Mybase::size_type size_type;
; 872  : 	typedef typename _Mybase::difference_type difference_type;
; 873  : 	typedef typename _Mybase::pointer pointer;
; 874  : 	typedef typename _Mybase::const_pointer const_pointer;
; 875  : 	typedef typename _Mybase::reference reference;
; 876  : 	typedef typename _Mybase::const_reference const_reference;
; 877  : 	typedef typename _Mybase::value_type value_type;
; 878  : 
; 879  : 	typedef typename _Mybase::const_iterator const_iterator;
; 880  : 	typedef typename _Mybase::iterator iterator;
; 881  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 882  : 		_Unchecked_const_iterator;
; 883  : 	typedef typename _Mybase::_Unchecked_iterator
; 884  : 		_Unchecked_iterator;
; 885  : 
; 886  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 887  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 888  : 
; 889  : 	list()
; 890  : 		: _Mybase()
; 891  : 		{	// construct empty list
; 892  : 		}
; 893  : 
; 894  : 	explicit list(const _Alloc& _Al)
; 895  : 		: _Mybase(_Al)
; 896  : 		{	// construct empty list, allocator
; 897  : 		}
; 898  : 
; 899  : 	explicit list(size_type _Count)
; 900  : 		: _Mybase()
; 901  : 		{	// construct list from _Count * _Ty()
; 902  : 		resize(_Count);
; 903  : 		}
; 904  : 
; 905  : 	list(size_type _Count, const _Ty& _Val)
; 906  : 		: _Mybase()
; 907  : 		{	// construct list from _Count * _Val
; 908  : 		_Construct_n(_Count, _Val);
; 909  : 		}
; 910  : 
; 911  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 912  : 		: _Mybase(_Al)
; 913  : 		{	// construct list from _Count * _Val, allocator
; 914  : 		_Construct_n(_Count, _Val);
; 915  : 		}
; 916  : 
; 917  : 	list(const _Myt& _Right)
; 918  : 
; 919  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 920  : 
; 921  : 
; 922  : 		{	// construct list by copying _Right
; 923  : 		_TRY_BEGIN
; 924  : 		insert(begin(), _Right.begin(), _Right.end());
; 925  : 		_CATCH_ALL
; 926  : 		_Tidy();
; 927  : 		_RERAISE;
; 928  : 		_CATCH_END
; 929  : 		}
; 930  : 
; 931  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 932  : 		: _Mybase(_Al)
; 933  : 		{	// construct list by copying _Right, allocator
; 934  : 		_TRY_BEGIN
; 935  : 		insert(begin(), _Right.begin(), _Right.end());
; 936  : 		_CATCH_ALL
; 937  : 		_Tidy();
; 938  : 		_RERAISE;
; 939  : 		_CATCH_END
; 940  : 		}
; 941  : 
; 942  : 	template<class _Iter,
; 943  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 944  : 			void>::type>
; 945  : 		list(_Iter _First, _Iter _Last)
; 946  : 		: _Mybase()
; 947  : 		{	// construct list from [_First, _Last)
; 948  : 		_Construct(_First, _Last);
; 949  : 		}
; 950  : 
; 951  : 	template<class _Iter,
; 952  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 953  : 			void>::type>
; 954  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct list, allocator from [_First, _Last)
; 957  : 		_Construct(_First, _Last);
; 958  : 		}
; 959  : 
; 960  : 	template<class _Iter>
; 961  : 		void _Construct(_Iter _First, _Iter _Last)
; 962  : 		{	// construct list from [_First, _Last), input iterators
; 963  : 		_TRY_BEGIN
; 964  : 		insert(begin(), _First, _Last);
; 965  : 		_CATCH_ALL
; 966  : 		_Tidy();
; 967  : 		_RERAISE;
; 968  : 		_CATCH_END
; 969  : 		}
; 970  : 
; 971  : 	void _Construct_n(size_type _Count,
; 972  : 		const _Ty& _Val)
; 973  : 		{	// construct from _Count * _Val
; 974  : 		_TRY_BEGIN
; 975  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 976  : 		_CATCH_ALL
; 977  : 		_Tidy();
; 978  : 		_RERAISE;
; 979  : 		_CATCH_END
; 980  : 		}
; 981  : 
; 982  : 	list(_Myt&& _Right)
; 983  : 		: _Mybase(_Right._Getal())
; 984  : 		{	// construct list by moving _Right
; 985  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 986  : 		}
; 987  : 
; 988  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 989  : 		: _Mybase(_Al)
; 990  : 		{	// construct list by moving _Right, allocator
; 991  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 992  : 		}
; 993  : 
; 994  : 	_Myt& operator=(_Myt&& _Right)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Change_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1013 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != this)
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);
; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;
; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
; 1066 : 		}
; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00042	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00044	89 00		 mov	 DWORD PTR [eax], eax

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00046	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]

; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  00049	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1499 : 		this->_Mysize = 0;

  0004c	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00053	3b 4f 4c	 cmp	 ecx, DWORD PTR [edi+76]
  00056	74 12		 je	 SHORT $LN10@SEventSet
$LL12@SEventSet:

; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);

  00058	8b 31		 mov	 esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00063	8b ce		 mov	 ecx, esi
  00065	3b 77 4c	 cmp	 esi, DWORD PTR [edi+76]
  00068	75 ee		 jne	 SHORT $LL12@SEventSet
$LN10@SEventSet:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0006a	ff 77 4c	 push	 DWORD PTR [edi+76]
  0006d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00072	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00075	83 7f 44 10	 cmp	 DWORD PTR [edi+68], 16	; 00000010H
  00079	72 0b		 jb	 SHORT $LN93@SEventSet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007b	ff 77 30	 push	 DWORD PTR [edi+48]
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
$LN93@SEventSet:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00086	c7 47 44 0f 00
	00 00		 mov	 DWORD PTR [edi+68], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0008d	c7 47 40 00 00
	00 00		 mov	 DWORD PTR [edi+64], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00094	c6 47 30 00	 mov	 BYTE PTR [edi+48], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.h

; 144  : 			virtual ~SEventSet() {}

  00098	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a2	59		 pop	 ecx
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1SEventSet@CPythonEventManager@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 30	 add	 ecx, 48			; 00000030H
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1SEventSet@CPythonEventManager@@UAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00011	e9 00 00 00 00	 jmp	 ??1?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::~list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >
__ehhandler$??1SEventSet@CPythonEventManager@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1SEventSet@CPythonEventManager@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1SEventSet@CPythonEventManager@@UAE@XZ ENDP		; CPythonEventManager::SEventSet::~SEventSet
; Function compile flags: /Ogtp
;	COMDAT ??_GSEventSet@CPythonEventManager@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GSEventSet@CPythonEventManager@@UAEPAXI@Z PROC	; CPythonEventManager::SEventSet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1SEventSet@CPythonEventManager@@UAE@XZ ; CPythonEventManager::SEventSet::~SEventSet
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GSEventSet@CPythonEventManager@@UAEPAXI@Z ENDP	; CPythonEventManager::SEventSet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z
_TEXT	SEGMENT
__N0$1$ = -24						; size = 4
_c_szName$1$ = -20					; size = 4
tv488 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z PROC ; GetArgumentString, COMDAT
; _c_szName$ = ecx
; _rArgumentList$ = edx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 45 ec	 mov	 DWORD PTR _c_szName$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0002d	8b 3a		 mov	 edi, DWORD PTR [edx]

; 44   : 		{	// construct with node pointer _Pnode

  0002f	8b 37		 mov	 esi, DWORD PTR [edi]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00031	3b f7		 cmp	 esi, edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 31   : 	for (script::TArgList::iterator itor = rArgumentList.begin(); itor != rArgumentList.end(); ++itor)

  00033	74 7d		 je	 SHORT $LN129@GetArgumen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00035	8a 10		 mov	 dl, BYTE PTR [eax]
  00037	88 55 f3	 mov	 BYTE PTR tv488[ebp], dl
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL23@GetArgumen:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 33   : 		const std::string & rName = (*itor).strName;

  00040	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00043	84 d2		 test	 dl, dl
  00045	75 04		 jne	 SHORT $LN51@GetArgumen
  00047	33 db		 xor	 ebx, ebx
  00049	eb 0e		 jmp	 SHORT $LN52@GetArgumen
$LN51@GetArgumen:
  0004b	8b d8		 mov	 ebx, eax
  0004d	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
$LL130@GetArgumen:
  00050	8a 03		 mov	 al, BYTE PTR [ebx]
  00052	43		 inc	 ebx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL130@GetArgumen
  00057	2b da		 sub	 ebx, edx
$LN52@GetArgumen:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00059	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));

  0005d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00060	89 55 e8	 mov	 DWORD PTR __N0$1$[ebp], edx

; 520  : 			: this->_Bx._Buf);

  00063	72 02		 jb	 SHORT $LN67@GetArgumen
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00065	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN67@GetArgumen:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2182 : 			_N0 < _Count ? _N0 : _Count);

  00067	3b d3		 cmp	 edx, ebx
  00069	8b c3		 mov	 eax, ebx
  0006b	0f 42 c2	 cmovb	 eax, edx
  0006e	50		 push	 eax
  0006f	ff 75 ec	 push	 DWORD PTR _c_szName$1$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);

  0007b	85 c0		 test	 eax, eax
  0007d	75 10		 jne	 SHORT $LN128@GetArgumen
  0007f	8b 4d e8	 mov	 ecx, DWORD PTR __N0$1$[ebp]
  00082	3b cb		 cmp	 ecx, ebx
  00084	72 09		 jb	 SHORT $LN128@GetArgumen
  00086	3b cb		 cmp	 ecx, ebx
  00088	0f 95 c0	 setne	 al
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 35   : 		if (0 == rName.compare(c_szName))

  0008b	85 c0		 test	 eax, eax
  0008d	74 0e		 je	 SHORT $LN124@GetArgumen
$LN128@GetArgumen:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  0008f	8b 36		 mov	 esi, DWORD PTR [esi]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00091	3b f7		 cmp	 esi, edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 31   : 	for (script::TArgList::iterator itor = rArgumentList.begin(); itor != rArgumentList.end(); ++itor)

  00093	74 1d		 je	 SHORT $LN129@GetArgumen
  00095	8b 45 ec	 mov	 eax, DWORD PTR _c_szName$1$[ebp]
  00098	8a 55 f3	 mov	 dl, BYTE PTR tv488[ebp]
  0009b	eb a3		 jmp	 SHORT $LL23@GetArgumen
$LN124@GetArgumen:

; 36   : 			return (*itor).strValue;

  0009d	8d 46 20	 lea	 eax, DWORD PTR [esi+32]

; 41   : }

  000a0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000aa	59		 pop	 ecx
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
$LN129@GetArgumen:

; 39   : 	static std::string strEmptyValue = "";

  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4IA
  000b7	a8 01		 test	 al, 1
  000b9	75 48		 jne	 SHORT $LN1@GetArgumen
  000bb	83 c8 01	 or	 eax, 1
  000be	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4IA, eax
  000c3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  000ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A
  000cf	6a 00		 push	 0
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  000d6	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A+20, 15 ; 0000000fH

; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000e0	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000ea	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  000f1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 39   : 	static std::string strEmptyValue = "";

  000f6	68 00 00 00 00	 push	 OFFSET ??__FstrEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z@YAXXZ ; `GetArgumentString'::`6'::`dynamic atexit destructor for 'strEmptyValue''
  000fb	e8 00 00 00 00	 call	 _atexit
  00100	83 c4 04	 add	 esp, 4
$LN1@GetArgumen:

; 40   : 	return strEmptyValue;

  00103	b8 00 00 00 00	 mov	 eax, OFFSET ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A

; 41   : }

  00108	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00112	59		 pop	 ecx
  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4IA, eax
  0000d	c3		 ret	 0
__ehhandler$?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z ENDP ; GetArgumentString
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??__FstrEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__FstrEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z@YAXXZ PROC ; `GetArgumentString'::`6'::`dynamic atexit destructor for 'strEmptyValue'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00004	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A+20, 16 ; 00000010H
  0000b	72 2e		 jb	 SHORT $LN23@dynamic
  0000d	56		 push	 esi

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

  0000e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A

; 684  : 		return (_Alty());

  00014	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

  0001c	68 00 00 00 00	 push	 OFFSET ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A
  00021	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00024	e8 00 00 00 00	 call	 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 684  : 		return (_Alty());

  00029	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00037	83 c4 04	 add	 esp, 4
  0003a	5e		 pop	 esi
$LN23@dynamic:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003b	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A+20, 15 ; 0000000fH

; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00045	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0004f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?strEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@3@@Z@4V23@A, 0
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??__FstrEmptyValue@?5??GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z@YAXXZ ENDP ; `GetArgumentString'::`6'::`dynamic atexit destructor for 'strEmptyValue''
text$yd	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z
_TEXT	SEGMENT
?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z PROC ; GetArgument, COMDAT
; _c_szName$ = ecx
; _rArgumentList$ = edx

; 45   : 	return GetArgumentString(c_szName, rArgumentList).c_str();

  00000	e8 00 00 00 00	 call	 ?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z ; GetArgumentString
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00005	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00009	72 02		 jb	 SHORT $LN8@GetArgumen
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 45   : 	return GetArgumentString(c_szName, rArgumentList).c_str();

  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN8@GetArgumen:

; 46   : }

  0000d	c3		 ret	 0
?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ENDP ; GetArgument
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?GetCameraSettingFromArgList@@YAXAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@PAUSCameraSetting@IAbstractApplication@@@Z
_TEXT	SEGMENT
_iViewDir$1$ = -28					; size = 4
_iUpDir$1$ = -24					; size = 4
_iz$1$ = -20						; size = 4
_iy$1$ = -16						; size = 4
_ix$1$ = -12						; size = 4
_pCameraSetting$1$ = -8					; size = 4
_rArgList$1$ = -4					; size = 4
?GetCameraSettingFromArgList@@YAXAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@PAUSCameraSetting@IAbstractApplication@@@Z PROC ; GetCameraSettingFromArgList, COMDAT
; _rArgList$ = ecx
; _pCameraSetting$ = edx

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	89 55 f8	 mov	 DWORD PTR _pCameraSetting$1$[ebp], edx
  0000d	57		 push	 edi

; 50   : 	int ix = atoi(GetArgument("x", rArgList));

  0000e	8b d6		 mov	 edx, esi
  00010	89 75 fc	 mov	 DWORD PTR _rArgList$1$[ebp], esi
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01FJMABOPO@x?$AA@
  00018	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 __atoi64

; 51   : 	int iy = atoi(GetArgument("y", rArgList));

  00023	8b d6		 mov	 edx, esi
  00025	89 45 f4	 mov	 DWORD PTR _ix$1$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01EANLCPLP@y?$AA@
  0002d	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 __atoi64

; 52   : 	int iz = atoi(GetArgument("z", rArgList));

  00038	8b d6		 mov	 edx, esi
  0003a	89 45 f0	 mov	 DWORD PTR _iy$1$[ebp], eax
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01GLPGHMHM@z?$AA@
  00042	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 __atoi64

; 53   : 	int iUpDir = atoi(GetArgument("up", rArgList));

  0004d	8b d6		 mov	 edx, esi
  0004f	89 45 ec	 mov	 DWORD PTR _iz$1$[ebp], eax
  00052	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02HNLLPFKA@up?$AA@
  00057	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 __atoi64

; 54   : 	int iViewDir = atoi(GetArgument("view", rArgList));

  00062	8b d6		 mov	 edx, esi
  00064	89 45 e8	 mov	 DWORD PTR _iUpDir$1$[ebp], eax
  00067	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_04CHADEDPO@view?$AA@
  0006c	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 __atoi64

; 55   : 	int iCrossDir = atoi(GetArgument("cross", rArgList));

  00077	8b d6		 mov	 edx, esi
  00079	89 45 e4	 mov	 DWORD PTR _iViewDir$1$[ebp], eax
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05HCKPILGO@cross?$AA@
  00081	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 __atoi64

; 56   : 	int iDistance = atoi(GetArgument("distance", rArgList));

  0008c	8b d6		 mov	 edx, esi
  0008e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_08LHFODBFO@distance?$AA@
  00093	8b d8		 mov	 ebx, eax
  00095	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 __atoi64

; 57   : 	int iRot = atoi(GetArgument("rot", rArgList));

  000a0	8b d6		 mov	 edx, esi
  000a2	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03BHFFHIBL@rot?$AA@
  000a7	8b f8		 mov	 edi, eax
  000a9	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 __atoi64

; 58   : 	int iPitch = atoi(GetArgument("pitch", rArgList));

  000b4	8b 55 fc	 mov	 edx, DWORD PTR _rArgList$1$[ebp]
  000b7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05NCNFOFLM@pitch?$AA@
  000bc	8b f0		 mov	 esi, eax
  000be	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 __atoi64

; 59   : 
; 60   : 	ZeroMemory(pCameraSetting, sizeof(IAbstractApplication::SCameraSetting));

  000c9	8b 4d f8	 mov	 ecx, DWORD PTR _pCameraSetting$1$[ebp]
  000cc	0f 57 c0	 xorps	 xmm0, xmm0
  000cf	83 c4 24	 add	 esp, 36			; 00000024H
  000d2	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  000d6	f3 0f 7f 41 10	 movdqu	 XMMWORD PTR [ecx+16], xmm0
  000db	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  000e2	66 0f 6e 45 f4	 movd	 xmm0, DWORD PTR _ix$1$[ebp]

; 61   : 	pCameraSetting->v3CenterPosition.x = float(ix);

  000e7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000ea	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  000ee	66 0f 6e 45 f0	 movd	 xmm0, DWORD PTR _iy$1$[ebp]

; 62   : 	pCameraSetting->v3CenterPosition.y = float(iy);

  000f3	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000f6	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  000fb	66 0f 6e 45 ec	 movd	 xmm0, DWORD PTR _iz$1$[ebp]

; 63   : 	pCameraSetting->v3CenterPosition.z = float(iz);

  00100	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00103	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00108	66 0f 6e 45 e8	 movd	 xmm0, DWORD PTR _iUpDir$1$[ebp]

; 64   : 	pCameraSetting->kCmrPos.m_fUpDir = float(iUpDir);

  0010d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00110	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  00115	66 0f 6e 45 e4	 movd	 xmm0, DWORD PTR _iViewDir$1$[ebp]

; 65   : 	pCameraSetting->kCmrPos.m_fViewDir = float(iViewDir);

  0011a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0011d	f3 0f 11 41 10	 movss	 DWORD PTR [ecx+16], xmm0
  00122	66 0f 6e c3	 movd	 xmm0, ebx

; 66   : 	pCameraSetting->kCmrPos.m_fCrossDir = float(iCrossDir);

  00126	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00129	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0
  0012e	66 0f 6e c7	 movd	 xmm0, edi

; 67   : 	pCameraSetting->fZoom = float(iDistance);

  00132	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00135	5f		 pop	 edi
  00136	f3 0f 11 41 20	 movss	 DWORD PTR [ecx+32], xmm0
  0013b	66 0f 6e c6	 movd	 xmm0, esi

; 68   : 	pCameraSetting->fRotation = float(iRot);

  0013f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00142	5e		 pop	 esi
  00143	5b		 pop	 ebx
  00144	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0
  00149	66 0f 6e c0	 movd	 xmm0, eax

; 69   : 	pCameraSetting->fPitch = float(iPitch);

  0014d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00150	f3 0f 11 41 1c	 movss	 DWORD PTR [ecx+28], xmm0

; 70   : }

  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
?GetCameraSettingFromArgList@@YAXAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@PAUSCameraSetting@IAbstractApplication@@@Z ENDP ; GetCameraSettingFromArgList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?__InitEventSet@CPythonEventManager@@IAEXAAUSEventSet@1@@Z
_TEXT	SEGMENT
_rEventSet$ = 8						; size = 4
?__InitEventSet@CPythonEventManager@@IAEXAAUSEventSet@1@@Z PROC ; CPythonEventManager::__InitEventSet, COMDAT
; _this$ = ecx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 74   : 	rEventSet.ix = 0;

  0000d	8b 7d 08	 mov	 edi, DWORD PTR _rEventSet$[ebp]
  00010	8b d9		 mov	 ebx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00012	6a 00		 push	 0
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 83   : 	rEventSet.strCurrentLine = "";

  00019	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  0001c	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00023	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  0002a	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00031	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00038	c6 47 14 00	 mov	 BYTE PTR [edi+20], 0
  0003c	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  00043	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], 0
  0004a	f3 0f 7f 47 20	 movdqu	 XMMWORD PTR [edi+32], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0004f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 85   : 	rEventSet.pCurrentTextLine = NULL;

  00054	c7 47 48 00 00
	00 00		 mov	 DWORD PTR [edi+72], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0005b	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]

; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();
; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 768  : 		}
; 769  : 
; 770  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 771  : 		{	// free head node using current allocator
; 772  : 		this->_Getal().destroy(
; 773  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 774  : 		this->_Getal().destroy(
; 775  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 776  : 		this->_Getal().deallocate(_Pnode, 1);
; 777  : 		}
; 778  : 
; 779  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 780  : 		_Nodeptr _Prev)
; 781  : 		{	// allocate a node and set links
; 782  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 783  : 
; 784  : 		if (_Next == _Nodeptr())
; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;
; 787  : 			_Prev = _Pnode;
; 788  : 			}
; 789  : 		_TRY_BEGIN
; 790  : 		this->_Getal().construct(
; 791  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 792  : 		this->_Getal().construct(
; 793  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 794  : 		_CATCH_ALL
; 795  : 		this->_Getal().deallocate(_Pnode, 1);
; 796  : 		_RERAISE;
; 797  : 		_CATCH_END
; 798  : 
; 799  : 		return (_Pnode);
; 800  : 		}
; 801  : 
; 802  : 	_Alty _Getal() const
; 803  : 		{	// get reference to allocator
; 804  : 		return (_Alty());
; 805  : 		}
; 806  : 	};
; 807  : 
; 808  : 		// TEMPLATE CLASS _List_buy
; 809  : template<class _Ty,
; 810  : 	class _Alloc>
; 811  : 	class _List_buy
; 812  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 813  : 			_List_base_types<_Ty, _Alloc> >
; 814  : 	{	// base class for list to hold buynode/freenode functions
; 815  : public:
; 816  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 817  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 818  : 	typedef typename _Mybase::_Alty _Alty;
; 819  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 820  : 
; 821  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 822  : 		: _Mybase(_Al)
; 823  : 		{	// construct from allocator
; 824  : 		}
; 825  : 
; 826  : 	template<class... _Valty>
; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 831  : 
; 832  : 		_TRY_BEGIN
; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);
; 836  : 		_CATCH_ALL
; 837  : 		this->_Getal().deallocate(_Pnode, 1);
; 838  : 		_RERAISE;
; 839  : 		_CATCH_END
; 840  : 
; 841  : 		return (_Pnode);
; 842  : 		}
; 843  : 
; 844  : 
; 845  : 	void _Freenode(_Nodeptr _Pnode)
; 846  : 		{	// give node back
; 847  : 		this->_Getal().destroy(
; 848  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Myval(_Pnode)));
; 853  : 		this->_Getal().deallocate(_Pnode, 1);
; 854  : 		}
; 855  : 	};
; 856  : 
; 857  : 		// TEMPLATE CLASS list
; 858  : template<class _Ty,
; 859  : 	class _Alloc = allocator<_Ty> >
; 860  : 	class list
; 861  : 		: public _List_buy<_Ty, _Alloc>
; 862  : 	{	// bidirectional linked list
; 863  : public:
; 864  : 	typedef list<_Ty, _Alloc> _Myt;
; 865  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 866  : 	typedef typename _Mybase::_Node _Node;
; 867  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 868  : 	typedef typename _Mybase::_Alty _Alty;
; 869  : 
; 870  : 	typedef _Alloc allocator_type;
; 871  : 	typedef typename _Mybase::size_type size_type;
; 872  : 	typedef typename _Mybase::difference_type difference_type;
; 873  : 	typedef typename _Mybase::pointer pointer;
; 874  : 	typedef typename _Mybase::const_pointer const_pointer;
; 875  : 	typedef typename _Mybase::reference reference;
; 876  : 	typedef typename _Mybase::const_reference const_reference;
; 877  : 	typedef typename _Mybase::value_type value_type;
; 878  : 
; 879  : 	typedef typename _Mybase::const_iterator const_iterator;
; 880  : 	typedef typename _Mybase::iterator iterator;
; 881  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 882  : 		_Unchecked_const_iterator;
; 883  : 	typedef typename _Mybase::_Unchecked_iterator
; 884  : 		_Unchecked_iterator;
; 885  : 
; 886  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 887  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 888  : 
; 889  : 	list()
; 890  : 		: _Mybase()
; 891  : 		{	// construct empty list
; 892  : 		}
; 893  : 
; 894  : 	explicit list(const _Alloc& _Al)
; 895  : 		: _Mybase(_Al)
; 896  : 		{	// construct empty list, allocator
; 897  : 		}
; 898  : 
; 899  : 	explicit list(size_type _Count)
; 900  : 		: _Mybase()
; 901  : 		{	// construct list from _Count * _Ty()
; 902  : 		resize(_Count);
; 903  : 		}
; 904  : 
; 905  : 	list(size_type _Count, const _Ty& _Val)
; 906  : 		: _Mybase()
; 907  : 		{	// construct list from _Count * _Val
; 908  : 		_Construct_n(_Count, _Val);
; 909  : 		}
; 910  : 
; 911  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 912  : 		: _Mybase(_Al)
; 913  : 		{	// construct list from _Count * _Val, allocator
; 914  : 		_Construct_n(_Count, _Val);
; 915  : 		}
; 916  : 
; 917  : 	list(const _Myt& _Right)
; 918  : 
; 919  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 920  : 
; 921  : 
; 922  : 		{	// construct list by copying _Right
; 923  : 		_TRY_BEGIN
; 924  : 		insert(begin(), _Right.begin(), _Right.end());
; 925  : 		_CATCH_ALL
; 926  : 		_Tidy();
; 927  : 		_RERAISE;
; 928  : 		_CATCH_END
; 929  : 		}
; 930  : 
; 931  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 932  : 		: _Mybase(_Al)
; 933  : 		{	// construct list by copying _Right, allocator
; 934  : 		_TRY_BEGIN
; 935  : 		insert(begin(), _Right.begin(), _Right.end());
; 936  : 		_CATCH_ALL
; 937  : 		_Tidy();
; 938  : 		_RERAISE;
; 939  : 		_CATCH_END
; 940  : 		}
; 941  : 
; 942  : 	template<class _Iter,
; 943  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 944  : 			void>::type>
; 945  : 		list(_Iter _First, _Iter _Last)
; 946  : 		: _Mybase()
; 947  : 		{	// construct list from [_First, _Last)
; 948  : 		_Construct(_First, _Last);
; 949  : 		}
; 950  : 
; 951  : 	template<class _Iter,
; 952  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 953  : 			void>::type>
; 954  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct list, allocator from [_First, _Last)
; 957  : 		_Construct(_First, _Last);
; 958  : 		}
; 959  : 
; 960  : 	template<class _Iter>
; 961  : 		void _Construct(_Iter _First, _Iter _Last)
; 962  : 		{	// construct list from [_First, _Last), input iterators
; 963  : 		_TRY_BEGIN
; 964  : 		insert(begin(), _First, _Last);
; 965  : 		_CATCH_ALL
; 966  : 		_Tidy();
; 967  : 		_RERAISE;
; 968  : 		_CATCH_END
; 969  : 		}
; 970  : 
; 971  : 	void _Construct_n(size_type _Count,
; 972  : 		const _Ty& _Val)
; 973  : 		{	// construct from _Count * _Val
; 974  : 		_TRY_BEGIN
; 975  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 976  : 		_CATCH_ALL
; 977  : 		_Tidy();
; 978  : 		_RERAISE;
; 979  : 		_CATCH_END
; 980  : 		}
; 981  : 
; 982  : 	list(_Myt&& _Right)
; 983  : 		: _Mybase(_Right._Getal())
; 984  : 		{	// construct list by moving _Right
; 985  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 986  : 		}
; 987  : 
; 988  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 989  : 		: _Mybase(_Al)
; 990  : 		{	// construct list by moving _Right, allocator
; 991  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 992  : 		}
; 993  : 
; 994  : 	_Myt& operator=(_Myt&& _Right)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Change_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1013 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != this)
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);
; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;
; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
; 1066 : 		}
; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00060	89 00		 mov	 DWORD PTR [eax], eax

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00062	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]

; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  00065	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1499 : 		this->_Mysize = 0;

  00068	c7 47 50 00 00
	00 00		 mov	 DWORD PTR [edi+80], 0

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  0006f	3b 4f 4c	 cmp	 ecx, DWORD PTR [edi+76]
  00072	74 12		 je	 SHORT $LN13@InitEventS
$LL15@InitEventS:

; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);

  00074	8b 31		 mov	 esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007c	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  0007f	8b ce		 mov	 ecx, esi
  00081	3b 77 4c	 cmp	 esi, DWORD PTR [edi+76]
  00084	75 ee		 jne	 SHORT $LL15@InitEventS
$LN13@InitEventS:
  00086	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 104  : 	__InsertLine(rEventSet);

  0008d	8b cb		 mov	 ecx, ebx
  0008f	6a 00		 push	 0
  00091	6a 00		 push	 0
  00093	57		 push	 edi
  00094	c7 47 54 00 00
	00 00		 mov	 DWORD PTR [edi+84], 0
  0009b	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0
  000a2	c7 47 5c 00 00
	00 00		 mov	 DWORD PTR [edi+92], 0
  000a9	f3 0f 7f 87 b0
	00 00 00	 movdqu	 XMMWORD PTR [edi+176], xmm0
  000b1	c7 87 c0 00 00
	00 0a 00 00 00	 mov	 DWORD PTR [edi+192], 10	; 0000000aH
  000bb	c7 87 c4 00 00
	00 1e 00 00 00	 mov	 DWORD PTR [edi+196], 30	; 0000001eH
  000c5	c7 87 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+164], 0
  000cf	c7 87 a8 00 00
	00 05 00 00 00	 mov	 DWORD PTR [edi+168], 5
  000d9	c7 87 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+172], 0
  000e3	66 c7 87 cc 00
	00 00 00 00	 mov	 WORD PTR [edi+204], 0
  000ec	e8 00 00 00 00	 call	 ?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z ; CPythonEventManager::__InsertLine

; 105  : }

  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	5d		 pop	 ebp
  000f5	c2 04 00	 ret	 4
?__InitEventSet@CPythonEventManager@@IAEXAAUSEventSet@1@@Z ENDP ; CPythonEventManager::__InitEventSet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z
_TEXT	SEGMENT
_pMap$ = -380						; size = 4
_strEventString$ = -376					; size = 24
_File$ = -352						; size = 324
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFileName$ = 8					; size = 4
?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z PROC	; CPythonEventManager::RegisterEventSet, COMDAT
; _this$ = ecx

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	89 84 24 68 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+380], eax
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c4		 xor	 eax, esp
  00032	50		 push	 eax
  00033	8d 84 24 80 01
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+396]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	8b d9		 mov	 ebx, ecx
  00042	8b 7d 08	 mov	 edi, DWORD PTR _c_szFileName$[ebp]

; 109  : 	CMappedFile File;

  00045	8d 4c 24 2c	 lea	 ecx, DWORD PTR _File$[esp+396]
  00049	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 110  : 	LPCVOID pMap;
; 111  : 
; 112  : 	if (!CEterPackManager::Instance().Get(File, c_szFileName, &pMap))

  0004e	8d 44 24 10	 lea	 eax, DWORD PTR _pMap$[esp+396]
  00052	c7 84 24 88 01
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+404], 0
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00063	50		 push	 eax
  00064	57		 push	 edi
  00065	8d 44 24 34	 lea	 eax, DWORD PTR _File$[esp+404]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get
  0006f	84 c0		 test	 al, al
  00071	75 08		 jne	 SHORT $LN3@RegisterEv
  00073	83 cf ff	 or	 edi, -1
  00076	e9 cb 00 00 00	 jmp	 $LN107@RegisterEv
$LN3@RegisterEv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0007b	c7 44 24 28 0f
	00 00 00	 mov	 DWORD PTR _strEventString$[esp+416], 15 ; 0000000fH

; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00083	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _strEventString$[esp+412], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0008b	c6 44 24 14 00	 mov	 BYTE PTR _strEventString$[esp+396], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 116  : 	strEventString.resize(File.Size()+1);

  00090	8d 4c 24 2c	 lea	 ecx, DWORD PTR _File$[esp+396]
  00094	c6 84 24 88 01
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+404], 1
  0009c	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  000a1	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1770 : 		if (_Newsize <= this->_Mysize)

  000a4	8b 44 24 24	 mov	 eax, DWORD PTR _strEventString$[esp+412]
  000a8	3b c8		 cmp	 ecx, eax
  000aa	77 18		 ja	 SHORT $LN54@RegisterEv

; 513  : 			: this->_Bx._Buf);

  000ac	83 7c 24 28 10	 cmp	 DWORD PTR _strEventString$[esp+416], 16 ; 00000010H
  000b1	8d 44 24 14	 lea	 eax, DWORD PTR _strEventString$[esp+396]

; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000b5	89 4c 24 24	 mov	 DWORD PTR _strEventString$[esp+412], ecx

; 513  : 			: this->_Bx._Buf);

  000b9	0f 43 44 24 14	 cmovae	 eax, DWORD PTR _strEventString$[esp+396]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000be	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1772 : 		else

  000c2	eb 0e		 jmp	 SHORT $LN53@RegisterEv
$LN54@RegisterEv:

; 1773 : 			append(_Newsize - this->_Mysize, _Ch);

  000c4	2b c8		 sub	 ecx, eax
  000c6	6a 00		 push	 0
  000c8	51		 push	 ecx
  000c9	8d 4c 24 1c	 lea	 ecx, DWORD PTR _strEventString$[esp+404]
  000cd	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN53@RegisterEv:

; 513  : 			: this->_Bx._Buf);

  000d2	83 7c 24 28 10	 cmp	 DWORD PTR _strEventString$[esp+416], 16 ; 00000010H
  000d7	8d 74 24 14	 lea	 esi, DWORD PTR _strEventString$[esp+396]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 118  : 	File.Read(&strEventString[0], File.Size());

  000db	8d 4c 24 2c	 lea	 ecx, DWORD PTR _File$[esp+396]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

  000df	0f 43 74 24 14	 cmovae	 esi, DWORD PTR _strEventString$[esp+396]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 118  : 	File.Read(&strEventString[0], File.Size());

  000e4	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  000e9	50		 push	 eax
  000ea	56		 push	 esi
  000eb	8d 4c 24 34	 lea	 ecx, DWORD PTR _File$[esp+404]
  000ef	e8 00 00 00 00	 call	 ?Read@CMappedFile@@QAEHPAXH@Z ; CMappedFile::Read

; 119  : 
; 120  : 	TEventSet * pEventSet = m_EventSetPool.Alloc();

  000f4	8d 4b 1c	 lea	 ecx, DWORD PTR [ebx+28]
  000f7	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ ; CDynamicPool<CPythonEventManager::SEventSet>::Alloc
  000fc	8b f0		 mov	 esi, eax

; 121  : 	if (!pEventSet)

  000fe	85 f6		 test	 esi, esi
  00100	74 19		 je	 SHORT $LN9@RegisterEv

; 122  : 		return -1;
; 123  : 
; 124  : 	if (!pEventSet->ScriptGroup.Create(strEventString))

  00102	8d 44 24 14	 lea	 eax, DWORD PTR _strEventString$[esp+396]
  00106	50		 push	 eax
  00107	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  0010a	e8 00 00 00 00	 call	 ?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; script::Group::Create
  0010f	84 c0		 test	 al, al
  00111	75 6f		 jne	 SHORT $LN1@RegisterEv

; 125  : 	{
; 126  : 		__ClearEventSetp(pEventSet);

  00113	56		 push	 esi
  00114	8b cb		 mov	 ecx, ebx
  00116	e8 00 00 00 00	 call	 ?__ClearEventSetp@CPythonEventManager@@QAEXPAUSEventSet@1@@Z ; CPythonEventManager::__ClearEventSetp
$LN9@RegisterEv:
  0011b	83 cf ff	 or	 edi, -1
$LN10@RegisterEv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0011e	83 7c 24 28 10	 cmp	 DWORD PTR _strEventString$[esp+416], 16 ; 00000010H
  00123	72 0c		 jb	 SHORT $LN97@RegisterEv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00125	ff 74 24 14	 push	 DWORD PTR _strEventString$[esp+396]
  00129	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0012e	83 c4 04	 add	 esp, 4
$LN97@RegisterEv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00131	c7 44 24 28 0f
	00 00 00	 mov	 DWORD PTR _strEventString$[esp+416], 15 ; 0000000fH

; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00139	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _strEventString$[esp+412], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00141	c6 44 24 14 00	 mov	 BYTE PTR _strEventString$[esp+396], 0
$LN107@RegisterEv:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 139  : 	return iEmptySlotIndex;

  00146	8d 4c 24 2c	 lea	 ecx, DWORD PTR _File$[esp+396]
  0014a	c7 84 24 88 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+404], -1
  00155	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0015a	8b c7		 mov	 eax, edi

; 140  : }

  0015c	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+396]
  00163	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016a	59		 pop	 ecx
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+380]
  00175	33 cc		 xor	 ecx, esp
  00177	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	c2 04 00	 ret	 4
$LN1@RegisterEv:

; 127  : 		return -1;
; 128  : 	}
; 129  : 
; 130  : 	strncpy(pEventSet->szFileName, c_szFileName, 32);

  00182	6a 20		 push	 32			; 00000020H
  00184	8d 86 80 00 00
	00		 lea	 eax, DWORD PTR [esi+128]
  0018a	57		 push	 edi
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 _strncpy
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH

; 131  : 
; 132  : 	pEventSet->pCurrentTextLine = NULL;

  00194	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0

; 133  : 	pEventSet->poEventHandler = NULL;
; 134  : 
; 135  : 	__InitEventSet(*pEventSet);

  0019b	8b cb		 mov	 ecx, ebx
  0019d	c7 86 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+208], 0
  001a7	56		 push	 esi
  001a8	e8 00 00 00 00	 call	 ?__InitEventSet@CPythonEventManager@@IAEXAAUSEventSet@1@@Z ; CPythonEventManager::__InitEventSet

; 136  : 
; 137  : 	int iEmptySlotIndex = GetEmptyEventSetSlot();

  001ad	8b cb		 mov	 ecx, ebx
  001af	e8 00 00 00 00	 call	 ?GetEmptyEventSetSlot@CPythonEventManager@@IAEKXZ ; CPythonEventManager::GetEmptyEventSetSlot
  001b4	8b f8		 mov	 edi, eax

; 138  : 	m_EventSetVector[iEmptySlotIndex] = pEventSet;

  001b6	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  001b9	89 34 b8	 mov	 DWORD PTR [eax+edi*4], esi

; 139  : 	return iEmptySlotIndex;

  001bc	e9 5d ff ff ff	 jmp	 $LN10@RegisterEv
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z$0:
  00000	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR _File$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z$1:
  0000b	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _strEventString$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 82 84 fe ff
	ff		 lea	 eax, DWORD PTR [edx-380]
  00020	8b 8a 80 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-384]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00030	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z ENDP	; CPythonEventManager::RegisterEventSet
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\parser.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_pEventPosition$ = -84					; size = 4
_strScript$GSCopy$1$ = -80				; size = 4
_iEventType$ = -80					; size = 4
_strFileName$2 = -76					; size = 24
_ScriptCommand$ = -52					; size = 32
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_strScript$ = 8						; size = 4
?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CPythonEventManager::RegisterEventSetFromString, COMDAT
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR _strScript$[ebp]

; 144  : 	TEventSet* pEventSet = m_EventSetPool.Alloc();

  00030	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  00033	89 45 b0	 mov	 DWORD PTR _strScript$GSCopy$1$[ebp], eax
  00036	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ ; CDynamicPool<CPythonEventManager::SEventSet>::Alloc
  0003b	8b f0		 mov	 esi, eax

; 145  : 	if (!pEventSet)

  0003d	85 f6		 test	 esi, esi
  0003f	74 1e		 je	 SHORT $LN148@RegisterEv

; 146  : 		return -1;
; 147  : 
; 148  : 	// SCRIPT_PARSING_FAILURE_CLEAR_BUG    __ClearEventSetp   
; 149  : 	pEventSet->pCurrentTextLine = NULL;
; 150  : 	// END_OF_SCRIPT_PARSING_FAILURE_CLEAR_BUG
; 151  : 	
; 152  : 	if (!pEventSet->ScriptGroup.Create(strScript))

  00041	ff 75 b0	 push	 DWORD PTR _strScript$GSCopy$1$[ebp]
  00044	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  00047	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  0004e	e8 00 00 00 00	 call	 ?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; script::Group::Create

; 153  : 	{
; 154  : 		__ClearEventSetp(pEventSet);

  00053	8b cf		 mov	 ecx, edi
  00055	56		 push	 esi
  00056	84 c0		 test	 al, al
  00058	75 0d		 jne	 SHORT $LN4@RegisterEv
  0005a	e8 00 00 00 00	 call	 ?__ClearEventSetp@CPythonEventManager@@QAEXPAUSEventSet@1@@Z ; CPythonEventManager::__ClearEventSetp
$LN148@RegisterEv:

; 155  : 		return -1;

  0005f	83 c8 ff	 or	 eax, -1
  00062	e9 fe 00 00 00	 jmp	 $LN6@RegisterEv
$LN4@RegisterEv:

; 156  : 	}
; 157  : 
; 158  : 	pEventSet->szFileName[0] = 0;

  00067	c6 86 80 00 00
	00 00		 mov	 BYTE PTR [esi+128], 0

; 159  : 	pEventSet->poEventHandler = NULL;

  0006e	c7 86 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+208], 0

; 160  : 	__InitEventSet(*pEventSet);

  00078	e8 00 00 00 00	 call	 ?__InitEventSet@CPythonEventManager@@IAEXAAUSEventSet@1@@Z ; CPythonEventManager::__InitEventSet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0007d	c7 45 e0 0f 00
	00 00		 mov	 DWORD PTR _ScriptCommand$[ebp+20], 15 ; 0000000fH

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00084	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _ScriptCommand$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0008b	c6 45 cc 00	 mov	 BYTE PTR _ScriptCommand$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0008f	6a 00		 push	 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\parser.h

; 37   : 		SCmd()

  00091	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00098	8d 4d e4	 lea	 ecx, DWORD PTR _ScriptCommand$[ebp+24]
  0009b	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  0009d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _ScriptCommand$[ebp+24], 0

; 528  : 		this->_Mysize = 0;

  000a4	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ScriptCommand$[ebp+28], 0

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  000ab	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buynode0

; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  000b0	89 45 e4	 mov	 DWORD PTR _ScriptCommand$[ebp+24], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 166  : 	if (pEventSet->ScriptGroup.ReadCmd(ScriptCommand))

  000b3	8d 45 cc	 lea	 eax, DWORD PTR _ScriptCommand$[ebp]
  000b6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000bd	50		 push	 eax
  000be	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  000c1	e8 00 00 00 00	 call	 ?ReadCmd@Group@script@@QAE_NAAUSCmd@2@@Z ; script::Group::ReadCmd
  000c6	84 c0		 test	 al, al
  000c8	74 66		 je	 SHORT $LN1@RegisterEv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000ca	83 7d e0 10	 cmp	 DWORD PTR _ScriptCommand$[ebp+20], 16 ; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 168  : 		if (GetScriptEventIndex(ScriptCommand.name.c_str(), &pEventPosition, &iEventType))

  000ce	8d 4d b0	 lea	 ecx, DWORD PTR _iEventType$[ebp]
  000d1	51		 push	 ecx
  000d2	8d 4d ac	 lea	 ecx, DWORD PTR _pEventPosition$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000d5	8d 45 cc	 lea	 eax, DWORD PTR _ScriptCommand$[ebp]
  000d8	0f 43 45 cc	 cmovae	 eax, DWORD PTR _ScriptCommand$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 168  : 		if (GetScriptEventIndex(ScriptCommand.name.c_str(), &pEventPosition, &iEventType))

  000dc	51		 push	 ecx
  000dd	50		 push	 eax
  000de	8b cf		 mov	 ecx, edi
  000e0	e8 00 00 00 00	 call	 ?GetScriptEventIndex@CPythonEventManager@@IAE_NPBDPAH1@Z ; CPythonEventManager::GetScriptEventIndex
  000e5	84 c0		 test	 al, al
  000e7	74 47		 je	 SHORT $LN1@RegisterEv

; 169  : 		{
; 170  : 			if (EVENT_TYPE_RUN_CINEMA == iEventType)

  000e9	83 7d b0 1f	 cmp	 DWORD PTR _iEventType$[ebp], 31 ; 0000001fH
  000ed	75 41		 jne	 SHORT $LN1@RegisterEv

; 171  : 			{
; 172  : 				std::string strFileName = GetArgument("value", ScriptCommand.argList);

  000ef	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  000f2	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05MFEJDJP@value?$AA@
  000f7	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  000fc	50		 push	 eax
  000fd	8d 4d b4	 lea	 ecx, DWORD PTR _strFileName$2[ebp]
  00100	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 173  : 
; 174  : 				__ClearEventSetp(pEventSet);

  00105	56		 push	 esi
  00106	8b cf		 mov	 ecx, edi
  00108	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0010c	e8 00 00 00 00	 call	 ?__ClearEventSetp@CPythonEventManager@@QAEXPAUSEventSet@1@@Z ; CPythonEventManager::__ClearEventSetp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00111	83 7d c8 10	 cmp	 DWORD PTR _strFileName$2[ebp+20], 16 ; 00000010H
  00115	8d 45 b4	 lea	 eax, DWORD PTR _strFileName$2[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 176  : 				return RegisterEventSet(strFileName.c_str());

  00118	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0011a	0f 43 45 b4	 cmovae	 eax, DWORD PTR _strFileName$2[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 176  : 				return RegisterEventSet(strFileName.c_str());

  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?RegisterEventSet@CPythonEventManager@@QAEHPBD@Z ; CPythonEventManager::RegisterEventSet
  00124	8d 4d b4	 lea	 ecx, DWORD PTR _strFileName$2[ebp]
  00127	8b d8		 mov	 ebx, eax
  00129	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0012e	eb 0f		 jmp	 SHORT $LN10@RegisterEv
$LN1@RegisterEv:

; 177  : 			}
; 178  : 		}
; 179  : 	}
; 180  : 
; 181  : 	int iEmptySlotIndex = GetEmptyEventSetSlot();

  00130	8b cf		 mov	 ecx, edi
  00132	e8 00 00 00 00	 call	 ?GetEmptyEventSetSlot@CPythonEventManager@@IAEKXZ ; CPythonEventManager::GetEmptyEventSetSlot
  00137	8b d8		 mov	 ebx, eax

; 182  : 	m_EventSetVector[iEmptySlotIndex] = pEventSet;

  00139	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0013c	89 34 98	 mov	 DWORD PTR [eax+ebx*4], esi
$LN10@RegisterEv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1883 : 		clear();

  0013f	8d 4d e4	 lea	 ecx, DWORD PTR _ScriptCommand$[ebp+24]
  00142	e8 00 00 00 00	 call	 ?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00147	ff 75 e4	 push	 DWORD PTR _ScriptCommand$[ebp+24]
  0014a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00152	83 7d e0 10	 cmp	 DWORD PTR _ScriptCommand$[ebp+20], 16 ; 00000010H
  00156	72 0b		 jb	 SHORT $LN135@RegisterEv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00158	ff 75 cc	 push	 DWORD PTR _ScriptCommand$[ebp]
  0015b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00160	83 c4 04	 add	 esp, 4
$LN135@RegisterEv:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 183  : 	return iEmptySlotIndex;

  00163	8b c3		 mov	 eax, ebx
$LN6@RegisterEv:

; 184  : }

  00165	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00168	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016f	59		 pop	 ecx
  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	5b		 pop	 ebx
  00173	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00176	33 cd		 xor	 ecx, ebp
  00178	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _ScriptCommand$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR _ScriptCommand$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1SCmd@script@@QAE@XZ
__unwindfunclet$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  00010	8d 4d b4	 lea	 ecx, DWORD PTR _strFileName$2[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterEventSetFromString@CPythonEventManager@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CPythonEventManager::RegisterEventSetFromString
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??1SCmd@script@@QAE@XZ
_TEXT	SEGMENT
??1SCmd@script@@QAE@XZ PROC				; script::SCmd::~SCmd, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1883 : 		clear();

  00004	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00007	e8 00 00 00 00	 call	 ?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000c	ff 77 18	 push	 DWORD PTR [edi+24]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00017	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  0001b	72 0a		 jb	 SHORT $LN51@SCmd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0001d	ff 37		 push	 DWORD PTR [edi]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	83 c4 04	 add	 esp, 4
$LN51@SCmd:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00027	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0002e	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00035	c6 07 00	 mov	 BYTE PTR [edi], 0
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	c3		 ret	 0
??1SCmd@script@@QAE@XZ ENDP				; script::SCmd::~SCmd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?ClearEventSeti@CPythonEventManager@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?ClearEventSeti@CPythonEventManager@@QAEXH@Z PROC	; CPythonEventManager::ClearEventSeti, COMDAT
; _this$ = ecx

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 188  : 	if (!CheckEventSetIndex(iIndex))

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  00010	84 c0		 test	 al, al
  00012	74 15		 je	 SHORT $LN2@ClearEvent

; 189  : 		return;
; 190  : 
; 191  : 	__ClearEventSetp(m_EventSetVector[iIndex]);

  00014	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00017	ff 34 b8	 push	 DWORD PTR [eax+edi*4]
  0001a	e8 00 00 00 00	 call	 ?__ClearEventSetp@CPythonEventManager@@QAEXPAUSEventSet@1@@Z ; CPythonEventManager::__ClearEventSetp

; 192  : 	m_EventSetVector[iIndex] = NULL;

  0001f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00022	c7 04 b8 00 00
	00 00		 mov	 DWORD PTR [eax+edi*4], 0
$LN2@ClearEvent:
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi

; 193  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?ClearEventSeti@CPythonEventManager@@QAEXH@Z ENDP	; CPythonEventManager::ClearEventSeti
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?__ClearEventSetp@CPythonEventManager@@QAEXPAUSEventSet@1@@Z
_TEXT	SEGMENT
__Idx$1$ = -20						; size = 4
_pkData$1$ = -20					; size = 4
_this$1$ = -16						; size = 4
_pkData$ = -12						; size = 4
_pkData$ = -8						; size = 4
_pkData$ = -4						; size = 4
_pEventSet$ = 8						; size = 4
?__ClearEventSetp@CPythonEventManager@@QAEXPAUSEventSet@1@@Z PROC ; CPythonEventManager::__ClearEventSetp, COMDAT
; _this$ = ecx

; 196  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx

; 197  : 	if (!pEventSet)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _pEventSet$[ebp]
  0000a	89 4d f0	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000d	85 db		 test	 ebx, ebx
  0000f	0f 84 a2 01 00
	00		 je	 $LN204@ClearEvent
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00015	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
  00018	56		 push	 esi
  00019	57		 push	 edi

; 44   : 		{	// construct with node pointer _Pnode

  0001a	8b 30		 mov	 esi, DWORD PTR [eax]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  0001c	3b f0		 cmp	 esi, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 200  : 	for (TScriptTextLineList::iterator itor = pEventSet->ScriptTextLineList.begin(); itor != pEventSet->ScriptTextLineList.end(); ++itor)

  0001e	74 7b		 je	 SHORT $LN2@ClearEvent
  00020	8d 79 50	 lea	 edi, DWORD PTR [ecx+80]
$LL22@ClearEvent:

; 201  : 	{
; 202  : 		TTextLine & rkLine = *itor;
; 203  : 		rkLine.pInstance->Destroy();

  00023	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00026	e8 00 00 00 00	 call	 ?Destroy@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Destroy

; 204  : 		m_ScriptTextLinePool.Free(rkLine.pInstance);

  0002b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0002e	8d 55 fc	 lea	 edx, DWORD PTR _pkData$[ebp]
  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 204  : 		m_ScriptTextLinePool.Free(rkLine.pInstance);

  00034	89 4d ec	 mov	 DWORD PTR _pkData$1$[ebp], ecx
  00037	89 4d fc	 mov	 DWORD PTR _pkData$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0003a	3b d0		 cmp	 edx, eax
  0003c	73 38		 jae	 SHORT $LN51@ClearEvent
  0003e	8b 17		 mov	 edx, DWORD PTR [edi]
  00040	8d 5d fc	 lea	 ebx, DWORD PTR _pkData$[ebp]
  00043	3b d3		 cmp	 edx, ebx
  00045	8b 5d 08	 mov	 ebx, DWORD PTR _pEventSet$[ebp]
  00048	77 2c		 ja	 SHORT $LN51@ClearEvent

; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  0004a	8d 4d fc	 lea	 ecx, DWORD PTR _pkData$[ebp]
  0004d	2b ca		 sub	 ecx, edx
  0004f	c1 f9 02	 sar	 ecx, 2
  00052	89 4d ec	 mov	 DWORD PTR __Idx$1$[ebp], ecx

; 1247 : 			if (this->_Mylast == this->_Myend)

  00055	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00058	75 0c		 jne	 SHORT $LN50@ClearEvent

; 1248 : 				_Reserve(1);

  0005a	6a 01		 push	 1
  0005c	8b cf		 mov	 ecx, edi
  0005e	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reserve
  00063	8b 4d ec	 mov	 ecx, DWORD PTR __Idx$1$[ebp]
$LN50@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00066	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00069	85 d2		 test	 edx, edx
  0006b	74 23		 je	 SHORT $LN96@ClearEvent
  0006d	8b 07		 mov	 eax, DWORD PTR [edi]
  0006f	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00072	89 02		 mov	 DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

  00074	eb 1a		 jmp	 SHORT $LN96@ClearEvent
$LN51@ClearEvent:

; 1256 : 			if (this->_Mylast == this->_Myend)

  00076	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00079	75 0c		 jne	 SHORT $LN48@ClearEvent

; 1257 : 				_Reserve(1);

  0007b	6a 01		 push	 1
  0007d	8b cf		 mov	 ecx, edi
  0007f	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reserve
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _pkData$1$[ebp]
$LN48@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00087	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008a	85 c0		 test	 eax, eax
  0008c	74 02		 je	 SHORT $LN96@ClearEvent
  0008e	89 08		 mov	 DWORD PTR [eax], ecx
$LN96@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00090	83 47 04 04	 add	 DWORD PTR [edi+4], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00094	8b 36		 mov	 esi, DWORD PTR [esi]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00096	3b 73 4c	 cmp	 esi, DWORD PTR [ebx+76]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 200  : 	for (TScriptTextLineList::iterator itor = pEventSet->ScriptTextLineList.begin(); itor != pEventSet->ScriptTextLineList.end(); ++itor)

  00099	75 88		 jne	 SHORT $LL22@ClearEvent
$LN2@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0009b	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]

; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();
; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 768  : 		}
; 769  : 
; 770  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 771  : 		{	// free head node using current allocator
; 772  : 		this->_Getal().destroy(
; 773  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 774  : 		this->_Getal().destroy(
; 775  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 776  : 		this->_Getal().deallocate(_Pnode, 1);
; 777  : 		}
; 778  : 
; 779  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 780  : 		_Nodeptr _Prev)
; 781  : 		{	// allocate a node and set links
; 782  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 783  : 
; 784  : 		if (_Next == _Nodeptr())
; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;
; 787  : 			_Prev = _Pnode;
; 788  : 			}
; 789  : 		_TRY_BEGIN
; 790  : 		this->_Getal().construct(
; 791  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 792  : 		this->_Getal().construct(
; 793  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 794  : 		_CATCH_ALL
; 795  : 		this->_Getal().deallocate(_Pnode, 1);
; 796  : 		_RERAISE;
; 797  : 		_CATCH_END
; 798  : 
; 799  : 		return (_Pnode);
; 800  : 		}
; 801  : 
; 802  : 	_Alty _Getal() const
; 803  : 		{	// get reference to allocator
; 804  : 		return (_Alty());
; 805  : 		}
; 806  : 	};
; 807  : 
; 808  : 		// TEMPLATE CLASS _List_buy
; 809  : template<class _Ty,
; 810  : 	class _Alloc>
; 811  : 	class _List_buy
; 812  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 813  : 			_List_base_types<_Ty, _Alloc> >
; 814  : 	{	// base class for list to hold buynode/freenode functions
; 815  : public:
; 816  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 817  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 818  : 	typedef typename _Mybase::_Alty _Alty;
; 819  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 820  : 
; 821  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 822  : 		: _Mybase(_Al)
; 823  : 		{	// construct from allocator
; 824  : 		}
; 825  : 
; 826  : 	template<class... _Valty>
; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 831  : 
; 832  : 		_TRY_BEGIN
; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);
; 836  : 		_CATCH_ALL
; 837  : 		this->_Getal().deallocate(_Pnode, 1);
; 838  : 		_RERAISE;
; 839  : 		_CATCH_END
; 840  : 
; 841  : 		return (_Pnode);
; 842  : 		}
; 843  : 
; 844  : 
; 845  : 	void _Freenode(_Nodeptr _Pnode)
; 846  : 		{	// give node back
; 847  : 		this->_Getal().destroy(
; 848  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Myval(_Pnode)));
; 853  : 		this->_Getal().deallocate(_Pnode, 1);
; 854  : 		}
; 855  : 	};
; 856  : 
; 857  : 		// TEMPLATE CLASS list
; 858  : template<class _Ty,
; 859  : 	class _Alloc = allocator<_Ty> >
; 860  : 	class list
; 861  : 		: public _List_buy<_Ty, _Alloc>
; 862  : 	{	// bidirectional linked list
; 863  : public:
; 864  : 	typedef list<_Ty, _Alloc> _Myt;
; 865  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 866  : 	typedef typename _Mybase::_Node _Node;
; 867  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 868  : 	typedef typename _Mybase::_Alty _Alty;
; 869  : 
; 870  : 	typedef _Alloc allocator_type;
; 871  : 	typedef typename _Mybase::size_type size_type;
; 872  : 	typedef typename _Mybase::difference_type difference_type;
; 873  : 	typedef typename _Mybase::pointer pointer;
; 874  : 	typedef typename _Mybase::const_pointer const_pointer;
; 875  : 	typedef typename _Mybase::reference reference;
; 876  : 	typedef typename _Mybase::const_reference const_reference;
; 877  : 	typedef typename _Mybase::value_type value_type;
; 878  : 
; 879  : 	typedef typename _Mybase::const_iterator const_iterator;
; 880  : 	typedef typename _Mybase::iterator iterator;
; 881  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 882  : 		_Unchecked_const_iterator;
; 883  : 	typedef typename _Mybase::_Unchecked_iterator
; 884  : 		_Unchecked_iterator;
; 885  : 
; 886  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 887  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 888  : 
; 889  : 	list()
; 890  : 		: _Mybase()
; 891  : 		{	// construct empty list
; 892  : 		}
; 893  : 
; 894  : 	explicit list(const _Alloc& _Al)
; 895  : 		: _Mybase(_Al)
; 896  : 		{	// construct empty list, allocator
; 897  : 		}
; 898  : 
; 899  : 	explicit list(size_type _Count)
; 900  : 		: _Mybase()
; 901  : 		{	// construct list from _Count * _Ty()
; 902  : 		resize(_Count);
; 903  : 		}
; 904  : 
; 905  : 	list(size_type _Count, const _Ty& _Val)
; 906  : 		: _Mybase()
; 907  : 		{	// construct list from _Count * _Val
; 908  : 		_Construct_n(_Count, _Val);
; 909  : 		}
; 910  : 
; 911  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 912  : 		: _Mybase(_Al)
; 913  : 		{	// construct list from _Count * _Val, allocator
; 914  : 		_Construct_n(_Count, _Val);
; 915  : 		}
; 916  : 
; 917  : 	list(const _Myt& _Right)
; 918  : 
; 919  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 920  : 
; 921  : 
; 922  : 		{	// construct list by copying _Right
; 923  : 		_TRY_BEGIN
; 924  : 		insert(begin(), _Right.begin(), _Right.end());
; 925  : 		_CATCH_ALL
; 926  : 		_Tidy();
; 927  : 		_RERAISE;
; 928  : 		_CATCH_END
; 929  : 		}
; 930  : 
; 931  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 932  : 		: _Mybase(_Al)
; 933  : 		{	// construct list by copying _Right, allocator
; 934  : 		_TRY_BEGIN
; 935  : 		insert(begin(), _Right.begin(), _Right.end());
; 936  : 		_CATCH_ALL
; 937  : 		_Tidy();
; 938  : 		_RERAISE;
; 939  : 		_CATCH_END
; 940  : 		}
; 941  : 
; 942  : 	template<class _Iter,
; 943  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 944  : 			void>::type>
; 945  : 		list(_Iter _First, _Iter _Last)
; 946  : 		: _Mybase()
; 947  : 		{	// construct list from [_First, _Last)
; 948  : 		_Construct(_First, _Last);
; 949  : 		}
; 950  : 
; 951  : 	template<class _Iter,
; 952  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 953  : 			void>::type>
; 954  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct list, allocator from [_First, _Last)
; 957  : 		_Construct(_First, _Last);
; 958  : 		}
; 959  : 
; 960  : 	template<class _Iter>
; 961  : 		void _Construct(_Iter _First, _Iter _Last)
; 962  : 		{	// construct list from [_First, _Last), input iterators
; 963  : 		_TRY_BEGIN
; 964  : 		insert(begin(), _First, _Last);
; 965  : 		_CATCH_ALL
; 966  : 		_Tidy();
; 967  : 		_RERAISE;
; 968  : 		_CATCH_END
; 969  : 		}
; 970  : 
; 971  : 	void _Construct_n(size_type _Count,
; 972  : 		const _Ty& _Val)
; 973  : 		{	// construct from _Count * _Val
; 974  : 		_TRY_BEGIN
; 975  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 976  : 		_CATCH_ALL
; 977  : 		_Tidy();
; 978  : 		_RERAISE;
; 979  : 		_CATCH_END
; 980  : 		}
; 981  : 
; 982  : 	list(_Myt&& _Right)
; 983  : 		: _Mybase(_Right._Getal())
; 984  : 		{	// construct list by moving _Right
; 985  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 986  : 		}
; 987  : 
; 988  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 989  : 		: _Mybase(_Al)
; 990  : 		{	// construct list by moving _Right, allocator
; 991  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 992  : 		}
; 993  : 
; 994  : 	_Myt& operator=(_Myt&& _Right)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Change_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1013 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != this)
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);
; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;
; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
; 1066 : 		}
; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  000a0	89 00		 mov	 DWORD PTR [eax], eax

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  000a2	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]

; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  000a5	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1499 : 		this->_Mysize = 0;

  000a8	c7 43 50 00 00
	00 00		 mov	 DWORD PTR [ebx+80], 0

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  000af	3b 4b 4c	 cmp	 ecx, DWORD PTR [ebx+76]
  000b2	74 12		 je	 SHORT $LN100@ClearEvent
$LL102@ClearEvent:

; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);

  000b4	8b 31		 mov	 esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000b6	51		 push	 ecx
  000b7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000bc	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  000bf	8b ce		 mov	 ecx, esi
  000c1	3b 73 4c	 cmp	 esi, DWORD PTR [ebx+76]
  000c4	75 ee		 jne	 SHORT $LL102@ClearEvent
$LN100@ClearEvent:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 208  : 	if (pEventSet->pCurrentTextLine)

  000c6	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  000c9	85 c9		 test	 ecx, ecx
  000cb	74 65		 je	 SHORT $LN142@ClearEvent

; 209  : 	{
; 210  : 		pEventSet->pCurrentTextLine->Destroy();

  000cd	e8 00 00 00 00	 call	 ?Destroy@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Destroy
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  000d2	8b 75 f0	 mov	 esi, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  000d5	8d 4d f8	 lea	 ecx, DWORD PTR _pkData$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 211  : 		m_ScriptTextLinePool.Free(pEventSet->pCurrentTextLine);

  000d8	8b 7b 48	 mov	 edi, DWORD PTR [ebx+72]
  000db	89 7d f8	 mov	 DWORD PTR _pkData$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  000de	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  000e1	3b c8		 cmp	 ecx, eax
  000e3	73 31		 jae	 SHORT $LN144@ClearEvent
  000e5	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  000e8	8d 55 f8	 lea	 edx, DWORD PTR _pkData$[ebp]
  000eb	3b ca		 cmp	 ecx, edx
  000ed	77 27		 ja	 SHORT $LN144@ClearEvent

; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  000ef	8b fa		 mov	 edi, edx
  000f1	2b f9		 sub	 edi, ecx
  000f3	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  000f6	3b 46 58	 cmp	 eax, DWORD PTR [esi+88]
  000f9	75 0a		 jne	 SHORT $LN143@ClearEvent

; 1248 : 				_Reserve(1);

  000fb	6a 01		 push	 1
  000fd	8d 4e 50	 lea	 ecx, DWORD PTR [esi+80]
  00100	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reserve
$LN143@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00105	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  00108	85 c9		 test	 ecx, ecx
  0010a	74 22		 je	 SHORT $LN189@ClearEvent
  0010c	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  0010f	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00112	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

  00114	eb 18		 jmp	 SHORT $LN189@ClearEvent
$LN144@ClearEvent:

; 1256 : 			if (this->_Mylast == this->_Myend)

  00116	3b 46 58	 cmp	 eax, DWORD PTR [esi+88]
  00119	75 0a		 jne	 SHORT $LN141@ClearEvent

; 1257 : 				_Reserve(1);

  0011b	6a 01		 push	 1
  0011d	8d 4e 50	 lea	 ecx, DWORD PTR [esi+80]
  00120	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reserve
$LN141@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00125	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00128	85 c0		 test	 eax, eax
  0012a	74 02		 je	 SHORT $LN189@ClearEvent
  0012c	89 38		 mov	 DWORD PTR [eax], edi
$LN189@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  0012e	83 46 54 04	 add	 DWORD PTR [esi+84], 4
$LN142@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00132	6a 00		 push	 0
  00134	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 214  : 	pEventSet->strCurrentLine = "";

  00139	8d 4b 30	 lea	 ecx, DWORD PTR [ebx+48]
  0013c	c7 43 48 00 00
	00 00		 mov	 DWORD PTR [ebx+72], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00143	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  00148	8b 75 f0	 mov	 esi, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0014b	8d 4d f4	 lea	 ecx, DWORD PTR _pkData$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 215  : 	pEventSet->iCurrentLetter = 0;

  0014e	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0

; 216  : 
; 217  : 	m_EventSetPool.Free(pEventSet);

  00155	89 5d f4	 mov	 DWORD PTR _pkData$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00158	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0015b	3b c8		 cmp	 ecx, eax
  0015d	73 3b		 jae	 SHORT $LN206@ClearEvent
  0015f	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00162	8d 55 f4	 lea	 edx, DWORD PTR _pkData$[ebp]
  00165	3b ca		 cmp	 ecx, edx
  00167	77 31		 ja	 SHORT $LN206@ClearEvent

; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00169	8b fa		 mov	 edi, edx
  0016b	2b f9		 sub	 edi, ecx
  0016d	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  00170	3b 46 34	 cmp	 eax, DWORD PTR [esi+52]
  00173	75 09		 jne	 SHORT $LN205@ClearEvent

; 1248 : 				_Reserve(1);

  00175	51		 push	 ecx
  00176	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00179	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reserve
$LN205@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0017e	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00181	85 c9		 test	 ecx, ecx
  00183	74 2c		 je	 SHORT $LN251@ClearEvent
  00185	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00188	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  0018b	5f		 pop	 edi
  0018c	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  0018e	83 46 30 04	 add	 DWORD PTR [esi+48], 4
  00192	5e		 pop	 esi
  00193	5b		 pop	 ebx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 218  : }

  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c2 04 00	 ret	 4
$LN206@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1256 : 			if (this->_Mylast == this->_Myend)

  0019a	3b 46 34	 cmp	 eax, DWORD PTR [esi+52]
  0019d	75 09		 jne	 SHORT $LN203@ClearEvent

; 1257 : 				_Reserve(1);

  0019f	51		 push	 ecx
  001a0	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  001a3	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reserve
$LN203@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  001a8	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001ab	85 c0		 test	 eax, eax
  001ad	74 02		 je	 SHORT $LN251@ClearEvent
  001af	89 18		 mov	 DWORD PTR [eax], ebx
$LN251@ClearEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  001b1	83 46 30 04	 add	 DWORD PTR [esi+48], 4
  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
$LN204@ClearEvent:
  001b7	5b		 pop	 ebx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 218  : }

  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c2 04 00	 ret	 4
?__ClearEventSetp@CPythonEventManager@@QAEXPAUSEventSet@1@@Z ENDP ; CPythonEventManager::__ClearEventSetp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?GetEmptyEventSetSlot@CPythonEventManager@@IAEKXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?GetEmptyEventSetSlot@CPythonEventManager@@IAEKXZ PROC	; CPythonEventManager::GetEmptyEventSetSlot, COMDAT
; _this$ = ecx

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00004	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 222  : 	for (DWORD i = 0; i < m_EventSetVector.size(); ++i)

  00007	33 d2		 xor	 edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00009	2b 41 0c	 sub	 eax, DWORD PTR [ecx+12]
  0000c	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 222  : 	for (DWORD i = 0; i < m_EventSetVector.size(); ++i)

  0000d	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00010	c1 f8 02	 sar	 eax, 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 222  : 	for (DWORD i = 0; i < m_EventSetVector.size(); ++i)

  00013	85 c0		 test	 eax, eax
  00015	74 1e		 je	 SHORT $LN2@GetEmptyEv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00017	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL4@GetEmptyEv:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 224  : 		if (NULL == m_EventSetVector[i])

  00020	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00023	74 60		 je	 SHORT $LN72@GetEmptyEv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00025	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 222  : 	for (DWORD i = 0; i < m_EventSetVector.size(); ++i)

  00028	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00029	2b 06		 sub	 eax, DWORD PTR [esi]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 222  : 	for (DWORD i = 0; i < m_EventSetVector.size(); ++i)

  0002b	83 c1 04	 add	 ecx, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0002e	c1 f8 02	 sar	 eax, 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 222  : 	for (DWORD i = 0; i < m_EventSetVector.size(); ++i)

  00031	3b d0		 cmp	 edx, eax
  00033	72 eb		 jb	 SHORT $LL4@GetEmptyEv
$LN2@GetEmptyEv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00035	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00038	8d 4d fc	 lea	 ecx, DWORD PTR $T1[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 230  : 	m_EventSetVector.push_back(NULL);

  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00042	3b c8		 cmp	 ecx, eax
  00044	73 46		 jae	 SHORT $LN14@GetEmptyEv
  00046	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00048	8d 55 fc	 lea	 edx, DWORD PTR $T1[ebp]
  0004b	3b ca		 cmp	 ecx, edx
  0004d	77 3d		 ja	 SHORT $LN14@GetEmptyEv
  0004f	57		 push	 edi

; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00050	8b fa		 mov	 edi, edx
  00052	2b f9		 sub	 edi, ecx
  00054	c1 ff 02	 sar	 edi, 2

; 869  : 			if (this->_Mylast == this->_Myend)

  00057	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0005a	75 08		 jne	 SHORT $LN13@GetEmptyEv

; 870  : 				_Reserve(1);

  0005c	51		 push	 ecx
  0005d	8b ce		 mov	 ecx, esi
  0005f	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reserve
$LN13@GetEmptyEv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00064	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00067	85 c9		 test	 ecx, ecx
  00069	74 07		 je	 SHORT $LN41@GetEmptyEv
  0006b	8b 06		 mov	 eax, DWORD PTR [esi]
  0006d	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00070	89 01		 mov	 DWORD PTR [ecx], eax
$LN41@GetEmptyEv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 883  : 			++this->_Mylast;

  00072	83 46 04 04	 add	 DWORD PTR [esi+4], 4

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00076	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00079	2b 06		 sub	 eax, DWORD PTR [esi]
  0007b	5f		 pop	 edi
  0007c	c1 f8 02	 sar	 eax, 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 231  : 	return m_EventSetVector.size()-1;

  0007f	48		 dec	 eax
  00080	5e		 pop	 esi

; 232  : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN72@GetEmptyEv:

; 225  : 		{
; 226  : 			return i;

  00085	8b c2		 mov	 eax, edx
  00087	5e		 pop	 esi

; 232  : }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
$LN14@GetEmptyEv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 878  : 			if (this->_Mylast == this->_Myend)

  0008c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0008f	75 08		 jne	 SHORT $LN11@GetEmptyEv

; 879  : 				_Reserve(1);

  00091	51		 push	 ecx
  00092	8b ce		 mov	 ecx, esi
  00094	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reserve
$LN11@GetEmptyEv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00099	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009c	85 c0		 test	 eax, eax
  0009e	74 06		 je	 SHORT $LN63@GetEmptyEv
  000a0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN63@GetEmptyEv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 883  : 			++this->_Mylast;

  000a6	83 46 04 04	 add	 DWORD PTR [esi+4], 4

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000aa	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ad	2b 06		 sub	 eax, DWORD PTR [esi]
  000af	c1 f8 02	 sar	 eax, 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 231  : 	return m_EventSetVector.size()-1;

  000b2	48		 dec	 eax
  000b3	5e		 pop	 esi

; 232  : }

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
?GetEmptyEventSetSlot@CPythonEventManager@@IAEKXZ ENDP	; CPythonEventManager::GetEmptyEventSetSlot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?SetRestrictedCount@CPythonEventManager@@QAEXHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iCount$ = 12						; size = 4
?SetRestrictedCount@CPythonEventManager@@QAEXHH@Z PROC	; CPythonEventManager::SetRestrictedCount, COMDAT
; _this$ = ecx

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 236  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	74 26		 je	 SHORT $LN3@SetRestric

; 237  : 		return;
; 238  : 
; 239  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00011	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00014	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]

; 240  : 	if (!pEventSet)

  00017	85 c9		 test	 ecx, ecx
  00019	75 13		 jne	 SHORT $LN1@SetRestric

; 241  : 	{
; 242  : 		TraceError("CPythonEventManager::SetRestrictedCount m_EventSetVector[iIndex=%d]==NULL", iIndex);

  0001b	56		 push	 esi
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@NAEFMGNK@CPythonEventManager?3?3SetRestrict@
  00021	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00026	83 c4 08	 add	 esp, 8
  00029	5e		 pop	 esi

; 247  : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
$LN1@SetRestric:

; 243  : 		return;
; 244  : 	}
; 245  : 
; 246  : 	pEventSet->iRestrictedCharacterCount = iCount;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _iCount$[ebp]
  00031	89 81 c4 00 00
	00		 mov	 DWORD PTR [ecx+196], eax
$LN3@SetRestric:
  00037	5e		 pop	 esi

; 247  : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?SetRestrictedCount@CPythonEventManager@@QAEXHH@Z ENDP	; CPythonEventManager::SetRestrictedCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?SetEventHandler@CPythonEventManager@@QAEXHPAU_object@@@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_poEventHandler$ = 12					; size = 4
?SetEventHandler@CPythonEventManager@@QAEXHPAU_object@@@Z PROC ; CPythonEventManager::SetEventHandler, COMDAT
; _this$ = ecx

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 251  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	74 26		 je	 SHORT $LN3@SetEventHa

; 252  : 		return;
; 253  : 
; 254  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00011	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00014	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]

; 255  : 	if (!pEventSet)

  00017	85 c9		 test	 ecx, ecx
  00019	75 13		 jne	 SHORT $LN1@SetEventHa

; 256  : 	{
; 257  : 		TraceError("CPythonEventManager::SetEventHandler m_EventSetVector[iIndex=%d]==NULL", iIndex);

  0001b	56		 push	 esi
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@KHNDFHCA@CPythonEventManager?3?3SetEventHan@
  00021	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00026	83 c4 08	 add	 esp, 8
  00029	5e		 pop	 esi

; 262  : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
$LN1@SetEventHa:

; 258  : 		return;
; 259  : 	}
; 260  : 
; 261  : 	pEventSet->poEventHandler = poEventHandler;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _poEventHandler$[ebp]
  00031	89 81 d0 00 00
	00		 mov	 DWORD PTR [ecx+208], eax
$LN3@SetEventHa:
  00037	5e		 pop	 esi

; 262  : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?SetEventHandler@CPythonEventManager@@QAEXHPAU_object@@@Z ENDP ; CPythonEventManager::SetEventHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?GetEventSetLocalYPosition@CPythonEventManager@@QAEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetEventSetLocalYPosition@CPythonEventManager@@QAEHH@Z PROC ; CPythonEventManager::GetEventSetLocalYPosition, COMDAT
; _this$ = ecx

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 266  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	75 07		 jne	 SHORT $LN2@GetEventSe
$LN7@GetEventSe:

; 267  : 		return 0;

  00011	33 c0		 xor	 eax, eax
  00013	5e		 pop	 esi

; 274  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@GetEventSe:

; 268  : 
; 269  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00018	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001b	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 270  : 	if (!pEventSet)

  0001e	85 c0		 test	 eax, eax
  00020	74 ef		 je	 SHORT $LN7@GetEventSe

; 271  : 		return 0;
; 272  : 
; 273  : 	return pEventSet->iyLocal;

  00022	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00025	5e		 pop	 esi

; 274  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?GetEventSetLocalYPosition@CPythonEventManager@@QAEHH@Z ENDP ; CPythonEventManager::GetEventSetLocalYPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?AddEventSetLocalYPosition@CPythonEventManager@@QAEXHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iAddValue$ = 12					; size = 4
?AddEventSetLocalYPosition@CPythonEventManager@@QAEXHH@Z PROC ; CPythonEventManager::AddEventSetLocalYPosition, COMDAT
; _this$ = ecx

; 277  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 278  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	74 10		 je	 SHORT $LN3@AddEventSe

; 279  : 		return;
; 280  : 
; 281  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00011	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00014	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]

; 282  : 	if (!pEventSet)

  00017	85 c9		 test	 ecx, ecx
  00019	74 06		 je	 SHORT $LN3@AddEventSe

; 283  : 		return;
; 284  : 
; 285  : 	pEventSet->iyLocal += iAddValue;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _iAddValue$[ebp]
  0001e	01 41 10	 add	 DWORD PTR [ecx+16], eax
$LN3@AddEventSe:
  00021	5e		 pop	 esi

; 286  : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?AddEventSetLocalYPosition@CPythonEventManager@@QAEXHH@Z ENDP ; CPythonEventManager::AddEventSetLocalYPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?InsertText@CPythonEventManager@@QAEXHPBDH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_c_szText$ = 12						; size = 4
_iX_pos$ = 16						; size = 4
?InsertText@CPythonEventManager@@QAEXHPBDH@Z PROC	; CPythonEventManager::InsertText, COMDAT
; _this$ = ecx

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 290  : 	if (!CheckEventSetIndex(iIndex))

  00005	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  00010	84 c0		 test	 al, al
  00012	74 68		 je	 SHORT $LN5@InsertText

; 291  : 		return;
; 292  : 
; 293  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00014	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00017	8b 34 b0	 mov	 esi, DWORD PTR [eax+esi*4]

; 294  : 	if (!pEventSet)

  0001a	85 f6		 test	 esi, esi
  0001c	74 5e		 je	 SHORT $LN5@InsertText
  0001e	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _c_szText$[ebp]
  00022	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00025	75 04		 jne	 SHORT $LN15@InsertText
  00027	33 c9		 xor	 ecx, ecx
  00029	eb 0e		 jmp	 SHORT $LN16@InsertText
$LN15@InsertText:
  0002b	8b cf		 mov	 ecx, edi
  0002d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL17@InsertText:
  00030	8a 01		 mov	 al, BYTE PTR [ecx]
  00032	41		 inc	 ecx
  00033	84 c0		 test	 al, al
  00035	75 f9		 jne	 SHORT $LL17@InsertText
  00037	2b ca		 sub	 ecx, edx
$LN16@InsertText:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00039	51		 push	 ecx
  0003a	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 297  : 	pEventSet->strCurrentLine = c_szText;

  0003b	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0003e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 298  : 	if (pEventSet->pCurrentTextLine)

  00043	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00046	85 c9		 test	 ecx, ecx
  00048	74 1b		 je	 SHORT $LN18@InsertText

; 299  : 	{
; 300  : 		pEventSet->pCurrentTextLine->SetValue(c_szText);

  0004a	6a ff		 push	 -1
  0004c	57		 push	 edi
  0004d	e8 00 00 00 00	 call	 ?SetValue@CGraphicTextInstance@@QAEXPBDI@Z ; CGraphicTextInstance::SetValue

; 301  : 		if (iX_pos == 0)

  00052	8b 7d 10	 mov	 edi, DWORD PTR _iX_pos$[ebp]
  00055	85 ff		 test	 edi, edi
  00057	75 0f		 jne	 SHORT $LN1@InsertText

; 302  : 		{
; 303  : 			pEventSet->pCurrentTextLine->SetHorizonalAlign(CGraphicTextInstance::HORIZONTAL_ALIGN_CENTER);

  00059	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  0005c	6a 02		 push	 2
  0005e	e8 00 00 00 00	 call	 ?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z ; CGraphicTextInstance::SetHorizonalAlign
  00063	eb 03		 jmp	 SHORT $LN1@InsertText
$LN18@InsertText:
  00065	8b 7d 10	 mov	 edi, DWORD PTR _iX_pos$[ebp]
$LN1@InsertText:

; 304  : 		}
; 305  : 	}
; 306  : 	
; 307  : 	pEventSet->pCurrentTextLine->Update();

  00068	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  0006b	e8 00 00 00 00	 call	 ?Update@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Update

; 308  : 	__InsertLine(*pEventSet, FALSE, iX_pos);

  00070	57		 push	 edi
  00071	6a 00		 push	 0
  00073	56		 push	 esi
  00074	8b cb		 mov	 ecx, ebx
  00076	e8 00 00 00 00	 call	 ?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z ; CPythonEventManager::__InsertLine
  0007b	5f		 pop	 edi
$LN5@InsertText:
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx

; 309  : }

  0007e	5d		 pop	 ebp
  0007f	c2 0c 00	 ret	 12			; 0000000cH
?InsertText@CPythonEventManager@@QAEXHPBDH@Z ENDP	; CPythonEventManager::InsertText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?UpdateEventSet@CPythonEventManager@@QAEXHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_ix$ = 12						; size = 4
_iy$ = 16						; size = 4
?UpdateEventSet@CPythonEventManager@@QAEXHHH@Z PROC	; CPythonEventManager::UpdateEventSet, COMDAT
; _this$ = ecx

; 313  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi

; 314  : 	if (!CheckEventSetIndex(iIndex))

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  0000d	8b d9		 mov	 ebx, ecx
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  00015	84 c0		 test	 al, al
  00017	0f 84 b0 00 00
	00		 je	 $LN4@UpdateEven

; 315  : 		return;
; 316  : 
; 317  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  0001d	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  00020	8b 34 be	 mov	 esi, DWORD PTR [esi+edi*4]

; 318  : 	if (!pEventSet)

  00023	85 f6		 test	 esi, esi
  00025	0f 84 a2 00 00
	00		 je	 $LN4@UpdateEven

; 319  : 		return;
; 320  : 
; 321  : 	pEventSet->ix = ix;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _ix$[ebp]
  0002e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 322  : 	pEventSet->iy = iy;

  00031	8b 45 10	 mov	 eax, DWORD PTR _iy$[ebp]

; 323  : 
; 324  : 	RefreshLinePosition(pEventSet);

  00034	56		 push	 esi
  00035	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00038	e8 00 00 00 00	 call	 ?RefreshLinePosition@CPythonEventManager@@IAEXPAUSEventSet@1@@Z ; CPythonEventManager::RefreshLinePosition

; 325  : 
; 326  : 	if (pEventSet->isConfirmWait)

  0003d	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  00041	74 3b		 je	 SHORT $LN8@UpdateEven

; 327  : 	{
; 328  : 		int iLeftTime = max(0, pEventSet->iConfirmEndTime - timeGetTime()/1000);

  00043	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__timeGetTime@0
  00049	ff d7		 call	 edi
  0004b	ff d7		 call	 edi
  0004d	8b c8		 mov	 ecx, eax
  0004f	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00054	f7 e1		 mul	 ecx
  00056	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]

; 329  : 		pEventSet->pConfirmTimeTextLine->SetValue(_getf(m_strLeftTimeString.c_str(), iLeftTime));

  00059	8d 43 68	 lea	 eax, DWORD PTR [ebx+104]
  0005c	c1 ea 06	 shr	 edx, 6
  0005f	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00061	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00065	72 02		 jb	 SHORT $LN24@UpdateEven
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00067	8b 00		 mov	 eax, DWORD PTR [eax]
$LN24@UpdateEven:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 329  : 		pEventSet->pConfirmTimeTextLine->SetValue(_getf(m_strLeftTimeString.c_str(), iLeftTime));

  00069	6a ff		 push	 -1
  0006b	51		 push	 ecx
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?_getf@@YAPBDPBDZZ	; _getf
  00072	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00075	83 c4 08	 add	 esp, 8
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?SetValue@CGraphicTextInstance@@QAEXPBDI@Z ; CGraphicTextInstance::SetValue
$LN8@UpdateEven:

; 330  : 	}
; 331  : 
; 332  : 	if (pEventSet->isWaitFlag)

  0007e	80 be cd 00 00
	00 00		 cmp	 BYTE PTR [esi+205], 0
  00085	75 46		 jne	 SHORT $LN4@UpdateEven

; 333  : 		return;
; 334  : 
; 335  : 	///////////////////////////////////////////////////////////////////////////////////////////////
; 336  : 
; 337  : 	// Process EventSet
; 338  : 	long lElapsedTime = CTimer::Instance().GetElapsedMilliecond();

  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  0008d	e8 00 00 00 00	 call	 ?GetElapsedMilliecond@CTimer@@QAEKXZ ; CTimer::GetElapsedMilliecond

; 339  : 
; 340  : 	pEventSet->lLastDelayTime = max(0, pEventSet->lLastDelayTime - lElapsedTime);

  00092	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00095	8b f8		 mov	 edi, eax
  00097	2b cf		 sub	 ecx, edi
  00099	b8 00 00 00 00	 mov	 eax, 0
  0009e	0f 48 c8	 cmovs	 ecx, eax
  000a1	89 4e 18	 mov	 DWORD PTR [esi+24], ecx

; 341  : 
; 342  : 	while (lElapsedTime > 0)

  000a4	85 ff		 test	 edi, edi
  000a6	7e 25		 jle	 SHORT $LN4@UpdateEven
$LL6@UpdateEven:

; 343  : 	{
; 344  : 		pEventSet->lLastDelayTime -= lElapsedTime;

  000a8	29 7e 18	 sub	 DWORD PTR [esi+24], edi
  000ab	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]

; 345  : 
; 346  : 		if (pEventSet->lLastDelayTime <= 0)

  000ae	85 ff		 test	 edi, edi
  000b0	7f 1b		 jg	 SHORT $LN4@UpdateEven

; 347  : 		{
; 348  : 			lElapsedTime = -pEventSet->lLastDelayTime;

  000b2	f7 df		 neg	 edi

; 349  : 			if (lElapsedTime <= 0)

  000b4	85 ff		 test	 edi, edi
  000b6	7e 15		 jle	 SHORT $LN4@UpdateEven

; 350  : 				break;
; 351  : 
; 352  : 			ProcessEventSet(pEventSet);

  000b8	56		 push	 esi
  000b9	8b cb		 mov	 ecx, ebx
  000bb	e8 00 00 00 00	 call	 ?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z ; CPythonEventManager::ProcessEventSet

; 353  : 
; 354  : 			if (pEventSet->lLastDelayTime < 0)

  000c0	83 7e 18 00	 cmp	 DWORD PTR [esi+24], 0
  000c4	7d e2		 jge	 SHORT $LL6@UpdateEven

; 355  : 			{
; 356  : 				pEventSet->lLastDelayTime = 0;

  000c6	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN4@UpdateEven:

; 357  : 				break;
; 358  : 			}
; 359  : 		}
; 360  : 		else
; 361  : 			break;
; 362  : 	}
; 363  : }

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 0c 00	 ret	 12			; 0000000cH
?UpdateEventSet@CPythonEventManager@@QAEXHHH@Z ENDP	; CPythonEventManager::UpdateEventSet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?SetEventSetWidth@CPythonEventManager@@QAEXHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iWidth$ = 12						; size = 4
?SetEventSetWidth@CPythonEventManager@@QAEXHH@Z PROC	; CPythonEventManager::SetEventSetWidth, COMDAT
; _this$ = ecx

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 367  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	74 10		 je	 SHORT $LN3@SetEventSe

; 368  : 		return;
; 369  : 
; 370  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00011	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00014	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]

; 371  : 	if (!pEventSet)

  00017	85 c9		 test	 ecx, ecx
  00019	74 06		 je	 SHORT $LN3@SetEventSe

; 372  : 		return;
; 373  : 
; 374  : 	pEventSet->iWidth = iWidth;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _iWidth$[ebp]
  0001e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN3@SetEventSe:
  00021	5e		 pop	 esi

; 375  : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?SetEventSetWidth@CPythonEventManager@@QAEXHH@Z ENDP	; CPythonEventManager::SetEventSetWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\parser.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z
_TEXT	SEGMENT
_killmob_count$1$ = -112				; size = 4
_find_hidden$1$ = -108					; size = 4
_killstone_count$1$ = -104				; size = 4
_c_szName$2 = -104					; size = 4
_use_potion$1$ = -100					; size = 4
_total$1$ = -100					; size = 4
_c_rstType$1$ = -100					; size = 4
_fSpeed$3 = -100					; size = 4
_y$4 = -100						; size = 4
_iEventType$ = -100					; size = 4
_name$1$ = -96						; size = 4
_hidden_total$1$ = -96					; size = 4
_desc$1$ = -96						; size = 4
_pEventPosition$ = -96					; size = 4
_this$GSCopy$1$ = -92					; size = 4
_index$1$ = -92						; size = 4
_idx$1$ = -92						; size = 4
_pItemData$5 = -92					; size = 4
_x$6 = -92						; size = 4
_CameraSetting$7 = -88					; size = 36
_CameraSetting$8 = -88					; size = 36
_ScriptCommand$ = -52					; size = 32
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_pEventSet$ = 8						; size = 4
?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z PROC ; CPythonEventManager::ProcessEventSet, COMDAT
; _this$ = ecx

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 68	 sub	 esp, 104		; 00000068H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d a4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  00030	8b 5d 08	 mov	 ebx, DWORD PTR _pEventSet$[ebp]

; 379  : 	if (pEventSet->isLock)

  00033	80 7b 14 00	 cmp	 BYTE PTR [ebx+20], 0
  00037	0f 85 00 0c 00
	00		 jne	 $LN257@ProcessEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003d	c7 45 e0 0f 00
	00 00		 mov	 DWORD PTR _ScriptCommand$[ebp+20], 15 ; 0000000fH

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00044	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _ScriptCommand$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0004b	c6 45 cc 00	 mov	 BYTE PTR _ScriptCommand$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0004f	6a 00		 push	 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\parser.h

; 37   : 		SCmd()

  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00058	8d 4d e4	 lea	 ecx, DWORD PTR _ScriptCommand$[ebp+24]
  0005b	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  0005d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _ScriptCommand$[ebp+24], 0

; 528  : 		this->_Mysize = 0;

  00064	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ScriptCommand$[ebp+28], 0

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0006b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buynode0

; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  00070	89 45 e4	 mov	 DWORD PTR _ScriptCommand$[ebp+24], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 386  : 	if (!pEventSet->ScriptGroup.GetCmd(ScriptCommand))

  00073	8d 45 cc	 lea	 eax, DWORD PTR _ScriptCommand$[ebp]
  00076	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0007d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A ; TAbstractSingleton<IAbstractApplication>::ms_singleton
  00083	8d 4b 60	 lea	 ecx, DWORD PTR [ebx+96]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ?GetCmd@Group@script@@QAE_NAAUSCmd@2@@Z ; script::Group::GetCmd
  0008c	84 c0		 test	 al, al
  0008e	75 09		 jne	 SHORT $LN68@ProcessEve

; 387  : 	{
; 388  : 		pEventSet->isLock = true;

  00090	c6 43 14 01	 mov	 BYTE PTR [ebx+20], 1
  00094	e9 80 0b 00 00	 jmp	 $LN65@ProcessEve
$LN68@ProcessEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00099	83 7d e0 10	 cmp	 DWORD PTR _ScriptCommand$[ebp+20], 16 ; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 394  : 	if (!GetScriptEventIndex(ScriptCommand.name.c_str(), &pEventPosition, &iEventType))

  0009d	8d 4d 9c	 lea	 ecx, DWORD PTR _iEventType$[ebp]
  000a0	51		 push	 ecx
  000a1	8d 4d a0	 lea	 ecx, DWORD PTR _pEventPosition$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  000a4	8d 45 cc	 lea	 eax, DWORD PTR _ScriptCommand$[ebp]
  000a7	0f 43 45 cc	 cmovae	 eax, DWORD PTR _ScriptCommand$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 394  : 	if (!GetScriptEventIndex(ScriptCommand.name.c_str(), &pEventPosition, &iEventType))

  000ab	51		 push	 ecx
  000ac	50		 push	 eax
  000ad	8b cf		 mov	 ecx, edi
  000af	e8 00 00 00 00	 call	 ?GetScriptEventIndex@CPythonEventManager@@IAE_NPBDPAH1@Z ; CPythonEventManager::GetScriptEventIndex
  000b4	84 c0		 test	 al, al
  000b6	0f 84 5d 0b 00
	00		 je	 $LN65@ProcessEve

; 395  : 		return;
; 396  : 
; 397  : 	switch (iEventType)

  000bc	8b 45 9c	 mov	 eax, DWORD PTR _iEventType$[ebp]
  000bf	83 f8 29	 cmp	 eax, 41			; 00000029H
  000c2	0f 87 51 0b 00
	00		 ja	 $LN65@ProcessEve
  000c8	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN285@ProcessEve[eax*4]
$LN64@ProcessEve:

; 401  : 			const std::string& c_rstValue = GetArgumentString("value", ScriptCommand.argList);

  000cf	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  000d2	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05MFEJDJP@value?$AA@
  000d7	e8 00 00 00 00	 call	 ?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z ; GetArgumentString
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

  000dc	6a ff		 push	 -1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 401  : 			const std::string& c_rstValue = GetArgumentString("value", ScriptCommand.argList);

  000de	8b f8		 mov	 edi, eax

; 402  : 			pEventSet->strCurrentLine.append(c_rstValue);

  000e0	8d 73 30	 lea	 esi, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

  000e3	6a 00		 push	 0
  000e5	57		 push	 edi
  000e6	8b ce		 mov	 ecx, esi
  000e8	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 403  : 			pEventSet->pCurrentTextLine->SetValueString(pEventSet->strCurrentLine);

  000ed	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  000f0	56		 push	 esi
  000f1	e8 00 00 00 00	 call	 ?SetValueString@CGraphicTextInstance@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CGraphicTextInstance::SetValueString

; 404  : 			pEventSet->pCurrentTextLine->SetColor(pEventSet->CurrentColor.r,pEventSet->CurrentColor.g,pEventSet->CurrentColor.b);

  000f6	f3 0f 10 43 28	 movss	 xmm0, DWORD PTR [ebx+40]
  000fb	83 ec 10	 sub	 esp, 16			; 00000010H
  000fe	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  00101	c7 44 24 0c 00
	00 80 3f	 mov	 DWORD PTR [esp+12], 1065353216 ; 3f800000H
  00109	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0010f	f3 0f 10 43 24	 movss	 xmm0, DWORD PTR [ebx+36]
  00114	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0011a	f3 0f 10 43 20	 movss	 xmm0, DWORD PTR [ebx+32]
  0011f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00124	e8 00 00 00 00	 call	 ?SetColor@CGraphicTextInstance@@QAEXMMMM@Z ; CGraphicTextInstance::SetColor

; 405  : 			pEventSet->iCurrentLetter+=c_rstValue.length();

  00129	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0012c	01 43 1c	 add	 DWORD PTR [ebx+28], eax
  0012f	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]

; 406  : 
; 407  : 			if (pEventSet->iCurrentLetter >= pEventSet->iRestrictedCharacterCount)

  00132	3b 83 c4 00 00
	00		 cmp	 eax, DWORD PTR [ebx+196]
  00138	7c 0d		 jl	 SHORT $LN63@ProcessEve

; 408  : 			{
; 409  : 				__InsertLine(*pEventSet);

  0013a	8b 4d a4	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0013d	6a 00		 push	 0
  0013f	6a 00		 push	 0
  00141	53		 push	 ebx
  00142	e8 00 00 00 00	 call	 ?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z ; CPythonEventManager::__InsertLine
$LN63@ProcessEve:

; 410  : 			}
; 411  : 
; 412  : 			pEventSet->lLastDelayTime = pEventSet->lWaitingTime;

  00147	8b 83 c0 00 00
	00		 mov	 eax, DWORD PTR [ebx+192]
  0014d	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 413  : 			break;

  00150	e9 c4 0a 00 00	 jmp	 $LN65@ProcessEve
$LN62@ProcessEve:

; 414  : 		}
; 415  : 
; 416  : 		case EVENT_TYPE_DELAY:
; 417  : 		{
; 418  : 			if (EVENT_POSITION_START == pEventPosition)

  00155	83 7d a0 00	 cmp	 DWORD PTR _pEventPosition$[ebp], 0
  00159	75 21		 jne	 SHORT $LN61@ProcessEve

; 419  : 				pEventSet->lWaitingTime = atoi(GetArgument("value", ScriptCommand.argList));

  0015b	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  0015e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05MFEJDJP@value?$AA@
  00163	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00168	50		 push	 eax
  00169	e8 00 00 00 00	 call	 __atoi64
  0016e	83 c4 04	 add	 esp, 4
  00171	89 83 c0 00 00
	00		 mov	 DWORD PTR [ebx+192], eax

; 420  : 			else

  00177	e9 9d 0a 00 00	 jmp	 $LN65@ProcessEve
$LN61@ProcessEve:

; 421  : 				pEventSet->lWaitingTime = c_lNormal_Waiting_Time;

  0017c	c7 83 c0 00 00
	00 0a 00 00 00	 mov	 DWORD PTR [ebx+192], 10	; 0000000aH

; 422  : 			break;

  00186	e9 8e 0a 00 00	 jmp	 $LN65@ProcessEve
$LN59@ProcessEve:

; 423  : 		}
; 424  : 
; 425  : 		case EVENT_TYPE_COLOR:
; 426  : 		{
; 427  : 			if (EVENT_POSITION_START == pEventPosition)

  0018b	83 7d a0 00	 cmp	 DWORD PTR _pEventPosition$[ebp], 0
  0018f	75 57		 jne	 SHORT $LN58@ProcessEve

; 428  : 			{
; 429  : 				pEventSet->CurrentColor.r = (float)atof(GetArgument("r", ScriptCommand.argList));

  00191	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00194	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00199	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 _atof
  001a4	83 c4 04	 add	 esp, 4

; 430  : 				pEventSet->CurrentColor.g = (float)atof(GetArgument("g", ScriptCommand.argList));

  001a7	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  001aa	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01JEJKBAGA@g?$AA@
  001af	d9 5b 20	 fstp	 DWORD PTR [ebx+32]
  001b2	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 _atof
  001bd	83 c4 04	 add	 esp, 4

; 431  : 				pEventSet->CurrentColor.b = (float)atof(GetArgument("b", ScriptCommand.argList));

  001c0	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  001c3	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01OJONOECF@b?$AA@
  001c8	d9 5b 24	 fstp	 DWORD PTR [ebx+36]
  001cb	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 _atof
  001d6	d9 5b 28	 fstp	 DWORD PTR [ebx+40]
  001d9	83 c4 04	 add	 esp, 4

; 432  : 				pEventSet->CurrentColor.a = 1.0f;

  001dc	c7 43 2c 00 00
	80 3f		 mov	 DWORD PTR [ebx+44], 1065353216 ; 3f800000H

; 433  : 			}
; 434  : 			else

  001e3	e9 31 0a 00 00	 jmp	 $LN65@ProcessEve
$LN58@ProcessEve:

; 435  : 			{
; 436  : 				pEventSet->CurrentColor.r = 1.0f;

  001e8	c7 43 20 00 00
	80 3f		 mov	 DWORD PTR [ebx+32], 1065353216 ; 3f800000H

; 437  : 				pEventSet->CurrentColor.g = 1.0f;

  001ef	c7 43 24 00 00
	80 3f		 mov	 DWORD PTR [ebx+36], 1065353216 ; 3f800000H

; 438  : 				pEventSet->CurrentColor.a = 1.0f;

  001f6	c7 43 2c 00 00
	80 3f		 mov	 DWORD PTR [ebx+44], 1065353216 ; 3f800000H

; 439  : 				pEventSet->CurrentColor.b = 1.0f;

  001fd	c7 43 28 00 00
	80 3f		 mov	 DWORD PTR [ebx+40], 1065353216 ; 3f800000H

; 440  : 			}
; 441  : 			break;

  00204	e9 10 0a 00 00	 jmp	 $LN65@ProcessEve
$LN56@ProcessEve:

; 442  : 		}
; 443  : 
; 444  : 		case EVENT_TYPE_COLOR256:
; 445  : 		{
; 446  : 			if (EVENT_POSITION_START == pEventPosition)

  00209	83 7d a0 00	 cmp	 DWORD PTR _pEventPosition$[ebp], 0
  0020d	75 d9		 jne	 SHORT $LN58@ProcessEve

; 447  : 			{
; 448  : 				pEventSet->CurrentColor.r = float(atof(GetArgument("r", ScriptCommand.argList)) / 255.0f);

  0020f	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00212	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00217	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0021c	50		 push	 eax
  0021d	e8 00 00 00 00	 call	 _atof
  00222	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@406fe00000000000

; 449  : 				pEventSet->CurrentColor.g = float(atof(GetArgument("g", ScriptCommand.argList)) / 255.0f);

  00228	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  0022b	83 c4 04	 add	 esp, 4
  0022e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01JEJKBAGA@g?$AA@
  00233	d9 5b 20	 fstp	 DWORD PTR [ebx+32]
  00236	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 _atof
  00241	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@406fe00000000000

; 450  : 				pEventSet->CurrentColor.b = float(atof(GetArgument("b", ScriptCommand.argList)) / 255.0f);

  00247	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  0024a	83 c4 04	 add	 esp, 4
  0024d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01OJONOECF@b?$AA@
  00252	d9 5b 24	 fstp	 DWORD PTR [ebx+36]
  00255	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0025a	50		 push	 eax
  0025b	e8 00 00 00 00	 call	 _atof
  00260	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@406fe00000000000
  00266	83 c4 04	 add	 esp, 4

; 451  : 				pEventSet->CurrentColor.a = 1.0f;

  00269	c7 43 2c 00 00
	80 3f		 mov	 DWORD PTR [ebx+44], 1065353216 ; 3f800000H
  00270	d9 5b 28	 fstp	 DWORD PTR [ebx+40]

; 452  : 			}
; 453  : 			else

  00273	e9 a1 09 00 00	 jmp	 $LN65@ProcessEve
$LN53@ProcessEve:

; 454  : 			{
; 455  : 				pEventSet->CurrentColor.r = 1.0f;
; 456  : 				pEventSet->CurrentColor.g = 1.0f;
; 457  : 				pEventSet->CurrentColor.a = 1.0f;
; 458  : 				pEventSet->CurrentColor.b = 1.0f;
; 459  : 			}
; 460  : 			break;
; 461  : 		}
; 462  : 
; 463  : 		case EVENT_TYPE_ENTER:
; 464  : 		{
; 465  : 			__InsertLine(*pEventSet);

  00278	6a 00		 push	 0
  0027a	6a 00		 push	 0
  0027c	53		 push	 ebx
  0027d	8b cf		 mov	 ecx, edi
  0027f	e8 00 00 00 00	 call	 ?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z ; CPythonEventManager::__InsertLine

; 466  : 			break;

  00284	e9 90 09 00 00	 jmp	 $LN65@ProcessEve
$LN52@ProcessEve:

; 467  : 		}
; 468  : 
; 469  : 		case EVENT_TYPE_WAIT:
; 470  : 		{
; 471  : 			//        /EVENT_TYPE_WAIT   .
; 472  : 			pEventSet->iyLocal = 0;

  00289	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 473  : 			pEventSet->isLock = true;

  00290	c6 43 14 01	 mov	 BYTE PTR [ebx+20], 1

; 474  : 			break;

  00294	e9 80 09 00 00	 jmp	 $LN65@ProcessEve
$LN51@ProcessEve:

; 475  : 		}
; 476  : 
; 477  : 		case EVENT_TYPE_NEXT:
; 478  : 		{
; 479  : 			MakeNextButton(pEventSet, BUTTON_TYPE_NEXT);

  00299	6a 00		 push	 0
  0029b	53		 push	 ebx
  0029c	e8 00 00 00 00	 call	 ?MakeNextButton@CPythonEventManager@@IAEXPAUSEventSet@1@H@Z ; CPythonEventManager::MakeNextButton

; 480  : 			pEventSet->iAdjustLine += 2;

  002a1	83 83 ac 00 00
	00 02		 add	 DWORD PTR [ebx+172], 2

; 481  : 			break;

  002a8	e9 6c 09 00 00	 jmp	 $LN65@ProcessEve
$LN50@ProcessEve:

; 482  : 		}
; 483  : 
; 484  : 		case EVENT_TYPE_DONE:
; 485  : 		{
; 486  : 			MakeNextButton(pEventSet, BUTTON_TYPE_DONE);

  002ad	6a 01		 push	 1
  002af	53		 push	 ebx
  002b0	e8 00 00 00 00	 call	 ?MakeNextButton@CPythonEventManager@@IAEXPAUSEventSet@1@H@Z ; CPythonEventManager::MakeNextButton

; 487  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "DoneEvent", Py_BuildValue("()"));

  002b5	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  002ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  002c0	83 c4 04	 add	 esp, 4
  002c3	50		 push	 eax
  002c4	68 00 00 00 00	 push	 OFFSET ??_C@_09DIPEHMLE@DoneEvent?$AA@
$LN280@ProcessEve:
  002c9	ff b3 d0 00 00
	00		 push	 DWORD PTR [ebx+208]
  002cf	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  002d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 488  : 			pEventSet->iAdjustLine += 2;

  002d7	83 83 ac 00 00
	00 02		 add	 DWORD PTR [ebx+172], 2

; 489  : 			break;

  002de	e9 36 09 00 00	 jmp	 $LN65@ProcessEve
$LN49@ProcessEve:

; 490  : 		}
; 491  : 
; 492  : 		case EVENT_TYPE_CLEAR:
; 493  : 		{
; 494  : 			ClearLine(pEventSet);

  002e3	53		 push	 ebx
  002e4	8b cf		 mov	 ecx, edi
  002e6	e8 00 00 00 00	 call	 ?ClearLine@CPythonEventManager@@IAEXPAUSEventSet@1@@Z ; CPythonEventManager::ClearLine

; 495  : 			break;

  002eb	e9 29 09 00 00	 jmp	 $LN65@ProcessEve
$LN48@ProcessEve:

; 496  : 		}
; 497  : 
; 498  : 		case EVENT_TYPE_QUESTION:
; 499  : 		{
; 500  : 			MakeQuestion(pEventSet, ScriptCommand.argList);

  002f0	8d 45 e4	 lea	 eax, DWORD PTR _ScriptCommand$[ebp+24]
  002f3	50		 push	 eax
  002f4	53		 push	 ebx
  002f5	e8 00 00 00 00	 call	 ?MakeQuestion@CPythonEventManager@@IAEXPAUSEventSet@1@AAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; CPythonEventManager::MakeQuestion

; 501  : 			break;

  002fa	e9 1a 09 00 00	 jmp	 $LN65@ProcessEve
$LN47@ProcessEve:

; 502  : 		}
; 503  : 
; 504  : 		case EVENT_TYPE_LEFT_IMAGE:
; 505  : 		{
; 506  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "OnLeftImage", Py_BuildValue("(s)", GetArgument("src", ScriptCommand.argList)));

  002ff	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00302	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03LOJEKLML@src?$AA@
  00307	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0030c	50		 push	 eax
  0030d	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  00312	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00318	50		 push	 eax
  00319	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MHNDOIJH@OnLeftImage?$AA@
  0031e	ff b3 d0 00 00
	00		 push	 DWORD PTR [ebx+208]
  00324	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00329	83 c4 14	 add	 esp, 20			; 00000014H

; 507  : 			break;

  0032c	e9 e8 08 00 00	 jmp	 $LN65@ProcessEve
$LN46@ProcessEve:

; 508  : 		}
; 509  : 
; 510  : 		case EVENT_TYPE_TOP_IMAGE:
; 511  : 		{
; 512  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "OnTopImage", Py_BuildValue("(s)", GetArgument("src", ScriptCommand.argList)));

  00331	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00334	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03LOJEKLML@src?$AA@
  00339	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0033e	50		 push	 eax
  0033f	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  00344	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0034a	50		 push	 eax
  0034b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@ELIGNPMG@OnTopImage?$AA@
  00350	ff b3 d0 00 00
	00		 push	 DWORD PTR [ebx+208]
  00356	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0035b	83 c4 14	 add	 esp, 20			; 00000014H

; 513  : 			break;

  0035e	e9 b6 08 00 00	 jmp	 $LN65@ProcessEve
$LN45@ProcessEve:

; 514  : 		}
; 515  : 
; 516  : 		case EVENT_TYPE_BACKGROUND_IMAGE:
; 517  : 		{
; 518  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "OnBackgroundImage", Py_BuildValue("(s)",GetArgument("src", ScriptCommand.argList)));

  00363	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00366	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03LOJEKLML@src?$AA@
  0036b	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00370	50		 push	 eax
  00371	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  00376	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0037c	50		 push	 eax
  0037d	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OIPDJOGL@OnBackgroundImage?$AA@
  00382	ff b3 d0 00 00
	00		 push	 DWORD PTR [ebx+208]
  00388	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0038d	83 c4 14	 add	 esp, 20			; 00000014H

; 519  : 			break;

  00390	e9 84 08 00 00	 jmp	 $LN65@ProcessEve
$LN44@ProcessEve:

; 520  : 		}
; 521  : 
; 522  : 		case EVENT_TYPE_IMAGE:
; 523  : 		{
; 524  : 			int x = atoi(GetArgument("x", ScriptCommand.argList));

  00395	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00398	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01FJMABOPO@x?$AA@
  0039d	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 __atoi64
  003a8	83 c4 04	 add	 esp, 4

; 525  : 			int y = atoi(GetArgument("y", ScriptCommand.argList));

  003ab	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  003ae	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01EANLCPLP@y?$AA@
  003b3	8b f8		 mov	 edi, eax
  003b5	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  003ba	50		 push	 eax
  003bb	e8 00 00 00 00	 call	 __atoi64
  003c0	83 c4 04	 add	 esp, 4

; 526  : 			const char * src = GetArgument("src", ScriptCommand.argList);

  003c3	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  003c6	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03LOJEKLML@src?$AA@
  003cb	8b f0		 mov	 esi, eax
  003cd	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument

; 527  : 
; 528  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "OnImage", Py_BuildValue("(iis)", x, y, src));

  003d2	50		 push	 eax
  003d3	56		 push	 esi
  003d4	57		 push	 edi
  003d5	68 00 00 00 00	 push	 OFFSET ??_C@_05GFDPDNFA@?$CIiis?$CJ?$AA@
  003da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  003e0	50		 push	 eax
  003e1	68 00 00 00 00	 push	 OFFSET ??_C@_07COJEPNBG@OnImage?$AA@
  003e6	ff b3 d0 00 00
	00		 push	 DWORD PTR [ebx+208]
  003ec	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  003f1	83 c4 1c	 add	 esp, 28			; 0000001cH

; 529  : 			break;

  003f4	e9 20 08 00 00	 jmp	 $LN65@ProcessEve
$LN43@ProcessEve:

; 530  : 		}
; 531  : 
; 532  : 		case EVENT_TYPE_INSERT_IMAGE:
; 533  : 		{
; 534  : 			const std::string & imageFile = GetArgumentString("image_name", ScriptCommand.argList);

  003f9	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  003fc	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@NDIFBCJA@image_name?$AA@
  00401	e8 00 00 00 00	 call	 ?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z ; GetArgumentString

; 535  : 			const char * title = GetArgument("title", ScriptCommand.argList);

  00406	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00409	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05PHLGJONK@title?$AA@
  0040e	8b f0		 mov	 esi, eax
  00410	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument

; 536  : 			const char * desc = GetArgument("desc", ScriptCommand.argList);

  00415	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00418	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_04EBPADADD@desc?$AA@
  0041d	8b f8		 mov	 edi, eax
  0041f	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument

; 537  : 			int index = atoi(GetArgument("index", ScriptCommand.argList));

  00424	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00427	89 45 a0	 mov	 DWORD PTR _desc$1$[ebp], eax
  0042a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05FKHKFDID@index?$AA@
  0042f	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00434	50		 push	 eax
  00435	e8 00 00 00 00	 call	 __atoi64
  0043a	83 c4 04	 add	 esp, 4
  0043d	89 45 a4	 mov	 DWORD PTR _index$1$[ebp], eax

; 538  : 			int total = atoi(GetArgument("total", ScriptCommand.argList));

  00440	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00443	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05KBOMEDGA@total?$AA@
  00448	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0044d	50		 push	 eax
  0044e	e8 00 00 00 00	 call	 __atoi64
  00453	83 c4 04	 add	 esp, 4
  00456	89 45 9c	 mov	 DWORD PTR _total$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

  00459	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 540  : 			if (imageFile.empty())

  0045d	75 4a		 jne	 SHORT $LN42@ProcessEve

; 541  : 			{
; 542  : 				const char * imageType = GetArgument("image_type", ScriptCommand.argList);

  0045f	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00462	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@HIIGNCOA@image_type?$AA@
  00467	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument

; 543  : 				int iItemIndex = atoi(GetArgument("idx", ScriptCommand.argList));

  0046c	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  0046f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03DAKNAIGI@idx?$AA@
  00474	8b f0		 mov	 esi, eax
  00476	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0047b	50		 push	 eax
  0047c	e8 00 00 00 00	 call	 __atoi64
  00481	83 c4 04	 add	 esp, 4

; 544  : 				PyCallClassMemberFunc(pEventSet->poEventHandler, "OnInsertItemIcon", Py_BuildValue("(sissii)", imageType, iItemIndex, title, desc, index, total));

  00484	ff 75 9c	 push	 DWORD PTR _total$1$[ebp]
  00487	ff 75 a4	 push	 DWORD PTR _index$1$[ebp]
  0048a	ff 75 a0	 push	 DWORD PTR _desc$1$[ebp]
  0048d	57		 push	 edi
  0048e	50		 push	 eax
  0048f	56		 push	 esi
  00490	68 00 00 00 00	 push	 OFFSET ??_C@_08GKIEGGBC@?$CIsissii?$CJ?$AA@
  00495	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0049b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0049e	50		 push	 eax
  0049f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCLBKNGH@OnInsertItemIcon?$AA@

; 545  : 			}
; 546  : 			else

  004a4	e9 20 fe ff ff	 jmp	 $LN280@ProcessEve
$LN42@ProcessEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  004a9	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  004ad	72 02		 jb	 SHORT $LN151@ProcessEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  004af	8b 36		 mov	 esi, DWORD PTR [esi]
$LN151@ProcessEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 548  : 				PyCallClassMemberFunc(pEventSet->poEventHandler, "OnInsertImage", Py_BuildValue("(ssssii)", imageFile.c_str(), title, title, desc, index, total));

  004b1	50		 push	 eax
  004b2	ff 75 a4	 push	 DWORD PTR _index$1$[ebp]
  004b5	ff 75 a0	 push	 DWORD PTR _desc$1$[ebp]
  004b8	57		 push	 edi
  004b9	57		 push	 edi
  004ba	56		 push	 esi
  004bb	68 00 00 00 00	 push	 OFFSET ??_C@_08KJCKKFJC@?$CIssssii?$CJ?$AA@
  004c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  004c6	83 c4 1c	 add	 esp, 28			; 0000001cH
  004c9	50		 push	 eax
  004ca	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LBIBFC@OnInsertImage?$AA@

; 549  : 			}
; 550  : 			pEventSet->iAdjustLine += 2;
; 551  : 			break;

  004cf	e9 f5 fd ff ff	 jmp	 $LN280@ProcessEve
$LN40@ProcessEve:

; 552  : 		}
; 553  : 
; 554  : 		case EVENT_TYPE_ADD_MAP_SIGNAL:
; 555  : 		{
; 556  : 			float x, y;
; 557  : 			x = (float)atof(GetArgument("x",ScriptCommand.argList));

  004d4	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  004d7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01FJMABOPO@x?$AA@
  004dc	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  004e1	50		 push	 eax
  004e2	e8 00 00 00 00	 call	 _atof
  004e7	83 c4 04	 add	 esp, 4

; 558  : 			y = (float)atof(GetArgument("y",ScriptCommand.argList));

  004ea	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  004ed	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01EANLCPLP@y?$AA@
  004f2	d9 5d a4	 fstp	 DWORD PTR _x$6[ebp]
  004f5	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  004fa	50		 push	 eax
  004fb	e8 00 00 00 00	 call	 _atof

; 559  : 			CPythonMiniMap::Instance().AddSignalPoint(x,y);

  00500	f3 0f 10 4d a4	 movss	 xmm1, DWORD PTR _x$6[ebp]
  00505	83 c4 04	 add	 esp, 4
  00508	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  0050e	d9 5d 9c	 fstp	 DWORD PTR _y$4[ebp]
  00511	f3 0f 10 55 9c	 movss	 xmm2, DWORD PTR _y$4[ebp]
  00516	e8 00 00 00 00	 call	 ?AddSignalPoint@CPythonMiniMap@@QAEXMM@Z ; CPythonMiniMap::AddSignalPoint

; 560  : 			CPythonMiniMap::Instance().OpenAtlasWindow();

  0051b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00521	e8 00 00 00 00	 call	 ?OpenAtlasWindow@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::OpenAtlasWindow

; 561  : 			break;

  00526	e9 ee 06 00 00	 jmp	 $LN65@ProcessEve
$LN39@ProcessEve:

; 562  : 		}
; 563  : 
; 564  : 		case EVENT_TYPE_CLEAR_MAP_SIGNAL:
; 565  : 		{
; 566  : 			CPythonMiniMap::Instance().ClearAllSignalPoint();

  0052b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
  00531	e8 00 00 00 00	 call	 ?ClearAllSignalPoint@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::ClearAllSignalPoint

; 567  : 			break;

  00536	e9 de 06 00 00	 jmp	 $LN65@ProcessEve
$LN38@ProcessEve:

; 568  : 		}
; 569  : 
; 570  : 		// HIDE_QUEST_LETTER
; 571  : 		case EVENT_TYPE_QUEST_BUTTON_CLOSE:
; 572  : 		{
; 573  : 			PyCallClassMemberFunc(m_poInterface, "BINARY_ClearQuest", 
; 574  : 				Py_BuildValue("(i)", atoi(GetArgument("idx", ScriptCommand.argList))));

  0053b	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  0053e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03DAKNAIGI@idx?$AA@
  00543	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00548	50		 push	 eax
  00549	e8 00 00 00 00	 call	 __atoi64
  0054e	83 c4 04	 add	 esp, 4
  00551	52		 push	 edx
  00552	50		 push	 eax
  00553	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00558	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0055e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00561	50		 push	 eax
  00562	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HCOLHKJD@BINARY_ClearQuest?$AA@

; 575  : 			break;

  00567	e9 a2 06 00 00	 jmp	 $LN281@ProcessEve
$LN37@ProcessEve:

; 576  : 		}
; 577  : 		// END_OF_HIDE_QUEST_LETTER
; 578  : 		
; 579  : 		case EVENT_TYPE_QUEST_BUTTON:
; 580  : 		{
; 581  : 			const std::string& c_rstType = GetArgumentString("icon_type", ScriptCommand.argList);

  0056c	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  0056f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09CNONGEHE@icon_type?$AA@
  00574	e8 00 00 00 00	 call	 ?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z ; GetArgumentString

; 582  : 			const std::string& c_rstFile = GetArgumentString("icon_name", ScriptCommand.argList);

  00579	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  0057c	89 45 9c	 mov	 DWORD PTR _c_rstType$1$[ebp], eax
  0057f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09IGOOKEAE@icon_name?$AA@
  00584	e8 00 00 00 00	 call	 ?GetArgumentString@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@2@@Z ; GetArgumentString

; 583  : 
; 584  : 			int idx = atoi(GetArgument("idx", ScriptCommand.argList));

  00589	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  0058c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03DAKNAIGI@idx?$AA@
  00591	8b f0		 mov	 esi, eax
  00593	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00598	50		 push	 eax
  00599	e8 00 00 00 00	 call	 __atoi64
  0059e	83 c4 04	 add	 esp, 4
  005a1	89 45 a4	 mov	 DWORD PTR _idx$1$[ebp], eax

; 585  : 			const char * name = GetArgument("name", ScriptCommand.argList);

  005a4	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  005a7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_04MEMAJGDJ@name?$AA@
  005ac	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  005b1	89 45 a0	 mov	 DWORD PTR _name$1$[ebp], eax

; 586  : 			
; 587  : 			//  UI        by chrislee
; 588  : 			if (!strcmp(name, " ?....")) {

  005b4	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BD@MDDAOGBD@?A?$LG?$LA?$KC?$LD?$KN?5?$LP?k?H?$KF?$LM?$KO?$DP?4?4?4?4?$AA@
  005b9	8b c8		 mov	 ecx, eax
  005bb	eb 03 8d 49 00	 npad	 5
$LL273@ProcessEve:
  005c0	8a 19		 mov	 bl, BYTE PTR [ecx]
  005c2	3a 1a		 cmp	 bl, BYTE PTR [edx]
  005c4	75 1a		 jne	 SHORT $LN274@ProcessEve
  005c6	84 db		 test	 bl, bl
  005c8	74 12		 je	 SHORT $LN275@ProcessEve
  005ca	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  005cd	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  005d0	75 0e		 jne	 SHORT $LN274@ProcessEve
  005d2	83 c1 02	 add	 ecx, 2
  005d5	83 c2 02	 add	 edx, 2
  005d8	84 c0		 test	 al, al
  005da	75 e4		 jne	 SHORT $LL273@ProcessEve
$LN275@ProcessEve:
  005dc	33 c0		 xor	 eax, eax
  005de	eb 05		 jmp	 SHORT $LN276@ProcessEve
$LN274@ProcessEve:
  005e0	1b c0		 sbb	 eax, eax
  005e2	83 c8 01	 or	 eax, 1
$LN276@ProcessEve:
  005e5	85 c0		 test	 eax, eax
  005e7	75 29		 jne	 SHORT $LN36@ProcessEve

; 589  : 				PyCallClassMemberFunc(m_poInterface, "BINARY_RecvQuest", Py_BuildValue("(isss)", idx, name, "highlight", ""));

  005e9	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  005ee	68 00 00 00 00	 push	 OFFSET ??_C@_09MIAHMBP@highlight?$AA@
  005f3	ff 75 a0	 push	 DWORD PTR _name$1$[ebp]
  005f6	ff 75 a4	 push	 DWORD PTR _idx$1$[ebp]
  005f9	68 00 00 00 00	 push	 OFFSET ??_C@_06GEDDNFGH@?$CIisss?$CJ?$AA@
  005fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00604	83 c4 14	 add	 esp, 20			; 00000014H
  00607	50		 push	 eax
  00608	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JCGLEGP@BINARY_RecvQuest?$AA@

; 590  : 			}
; 591  : 			else {

  0060d	e9 fc 05 00 00	 jmp	 $LN281@ProcessEve
$LN36@ProcessEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

  00612	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 592  : 				if (c_rstFile.empty())

  00616	75 1f		 jne	 SHORT $LN34@ProcessEve

; 593  : 				{
; 594  : 					PyCallClassMemberFunc(m_poInterface, "RecvQuest", Py_BuildValue("(is)", idx, name));

  00618	ff 75 a0	 push	 DWORD PTR _name$1$[ebp]
  0061b	ff 75 a4	 push	 DWORD PTR _idx$1$[ebp]
  0061e	68 00 00 00 00	 push	 OFFSET ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
  00623	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00629	83 c4 0c	 add	 esp, 12			; 0000000cH
  0062c	50		 push	 eax
  0062d	68 00 00 00 00	 push	 OFFSET ??_C@_09IBEAJOHJ@RecvQuest?$AA@

; 595  : 				}
; 596  : 				else

  00632	e9 d7 05 00 00	 jmp	 $LN281@ProcessEve
$LN34@ProcessEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00637	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0063b	72 02		 jb	 SHORT $LN167@ProcessEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0063d	8b 36		 mov	 esi, DWORD PTR [esi]
$LN167@ProcessEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0063f	8b 45 9c	 mov	 eax, DWORD PTR _c_rstType$1$[ebp]
  00642	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00646	72 02		 jb	 SHORT $LN175@ProcessEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00648	8b 00		 mov	 eax, DWORD PTR [eax]
$LN175@ProcessEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 599  : 						Py_BuildValue("(isss)", idx, name, c_rstType.c_str(), c_rstFile.c_str()));

  0064a	56		 push	 esi
  0064b	50		 push	 eax
  0064c	ff 75 a0	 push	 DWORD PTR _name$1$[ebp]
  0064f	ff 75 a4	 push	 DWORD PTR _idx$1$[ebp]
  00652	68 00 00 00 00	 push	 OFFSET ??_C@_06GEDDNFGH@?$CIisss?$CJ?$AA@
  00657	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0065d	83 c4 14	 add	 esp, 20			; 00000014H
  00660	50		 push	 eax
  00661	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JCGLEGP@BINARY_RecvQuest?$AA@

; 600  : 				}
; 601  : 			}
; 602  : 			break;

  00666	e9 a3 05 00 00	 jmp	 $LN281@ProcessEve
$LN30@ProcessEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 27   : 		return (*ms_singleton);

  0066b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonMiniMap@@@@0PAVCPythonMiniMap@@A ; CSingleton<CPythonMiniMap>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 614  : 			CPythonMiniMap::Instance().SetAtlasCenterPosition(atoi(GetArgument("x", ScriptCommand.argList)),atoi(GetArgument("y", ScriptCommand.argList)));

  00671	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00674	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01EANLCPLP@y?$AA@
  00679	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0067e	50		 push	 eax
  0067f	e8 00 00 00 00	 call	 __atoi64
  00684	83 c4 04	 add	 esp, 4
  00687	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  0068a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01FJMABOPO@x?$AA@
  0068f	50		 push	 eax
  00690	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00695	50		 push	 eax
  00696	e8 00 00 00 00	 call	 __atoi64
  0069b	83 c4 04	 add	 esp, 4
  0069e	8b ce		 mov	 ecx, esi
  006a0	50		 push	 eax
  006a1	e8 00 00 00 00	 call	 ?SetAtlasCenterPosition@CPythonMiniMap@@QAEXHH@Z ; CPythonMiniMap::SetAtlasCenterPosition

; 615  : 			break;

  006a6	e9 6e 05 00 00	 jmp	 $LN65@ProcessEve
$LN29@ProcessEve:

; 616  : 		}
; 617  : 		case EVENT_TYPE_SLEEP:
; 618  : 			pEventSet->lLastDelayTime = atoi(GetArgument("value", ScriptCommand.argList));

  006ab	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  006ae	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05MFEJDJP@value?$AA@
  006b3	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  006b8	50		 push	 eax
  006b9	e8 00 00 00 00	 call	 __atoi64
  006be	83 c4 04	 add	 esp, 4
  006c1	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 619  : 			break;

  006c4	e9 50 05 00 00	 jmp	 $LN65@ProcessEve
$LN28@ProcessEve:

; 620  : 		case EVENT_TYPE_SET_CAMERA:
; 621  : 		{
; 622  : 			IAbstractApplication::SCameraSetting CameraSetting;

  006c9	8d 4d a8	 lea	 ecx, DWORD PTR _CameraSetting$8[ebp]
  006cc	e8 00 00 00 00	 call	 ??0SCameraSetting@IAbstractApplication@@QAE@XZ ; IAbstractApplication::SCameraSetting::SCameraSetting

; 623  : 			GetCameraSettingFromArgList(ScriptCommand.argList, &CameraSetting);

  006d1	8d 55 a8	 lea	 edx, DWORD PTR _CameraSetting$8[ebp]
  006d4	8d 4d e4	 lea	 ecx, DWORD PTR _ScriptCommand$[ebp+24]
  006d7	e8 00 00 00 00	 call	 ?GetCameraSettingFromArgList@@YAXAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@PAUSCameraSetting@IAbstractApplication@@@Z ; GetCameraSettingFromArgList

; 624  : 			rApp.SetEventCamera(CameraSetting);

  006dc	8b 06		 mov	 eax, DWORD PTR [esi]
  006de	8d 4d a8	 lea	 ecx, DWORD PTR _CameraSetting$8[ebp]
  006e1	51		 push	 ecx
  006e2	8b ce		 mov	 ecx, esi
  006e4	ff 50 1c	 call	 DWORD PTR [eax+28]

; 625  : 			break;

  006e7	e9 2d 05 00 00	 jmp	 $LN65@ProcessEve
$LN27@ProcessEve:

; 626  : 		}
; 627  : 		case EVENT_TYPE_BLEND_CAMERA:
; 628  : 		{
; 629  : 			IAbstractApplication::SCameraSetting CameraSetting;

  006ec	8d 4d a8	 lea	 ecx, DWORD PTR _CameraSetting$7[ebp]
  006ef	e8 00 00 00 00	 call	 ??0SCameraSetting@IAbstractApplication@@QAE@XZ ; IAbstractApplication::SCameraSetting::SCameraSetting

; 630  : 			GetCameraSettingFromArgList(ScriptCommand.argList, &CameraSetting);

  006f4	8d 55 a8	 lea	 edx, DWORD PTR _CameraSetting$7[ebp]
  006f7	8d 4d e4	 lea	 ecx, DWORD PTR _ScriptCommand$[ebp+24]
  006fa	e8 00 00 00 00	 call	 ?GetCameraSettingFromArgList@@YAXAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@PAUSCameraSetting@IAbstractApplication@@@Z ; GetCameraSettingFromArgList

; 631  : 
; 632  : 			float fBlendTime = atoi(GetArgument("blendtime", ScriptCommand.argList));

  006ff	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00702	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09LBCONMEI@blendtime?$AA@
  00707	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0070c	50		 push	 eax
  0070d	e8 00 00 00 00	 call	 __atoi64
  00712	83 c4 04	 add	 esp, 4
  00715	8b c8		 mov	 ecx, eax
  00717	e8 00 00 00 00	 call	 __ltod3

; 633  : 
; 634  : 			rApp.BlendEventCamera(CameraSetting, fBlendTime);

  0071c	8b 06		 mov	 eax, DWORD PTR [esi]
  0071e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00722	51		 push	 ecx
  00723	8d 4d a8	 lea	 ecx, DWORD PTR _CameraSetting$7[ebp]
  00726	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0072b	51		 push	 ecx
  0072c	8b ce		 mov	 ecx, esi
  0072e	ff 50 20	 call	 DWORD PTR [eax+32]

; 635  : 			break;

  00731	e9 e3 04 00 00	 jmp	 $LN65@ProcessEve
$LN26@ProcessEve:

; 636  : 		}
; 637  : 		case EVENT_TYPE_RESTORE_CAMERA:
; 638  : 		{
; 639  : 			rApp.SetDefaultCamera();

  00736	8b 06		 mov	 eax, DWORD PTR [esi]
  00738	8b ce		 mov	 ecx, esi
  0073a	ff 50 24	 call	 DWORD PTR [eax+36]

; 640  : 			break;

  0073d	e9 d7 04 00 00	 jmp	 $LN65@ProcessEve
$LN25@ProcessEve:

; 641  : 		}
; 642  : 		case EVENT_TYPE_FADE_OUT:
; 643  : 		{
; 644  : 			float fSpeed = (float)atof(GetArgument("speed", ScriptCommand.argList));

  00742	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00745	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05HJCMGBKF@speed?$AA@
  0074a	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0074f	50		 push	 eax
  00750	e8 00 00 00 00	 call	 _atof
  00755	d9 5d 9c	 fstp	 DWORD PTR _fSpeed$3[ebp]
  00758	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _fSpeed$3[ebp]

; 645  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "FadeOut", Py_BuildValue("(f)", fSpeed));

  0075d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00760	51		 push	 ecx
  00761	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00766	68 00 00 00 00	 push	 OFFSET ??_C@_03LDCBIPEL@?$CIf?$CJ?$AA@
  0076b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00771	83 c4 0c	 add	 esp, 12			; 0000000cH
  00774	50		 push	 eax
  00775	68 00 00 00 00	 push	 OFFSET ??_C@_07EAEHEHPO@FadeOut?$AA@
$LN284@ProcessEve:
  0077a	ff b3 d0 00 00
	00		 push	 DWORD PTR [ebx+208]
  00780	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 646  : 			pEventSet->isWaitFlag = true;

  00785	c6 83 cd 00 00
	00 01		 mov	 BYTE PTR [ebx+205], 1

; 647  : 			break;

  0078c	e9 85 04 00 00	 jmp	 $LN282@ProcessEve
$LN24@ProcessEve:

; 648  : 		}
; 649  : 		case EVENT_TYPE_FADE_IN:
; 650  : 		{
; 651  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "FadeIn", Py_BuildValue("(f)", atof(GetArgument("speed", ScriptCommand.argList))));

  00791	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00794	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05HJCMGBKF@speed?$AA@
  00799	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0079e	50		 push	 eax
  0079f	e8 00 00 00 00	 call	 _atof
  007a4	51		 push	 ecx
  007a5	dd 1c 24	 fstp	 QWORD PTR [esp]
  007a8	68 00 00 00 00	 push	 OFFSET ??_C@_03LDCBIPEL@?$CIf?$CJ?$AA@
  007ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  007b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  007b6	50		 push	 eax
  007b7	68 00 00 00 00	 push	 OFFSET ??_C@_06GCJPJKOH@FadeIn?$AA@

; 652  : 			pEventSet->isWaitFlag = true;
; 653  : 			break;

  007bc	eb bc		 jmp	 SHORT $LN284@ProcessEve
$LN23@ProcessEve:

; 654  : 		}
; 655  : 		case EVENT_TYPE_WHITE_OUT:
; 656  : 		{
; 657  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "WhiteOut", Py_BuildValue("(f)", atof(GetArgument("speed", ScriptCommand.argList))));

  007be	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  007c1	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05HJCMGBKF@speed?$AA@
  007c6	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  007cb	50		 push	 eax
  007cc	e8 00 00 00 00	 call	 _atof
  007d1	51		 push	 ecx
  007d2	dd 1c 24	 fstp	 QWORD PTR [esp]
  007d5	68 00 00 00 00	 push	 OFFSET ??_C@_03LDCBIPEL@?$CIf?$CJ?$AA@
  007da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  007e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  007e3	50		 push	 eax
  007e4	68 00 00 00 00	 push	 OFFSET ??_C@_08JJKJMBO@WhiteOut?$AA@

; 658  : 			pEventSet->isWaitFlag = true;
; 659  : 			break;

  007e9	eb 8f		 jmp	 SHORT $LN284@ProcessEve
$LN22@ProcessEve:

; 660  : 		}
; 661  : 		case EVENT_TYPE_WHITE_IN:
; 662  : 		{
; 663  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "WhiteIn", Py_BuildValue("(f)", atof(GetArgument("speed", ScriptCommand.argList))));

  007eb	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  007ee	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05HJCMGBKF@speed?$AA@
  007f3	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  007f8	50		 push	 eax
  007f9	e8 00 00 00 00	 call	 _atof
  007fe	51		 push	 ecx
  007ff	dd 1c 24	 fstp	 QWORD PTR [esp]
  00802	68 00 00 00 00	 push	 OFFSET ??_C@_03LDCBIPEL@?$CIf?$CJ?$AA@
  00807	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0080d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00810	50		 push	 eax
  00811	68 00 00 00 00	 push	 OFFSET ??_C@_07NGADDHAB@WhiteIn?$AA@

; 664  : 			pEventSet->isWaitFlag = true;
; 665  : 			break;

  00816	e9 5f ff ff ff	 jmp	 $LN284@ProcessEve
$LN20@ProcessEve:

; 666  : 		}
; 667  : 		case EVENT_TYPE_CLEAR_TEXT:
; 668  : 		{
; 669  : 			ClearLine(pEventSet);
; 670  : 			break;
; 671  : 		}
; 672  : 		case EVENT_TYPE_TEXT_HORIZONTAL_ALIGN_CENTER:
; 673  : 		{
; 674  : 			pEventSet->isTextCenterMode = true;
; 675  : 			if (pEventSet->pCurrentTextLine)

  0081b	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  0081e	c6 83 cc 00 00
	00 01		 mov	 BYTE PTR [ebx+204], 1
  00825	85 c9		 test	 ecx, ecx
  00827	0f 84 ec 03 00
	00		 je	 $LN65@ProcessEve

; 676  : 				pEventSet->pCurrentTextLine->SetHorizonalAlign(CGraphicTextInstance::HORIZONTAL_ALIGN_CENTER);

  0082d	6a 02		 push	 2
  0082f	e8 00 00 00 00	 call	 ?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z ; CGraphicTextInstance::SetHorizonalAlign

; 677  : 			break;

  00834	e9 e0 03 00 00	 jmp	 $LN65@ProcessEve
$LN18@ProcessEve:

; 678  : 		}
; 679  : 		case EVENT_TYPE_TITLE_IMAGE:
; 680  : 		{
; 681  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "OnTitleImage", Py_BuildValue("(s)", GetArgument("src", ScriptCommand.argList)));

  00839	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  0083c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03LOJEKLML@src?$AA@
  00841	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00846	50		 push	 eax
  00847	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  0084c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00852	50		 push	 eax
  00853	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CCHILNPP@OnTitleImage?$AA@
  00858	ff b3 d0 00 00
	00		 push	 DWORD PTR [ebx+208]
  0085e	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00863	83 c4 14	 add	 esp, 20			; 00000014H

; 682  : 			break;

  00866	e9 ae 03 00 00	 jmp	 $LN65@ProcessEve
$LN17@ProcessEve:

; 683  : 		}
; 684  : 		case EVENT_TYPE_DUNGEON_RESULT:
; 685  : 		{
; 686  : 			int killstone_count = atoi(GetArgument("killstone_count", ScriptCommand.argList));

  0086b	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  0086e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BA@FCPOOKJM@killstone_count?$AA@
  00873	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00878	50		 push	 eax
  00879	e8 00 00 00 00	 call	 __atoi64
  0087e	83 c4 04	 add	 esp, 4
  00881	89 45 98	 mov	 DWORD PTR _killstone_count$1$[ebp], eax

; 687  : 			int killmob_count = atoi(GetArgument("killmob_count", ScriptCommand.argList));

  00884	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00887	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0O@DDDIKPAP@killmob_count?$AA@
  0088c	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00891	50		 push	 eax
  00892	e8 00 00 00 00	 call	 __atoi64
  00897	83 c4 04	 add	 esp, 4
  0089a	89 45 90	 mov	 DWORD PTR _killmob_count$1$[ebp], eax

; 688  : 			int find_hidden = atoi(GetArgument("find_hidden", ScriptCommand.argList));

  0089d	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  008a0	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@NAENPPOP@find_hidden?$AA@
  008a5	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  008aa	50		 push	 eax
  008ab	e8 00 00 00 00	 call	 __atoi64
  008b0	83 c4 04	 add	 esp, 4
  008b3	89 45 94	 mov	 DWORD PTR _find_hidden$1$[ebp], eax

; 689  : 			int hidden_total = atoi(GetArgument("hidden_total", ScriptCommand.argList));

  008b6	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  008b9	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0N@MAFIFFGH@hidden_total?$AA@
  008be	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  008c3	50		 push	 eax
  008c4	e8 00 00 00 00	 call	 __atoi64
  008c9	83 c4 04	 add	 esp, 4
  008cc	89 45 a0	 mov	 DWORD PTR _hidden_total$1$[ebp], eax

; 690  : 			int use_potion = atoi(GetArgument("use_potion", ScriptCommand.argList));

  008cf	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  008d2	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@HLMCPCKO@use_potion?$AA@
  008d7	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  008dc	50		 push	 eax
  008dd	e8 00 00 00 00	 call	 __atoi64
  008e2	83 c4 04	 add	 esp, 4
  008e5	89 45 9c	 mov	 DWORD PTR _use_potion$1$[ebp], eax

; 691  : 			int is_revived = atoi(GetArgument("is_revived", ScriptCommand.argList));

  008e8	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  008eb	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@HAAPAAPF@is_revived?$AA@
  008f0	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  008f5	50		 push	 eax
  008f6	e8 00 00 00 00	 call	 __atoi64
  008fb	83 c4 04	 add	 esp, 4

; 692  : 			int killallmob = atoi(GetArgument("killallmob", ScriptCommand.argList));

  008fe	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00901	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@CEFFAPEL@killallmob?$AA@
  00906	8b d8		 mov	 ebx, eax
  00908	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0090d	50		 push	 eax
  0090e	e8 00 00 00 00	 call	 __atoi64
  00913	83 c4 04	 add	 esp, 4

; 693  : 			int total_time = atoi(GetArgument("total_time", ScriptCommand.argList));

  00916	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00919	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@OIFGKHMH@total_time?$AA@
  0091e	8b f8		 mov	 edi, eax
  00920	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00925	50		 push	 eax
  00926	e8 00 00 00 00	 call	 __atoi64
  0092b	83 c4 04	 add	 esp, 4

; 694  : 			int bonus_exp = atoi(GetArgument("bonus_exp", ScriptCommand.argList));

  0092e	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00931	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09HPFMCAOO@bonus_exp?$AA@
  00936	8b f0		 mov	 esi, eax
  00938	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0093d	50		 push	 eax
  0093e	e8 00 00 00 00	 call	 __atoi64
  00943	83 c4 04	 add	 esp, 4

; 695  : 
; 696  : 			PyCallClassMemberFunc(m_poInterface, "ShowDungeonResult", 
; 697  : 								  Py_BuildValue("(iiiiiiiii)",
; 698  : 												killstone_count,
; 699  : 												killmob_count,
; 700  : 												find_hidden,
; 701  : 												hidden_total,
; 702  : 												use_potion,
; 703  : 												is_revived,
; 704  : 												killallmob,
; 705  : 												total_time,
; 706  : 												bonus_exp));

  00946	50		 push	 eax
  00947	56		 push	 esi
  00948	57		 push	 edi
  00949	53		 push	 ebx
  0094a	ff 75 9c	 push	 DWORD PTR _use_potion$1$[ebp]
  0094d	ff 75 a0	 push	 DWORD PTR _hidden_total$1$[ebp]
  00950	ff 75 94	 push	 DWORD PTR _find_hidden$1$[ebp]
  00953	ff 75 90	 push	 DWORD PTR _killmob_count$1$[ebp]
  00956	ff 75 98	 push	 DWORD PTR _killstone_count$1$[ebp]
  00959	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EDIBAKKL@?$CIiiiiiiiii?$CJ?$AA@
  0095e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00964	50		 push	 eax
  00965	8b 45 a4	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00968	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GLAGHMFL@ShowDungeonResult?$AA@
  0096d	ff 70 64	 push	 DWORD PTR [eax+100]
  00970	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00975	83 c4 34	 add	 esp, 52			; 00000034H

; 707  : 			break;

  00978	e9 9c 02 00 00	 jmp	 $LN65@ProcessEve
$LN16@ProcessEve:

; 708  : 		}
; 709  : 		case EVENT_TYPE_ITEM_NAME:
; 710  : 		{
; 711  : 			int iIndex = atoi(GetArgument("value", ScriptCommand.argList));

  0097d	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00980	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05MFEJDJP@value?$AA@
  00985	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  0098a	50		 push	 eax
  0098b	e8 00 00 00 00	 call	 __atoi64
  00990	83 c4 04	 add	 esp, 4

; 712  : 			CItemData * pItemData;
; 713  : 			if (CItemManager::Instance().GetItemDataPointer(iIndex, &pItemData))

  00993	8d 4d a4	 lea	 ecx, DWORD PTR _pItemData$5[ebp]
  00996	51		 push	 ecx
  00997	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  0099d	50		 push	 eax
  0099e	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  009a3	85 c0		 test	 eax, eax
  009a5	0f 84 6e 02 00
	00		 je	 $LN65@ProcessEve

; 714  : 			{
; 715  : 				pEventSet->strCurrentLine.append(pItemData->GetName());

  009ab	8b 4d a4	 mov	 ecx, DWORD PTR _pItemData$5[ebp]
  009ae	8d 73 30	 lea	 esi, DWORD PTR [ebx+48]
  009b1	e8 00 00 00 00	 call	 ?GetName@CItemData@@QBEPBDXZ ; CItemData::GetName
  009b6	50		 push	 eax
  009b7	8b ce		 mov	 ecx, esi
  009b9	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  009be	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  009c2	72 02		 jb	 SHORT $LN187@ProcessEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  009c4	8b 36		 mov	 esi, DWORD PTR [esi]
$LN187@ProcessEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 716  : 				pEventSet->pCurrentTextLine->SetValue(pEventSet->strCurrentLine.c_str());

  009c6	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  009c9	6a ff		 push	 -1
  009cb	56		 push	 esi
  009cc	e8 00 00 00 00	 call	 ?SetValue@CGraphicTextInstance@@QAEXPBDI@Z ; CGraphicTextInstance::SetValue

; 717  : 				pEventSet->pCurrentTextLine->SetColor(1.0f, 0.2f, 0.2f);

  009d1	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  009d4	83 ec 10	 sub	 esp, 16			; 00000010H
  009d7	c7 44 24 0c 00
	00 80 3f	 mov	 DWORD PTR [esp+12], 1065353216 ; 3f800000H
  009df	c7 44 24 08 cd
	cc 4c 3e	 mov	 DWORD PTR [esp+8], 1045220557 ; 3e4ccccdH
  009e7	c7 44 24 04 cd
	cc 4c 3e	 mov	 DWORD PTR [esp+4], 1045220557 ; 3e4ccccdH
  009ef	c7 04 24 00 00
	80 3f		 mov	 DWORD PTR [esp], 1065353216 ; 3f800000H
  009f6	e8 00 00 00 00	 call	 ?SetColor@CGraphicTextInstance@@QAEXMMMM@Z ; CGraphicTextInstance::SetColor

; 718  : 				pEventSet->iCurrentLetter+= strlen(pItemData->GetName());

  009fb	8b 4d a4	 mov	 ecx, DWORD PTR _pItemData$5[ebp]
  009fe	e8 00 00 00 00	 call	 ?GetName@CItemData@@QBEPBDXZ ; CItemData::GetName
  00a03	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL277@ProcessEve:
  00a06	8a 08		 mov	 cl, BYTE PTR [eax]
  00a08	40		 inc	 eax
  00a09	84 c9		 test	 cl, cl
  00a0b	75 f9		 jne	 SHORT $LL277@ProcessEve
  00a0d	2b c2		 sub	 eax, edx
  00a0f	01 43 1c	 add	 DWORD PTR [ebx+28], eax
  00a12	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]

; 719  : 
; 720  : 				if (pEventSet->iCurrentLetter >= pEventSet->iRestrictedCharacterCount)

  00a15	3b 83 c4 00 00
	00		 cmp	 eax, DWORD PTR [ebx+196]
  00a1b	0f 8c 26 f7 ff
	ff		 jl	 $LN63@ProcessEve

; 721  : 					__InsertLine(*pEventSet);

  00a21	6a 00		 push	 0
  00a23	6a 00		 push	 0
  00a25	53		 push	 ebx
  00a26	8b cf		 mov	 ecx, edi
  00a28	e8 00 00 00 00	 call	 ?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z ; CPythonEventManager::__InsertLine

; 722  : 
; 723  : 				pEventSet->lLastDelayTime = pEventSet->lWaitingTime;

  00a2d	8b 83 c0 00 00
	00		 mov	 eax, DWORD PTR [ebx+192]
  00a33	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 724  : 			}
; 725  : 
; 726  : 			break;

  00a36	e9 de 01 00 00	 jmp	 $LN65@ProcessEve
$LN13@ProcessEve:

; 727  : 		}
; 728  : 		case EVENT_TYPE_MONSTER_NAME:
; 729  : 		{
; 730  : 			int iIndex = atoi(GetArgument("value", ScriptCommand.argList));

  00a3b	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00a3e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05MFEJDJP@value?$AA@
  00a43	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00a48	50		 push	 eax
  00a49	e8 00 00 00 00	 call	 __atoi64
  00a4e	83 c4 04	 add	 esp, 4

; 731  : 			const char * c_szName;
; 732  : 
; 733  : 			CPythonNonPlayer& rkNonPlayer=CPythonNonPlayer::Instance();
; 734  : 			if (rkNonPlayer.GetName(iIndex, &c_szName))

  00a51	8d 4d 98	 lea	 ecx, DWORD PTR _c_szName$2[ebp]
  00a54	51		 push	 ecx
  00a55	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNonPlayer@@@@0PAVCPythonNonPlayer@@A ; CSingleton<CPythonNonPlayer>::ms_singleton
  00a5b	50		 push	 eax
  00a5c	e8 00 00 00 00	 call	 ?GetName@CPythonNonPlayer@@QAE_NKPAPBD@Z ; CPythonNonPlayer::GetName
  00a61	84 c0		 test	 al, al
  00a63	0f 84 b0 01 00
	00		 je	 $LN65@ProcessEve

; 735  : 			{
; 736  : 				pEventSet->strCurrentLine.append(c_szName);

  00a69	8b 75 98	 mov	 esi, DWORD PTR _c_szName$2[ebp]
  00a6c	8d 4b 30	 lea	 ecx, DWORD PTR [ebx+48]
  00a6f	56		 push	 esi
  00a70	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00a75	83 7b 44 10	 cmp	 DWORD PTR [ebx+68], 16	; 00000010H
  00a79	8d 43 30	 lea	 eax, DWORD PTR [ebx+48]
  00a7c	72 02		 jb	 SHORT $LN197@ProcessEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00a7e	8b 00		 mov	 eax, DWORD PTR [eax]
$LN197@ProcessEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 737  : 				pEventSet->pCurrentTextLine->SetValue(pEventSet->strCurrentLine.c_str());

  00a80	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  00a83	6a ff		 push	 -1
  00a85	50		 push	 eax
  00a86	e8 00 00 00 00	 call	 ?SetValue@CGraphicTextInstance@@QAEXPBDI@Z ; CGraphicTextInstance::SetValue

; 738  : 				pEventSet->iCurrentLetter+= strlen(c_szName);

  00a8b	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00a8e	8b ff		 npad	 2
$LL278@ProcessEve:
  00a90	8a 06		 mov	 al, BYTE PTR [esi]
  00a92	46		 inc	 esi
  00a93	84 c0		 test	 al, al
  00a95	75 f9		 jne	 SHORT $LL278@ProcessEve
  00a97	2b f1		 sub	 esi, ecx
  00a99	01 73 1c	 add	 DWORD PTR [ebx+28], esi
  00a9c	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]

; 739  : 
; 740  : 				if (pEventSet->iCurrentLetter >= pEventSet->iRestrictedCharacterCount)

  00a9f	3b 83 c4 00 00
	00		 cmp	 eax, DWORD PTR [ebx+196]
  00aa5	0f 8c 9c f6 ff
	ff		 jl	 $LN63@ProcessEve

; 741  : 					__InsertLine(*pEventSet);

  00aab	6a 00		 push	 0
  00aad	6a 00		 push	 0
  00aaf	53		 push	 ebx
  00ab0	8b cf		 mov	 ecx, edi
  00ab2	e8 00 00 00 00	 call	 ?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z ; CPythonEventManager::__InsertLine

; 742  : 
; 743  : 				pEventSet->lLastDelayTime = pEventSet->lWaitingTime;

  00ab7	8b 83 c0 00 00
	00		 mov	 eax, DWORD PTR [ebx+192]
  00abd	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 744  : 			}
; 745  : 
; 746  : 			break;

  00ac0	e9 54 01 00 00	 jmp	 $LN65@ProcessEve
$LN10@ProcessEve:

; 747  : 		}
; 748  : 		case EVENT_TYPE_WINDOW_SIZE:
; 749  : 		{
; 750  : 			int iWidth = atoi(GetArgument("width", ScriptCommand.argList));

  00ac5	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00ac8	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05IGKADHGO@width?$AA@
  00acd	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00ad2	50		 push	 eax
  00ad3	e8 00 00 00 00	 call	 __atoi64
  00ad8	83 c4 04	 add	 esp, 4

; 751  : 			int iHeight = atoi(GetArgument("height", ScriptCommand.argList));

  00adb	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00ade	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_06LNLHEAAG@height?$AA@
  00ae3	8b f0		 mov	 esi, eax
  00ae5	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00aea	50		 push	 eax
  00aeb	e8 00 00 00 00	 call	 __atoi64
  00af0	83 c4 04	 add	 esp, 4

; 752  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "OnSize", Py_BuildValue("(ii)", iWidth, iHeight));

  00af3	50		 push	 eax
  00af4	56		 push	 esi
  00af5	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  00afa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00b00	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b03	50		 push	 eax
  00b04	68 00 00 00 00	 push	 OFFSET ??_C@_06JKFPDEMN@OnSize?$AA@
  00b09	ff b3 d0 00 00
	00		 push	 DWORD PTR [ebx+208]

; 753  : 			break;

  00b0f	e9 fd 00 00 00	 jmp	 $LN283@ProcessEve
$LN9@ProcessEve:

; 754  : 		}
; 755  : 		case EVENT_TYPE_INPUT:
; 756  : 		{
; 757  : 			__InsertLine(*pEventSet);

  00b14	6a 00		 push	 0
  00b16	6a 00		 push	 0
  00b18	53		 push	 ebx
  00b19	8b cf		 mov	 ecx, edi
  00b1b	e8 00 00 00 00	 call	 ?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z ; CPythonEventManager::__InsertLine

; 758  : 			PyCallClassMemberFunc(pEventSet->poEventHandler, "OnInput", Py_BuildValue("()"));

  00b20	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00b25	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00b2b	83 c4 04	 add	 esp, 4
  00b2e	50		 push	 eax
  00b2f	68 00 00 00 00	 push	 OFFSET ??_C@_07MNOKODDC@OnInput?$AA@
  00b34	ff b3 d0 00 00
	00		 push	 DWORD PTR [ebx+208]

; 759  : 			break;

  00b3a	e9 d2 00 00 00	 jmp	 $LN283@ProcessEve
$LN8@ProcessEve:

; 760  : 		}
; 761  : 		case EVENT_TYPE_CONFIRM_WAIT:
; 762  : 		{
; 763  : 			int iTimeOut = atoi(GetArgument("timeout", ScriptCommand.argList));

  00b3f	8d 55 e4	 lea	 edx, DWORD PTR _ScriptCommand$[ebp+24]
  00b42	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07DDHNKDGP@timeout?$AA@
  00b47	e8 00 00 00 00	 call	 ?GetArgument@@YAPBDPBDAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; GetArgument
  00b4c	50		 push	 eax
  00b4d	e8 00 00 00 00	 call	 __atoi64

; 764  : 			pEventSet->isConfirmWait = TRUE;
; 765  : 			pEventSet->pConfirmTimeTextLine = pEventSet->pCurrentTextLine;

  00b52	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  00b55	83 c4 04	 add	 esp, 4
  00b58	8b f0		 mov	 esi, eax
  00b5a	c7 43 54 01 00
	00 00		 mov	 DWORD PTR [ebx+84], 1
  00b61	89 4b 58	 mov	 DWORD PTR [ebx+88], ecx

; 766  : 			pEventSet->iConfirmEndTime = timeGetTime()/1000 + iTimeOut;

  00b64	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00b6a	8b c8		 mov	 ecx, eax
  00b6c	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00b71	f7 e1		 mul	 ecx

; 767  : 			__InsertLine(*pEventSet, TRUE);

  00b73	6a 00		 push	 0
  00b75	c1 ea 06	 shr	 edx, 6
  00b78	8b cf		 mov	 ecx, edi
  00b7a	6a 01		 push	 1
  00b7c	03 d6		 add	 edx, esi
  00b7e	53		 push	 ebx
  00b7f	89 53 5c	 mov	 DWORD PTR [ebx+92], edx
  00b82	e8 00 00 00 00	 call	 ?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z ; CPythonEventManager::__InsertLine

; 768  : 			MakeNextButton(pEventSet, BUTTON_TYPE_CANCEL);

  00b87	6a 02		 push	 2
  00b89	53		 push	 ebx
  00b8a	e8 00 00 00 00	 call	 ?MakeNextButton@CPythonEventManager@@IAEXPAUSEventSet@1@H@Z ; CPythonEventManager::MakeNextButton

; 769  : 			break;

  00b8f	e9 85 00 00 00	 jmp	 $LN65@ProcessEve
$LN7@ProcessEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00b94	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 773  : 			for (DWORD i = 0; i < m_EventSetVector.size(); ++i)

  00b97	33 db		 xor	 ebx, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00b99	2b 47 0c	 sub	 eax, DWORD PTR [edi+12]
  00b9c	c1 f8 02	 sar	 eax, 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 773  : 			for (DWORD i = 0; i < m_EventSetVector.size(); ++i)

  00b9f	85 c0		 test	 eax, eax
  00ba1	74 76		 je	 SHORT $LN65@ProcessEve
$LL6@ProcessEve:

; 774  : 			{
; 775  : 				if (NULL == m_EventSetVector[i])

  00ba3	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00ba6	8b 34 98	 mov	 esi, DWORD PTR [eax+ebx*4]
  00ba9	85 f6		 test	 esi, esi
  00bab	74 3d		 je	 SHORT $LN5@ProcessEve

; 776  : 					continue;
; 777  : 
; 778  : 				TEventSet * pSet = m_EventSetVector[i];
; 779  : 				if (!pSet->isConfirmWait)

  00bad	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  00bb1	74 37		 je	 SHORT $LN5@ProcessEve

; 780  : 					continue;
; 781  : 
; 782  : 				pSet->isConfirmWait = FALSE;
; 783  : 				pSet->pConfirmTimeTextLine = NULL;
; 784  : 				pSet->iConfirmEndTime = 0;
; 785  : 
; 786  : 				PyCallClassMemberFunc(pSet->poEventHandler, "CloseSelf", Py_BuildValue("()"));

  00bb3	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00bb8	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0
  00bbf	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  00bc6	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
  00bcd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00bd3	83 c4 04	 add	 esp, 4
  00bd6	50		 push	 eax
  00bd7	68 00 00 00 00	 push	 OFFSET ??_C@_09FOPMPDJN@CloseSelf?$AA@
  00bdc	ff b6 d0 00 00
	00		 push	 DWORD PTR [esi+208]
  00be2	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00be7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@ProcessEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00bea	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 773  : 			for (DWORD i = 0; i < m_EventSetVector.size(); ++i)

  00bed	43		 inc	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00bee	2b 47 0c	 sub	 eax, DWORD PTR [edi+12]
  00bf1	c1 f8 02	 sar	 eax, 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 773  : 			for (DWORD i = 0; i < m_EventSetVector.size(); ++i)

  00bf4	3b d8		 cmp	 ebx, eax
  00bf6	72 ab		 jb	 SHORT $LL6@ProcessEve

; 787  : 			}
; 788  : 			break;

  00bf8	eb 1f		 jmp	 SHORT $LN65@ProcessEve
$LN1@ProcessEve:

; 789  : 		}
; 790  : 		case EVENT_TYPE_SELECT_ITEM:
; 791  : 		{
; 792  : 			PyCallClassMemberFunc(m_poInterface, "BINARY_OpenSelectItemWindow", Py_BuildValue("()"));

  00bfa	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00bff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00c05	83 c4 04	 add	 esp, 4
  00c08	50		 push	 eax
  00c09	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GFGEFDCO@BINARY_OpenSelectItemWindow?$AA@
$LN281@ProcessEve:
  00c0e	ff 77 64	 push	 DWORD PTR [edi+100]
$LN283@ProcessEve:
  00c11	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
$LN282@ProcessEve:
  00c16	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN65@ProcessEve:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1883 : 		clear();

  00c19	8d 4d e4	 lea	 ecx, DWORD PTR _ScriptCommand$[ebp+24]
  00c1c	e8 00 00 00 00	 call	 ?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00c21	ff 75 e4	 push	 DWORD PTR _ScriptCommand$[ebp+24]
  00c24	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c29	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00c2c	83 7d e0 10	 cmp	 DWORD PTR _ScriptCommand$[ebp+20], 16 ; 00000010H
  00c30	72 0b		 jb	 SHORT $LN257@ProcessEve
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00c32	ff 75 cc	 push	 DWORD PTR _ScriptCommand$[ebp]
  00c35	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c3a	83 c4 04	 add	 esp, 4
$LN257@ProcessEve:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 796  : }

  00c3d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00c40	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00c47	59		 pop	 ecx
  00c48	5f		 pop	 edi
  00c49	5e		 pop	 esi
  00c4a	5b		 pop	 ebx
  00c4b	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c4e	33 cd		 xor	 ecx, ebp
  00c50	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c55	8b e5		 mov	 esp, ebp
  00c57	5d		 pop	 ebp
  00c58	c2 04 00	 ret	 4
  00c5b	90		 npad	 1
$LN285@ProcessEve:
  00c5c	00 00 00 00	 DD	 $LN64@ProcessEve
  00c60	00 00 00 00	 DD	 $LN59@ProcessEve
  00c64	00 00 00 00	 DD	 $LN62@ProcessEve
  00c68	00 00 00 00	 DD	 $LN53@ProcessEve
  00c6c	00 00 00 00	 DD	 $LN52@ProcessEve
  00c70	00 00 00 00	 DD	 $LN49@ProcessEve
  00c74	00 00 00 00	 DD	 $LN48@ProcessEve
  00c78	00 00 00 00	 DD	 $LN51@ProcessEve
  00c7c	00 00 00 00	 DD	 $LN50@ProcessEve
  00c80	00 00 00 00	 DD	 $LN47@ProcessEve
  00c84	00 00 00 00	 DD	 $LN46@ProcessEve
  00c88	00 00 00 00	 DD	 $LN45@ProcessEve
  00c8c	00 00 00 00	 DD	 $LN44@ProcessEve
  00c90	00 00 00 00	 DD	 $LN40@ProcessEve
  00c94	00 00 00 00	 DD	 $LN39@ProcessEve
  00c98	00 00 00 00	 DD	 $LN65@ProcessEve
  00c9c	00 00 00 00	 DD	 $LN65@ProcessEve
  00ca0	00 00 00 00	 DD	 $LN30@ProcessEve
  00ca4	00 00 00 00	 DD	 $LN37@ProcessEve
  00ca8	00 00 00 00	 DD	 $LN38@ProcessEve
  00cac	00 00 00 00	 DD	 $LN29@ProcessEve
  00cb0	00 00 00 00	 DD	 $LN28@ProcessEve
  00cb4	00 00 00 00	 DD	 $LN27@ProcessEve
  00cb8	00 00 00 00	 DD	 $LN26@ProcessEve
  00cbc	00 00 00 00	 DD	 $LN25@ProcessEve
  00cc0	00 00 00 00	 DD	 $LN24@ProcessEve
  00cc4	00 00 00 00	 DD	 $LN23@ProcessEve
  00cc8	00 00 00 00	 DD	 $LN22@ProcessEve
  00ccc	00 00 00 00	 DD	 $LN49@ProcessEve
  00cd0	00 00 00 00	 DD	 $LN20@ProcessEve
  00cd4	00 00 00 00	 DD	 $LN18@ProcessEve
  00cd8	00 00 00 00	 DD	 $LN65@ProcessEve
  00cdc	00 00 00 00	 DD	 $LN17@ProcessEve
  00ce0	00 00 00 00	 DD	 $LN16@ProcessEve
  00ce4	00 00 00 00	 DD	 $LN13@ProcessEve
  00ce8	00 00 00 00	 DD	 $LN56@ProcessEve
  00cec	00 00 00 00	 DD	 $LN10@ProcessEve
  00cf0	00 00 00 00	 DD	 $LN9@ProcessEve
  00cf4	00 00 00 00	 DD	 $LN8@ProcessEve
  00cf8	00 00 00 00	 DD	 $LN7@ProcessEve
  00cfc	00 00 00 00	 DD	 $LN43@ProcessEve
  00d00	00 00 00 00	 DD	 $LN1@ProcessEve
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z$1:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _ScriptCommand$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z$0:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR _ScriptCommand$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1SCmd@script@@QAE@XZ
__ehhandler$?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ProcessEventSet@CPythonEventManager@@IAEXPAUSEventSet@1@@Z ENDP ; CPythonEventManager::ProcessEventSet
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?RenderEventSet@CPythonEventManager@@QAEXH@Z
_TEXT	SEGMENT
_iCount$1$ = 8						; size = 4
_iIndex$ = 8						; size = 4
?RenderEventSet@CPythonEventManager@@QAEXH@Z PROC	; CPythonEventManager::RenderEventSet, COMDAT
; _this$ = ecx

; 799  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 800  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00007	53		 push	 ebx
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	0f 84 7c 00 00
	00		 je	 $LN1@RenderEven

; 801  : 		return;
; 802  : 
; 803  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00015	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00018	8b 1c 98	 mov	 ebx, DWORD PTR [eax+ebx*4]

; 804  : 	if (!pEventSet)

  0001b	85 db		 test	 ebx, ebx
  0001d	74 72		 je	 SHORT $LN1@RenderEven
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0001f	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 807  : 	int iCount = 0;

  00022	33 c9		 xor	 ecx, ecx
  00024	56		 push	 esi
  00025	89 4d 08	 mov	 DWORD PTR _iCount$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00028	8b 30		 mov	 esi, DWORD PTR [eax]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0002a	3b f0		 cmp	 esi, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 809  : 	for (TScriptTextLineList::iterator itor = pEventSet->ScriptTextLineList.begin(); itor != pEventSet->ScriptTextLineList.end(); ++itor, ++iCount)

  0002c	74 3a		 je	 SHORT $LN5@RenderEven
  0002e	57		 push	 edi
  0002f	90		 npad	 1
$LL7@RenderEven:

; 810  : 	{
; 811  : 		if (iCount < pEventSet->iVisibleStartLine)

  00030	8b 93 a4 00 00
	00		 mov	 edx, DWORD PTR [ebx+164]
  00036	3b ca		 cmp	 ecx, edx
  00038	7c 22		 jl	 SHORT $LN6@RenderEven

; 812  : 			continue;
; 813  : 
; 814  : 		if (iCount >= pEventSet->iVisibleStartLine + pEventSet->iVisibleLineCount)

  0003a	8b 83 a8 00 00
	00		 mov	 eax, DWORD PTR [ebx+168]
  00040	03 c2		 add	 eax, edx
  00042	3b c8		 cmp	 ecx, eax
  00044	7d 16		 jge	 SHORT $LN6@RenderEven

; 815  : 			continue;
; 816  : 
; 817  : 		TTextLine & rkLine = *itor;
; 818  : 		CGraphicTextInstance * pInstance = rkLine.pInstance;

  00046	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]

; 819  : 
; 820  : 		pInstance->Update();

  00049	8b cf		 mov	 ecx, edi
  0004b	e8 00 00 00 00	 call	 ?Update@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Update

; 821  : 		pInstance->Render();

  00050	6a 00		 push	 0
  00052	8b cf		 mov	 ecx, edi
  00054	e8 00 00 00 00	 call	 ?Render@CGraphicTextInstance@@QAEXPAUtagRECT@@@Z ; CGraphicTextInstance::Render
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _iCount$1$[ebp]
$LN6@RenderEven:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  0005c	8b 36		 mov	 esi, DWORD PTR [esi]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 809  : 	for (TScriptTextLineList::iterator itor = pEventSet->ScriptTextLineList.begin(); itor != pEventSet->ScriptTextLineList.end(); ++itor, ++iCount)

  0005e	41		 inc	 ecx
  0005f	89 4d 08	 mov	 DWORD PTR _iCount$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00062	3b 73 4c	 cmp	 esi, DWORD PTR [ebx+76]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 809  : 	for (TScriptTextLineList::iterator itor = pEventSet->ScriptTextLineList.begin(); itor != pEventSet->ScriptTextLineList.end(); ++itor, ++iCount)

  00065	75 c9		 jne	 SHORT $LL7@RenderEven
  00067	5f		 pop	 edi
$LN5@RenderEven:

; 822  : 	}
; 823  : 
; 824  : 	if (iCount >= pEventSet->iVisibleStartLine)

  00068	8b 93 a4 00 00
	00		 mov	 edx, DWORD PTR [ebx+164]
  0006e	5e		 pop	 esi
  0006f	3b ca		 cmp	 ecx, edx
  00071	7c 1e		 jl	 SHORT $LN1@RenderEven

; 825  : 	if (iCount < pEventSet->iVisibleStartLine + pEventSet->iVisibleLineCount)

  00073	8b 83 a8 00 00
	00		 mov	 eax, DWORD PTR [ebx+168]
  00079	03 c2		 add	 eax, edx
  0007b	3b c8		 cmp	 ecx, eax
  0007d	7d 12		 jge	 SHORT $LN1@RenderEven

; 826  : 	{
; 827  : 		pEventSet->pCurrentTextLine->Update();

  0007f	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  00082	e8 00 00 00 00	 call	 ?Update@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Update

; 828  : 		pEventSet->pCurrentTextLine->Render();

  00087	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  0008a	6a 00		 push	 0
  0008c	e8 00 00 00 00	 call	 ?Render@CGraphicTextInstance@@QAEXPAUtagRECT@@@Z ; CGraphicTextInstance::Render
$LN1@RenderEven:
  00091	5b		 pop	 ebx

; 829  : 	}
; 830  : }

  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?RenderEventSet@CPythonEventManager@@QAEXH@Z ENDP	; CPythonEventManager::RenderEventSet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?Skip@CPythonEventManager@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?Skip@CPythonEventManager@@QAEXH@Z PROC			; CPythonEventManager::Skip, COMDAT
; _this$ = ecx

; 833  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 834  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	74 23		 je	 SHORT $LN1@Skip

; 835  : 		return;
; 836  : 
; 837  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00011	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00014	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 838  : 
; 839  : 	if (true == pEventSet->isLock)

  00017	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0001b	75 10		 jne	 SHORT $LN2@Skip

; 840  : 	{
; 841  : 		pEventSet->lLastDelayTime = 0;

  0001d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 842  : 		pEventSet->isLock = false;

  00024	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  00028	5e		 pop	 esi

; 847  : 	}
; 848  : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN2@Skip:

; 843  : 	}
; 844  : 	else
; 845  : 	{
; 846  : 		pEventSet->lLastDelayTime = -1000;

  0002d	c7 40 18 18 fc
	ff ff		 mov	 DWORD PTR [eax+24], -1000 ; fffffc18H
$LN1@Skip:
  00034	5e		 pop	 esi

; 847  : 	}
; 848  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?Skip@CPythonEventManager@@QAEXH@Z ENDP			; CPythonEventManager::Skip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?IsWait@CPythonEventManager@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?IsWait@CPythonEventManager@@QAE_NH@Z PROC		; CPythonEventManager::IsWait, COMDAT
; _this$ = ecx

; 851  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 852  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	75 07		 jne	 SHORT $LN2@IsWait
$LN7@IsWait:

; 853  : 		return false;

  00011	32 c0		 xor	 al, al
  00013	5e		 pop	 esi

; 862  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@IsWait:

; 854  : 
; 855  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00018	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001b	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 856  : 	if (!pEventSet)

  0001e	85 c0		 test	 eax, eax
  00020	74 ef		 je	 SHORT $LN7@IsWait

; 857  : 	{
; 858  : 		return false;
; 859  : 	}
; 860  : 
; 861  : 	return pEventSet->isLock;

  00022	8a 40 14	 mov	 al, BYTE PTR [eax+20]
  00025	5e		 pop	 esi

; 862  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?IsWait@CPythonEventManager@@QAE_NH@Z ENDP		; CPythonEventManager::IsWait
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?EndEventProcess@CPythonEventManager@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?EndEventProcess@CPythonEventManager@@QAEXH@Z PROC	; CPythonEventManager::EndEventProcess, COMDAT
; _this$ = ecx

; 865  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 866  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	74 11		 je	 SHORT $LN3@EndEventPr

; 867  : 		return;
; 868  : 
; 869  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00011	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00014	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 870  : 	if (!pEventSet)

  00017	85 c0		 test	 eax, eax
  00019	74 07		 je	 SHORT $LN3@EndEventPr

; 871  : 	{
; 872  : 		return;
; 873  : 	}
; 874  : 
; 875  : 	pEventSet->isWaitFlag = false;

  0001b	c6 80 cd 00 00
	00 00		 mov	 BYTE PTR [eax+205], 0
$LN3@EndEventPr:
  00022	5e		 pop	 esi

; 876  : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?EndEventProcess@CPythonEventManager@@QAEXH@Z ENDP	; CPythonEventManager::EndEventProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?MakeNextButton@CPythonEventManager@@IAEXPAUSEventSet@1@H@Z
_TEXT	SEGMENT
_pEventSet$ = 8						; size = 4
_iButtonType$ = 12					; size = 4
?MakeNextButton@CPythonEventManager@@IAEXPAUSEventSet@1@H@Z PROC ; CPythonEventManager::MakeNextButton, COMDAT
; _this$dead$ = ecx

; 879  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 880  : 	__AddSpace(*pEventSet, c_fLine_Temp+5);

  00004	8b 75 08	 mov	 esi, DWORD PTR _pEventSet$[ebp]
  00007	6a 15		 push	 21			; 00000015H
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 ?__AddSpace@CPythonEventManager@@IAEXAAUSEventSet@1@H@Z ; CPythonEventManager::__AddSpace

; 881  : 	PyCallClassMemberFunc(pEventSet->poEventHandler, "MakeNextButton", Py_BuildValue("(i)", iButtonType));

  0000f	ff 75 0c	 push	 DWORD PTR _iButtonType$[ebp]
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001d	50		 push	 eax
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FONAKFHL@MakeNextButton?$AA@
  00023	ff b6 d0 00 00
	00		 push	 DWORD PTR [esi+208]
  00029	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
  00031	5e		 pop	 esi

; 882  : }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?MakeNextButton@CPythonEventManager@@IAEXPAUSEventSet@1@H@Z ENDP ; CPythonEventManager::MakeNextButton
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?MakeQuestion@CPythonEventManager@@IAEXPAUSEventSet@1@AAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z
_TEXT	SEGMENT
_pEventSet$ = 8						; size = 4
_rArgumentList$ = 12					; size = 4
?MakeQuestion@CPythonEventManager@@IAEXPAUSEventSet@1@AAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z PROC ; CPythonEventManager::MakeQuestion, COMDAT
; _this$dead$ = ecx

; 885  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1246 : 		return (this->_Mysize == 0);

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _rArgumentList$[ebp]
  00007	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0000a	85 c0		 test	 eax, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 886  : 	if (rArgumentList.empty())

  0000c	74 70		 je	 SHORT $LN1@MakeQuesti

; 887  : 		return;
; 888  : 
; 889  : 	PyCallClassMemberFunc(pEventSet->poEventHandler, "MakeQuestion", Py_BuildValue("(i)", rArgumentList.size()));

  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	50		 push	 eax
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001c	8b 75 08	 mov	 esi, DWORD PTR _pEventSet$[ebp]
  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NKMOFENJ@MakeQuestion?$AA@
  00025	ff b6 d0 00 00
	00		 push	 DWORD PTR [esi+208]
  0002b	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc

; 890  : 	pEventSet->nAnswer = rArgumentList.size();

  00030	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00033	83 c4 14	 add	 esp, 20			; 00000014H
  00036	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax

; 891  : 
; 892  : 	int iIndex = 0;

  0003c	33 ff		 xor	 edi, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0003e	8b 03		 mov	 eax, DWORD PTR [ebx]

; 44   : 		{	// construct with node pointer _Pnode

  00040	8b 30		 mov	 esi, DWORD PTR [eax]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00042	3b f0		 cmp	 esi, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 893  : 	for (script::TArgList::iterator itor=rArgumentList.begin(); itor!=rArgumentList.end(); ++itor)

  00044	74 36		 je	 SHORT $LN63@MakeQuesti
$LL27@MakeQuesti:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00046	83 7e 34 10	 cmp	 DWORD PTR [esi+52], 16	; 00000010H
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 896  : 		PyCallClassMemberFunc(pEventSet->poEventHandler, "AppendQuestion", Py_BuildValue("(si)", rArgument.strValue.c_str(), iIndex));

  0004a	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0004d	72 02		 jb	 SHORT $LN55@MakeQuesti
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN55@MakeQuesti:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 896  : 		PyCallClassMemberFunc(pEventSet->poEventHandler, "AppendQuestion", Py_BuildValue("(si)", rArgument.strValue.c_str(), iIndex));

  00051	57		 push	 edi
  00052	50		 push	 eax
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_04LCKGAMBB@?$CIsi?$CJ?$AA@
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0005e	50		 push	 eax
  0005f	8b 45 08	 mov	 eax, DWORD PTR _pEventSet$[ebp]
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EGMAHDDO@AppendQuestion?$AA@
  00067	ff b0 d0 00 00
	00		 push	 DWORD PTR [eax+208]
  0006d	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00072	8b 36		 mov	 esi, DWORD PTR [esi]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 896  : 		PyCallClassMemberFunc(pEventSet->poEventHandler, "AppendQuestion", Py_BuildValue("(si)", rArgument.strValue.c_str(), iIndex));

  00074	83 c4 18	 add	 esp, 24			; 00000018H

; 897  : 		++iIndex;

  00077	47		 inc	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00078	3b 33		 cmp	 esi, DWORD PTR [ebx]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 893  : 	for (script::TArgList::iterator itor=rArgumentList.begin(); itor!=rArgumentList.end(); ++itor)

  0007a	75 ca		 jne	 SHORT $LL27@MakeQuesti
$LN63@MakeQuesti:
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
$LN1@MakeQuesti:
  0007e	5b		 pop	 ebx

; 898  : 	}
; 899  : }

  0007f	5d		 pop	 ebp
  00080	c2 08 00	 ret	 8
?MakeQuestion@CPythonEventManager@@IAEXPAUSEventSet@1@AAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ENDP ; CPythonEventManager::MakeQuestion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?SelectAnswer@CPythonEventManager@@QAEXHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iAnswer$ = 12						; size = 4
?SelectAnswer@CPythonEventManager@@QAEXHH@Z PROC	; CPythonEventManager::SelectAnswer, COMDAT
; _this$ = ecx

; 903  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 904  : 	if (!CheckEventSetIndex(iIndex))

  00003	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  00006	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000b	84 c0		 test	 al, al
  0000d	74 0e		 je	 SHORT $LN2@SelectAnsw

; 905  : 		return;
; 906  : 
; 907  : 	//TEventSet * pEventSet = m_EventSetVector[iIndex];
; 908  : 
; 909  : 	CPythonNetworkStream::Instance().SendScriptAnswerPacket(iAnswer);

  0000f	ff 75 0c	 push	 DWORD PTR _iAnswer$[ebp]
  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  00018	e8 00 00 00 00	 call	 ?SendScriptAnswerPacket@CPythonNetworkStream@@QAE_NH@Z ; CPythonNetworkStream::SendScriptAnswerPacket
$LN2@SelectAnsw:

; 910  : }

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?SelectAnswer@CPythonEventManager@@QAEXHH@Z ENDP	; CPythonEventManager::SelectAnswer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?SetVisibleStartLine@CPythonEventManager@@QAEXHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iStartLine$ = 12					; size = 4
?SetVisibleStartLine@CPythonEventManager@@QAEXHH@Z PROC	; CPythonEventManager::SetVisibleStartLine, COMDAT
; _this$ = ecx

; 913  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 914  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	74 14		 je	 SHORT $LN3@SetVisible

; 915  : 		return;
; 916  : 
; 917  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00011	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 918  : 
; 919  : 	if (DWORD(iStartLine) > pEventSet->ScriptTextLineList.size())

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _iStartLine$[ebp]
  00017	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0001a	3b 48 50	 cmp	 ecx, DWORD PTR [eax+80]
  0001d	77 06		 ja	 SHORT $LN3@SetVisible

; 920  : 		return;
; 921  : 
; 922  : 	pEventSet->iVisibleStartLine = iStartLine;

  0001f	89 88 a4 00 00
	00		 mov	 DWORD PTR [eax+164], ecx
$LN3@SetVisible:
  00025	5e		 pop	 esi

; 923  : }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?SetVisibleStartLine@CPythonEventManager@@QAEXHH@Z ENDP	; CPythonEventManager::SetVisibleStartLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?SetVisibleLineCount@CPythonEventManager@@QAEXHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iLineCount$dead$ = 12					; size = 4
?SetVisibleLineCount@CPythonEventManager@@QAEXHH@Z PROC	; CPythonEventManager::SetVisibleLineCount, COMDAT
; _this$ = ecx

; 926  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 927  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	74 10		 je	 SHORT $LN2@SetVisible

; 928  : 		return;
; 929  : 
; 930  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];
; 931  : 
; 932  : 	pEventSet->iVisibleLineCount = iLineCount;

  00011	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00014	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00017	c7 80 a8 00 00
	00 1e 00 00 00	 mov	 DWORD PTR [eax+168], 30	; 0000001eH
$LN2@SetVisible:
  00021	5e		 pop	 esi

; 933  : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?SetVisibleLineCount@CPythonEventManager@@QAEXHH@Z ENDP	; CPythonEventManager::SetVisibleLineCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?GetVisibleStartLine@CPythonEventManager@@QAEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetVisibleStartLine@CPythonEventManager@@QAEHH@Z PROC	; CPythonEventManager::GetVisibleStartLine, COMDAT
; _this$ = ecx

; 936  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 937  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	75 07		 jne	 SHORT $LN1@GetVisible

; 938  : 		return 0;

  00011	33 c0		 xor	 eax, eax
  00013	5e		 pop	 esi

; 942  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN1@GetVisible:

; 939  : 
; 940  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];
; 941  : 	return pEventSet->iVisibleStartLine;

  00018	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001b	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0001e	5e		 pop	 esi
  0001f	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [eax+164]

; 942  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GetVisibleStartLine@CPythonEventManager@@QAEHH@Z ENDP	; CPythonEventManager::GetVisibleStartLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?GetLineCount@CPythonEventManager@@QAEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetLineCount@CPythonEventManager@@QAEHH@Z PROC		; CPythonEventManager::GetLineCount, COMDAT
; _this$ = ecx

; 945  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 946  : 	if (!CheckEventSetIndex(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ; CPythonEventManager::CheckEventSetIndex
  0000d	84 c0		 test	 al, al
  0000f	75 07		 jne	 SHORT $LN1@GetLineCou

; 947  : 		return 0;

  00011	33 c0		 xor	 eax, eax
  00013	5e		 pop	 esi

; 951  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN1@GetLineCou:

; 948  : 
; 949  : 	TEventSet * pEventSet = m_EventSetVector[iIndex];

  00018	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0001b	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  0001e	5e		 pop	 esi

; 950  : 	return pEventSet->ScriptTextLineList.size()+pEventSet->iAdjustLine;

  0001f	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00025	03 41 50	 add	 eax, DWORD PTR [ecx+80]

; 951  : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?GetLineCount@CPythonEventManager@@QAEHH@Z ENDP		; CPythonEventManager::GetLineCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?ClearLine@CPythonEventManager@@IAEXPAUSEventSet@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_pEventSet$ = 8						; size = 4
?ClearLine@CPythonEventManager@@IAEXPAUSEventSet@1@@Z PROC ; CPythonEventManager::ClearLine, COMDAT
; _this$ = ecx

; 954  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 955  : 	if (!pEventSet)

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _pEventSet$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	89 7d fc	 mov	 DWORD PTR _this$1$[ebp], edi
  0000e	85 db		 test	 ebx, ebx
  00010	74 7d		 je	 SHORT $LN5@ClearLine
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00012	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
  00015	56		 push	 esi

; 44   : 		{	// construct with node pointer _Pnode

  00016	8b 30		 mov	 esi, DWORD PTR [eax]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00018	3b f0		 cmp	 esi, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 958  : 	for (TScriptTextLineList::iterator itor = pEventSet->ScriptTextLineList.begin(); itor != pEventSet->ScriptTextLineList.end(); ++itor)

  0001a	74 1f		 je	 SHORT $LN1@ClearLine
  0001c	8d 64 24 00	 npad	 4
$LL21@ClearLine:

; 959  : 	{
; 960  : 		TTextLine & rkLine = *itor;
; 961  : 		CGraphicTextInstance * pInstance = rkLine.pInstance;

  00020	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]

; 962  : 		pInstance->Destroy();

  00023	8b cf		 mov	 ecx, edi
  00025	e8 00 00 00 00	 call	 ?Destroy@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Destroy

; 963  : 		pInstance->Update();

  0002a	8b cf		 mov	 ecx, edi
  0002c	e8 00 00 00 00	 call	 ?Update@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Update
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00031	8b 36		 mov	 esi, DWORD PTR [esi]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00033	3b 73 4c	 cmp	 esi, DWORD PTR [ebx+76]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 958  : 	for (TScriptTextLineList::iterator itor = pEventSet->ScriptTextLineList.begin(); itor != pEventSet->ScriptTextLineList.end(); ++itor)

  00036	75 e8		 jne	 SHORT $LL21@ClearLine
  00038	8b 7d fc	 mov	 edi, DWORD PTR _this$1$[ebp]
$LN1@ClearLine:

; 964  : 	}
; 965  : 
; 966  : 	pEventSet->pCurrentTextLine->Destroy();

  0003b	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  0003e	e8 00 00 00 00	 call	 ?Destroy@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Destroy

; 967  : 	pEventSet->pCurrentTextLine->Update();

  00043	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]
  00046	e8 00 00 00 00	 call	 ?Update@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Update

; 968  : 
; 969  : 	// clear
; 970  : 	pEventSet->pCurrentTextLine = NULL;

  0004b	c7 43 48 00 00
	00 00		 mov	 DWORD PTR [ebx+72], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00052	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]

; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();
; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 768  : 		}
; 769  : 
; 770  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 771  : 		{	// free head node using current allocator
; 772  : 		this->_Getal().destroy(
; 773  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 774  : 		this->_Getal().destroy(
; 775  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 776  : 		this->_Getal().deallocate(_Pnode, 1);
; 777  : 		}
; 778  : 
; 779  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 780  : 		_Nodeptr _Prev)
; 781  : 		{	// allocate a node and set links
; 782  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 783  : 
; 784  : 		if (_Next == _Nodeptr())
; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;
; 787  : 			_Prev = _Pnode;
; 788  : 			}
; 789  : 		_TRY_BEGIN
; 790  : 		this->_Getal().construct(
; 791  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 792  : 		this->_Getal().construct(
; 793  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 794  : 		_CATCH_ALL
; 795  : 		this->_Getal().deallocate(_Pnode, 1);
; 796  : 		_RERAISE;
; 797  : 		_CATCH_END
; 798  : 
; 799  : 		return (_Pnode);
; 800  : 		}
; 801  : 
; 802  : 	_Alty _Getal() const
; 803  : 		{	// get reference to allocator
; 804  : 		return (_Alty());
; 805  : 		}
; 806  : 	};
; 807  : 
; 808  : 		// TEMPLATE CLASS _List_buy
; 809  : template<class _Ty,
; 810  : 	class _Alloc>
; 811  : 	class _List_buy
; 812  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 813  : 			_List_base_types<_Ty, _Alloc> >
; 814  : 	{	// base class for list to hold buynode/freenode functions
; 815  : public:
; 816  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 817  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 818  : 	typedef typename _Mybase::_Alty _Alty;
; 819  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 820  : 
; 821  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 822  : 		: _Mybase(_Al)
; 823  : 		{	// construct from allocator
; 824  : 		}
; 825  : 
; 826  : 	template<class... _Valty>
; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 831  : 
; 832  : 		_TRY_BEGIN
; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);
; 836  : 		_CATCH_ALL
; 837  : 		this->_Getal().deallocate(_Pnode, 1);
; 838  : 		_RERAISE;
; 839  : 		_CATCH_END
; 840  : 
; 841  : 		return (_Pnode);
; 842  : 		}
; 843  : 
; 844  : 
; 845  : 	void _Freenode(_Nodeptr _Pnode)
; 846  : 		{	// give node back
; 847  : 		this->_Getal().destroy(
; 848  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Myval(_Pnode)));
; 853  : 		this->_Getal().deallocate(_Pnode, 1);
; 854  : 		}
; 855  : 	};
; 856  : 
; 857  : 		// TEMPLATE CLASS list
; 858  : template<class _Ty,
; 859  : 	class _Alloc = allocator<_Ty> >
; 860  : 	class list
; 861  : 		: public _List_buy<_Ty, _Alloc>
; 862  : 	{	// bidirectional linked list
; 863  : public:
; 864  : 	typedef list<_Ty, _Alloc> _Myt;
; 865  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 866  : 	typedef typename _Mybase::_Node _Node;
; 867  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 868  : 	typedef typename _Mybase::_Alty _Alty;
; 869  : 
; 870  : 	typedef _Alloc allocator_type;
; 871  : 	typedef typename _Mybase::size_type size_type;
; 872  : 	typedef typename _Mybase::difference_type difference_type;
; 873  : 	typedef typename _Mybase::pointer pointer;
; 874  : 	typedef typename _Mybase::const_pointer const_pointer;
; 875  : 	typedef typename _Mybase::reference reference;
; 876  : 	typedef typename _Mybase::const_reference const_reference;
; 877  : 	typedef typename _Mybase::value_type value_type;
; 878  : 
; 879  : 	typedef typename _Mybase::const_iterator const_iterator;
; 880  : 	typedef typename _Mybase::iterator iterator;
; 881  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 882  : 		_Unchecked_const_iterator;
; 883  : 	typedef typename _Mybase::_Unchecked_iterator
; 884  : 		_Unchecked_iterator;
; 885  : 
; 886  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 887  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 888  : 
; 889  : 	list()
; 890  : 		: _Mybase()
; 891  : 		{	// construct empty list
; 892  : 		}
; 893  : 
; 894  : 	explicit list(const _Alloc& _Al)
; 895  : 		: _Mybase(_Al)
; 896  : 		{	// construct empty list, allocator
; 897  : 		}
; 898  : 
; 899  : 	explicit list(size_type _Count)
; 900  : 		: _Mybase()
; 901  : 		{	// construct list from _Count * _Ty()
; 902  : 		resize(_Count);
; 903  : 		}
; 904  : 
; 905  : 	list(size_type _Count, const _Ty& _Val)
; 906  : 		: _Mybase()
; 907  : 		{	// construct list from _Count * _Val
; 908  : 		_Construct_n(_Count, _Val);
; 909  : 		}
; 910  : 
; 911  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 912  : 		: _Mybase(_Al)
; 913  : 		{	// construct list from _Count * _Val, allocator
; 914  : 		_Construct_n(_Count, _Val);
; 915  : 		}
; 916  : 
; 917  : 	list(const _Myt& _Right)
; 918  : 
; 919  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 920  : 
; 921  : 
; 922  : 		{	// construct list by copying _Right
; 923  : 		_TRY_BEGIN
; 924  : 		insert(begin(), _Right.begin(), _Right.end());
; 925  : 		_CATCH_ALL
; 926  : 		_Tidy();
; 927  : 		_RERAISE;
; 928  : 		_CATCH_END
; 929  : 		}
; 930  : 
; 931  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 932  : 		: _Mybase(_Al)
; 933  : 		{	// construct list by copying _Right, allocator
; 934  : 		_TRY_BEGIN
; 935  : 		insert(begin(), _Right.begin(), _Right.end());
; 936  : 		_CATCH_ALL
; 937  : 		_Tidy();
; 938  : 		_RERAISE;
; 939  : 		_CATCH_END
; 940  : 		}
; 941  : 
; 942  : 	template<class _Iter,
; 943  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 944  : 			void>::type>
; 945  : 		list(_Iter _First, _Iter _Last)
; 946  : 		: _Mybase()
; 947  : 		{	// construct list from [_First, _Last)
; 948  : 		_Construct(_First, _Last);
; 949  : 		}
; 950  : 
; 951  : 	template<class _Iter,
; 952  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 953  : 			void>::type>
; 954  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct list, allocator from [_First, _Last)
; 957  : 		_Construct(_First, _Last);
; 958  : 		}
; 959  : 
; 960  : 	template<class _Iter>
; 961  : 		void _Construct(_Iter _First, _Iter _Last)
; 962  : 		{	// construct list from [_First, _Last), input iterators
; 963  : 		_TRY_BEGIN
; 964  : 		insert(begin(), _First, _Last);
; 965  : 		_CATCH_ALL
; 966  : 		_Tidy();
; 967  : 		_RERAISE;
; 968  : 		_CATCH_END
; 969  : 		}
; 970  : 
; 971  : 	void _Construct_n(size_type _Count,
; 972  : 		const _Ty& _Val)
; 973  : 		{	// construct from _Count * _Val
; 974  : 		_TRY_BEGIN
; 975  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 976  : 		_CATCH_ALL
; 977  : 		_Tidy();
; 978  : 		_RERAISE;
; 979  : 		_CATCH_END
; 980  : 		}
; 981  : 
; 982  : 	list(_Myt&& _Right)
; 983  : 		: _Mybase(_Right._Getal())
; 984  : 		{	// construct list by moving _Right
; 985  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 986  : 		}
; 987  : 
; 988  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 989  : 		: _Mybase(_Al)
; 990  : 		{	// construct list by moving _Right, allocator
; 991  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 992  : 		}
; 993  : 
; 994  : 	_Myt& operator=(_Myt&& _Right)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Change_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1013 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != this)
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);
; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;
; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
; 1066 : 		}
; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00055	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00057	89 00		 mov	 DWORD PTR [eax], eax

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00059	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]

; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  0005c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1499 : 		this->_Mysize = 0;

  0005f	c7 43 50 00 00
	00 00		 mov	 DWORD PTR [ebx+80], 0

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00066	3b 4b 4c	 cmp	 ecx, DWORD PTR [ebx+76]
  00069	74 17		 je	 SHORT $LN45@ClearLine
  0006b	eb 03 8d 49 00	 npad	 5
$LL47@ClearLine:

; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);

  00070	8b 31		 mov	 esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00078	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  0007b	8b ce		 mov	 ecx, esi
  0007d	3b 73 4c	 cmp	 esi, DWORD PTR [ebx+76]
  00080	75 ee		 jne	 SHORT $LL47@ClearLine
$LN45@ClearLine:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 973  : 	__InsertLine(*pEventSet);

  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	53		 push	 ebx
  00087	8b cf		 mov	 ecx, edi
  00089	e8 00 00 00 00	 call	 ?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z ; CPythonEventManager::__InsertLine
  0008e	5e		 pop	 esi
$LN5@ClearLine:
  0008f	5f		 pop	 edi
  00090	5b		 pop	 ebx

; 974  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 04 00	 ret	 4
?ClearLine@CPythonEventManager@@IAEXPAUSEventSet@1@@Z ENDP ; CPythonEventManager::ClearLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z
_TEXT	SEGMENT
_kLine$1 = -16						; size = 12
_textHeight$2 = -4					; size = 4
_textWidth$3 = 8					; size = 4
_rEventSet$ = 8						; size = 4
_isCenter$ = 12						; size = 4
_iX_pos$ = 16						; size = 4
?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z PROC ; CPythonEventManager::__InsertLine, COMDAT
; _this$ = ecx

; 977  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 978  : 	if (rEventSet.pCurrentTextLine)

  00008	8b 75 08	 mov	 esi, DWORD PTR _rEventSet$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	57		 push	 edi
  0000e	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00011	85 c9		 test	 ecx, ecx
  00013	0f 84 b7 00 00
	00		 je	 $LN14@InsertLine

; 979  : 	{
; 980  : 		TTextLine kLine;
; 981  : 		if (CGraphicTextInstance::HORIZONTAL_ALIGN_CENTER == rEventSet.pCurrentTextLine->GetHorizontalAlign())

  00019	e8 00 00 00 00	 call	 ?GetHorizontalAlign@CGraphicTextInstance@@QAEHXZ ; CGraphicTextInstance::GetHorizontalAlign
  0001e	83 f8 02	 cmp	 eax, 2
  00021	75 0d		 jne	 SHORT $LN13@InsertLine

; 982  : 		{
; 983  : 			kLine.ixLocal = rEventSet.iWidth/2;

  00023	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00026	99		 cdq
  00027	2b c2		 sub	 eax, edx
  00029	d1 f8		 sar	 eax, 1
  0002b	89 45 f0	 mov	 DWORD PTR _kLine$1[ebp], eax

; 984  : 			kLine.iyLocal = rEventSet.iyLocal;
; 985  : 
; 986  : 		}
; 987  : 		else

  0002e	eb 5b		 jmp	 SHORT $LN8@InsertLine
$LN13@InsertLine:

; 988  : 		{
; 989  : 			int textWidth;
; 990  : 			int textHeight;
; 991  : 			rEventSet.pCurrentTextLine->GetTextSize(&textWidth,&textHeight);

  00030	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00033	8d 45 fc	 lea	 eax, DWORD PTR _textHeight$2[ebp]
  00036	50		 push	 eax
  00037	8d 45 08	 lea	 eax, DWORD PTR _textWidth$3[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?GetTextSize@CGraphicTextInstance@@QAEXPAH0@Z ; CGraphicTextInstance::GetTextSize

; 992  : 			if (GetDefaultCodePage() == CP_1256)

  00040	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  00045	3d e8 04 00 00	 cmp	 eax, 1256		; 000004e8H
  0004a	75 21		 jne	 SHORT $LN11@InsertLine

; 993  : 			{
; 994  : 				kLine.ixLocal = rEventSet.iWidth;
; 995  : 				if (iX_pos != 0)

  0004c	8b 7d 10	 mov	 edi, DWORD PTR _iX_pos$[ebp]
  0004f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00052	89 4d f0	 mov	 DWORD PTR _kLine$1[ebp], ecx
  00055	85 ff		 test	 edi, edi
  00057	74 32		 je	 SHORT $LN8@InsertLine

; 996  : 				{
; 997  : 					kLine.ixLocal -= iX_pos - 20;
; 998  : 					kLine.ixLocal += textWidth / 2;

  00059	8b 45 08	 mov	 eax, DWORD PTR _textWidth$3[ebp]
  0005c	99		 cdq
  0005d	2b c2		 sub	 eax, edx
  0005f	d1 f8		 sar	 eax, 1
  00061	2b c7		 sub	 eax, edi
  00063	83 c0 14	 add	 eax, 20			; 00000014H
  00066	03 c1		 add	 eax, ecx
  00068	89 45 f0	 mov	 DWORD PTR _kLine$1[ebp], eax

; 999  : 				}
; 1000 : 			}
; 1001 : 			else

  0006b	eb 1e		 jmp	 SHORT $LN8@InsertLine
$LN11@InsertLine:

; 1002 : 			{
; 1003 : 				kLine.ixLocal = 0;
; 1004 : 				if (iX_pos != 0)

  0006d	8b 4d 10	 mov	 ecx, DWORD PTR _iX_pos$[ebp]
  00070	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _kLine$1[ebp], 0
  00077	85 c9		 test	 ecx, ecx
  00079	74 10		 je	 SHORT $LN8@InsertLine

; 1005 : 				{
; 1006 : 					kLine.ixLocal += (iX_pos - 20);
; 1007 : 					kLine.ixLocal -= textWidth / 2;

  0007b	8b 45 08	 mov	 eax, DWORD PTR _textWidth$3[ebp]
  0007e	99		 cdq
  0007f	2b c2		 sub	 eax, edx
  00081	d1 f8		 sar	 eax, 1
  00083	2b c8		 sub	 ecx, eax
  00085	83 e9 14	 sub	 ecx, 20			; 00000014H
  00088	89 4d f0	 mov	 DWORD PTR _kLine$1[ebp], ecx
$LN8@InsertLine:

; 1011 : 			kLine.iyLocal = rEventSet.iyLocal;

  0008b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 96   : 		return (_Ptr);

  0008e	8b 7e 4c	 mov	 edi, DWORD PTR [esi+76]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1011 : 			kLine.iyLocal = rEventSet.iyLocal;

  00091	89 45 f4	 mov	 DWORD PTR _kLine$1[ebp+4], eax

; 1012 : 		}
; 1013 : 		kLine.pInstance = rEventSet.pCurrentTextLine;

  00094	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00097	89 45 f8	 mov	 DWORD PTR _kLine$1[ebp+8], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1062 : 				_STD forward<_Valty>(_Val)...);

  0009a	8d 45 f0	 lea	 eax, DWORD PTR _kLine$1[ebp]
  0009d	50		 push	 eax
  0009e	ff 77 04	 push	 DWORD PTR [edi+4]
  000a1	57		 push	 edi
  000a2	e8 00 00 00 00	 call	 ??$_Buynode@ABUSTextLine@CPythonEventManager@@@?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PAU21@0ABUSTextLine@CPythonEventManager@@@Z ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Buynode<CPythonEventManager::STextLine const &>
  000a7	8b d0		 mov	 edx, eax

; 1066 : 		}
; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1499 : 		this->_Mysize = 0;
; 1500 : 
; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);
; 1504 : 			this->_Freenode(_Pnode);
; 1505 : 			}
; 1506 : 		}
; 1507 : 
; 1508 : 	void swap(_Myt& _Right)
; 1509 : 		{	// exchange contents with _Right
; 1510 : 		if (this == &_Right)
; 1511 : 			;	// same object, do nothing
; 1512 : 		else if (this->_Getal() == _Right._Getal())
; 1513 : 			{	// same allocator, swap control information
; 1514 : 			this->_Swap_all(_Right);
; 1515 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1516 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1517 : 			}
; 1518 : 
; 1519 : 		else if (_Alty::propagate_on_container_swap::value)
; 1520 : 			{	// swap allocators and control information
; 1521 : 			this->_Swap_alloc(_Right);
; 1522 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1523 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1524 : 			}
; 1525 : 
; 1526 : 		else	// containers are incompatible
; 1527 : 
; 1528 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1529 : 			_DEBUG_ERROR("list containers incompatible for swap");
; 1530 : 
; 1531 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1532 : 			_XSTD terminate();
; 1533 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1534 : 		}
; 1535 : 
; 1536 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1537 : 		{	// splice all of _Right at _Where
; 1538 : 		if (this != &_Right && !_Right.empty())
; 1539 : 			{	// worth splicing, do it
; 1540 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1541 : 				_Right._Mysize);
; 1542 : 			}
; 1543 : 		}
; 1544 : 
; 1545 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1546 : 		{	// splice all of _Right at _Where
; 1547 : 		splice(_Where, (_Myt&)_Right);
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1554 : 		if (_First == _Right.end())
; 1555 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1556 : 		else
; 1557 : 
; 1558 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1559 : 		if (_First != _Right.end())
; 1560 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1561 : 
; 1562 : 			{	// element exists, try splice
; 1563 : 			const_iterator _Last = _First;
; 1564 : 			++_Last;
; 1565 : 			if (this != &_Right
; 1566 : 				|| (_Where != _First && _Where != _Last))
; 1567 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1568 : 			}
; 1569 : 		}
; 1570 : 
; 1571 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1572 : 		const_iterator _First)
; 1573 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1574 : 		splice(_Where, (_Myt&)_Right, _First);
; 1575 : 		}
; 1576 : 
; 1577 : 	void splice(const_iterator _Where,
; 1578 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1579 : 		{	// splice _Right [_First, _Last) at _Where
; 1580 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1581 : 			{	// worth splicing, do it
; 1582 : 			size_type _Count = 0;
; 1583 : 
; 1584 : 			if (this == &_Right)
; 1585 : 				;	// just rearrange this list
; 1586 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1587 : 				_Count = _Right._Mysize;	// splice in whole list
; 1588 : 			else
; 1589 : 				{	// count nodes and check for knot
; 1590 : 				const_iterator _Next = _First;
; 1591 : 
; 1592 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1593 : 					if (_Next == _Right.end())
; 1594 : 						_Xlength_error("list<T> bad splice");
; 1595 : 				}
; 1596 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1597 : 			}
; 1598 : 		}
; 1599 : 
; 1600 : 	void splice(const_iterator _Where,
; 1601 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1602 : 		{	// splice _Right [_First, _Last) at _Where
; 1603 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1604 : 		}
; 1605 : 
; 1606 : 	void remove(const _Ty& _Val)
; 1607 : 		{	// erase each element matching _Val
; 1608 : 		iterator _Val_it = end();
; 1609 : 
; 1610 : 		for (iterator _First = begin(); _First != end(); )
; 1611 : 			if (*_First == _Val)
; 1612 : 				if (_STD addressof(*_First) == _STD addressof(_Val))
; 1613 : 					_Val_it = _First++;
; 1614 : 				else
; 1615 : 					_First = erase(_First);
; 1616 : 			else
; 1617 : 				++_First;
; 1618 : 
; 1619 : 		if (_Val_it != end())
; 1620 : 			erase(_Val_it);
; 1621 : 		}
; 1622 : 
; 1623 : 	template<class _Pr1>
; 1624 : 		void remove_if(_Pr1 _Pred)
; 1625 : 		{	// erase each element satisfying _Pred
; 1626 : 		for (iterator _First = begin(); _First != end(); )
; 1627 : 			if (_Pred(*_First))
; 1628 : 				_First = erase(_First);
; 1629 : 			else
; 1630 : 				++_First;
; 1631 : 		}
; 1632 : 
; 1633 : 	void unique()
; 1634 : 		{	// erase each element matching previous
; 1635 : 		unique(equal_to<>());
; 1636 : 		}
; 1637 : 
; 1638 : 	template<class _Pr2>
; 1639 : 		void unique(_Pr2 _Pred)
; 1640 : 		{	// erase each element satisfying _Pred with previous
; 1641 : 		const _Nodeptr _Phead = this->_Myhead;
; 1642 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1643 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1644 : 
; 1645 : 		while (_Pnode != _Phead)
; 1646 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1647 : 				{	// match, remove it
; 1648 : 				const _Nodeptr _Perase = _Pnode;
; 1649 : 				_Pnode = this->_Nextnode(_Pnode);
; 1650 : 
; 1651 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1652 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1653 : 				this->_Freenode(_Perase);
; 1654 : 
; 1655 : 				--this->_Mysize;
; 1656 : 				}
; 1657 : 			else
; 1658 : 				{	// no match, advance
; 1659 : 				_Pprev = _Pnode;
; 1660 : 				_Pnode = this->_Nextnode(_Pnode);
; 1661 : 				}
; 1662 : 		}
; 1663 : 
; 1664 : 	void merge(_Myt& _Right)
; 1665 : 		{	// merge in elements from _Right, both ordered by operator<
; 1666 : 		merge(_Right, less<>());
; 1667 : 		}
; 1668 : 
; 1669 : 	void merge(_Myt&& _Right)
; 1670 : 		{	// merge in elements from _Right, both ordered by operator<
; 1671 : 		merge((_Myt&)_Right);
; 1672 : 		}
; 1673 : 
; 1674 : 	template<class _Pr2>
; 1675 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1676 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1677 : 		if (&_Right != this)
; 1678 : 			{	// safe to merge, do it
; 1679 : 			iterator _First1 = begin(), _Last1 = end();
; 1680 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1681 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1682 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1683 : 
; 1684 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1685 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1686 : 					{	// splice in an element from _Right
; 1687 : 					iterator _Mid2 = _First2;
; 1688 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1689 : 					_First2 = _Mid2;
; 1690 : 					}
; 1691 : 				else
; 1692 : 					++_First1;
; 1693 : 
; 1694 : 			if (_First2 != _Last2)
; 1695 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1696 : 					_Right._Mysize);	// splice remainder of _Right
; 1697 : 			}
; 1698 : 		}
; 1699 : 
; 1700 : 	template<class _Pr2>
; 1701 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1702 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1703 : 		merge((_Myt&)_Right, _Pred);
; 1704 : 		}
; 1705 : 
; 1706 : 	void sort()
; 1707 : 		{	// order sequence, using operator<
; 1708 : 		sort(less<>());
; 1709 : 		}
; 1710 : 
; 1711 : 	template<class _Pr2>
; 1712 : 		void sort(_Pr2 _Pred)
; 1713 : 		{	// order sequence, using _Pred
; 1714 : 		if (2 <= this->_Mysize)
; 1715 : 			{	// worth sorting, do it
; 1716 : 			const size_t _MAXBINS = 25;
; 1717 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1718 : 			size_t _Maxbin = 0;
; 1719 : 
; 1720 : 			while (!empty())
; 1721 : 				{	// sort another element, using bins
; 1722 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1723 : 					++begin(), 1);
; 1724 : 
; 1725 : 				size_t _Bin;
; 1726 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1727 : 					++_Bin)
; 1728 : 					{	// merge into ever larger bins
; 1729 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1730 : 					_Binlist[_Bin].swap(_Templist);
; 1731 : 					}
; 1732 : 
; 1733 : 				if (_Bin == _MAXBINS)
; 1734 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1735 : 				else
; 1736 : 					{	// spill to new bin, while they last
; 1737 : 					_Binlist[_Bin].swap(_Templist);
; 1738 : 					if (_Bin == _Maxbin)
; 1739 : 						++_Maxbin;
; 1740 : 					}
; 1741 : 				}
; 1742 : 
; 1743 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1744 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1745 : 					_Pred);	// merge up
; 1746 : 
; 1747 : 			_Analysis_assume_(0 < _Maxbin);
; 1748 : 
; 1749 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1750 : 			}
; 1751 : 		}
; 1752 : 
; 1753 : 	void reverse() _NOEXCEPT
; 1754 : 		{	// reverse sequence
; 1755 : 		const _Nodeptr _Phead = this->_Myhead;
; 1756 : 		_Nodeptr _Pnode = _Phead;
; 1757 : 
; 1758 : 		for (; ; )
; 1759 : 			{	// flip pointers in a node
; 1760 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1761 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1762 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1763 : 
; 1764 : 			if (_Pnext == _Phead)
; 1765 : 				break;
; 1766 : 			_Pnode = _Pnext;
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	void _Splice(const_iterator _Where,
; 1771 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1772 : 		size_type _Count)
; 1773 : 		{	// splice _Right [_First, _Last) before _Where
; 1774 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1775 : 		if (_Where._Getcont() != this)
; 1776 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1777 : 		if (this->_Getal() != _Right._Getal())
; 1778 : 			_DEBUG_ERROR("list containers incompatible for splice");
; 1779 : 
; 1780 : 		if (this != &_Right)
; 1781 : 			{	// transfer ownership
; 1782 : 			_Lockit _Lock(_LOCK_DEBUG);
; 1783 : 
; 1784 : 			const bool _One = _Count == 1;
; 1785 : 			const bool _All = _Count == _Right.size();
; 1786 : 			const bool _Some = !_One && !_All;
; 1787 : 
; 1788 : 			_Nodeptr _Oldprev = _First._Ptr->_Prev;
; 1789 : 
; 1790 : 			if (_Some)
; 1791 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1792 : 					_Ptr = _Ptr->_Next)
; 1793 : 					{	// mark _Prev pointers
; 1794 : 					_Ptr->_Prev = 0;
; 1795 : 					}
; 1796 : 
; 1797 : 			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();
; 1798 : 
; 1799 : 			if (_Pnext == 0)
; 1800 : 				_DEBUG_ERROR("list container corrupted");
; 1801 : 
; 1802 : 			while (*_Pnext != 0)
; 1803 : 				{	// check the iterator
; 1804 : 				const_iterator& _Iter = **_Pnext;
; 1805 : 
; 1806 : 				if ((_One && _Iter._Ptr == _First._Ptr)
; 1807 : 					|| (_All && _Iter._Ptr != _Right._Myhead)
; 1808 : 					|| (_Some && _Iter._Ptr->_Prev == 0))
; 1809 : 					{	// adopt the iterator
; 1810 : 					*_Pnext = (const_iterator *)_Iter._Mynextiter;
; 1811 : 					_Iter._Myproxy = this->_Myproxy;
; 1812 : 					_Iter._Mynextiter = this->_Myproxy->_Myfirstiter;
; 1813 : 					this->_Myproxy->_Myfirstiter = &_Iter;
; 1814 : 					}
; 1815 : 				else
; 1816 : 					{	// skip the iterator
; 1817 : 					_Pnext = (const_iterator **)_Iter._Getpnext();
; 1818 : 					}
; 1819 : 				}
; 1820 : 
; 1821 : 			if (_Some)
; 1822 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1823 : 					_Ptr = _Ptr->_Next)
; 1824 : 					{	// restore _Prev pointers
; 1825 : 					_Ptr->_Prev = _Oldprev;
; 1826 : 					_Oldprev = _Ptr;
; 1827 : 					}
; 1828 : 			}
; 1829 : 
; 1830 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1831 : 		if (this->_Getal() != _Right._Getal())
; 1832 : 			_XSTD terminate();
; 1833 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1834 : 
; 1835 : 		_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1836 : 		}
; 1837 : 
; 1838 : 	void _Splice_same(const_iterator _Where,
; 1839 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1840 : 		size_type _Count)
; 1841 : 		{	// splice _Right [_First, _Last) before _Where
; 1842 : 		if (this != &_Right)
; 1843 : 			{	// splicing from another list, adjust counts
; 1844 : 			_Incsize(_Count);
; 1845 : 			_Right._Mysize -= _Count;
; 1846 : 			}
; 1847 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1848 : 			_Last._Mynode();
; 1849 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1850 : 			_Where._Mynode();
; 1851 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1852 : 			_First._Mynode();
; 1853 : 
; 1854 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1855 : 		this->_Prevnode(_Where._Mynode()) =
; 1856 : 			this->_Prevnode(_Last._Mynode());
; 1857 : 		this->_Prevnode(_Last._Mynode()) =
; 1858 : 			this->_Prevnode(_First._Mynode());
; 1859 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1860 : 		}
; 1861 : 
; 1862 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1863 : 		_Unchecked_const_iterator _First,
; 1864 : 		_Unchecked_const_iterator _Last)
; 1865 : 		{	// splice [_First, _Last) before _Where
; 1866 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1867 : 			_Last._Mynode();
; 1868 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1869 : 			_Where._Mynode();
; 1870 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1871 : 			_First._Mynode();
; 1872 : 
; 1873 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1874 : 		this->_Prevnode(_Where._Mynode()) =
; 1875 : 			this->_Prevnode(_Last._Mynode());
; 1876 : 		this->_Prevnode(_Last._Mynode()) =
; 1877 : 			this->_Prevnode(_First._Mynode());
; 1878 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1879 : 		}
; 1880 : 
; 1881 : 	void _Tidy()
; 1882 : 		{	// free all storage
; 1883 : 		clear();
; 1884 : 		}
; 1885 : 
; 1886 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1887 : 		size_type _Count, const _Ty& _Val)
; 1888 : 		{	// insert _Count * _Val at _Where
; 1889 : 		size_type _Countsave = _Count;
; 1890 : 
; 1891 : 		_TRY_BEGIN
; 1892 : 		for (; 0 < _Count; --_Count)
; 1893 : 			_Insert(_Where, _Val);
; 1894 : 		_CATCH_ALL
; 1895 : 		for (; _Count < _Countsave; ++_Count)
; 1896 : 			{	// undo inserts
; 1897 : 			_Unchecked_const_iterator _Before = _Where;
; 1898 : 			_Unchecked_erase(--_Before);
; 1899 : 			}
; 1900 : 		_RERAISE;
; 1901 : 		_CATCH_END
; 1902 : 		}
; 1903 : 
; 1904 : 	void _Incsize(size_type _Count)
; 1905 : 		{	// alter element count, with checking
; 1906 : 		if (max_size() - this->_Mysize - 1 < _Count)

  000a9	b9 cb cc cc 0c	 mov	 ecx, 214748363		; 0ccccccbH
  000ae	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  000b1	2b c8		 sub	 ecx, eax
  000b3	83 f9 01	 cmp	 ecx, 1
  000b6	0f 82 5f 01 00
	00		 jb	 $LN68@InsertLine

; 1908 : 		this->_Mysize += _Count;

  000bc	40		 inc	 eax
  000bd	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;

  000c0	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  000c3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1015 : 		__AddSpace(rEventSet, c_fLine_Temp);		

  000c6	6a 10		 push	 16			; 00000010H
  000c8	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  000c9	89 10		 mov	 DWORD PTR [eax], edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1015 : 		__AddSpace(rEventSet, c_fLine_Temp);		

  000cb	e8 00 00 00 00	 call	 ?__AddSpace@CPythonEventManager@@IAEXAAUSEventSet@1@H@Z ; CPythonEventManager::__AddSpace
$LN14@InsertLine:

; 1016 : 	}
; 1017 : 
; 1018 : 	// DEFAULT_FONT
; 1019 : 	//CGraphicText * pText = (CGraphicText*)CResourceManager::Instance().GetTypeResourcePointer(g_strDefaultFontName.c_str());
; 1020 : 	CGraphicText* pkDefaultFont = static_cast<CGraphicText*>(DefaultFont_GetResource());

  000d0	e8 00 00 00 00	 call	 ?DefaultFont_GetResource@@YAPAVCResource@@XZ ; DefaultFont_GetResource
  000d5	8b f8		 mov	 edi, eax

; 1021 : 	if (!pkDefaultFont)

  000d7	85 ff		 test	 edi, edi
  000d9	75 16		 jne	 SHORT $LN7@InsertLine

; 1022 : 	{
; 1023 : 		TraceError("CPythonEventManager::InsertLine - CANNOT_FIND_DEFAULT_FONT");

  000db	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@PFMMJDKG@CPythonEventManager?3?3InsertLine?5@
  000e0	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000e5	83 c4 04	 add	 esp, 4
  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx

; 1061 : }

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c2 0c 00	 ret	 12			; 0000000cH
$LN7@InsertLine:

; 1024 : 		return;
; 1025 : 	}
; 1026 : 
; 1027 : 	rEventSet.pCurrentTextLine = m_ScriptTextLinePool.Alloc();

  000f1	8d 4b 40	 lea	 ecx, DWORD PTR [ebx+64]
  000f4	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ ; CDynamicPool<CGraphicTextInstance>::Alloc
  000f9	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 1028 : 	if (!rEventSet.pCurrentTextLine)

  000fc	85 c0		 test	 eax, eax
  000fe	75 16		 jne	 SHORT $LN6@InsertLine

; 1029 : 	{
; 1030 : 		TraceError("CPythonEventManager::InsertLine - OUT_OF_TEXT_LINE");

  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@ENOBDFJN@CPythonEventManager?3?3InsertLine?5@
  00105	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0010a	83 c4 04	 add	 esp, 4
  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	5b		 pop	 ebx

; 1061 : }

  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 0c 00	 ret	 12			; 0000000cH
$LN6@InsertLine:

; 1031 : 		return;
; 1032 : 	}
; 1033 : 
; 1034 : 	rEventSet.pCurrentTextLine->SetTextPointer(pkDefaultFont);

  00116	57		 push	 edi
  00117	8b c8		 mov	 ecx, eax
  00119	e8 00 00 00 00	 call	 ?SetTextPointer@CGraphicTextInstance@@QAEXPAVCGraphicText@@@Z ; CGraphicTextInstance::SetTextPointer

; 1035 : 	// END_OF_DEFAULT_FONT
; 1036 : 
; 1037 : 	rEventSet.pCurrentTextLine->SetColor(1.0f, 1.0f, 1.0f);

  0011e	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00121	83 ec 10	 sub	 esp, 16			; 00000010H
  00124	c7 44 24 0c 00
	00 80 3f	 mov	 DWORD PTR [esp+12], 1065353216 ; 3f800000H
  0012c	c7 44 24 08 00
	00 80 3f	 mov	 DWORD PTR [esp+8], 1065353216 ; 3f800000H
  00134	c7 44 24 04 00
	00 80 3f	 mov	 DWORD PTR [esp+4], 1065353216 ; 3f800000H
  0013c	c7 04 24 00 00
	80 3f		 mov	 DWORD PTR [esp], 1065353216 ; 3f800000H
  00143	e8 00 00 00 00	 call	 ?SetColor@CGraphicTextInstance@@QAEXMMMM@Z ; CGraphicTextInstance::SetColor

; 1038 : 	rEventSet.pCurrentTextLine->SetValue("");

  00148	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  0014b	6a ff		 push	 -1
  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00152	e8 00 00 00 00	 call	 ?SetValue@CGraphicTextInstance@@QAEXPBDI@Z ; CGraphicTextInstance::SetValue

; 1039 : 	
; 1040 : 	if (rEventSet.isTextCenterMode || isCenter)

  00157	80 be cc 00 00
	00 00		 cmp	 BYTE PTR [esi+204], 0
  0015e	75 55		 jne	 SHORT $LN4@InsertLine
  00160	83 7d 0c 00	 cmp	 DWORD PTR _isCenter$[ebp], 0
  00164	75 4f		 jne	 SHORT $LN4@InsertLine

; 1044 : 	}
; 1045 : 	else
; 1046 : 	{
; 1047 : 		if (GetDefaultCodePage() == CP_1256)

  00166	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage

; 1048 : 		{
; 1049 : 			rEventSet.pCurrentTextLine->SetHorizonalAlign(CGraphicTextInstance::HORIZONTAL_ALIGN_LEFT);

  0016b	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  0016e	6a 01		 push	 1
  00170	3d e8 04 00 00	 cmp	 eax, 1256		; 000004e8H
  00175	75 14		 jne	 SHORT $LN2@InsertLine
  00177	e8 00 00 00 00	 call	 ?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z ; CGraphicTextInstance::SetHorizonalAlign

; 1050 : 			rEventSet.pCurrentTextLine->SetPosition(rEventSet.ix + rEventSet.iWidth, rEventSet.iy + rEventSet.iyLocal);

  0017c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0017f	03 46 08	 add	 eax, DWORD PTR [esi+8]
  00182	66 0f 6e c0	 movd	 xmm0, eax
  00186	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 1051 : 		}
; 1052 : 		else

  00189	eb 46		 jmp	 SHORT $LN66@InsertLine
$LN2@InsertLine:

; 1053 : 		{
; 1054 : 			rEventSet.pCurrentTextLine->SetHorizonalAlign(CGraphicTextInstance::HORIZONTAL_ALIGN_LEFT);

  0018b	e8 00 00 00 00	 call	 ?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z ; CGraphicTextInstance::SetHorizonalAlign

; 1055 : 			rEventSet.pCurrentTextLine->SetPosition(rEventSet.ix, rEventSet.iy + rEventSet.iyLocal);

  00190	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00193	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00196	03 46 08	 add	 eax, DWORD PTR [esi+8]
  00199	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  001a1	66 0f 6e c0	 movd	 xmm0, eax
  001a5	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001a8	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001ae	66 0f 6e 46 04	 movd	 xmm0, DWORD PTR [esi+4]
  001b3	eb 37		 jmp	 SHORT $LN67@InsertLine
$LN4@InsertLine:

; 1041 : 	{
; 1042 : 		rEventSet.pCurrentTextLine->SetHorizonalAlign(CGraphicTextInstance::HORIZONTAL_ALIGN_CENTER);

  001b5	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  001b8	6a 02		 push	 2
  001ba	e8 00 00 00 00	 call	 ?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z ; CGraphicTextInstance::SetHorizonalAlign

; 1043 : 		rEventSet.pCurrentTextLine->SetPosition(rEventSet.ix+rEventSet.iWidth/2, rEventSet.iy + rEventSet.iyLocal);

  001bf	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001c2	03 46 08	 add	 eax, DWORD PTR [esi+8]
  001c5	66 0f 6e c0	 movd	 xmm0, eax
  001c9	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001cc	99		 cdq
  001cd	2b c2		 sub	 eax, edx
  001cf	d1 f8		 sar	 eax, 1
$LN66@InsertLine:
  001d1	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001d4	03 46 04	 add	 eax, DWORD PTR [esi+4]
  001d7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001da	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  001e2	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001e8	66 0f 6e c0	 movd	 xmm0, eax
$LN67@InsertLine:
  001ec	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  001ef	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001f2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f7	e8 00 00 00 00	 call	 ?SetPosition@CGraphicTextInstance@@QAEXMMM@Z ; CGraphicTextInstance::SetPosition
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  001fc	6a 00		 push	 0
  001fe	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1060 : 	rEventSet.strCurrentLine = "";

  00203	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00206	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0020d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00212	5f		 pop	 edi
  00213	5e		 pop	 esi
  00214	5b		 pop	 ebx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1061 : }

  00215	8b e5		 mov	 esp, ebp
  00217	5d		 pop	 ebp
  00218	c2 0c 00	 ret	 12			; 0000000cH
$LN68@InsertLine:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1907 : 			_Xlength_error("list<T> too long");

  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00220	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN70@InsertLine:
$LN65@InsertLine:
  00225	cc		 int	 3
?__InsertLine@CPythonEventManager@@IAEXAAUSEventSet@1@HH@Z ENDP ; CPythonEventManager::__InsertLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?RefreshLinePosition@CPythonEventManager@@IAEXPAUSEventSet@1@@Z
_TEXT	SEGMENT
_pEventSet$ = 8						; size = 4
?RefreshLinePosition@CPythonEventManager@@IAEXPAUSEventSet@1@@Z PROC ; CPythonEventManager::RefreshLinePosition, COMDAT
; _this$dead$ = ecx

; 1064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1066 : 	for (TScriptTextLineList::iterator itor = pEventSet->ScriptTextLineList.begin(); itor != pEventSet->ScriptTextLineList.end(); ++itor)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _pEventSet$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00008	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]

; 44   : 		{	// construct with node pointer _Pnode

  0000b	8b 30		 mov	 esi, DWORD PTR [eax]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  0000d	3b f0		 cmp	 esi, eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1066 : 	for (TScriptTextLineList::iterator itor = pEventSet->ScriptTextLineList.begin(); itor != pEventSet->ScriptTextLineList.end(); ++itor)

  0000f	74 3f		 je	 SHORT $LN5@RefreshLin
$LL24@RefreshLin:

; 1067 : 	{
; 1068 : 		TTextLine & rkLine = *itor;
; 1069 : 		CGraphicTextInstance * pInstance = rkLine.pInstance;
; 1070 : 		pInstance->SetPosition(pEventSet->ix + rkLine.ixLocal, pEventSet->iy + rkLine.iyLocal);

  00011	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00014	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00017	03 47 08	 add	 eax, DWORD PTR [edi+8]
  0001a	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0001d	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  00025	66 0f 6e c0	 movd	 xmm0, eax
  00029	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002c	03 46 08	 add	 eax, DWORD PTR [esi+8]
  0002f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00032	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00038	66 0f 6e c0	 movd	 xmm0, eax
  0003c	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0003f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00044	e8 00 00 00 00	 call	 ?SetPosition@CGraphicTextInstance@@QAEXMMM@Z ; CGraphicTextInstance::SetPosition
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00049	8b 36		 mov	 esi, DWORD PTR [esi]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  0004b	3b 77 4c	 cmp	 esi, DWORD PTR [edi+76]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1066 : 	for (TScriptTextLineList::iterator itor = pEventSet->ScriptTextLineList.begin(); itor != pEventSet->ScriptTextLineList.end(); ++itor)

  0004e	75 c1		 jne	 SHORT $LL24@RefreshLin
$LN5@RefreshLin:

; 1071 : 	}
; 1072 : 
; 1073 : 	int ixTextPos;
; 1074 : 	if (CGraphicTextInstance::HORIZONTAL_ALIGN_CENTER == pEventSet->pCurrentTextLine->GetHorizontalAlign())

  00050	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  00053	e8 00 00 00 00	 call	 ?GetHorizontalAlign@CGraphicTextInstance@@QAEHXZ ; CGraphicTextInstance::GetHorizontalAlign
  00058	83 f8 02	 cmp	 eax, 2
  0005b	75 0f		 jne	 SHORT $LN4@RefreshLin

; 1075 : 	{
; 1076 : 		ixTextPos = pEventSet->ix+pEventSet->iWidth/2;

  0005d	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00060	99		 cdq
  00061	2b c2		 sub	 eax, edx
  00063	8b c8		 mov	 ecx, eax
  00065	d1 f9		 sar	 ecx, 1
  00067	03 4f 04	 add	 ecx, DWORD PTR [edi+4]

; 1077 : 	}
; 1078 : 	else

  0006a	eb 17		 jmp	 SHORT $LN1@RefreshLin
$LN4@RefreshLin:

; 1079 : 	{
; 1080 : 		if (GetDefaultCodePage() == CP_1256)

  0006c	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  00071	3d e8 04 00 00	 cmp	 eax, 1256		; 000004e8H
  00076	75 08		 jne	 SHORT $LN2@RefreshLin

; 1081 : 			ixTextPos = pEventSet->ix+pEventSet->iWidth;

  00078	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0007b	03 4f 04	 add	 ecx, DWORD PTR [edi+4]

; 1082 : 		else

  0007e	eb 03		 jmp	 SHORT $LN1@RefreshLin
$LN2@RefreshLin:

; 1083 : 			ixTextPos = pEventSet->ix;

  00080	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
$LN1@RefreshLin:

; 1084 : 	}
; 1085 : 	pEventSet->pCurrentTextLine->SetPosition(ixTextPos, pEventSet->iy + pEventSet->iyLocal);

  00083	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00086	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00089	03 47 08	 add	 eax, DWORD PTR [edi+8]
  0008c	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  00094	66 0f 6e c0	 movd	 xmm0, eax
  00098	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0009b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000a1	66 0f 6e c1	 movd	 xmm0, ecx
  000a5	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  000a8	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b0	e8 00 00 00 00	 call	 ?SetPosition@CGraphicTextInstance@@QAEXMMM@Z ; CGraphicTextInstance::SetPosition
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi

; 1086 : }

  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
?RefreshLinePosition@CPythonEventManager@@IAEXPAUSEventSet@1@@Z ENDP ; CPythonEventManager::RefreshLinePosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?__AddSpace@CPythonEventManager@@IAEXAAUSEventSet@1@H@Z
_TEXT	SEGMENT
_rEventSet$ = 8						; size = 4
_iSpace$ = 12						; size = 4
?__AddSpace@CPythonEventManager@@IAEXAAUSEventSet@1@H@Z PROC ; CPythonEventManager::__AddSpace, COMDAT
; _this$dead$ = ecx

; 1089 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1090 : 	rEventSet.iyLocal += iSpace;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _rEventSet$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _iSpace$[ebp]
  00009	01 41 10	 add	 DWORD PTR [ecx+16], eax

; 1091 : }

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?__AddSpace@CPythonEventManager@@IAEXAAUSEventSet@1@H@Z ENDP ; CPythonEventManager::__AddSpace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?GetScriptEventIndex@CPythonEventManager@@IAE_NPBDPAH1@Z
_TEXT	SEGMENT
_pEventType$GSCopy$1$ = -40				; size = 4
$T1 = -36						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 24
__$ArrayPad$ = -8					; size = 4
_c_szName$ = 8						; size = 4
_pEventPosition$ = 12					; size = 4
_pEventType$ = 16					; size = 4
?GetScriptEventIndex@CPythonEventManager@@IAE_NPBDPAH1@Z PROC ; CPythonEventManager::GetScriptEventIndex, COMDAT
; _this$ = ecx

; 1094 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _pEventPosition$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _c_szName$[ebp]
  00019	8b d9		 mov	 ebx, ecx
  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _pEventType$[ebp]
  0001e	89 4d d8	 mov	 DWORD PTR _pEventType$GSCopy$1$[ebp], ecx

; 1095 : 	const char * c_szEventName;
; 1096 : 
; 1097 : 	if ('/' == c_szName[0])

  00021	80 3f 2f	 cmp	 BYTE PTR [edi], 47	; 0000002fH
  00024	75 09		 jne	 SHORT $LN3@GetScriptE

; 1098 : 	{
; 1099 : 		*pEventPosition = EVENT_POSITION_END;

  00026	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 1100 : 		c_szEventName = &c_szName[1];

  0002c	47		 inc	 edi

; 1101 : 	}
; 1102 : 	else

  0002d	eb 06		 jmp	 SHORT $LN2@GetScriptE
$LN3@GetScriptE:

; 1103 : 	{
; 1104 : 		*pEventPosition = EVENT_POSITION_START;

  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN2@GetScriptE:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00035	80 3f 00	 cmp	 BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00038	c7 45 f4 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH

; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0003f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00046	c6 45 e0 00	 mov	 BYTE PTR $T3[ebp], 0

; 523  : 			: _CSTD strlen(_First));

  0004a	75 04		 jne	 SHORT $LN49@GetScriptE
  0004c	33 c9		 xor	 ecx, ecx
  0004e	eb 0e		 jmp	 SHORT $LN50@GetScriptE
$LN49@GetScriptE:
  00050	8b cf		 mov	 ecx, edi
  00052	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL169@GetScriptE:
  00055	8a 01		 mov	 al, BYTE PTR [ecx]
  00057	41		 inc	 ecx
  00058	84 c0		 test	 al, al
  0005a	75 f9		 jne	 SHORT $LL169@GetScriptE
  0005c	2b ca		 sub	 ecx, edx
$LN50@GetScriptE:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0005e	51		 push	 ecx
  0005f	57		 push	 edi
  00060	8d 4d e0	 lea	 ecx, DWORD PTR $T3[ebp]
  00063	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1575 : 		return (iterator(_Lbound(_Keyval), this));

  00068	8d 45 e0	 lea	 eax, DWORD PTR $T3[ebp]
  0006b	50		 push	 eax
  0006c	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0006f	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lbound

; 44   : 		{	// construct with node pointer _Pnode

  00074	8b f0		 mov	 esi, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00076	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]

; 1553 : 					? end() : _Where);

  00079	74 26		 je	 SHORT $LN53@GetScriptE
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0007b	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  0007f	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

  00082	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 520  : 			: this->_Bx._Buf);

  00085	72 02		 jb	 SHORT $LN100@GetScriptE
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00087	8b 00		 mov	 eax, DWORD PTR [eax]
$LN100@GetScriptE:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));

  00089	51		 push	 ecx
  0008a	50		 push	 eax
  0008b	ff 75 f0	 push	 DWORD PTR $T3[ebp+16]
  0008e	8d 4d e0	 lea	 ecx, DWORD PTR $T3[ebp]
  00091	6a 00		 push	 0
  00093	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);
; 2490 : 	}
; 2491 : 
; 2492 : template<class _Elem,
; 2493 : 	class _Traits,
; 2494 : 	class _Alloc> inline
; 2495 : 	bool operator!=(
; 2496 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2497 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2498 : 	{	// test for string inequality
; 2499 : 	return (!(_Left == _Right));
; 2500 : 	}
; 2501 : 
; 2502 : template<class _Elem,
; 2503 : 	class _Traits,
; 2504 : 	class _Alloc> inline
; 2505 : 	bool operator!=(
; 2506 : 		const _Elem *_Left,
; 2507 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2508 : 	{	// test for NTCS vs. string inequality
; 2509 : 	return (!(_Left == _Right));
; 2510 : 	}
; 2511 : 
; 2512 : template<class _Elem,
; 2513 : 	class _Traits,
; 2514 : 	class _Alloc> inline
; 2515 : 	bool operator!=(
; 2516 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2517 : 		const _Elem *_Right)
; 2518 : 	{	// test for string vs. NTCS inequality
; 2519 : 	return (!(_Left == _Right));
; 2520 : 	}
; 2521 : 
; 2522 : template<class _Elem,
; 2523 : 	class _Traits,
; 2524 : 	class _Alloc> inline
; 2525 : 	bool operator<(
; 2526 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2527 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2528 : 	{	// test if string < string
; 2529 : 	return (_Left.compare(_Right) < 0);

  00098	85 c0		 test	 eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  0009a	78 05		 js	 SHORT $LN53@GetScriptE
  0009c	89 75 dc	 mov	 DWORD PTR $T1[ebp], esi
  0009f	eb 06		 jmp	 SHORT $LN170@GetScriptE
$LN53@GetScriptE:

; 44   : 		{	// construct with node pointer _Pnode

  000a1	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000a4	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
$LN170@GetScriptE:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000a7	83 7d f4 10	 cmp	 DWORD PTR $T3[ebp+20], 16 ; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  000ab	8d 75 dc	 lea	 esi, DWORD PTR $T2[ebp]
  000ae	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000b0	72 0b		 jb	 SHORT $LN133@GetScriptE
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000b2	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  000b5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ba	83 c4 04	 add	 esp, 4
$LN133@GetScriptE:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  000bd	c7 45 f4 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH

; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000c4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000cb	c6 45 e0 00	 mov	 BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  000cf	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1109 : 	if (it == EventTypeMap.end())

  000d2	75 23		 jne	 SHORT $LN1@GetScriptE

; 1110 : 	{
; 1111 : 		Tracef(" !! PARSING ERROR - Strange Command : %s\n", c_szEventName);

  000d4	57		 push	 edi
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JOIMEHF@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Strange?5Comm@
  000da	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  000df	83 c4 08	 add	 esp, 8

; 1112 : 		return false;

  000e2	32 c0		 xor	 al, al

; 1116 : 
; 1117 : 	return true;
; 1118 : }

  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c2 0c 00	 ret	 12			; 0000000cH
$LN1@GetScriptE:

; 1113 : 	}
; 1114 : 
; 1115 : 	*pEventType = it->second;

  000f7	8b 4d d8	 mov	 ecx, DWORD PTR _pEventType$GSCopy$1$[ebp]
  000fa	8b 46 28	 mov	 eax, DWORD PTR [esi+40]

; 1116 : 
; 1117 : 	return true;
; 1118 : }

  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	89 01		 mov	 DWORD PTR [ecx], eax
  00101	b0 01		 mov	 al, 1
  00103	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	5b		 pop	 ebx
  00109	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c2 0c 00	 ret	 12			; 0000000cH
?GetScriptEventIndex@CPythonEventManager@@IAE_NPBDPAH1@Z ENDP ; CPythonEventManager::GetScriptEventIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z PROC	; CPythonEventManager::CheckEventSetIndex, COMDAT
; _this$ = ecx

; 1121 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1122 : 	if (iIndex < 0)

  00003	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	79 06		 jns	 SHORT $LN2@CheckEvent

; 1123 : 		return false;

  0000a	32 c0		 xor	 al, al

; 1126 : 		return false;
; 1127 : 
; 1128 : 	return true;
; 1129 : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
$LN2@CheckEvent:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00010	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00013	2b 41 0c	 sub	 eax, DWORD PTR [ecx+12]
  00016	c1 f8 02	 sar	 eax, 2
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1125 : 	if ((DWORD) iIndex >= m_EventSetVector.size())

  00019	3b d0		 cmp	 edx, eax
  0001b	0f 92 c0	 setb	 al

; 1126 : 		return false;
; 1127 : 
; 1128 : 	return true;
; 1129 : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?CheckEventSetIndex@CPythonEventManager@@IAE_NH@Z ENDP	; CPythonEventManager::CheckEventSetIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?SetInterfaceWindow@CPythonEventManager@@QAEXPAU_object@@@Z
_TEXT	SEGMENT
_poInterface$ = 8					; size = 4
?SetInterfaceWindow@CPythonEventManager@@QAEXPAU_object@@@Z PROC ; CPythonEventManager::SetInterfaceWindow, COMDAT
; _this$ = ecx

; 1139 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1140 : 	m_poInterface = poInterface;

  00003	8b 45 08	 mov	 eax, DWORD PTR _poInterface$[ebp]
  00006	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 1141 : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetInterfaceWindow@CPythonEventManager@@QAEXPAU_object@@@Z ENDP ; CPythonEventManager::SetInterfaceWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp
;	COMDAT ?SetLeftTimeString@CPythonEventManager@@QAEXPBD@Z
_TEXT	SEGMENT
_c_szString$ = 8					; size = 4
?SetLeftTimeString@CPythonEventManager@@QAEXPBD@Z PROC	; CPythonEventManager::SetLeftTimeString, COMDAT
; _this$ = ecx

; 1144 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00004	8b 75 08	 mov	 esi, DWORD PTR _c_szString$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN9@SetLeftTim
  0000c	33 d2		 xor	 edx, edx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1145 : 	m_strLeftTimeString = c_szString;

  0000e	83 c1 68	 add	 ecx, 104		; 00000068H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00011	52		 push	 edx
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00018	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1146 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN9@SetLeftTim:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL11@SetLeftTim:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL11@SetLeftTim
  0002a	2b d7		 sub	 edx, edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1145 : 	m_strLeftTimeString = c_szString;

  0002c	83 c1 68	 add	 ecx, 104		; 00000068H
  0002f	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00030	52		 push	 edx
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00037	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythoneventmanager.cpp

; 1146 : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?SetLeftTimeString@CPythonEventManager@@QAEXPBD@Z ENDP	; CPythonEventManager::SetLeftTimeString
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCPythonEventManager@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPythonEventManager@@UAEPAXI@Z PROC			; CPythonEventManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPythonEventManager@@UAE@XZ ; CPythonEventManager::~CPythonEventManager
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCPythonEventManager@@UAEPAXI@Z ENDP			; CPythonEventManager::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ??0?$CDynamicPool@VCGraphicTextInstance@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPool@VCGraphicTextInstance@@@@QAE@XZ PROC	; CDynamicPool<CGraphicTextInstance>::CDynamicPool<CGraphicTextInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@

; 16   : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 14   : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 15   : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 16   : 		}

  00040	c3		 ret	 0
??0?$CDynamicPool@VCGraphicTextInstance@@@@QAE@XZ ENDP	; CDynamicPool<CGraphicTextInstance>::CDynamicPool<CGraphicTextInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ?Clear@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Clear@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ PROC ; CDynamicPool<CGraphicTextInstance>::Clear, COMDAT
; _this$ = ecx

; 33   : 		{			

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 33   : 		{			

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN31@Clear
$LL33@Clear:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z ; CDynamicPool<CGraphicTextInstance>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL33@Clear
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN31@Clear:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 35   : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Clear@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ ENDP ; CDynamicPool<CGraphicTextInstance>::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
_pkNewData$3 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ PROC ; CDynamicPool<CGraphicTextInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00026	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00029	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  0002c	75 4f		 jne	 SHORT $LN1@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0002e	6a 70		 push	 112			; 00000070H
  00030	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00035	83 c4 04	 add	 esp, 4
  00038	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	85 c0		 test	 eax, eax
  00044	74 09		 je	 SHORT $LN4@Alloc
  00046	8b c8		 mov	 ecx, eax
  00048	e8 00 00 00 00	 call	 ??0CGraphicTextInstance@@QAE@XZ ; CGraphicTextInstance::CGraphicTextInstance
  0004d	eb 02		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0004f	33 c0		 xor	 eax, eax
$LN5@Alloc:
  00051	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00058	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0005b	89 45 f0	 mov	 DWORD PTR _pkNewData$3[ebp], eax
  0005e	8d 45 f0	 lea	 eax, DWORD PTR _pkNewData$3[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::push_back

; 67   : 				++m_uUsedCapacity;

  00067	ff 46 20	 inc	 DWORD PTR [esi+32]

; 68   : 				return pkNewData;

  0006a	8b 45 f0	 mov	 eax, DWORD PTR _pkNewData$3[ebp]

; 74   : 		}

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00077	59		 pop	 ecx
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN1@Alloc:

; 69   : 			}
; 70   : 
; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  0007d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00080	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1282 : 		--this->_Mylast;

  00083	83 46 14 fc	 add	 DWORD PTR [esi+20], -4	; fffffffcH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 74   : 		}

  00087	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00091	59		 pop	 ecx
  00092	5e		 pop	 esi
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ ENDP ; CDynamicPool<CGraphicTextInstance>::Alloc
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ?Free@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXPAVCGraphicTextInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Free@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXPAVCGraphicTextInstance@@@Z PROC ; CDynamicPool<CGraphicTextInstance>::Free, COMDAT
; _this$ = ecx

; 76   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : #ifdef DYNAMIC_POOL_STRICT
; 78   : 			assert(__IsValidData(pkData));
; 79   : 			assert(!__IsFreeData(pkData));
; 80   : #endif
; 81   : 			m_kVct_pkFree.push_back(pkData);

  00003	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
  00006	83 c1 10	 add	 ecx, 16			; 00000010H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::push_back

; 82   : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?Free@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXPAVCGraphicTextInstance@@@Z ENDP ; CDynamicPool<CGraphicTextInstance>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::list<script::SArgumet,std::allocator<script::SArgumet> >, COMDAT
; _this$ = ecx

; 891  : 		{	// construct empty list

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 528  : 		this->_Mysize = 0;

  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buynode0

; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  00019	89 06		 mov	 DWORD PTR [esi], eax

; 892  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c3		 ret	 0
??0?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::list<script::SArgumet,std::allocator<script::SArgumet> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??1?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::~list<script::SArgumet,std::allocator<script::SArgumet> >, COMDAT
; _this$ = ecx

; 1094 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1499 : 		this->_Mysize = 0;
; 1500 : 
; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);
; 1504 : 			this->_Freenode(_Pnode);
; 1505 : 			}
; 1506 : 		}
; 1507 : 
; 1508 : 	void swap(_Myt& _Right)
; 1509 : 		{	// exchange contents with _Right
; 1510 : 		if (this == &_Right)
; 1511 : 			;	// same object, do nothing
; 1512 : 		else if (this->_Getal() == _Right._Getal())
; 1513 : 			{	// same allocator, swap control information
; 1514 : 			this->_Swap_all(_Right);
; 1515 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1516 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1517 : 			}
; 1518 : 
; 1519 : 		else if (_Alty::propagate_on_container_swap::value)
; 1520 : 			{	// swap allocators and control information
; 1521 : 			this->_Swap_alloc(_Right);
; 1522 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1523 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1524 : 			}
; 1525 : 
; 1526 : 		else	// containers are incompatible
; 1527 : 
; 1528 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1529 : 			_DEBUG_ERROR("list containers incompatible for swap");
; 1530 : 
; 1531 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1532 : 			_XSTD terminate();
; 1533 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1534 : 		}
; 1535 : 
; 1536 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1537 : 		{	// splice all of _Right at _Where
; 1538 : 		if (this != &_Right && !_Right.empty())
; 1539 : 			{	// worth splicing, do it
; 1540 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1541 : 				_Right._Mysize);
; 1542 : 			}
; 1543 : 		}
; 1544 : 
; 1545 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1546 : 		{	// splice all of _Right at _Where
; 1547 : 		splice(_Where, (_Myt&)_Right);
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1554 : 		if (_First == _Right.end())
; 1555 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1556 : 		else
; 1557 : 
; 1558 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1559 : 		if (_First != _Right.end())
; 1560 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1561 : 
; 1562 : 			{	// element exists, try splice
; 1563 : 			const_iterator _Last = _First;
; 1564 : 			++_Last;
; 1565 : 			if (this != &_Right
; 1566 : 				|| (_Where != _First && _Where != _Last))
; 1567 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1568 : 			}
; 1569 : 		}
; 1570 : 
; 1571 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1572 : 		const_iterator _First)
; 1573 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1574 : 		splice(_Where, (_Myt&)_Right, _First);
; 1575 : 		}
; 1576 : 
; 1577 : 	void splice(const_iterator _Where,
; 1578 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1579 : 		{	// splice _Right [_First, _Last) at _Where
; 1580 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1581 : 			{	// worth splicing, do it
; 1582 : 			size_type _Count = 0;
; 1583 : 
; 1584 : 			if (this == &_Right)
; 1585 : 				;	// just rearrange this list
; 1586 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1587 : 				_Count = _Right._Mysize;	// splice in whole list
; 1588 : 			else
; 1589 : 				{	// count nodes and check for knot
; 1590 : 				const_iterator _Next = _First;
; 1591 : 
; 1592 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1593 : 					if (_Next == _Right.end())
; 1594 : 						_Xlength_error("list<T> bad splice");
; 1595 : 				}
; 1596 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1597 : 			}
; 1598 : 		}
; 1599 : 
; 1600 : 	void splice(const_iterator _Where,
; 1601 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1602 : 		{	// splice _Right [_First, _Last) at _Where
; 1603 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1604 : 		}
; 1605 : 
; 1606 : 	void remove(const _Ty& _Val)
; 1607 : 		{	// erase each element matching _Val
; 1608 : 		iterator _Val_it = end();
; 1609 : 
; 1610 : 		for (iterator _First = begin(); _First != end(); )
; 1611 : 			if (*_First == _Val)
; 1612 : 				if (_STD addressof(*_First) == _STD addressof(_Val))
; 1613 : 					_Val_it = _First++;
; 1614 : 				else
; 1615 : 					_First = erase(_First);
; 1616 : 			else
; 1617 : 				++_First;
; 1618 : 
; 1619 : 		if (_Val_it != end())
; 1620 : 			erase(_Val_it);
; 1621 : 		}
; 1622 : 
; 1623 : 	template<class _Pr1>
; 1624 : 		void remove_if(_Pr1 _Pred)
; 1625 : 		{	// erase each element satisfying _Pred
; 1626 : 		for (iterator _First = begin(); _First != end(); )
; 1627 : 			if (_Pred(*_First))
; 1628 : 				_First = erase(_First);
; 1629 : 			else
; 1630 : 				++_First;
; 1631 : 		}
; 1632 : 
; 1633 : 	void unique()
; 1634 : 		{	// erase each element matching previous
; 1635 : 		unique(equal_to<>());
; 1636 : 		}
; 1637 : 
; 1638 : 	template<class _Pr2>
; 1639 : 		void unique(_Pr2 _Pred)
; 1640 : 		{	// erase each element satisfying _Pred with previous
; 1641 : 		const _Nodeptr _Phead = this->_Myhead;
; 1642 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1643 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1644 : 
; 1645 : 		while (_Pnode != _Phead)
; 1646 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1647 : 				{	// match, remove it
; 1648 : 				const _Nodeptr _Perase = _Pnode;
; 1649 : 				_Pnode = this->_Nextnode(_Pnode);
; 1650 : 
; 1651 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1652 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1653 : 				this->_Freenode(_Perase);
; 1654 : 
; 1655 : 				--this->_Mysize;
; 1656 : 				}
; 1657 : 			else
; 1658 : 				{	// no match, advance
; 1659 : 				_Pprev = _Pnode;
; 1660 : 				_Pnode = this->_Nextnode(_Pnode);
; 1661 : 				}
; 1662 : 		}
; 1663 : 
; 1664 : 	void merge(_Myt& _Right)
; 1665 : 		{	// merge in elements from _Right, both ordered by operator<
; 1666 : 		merge(_Right, less<>());
; 1667 : 		}
; 1668 : 
; 1669 : 	void merge(_Myt&& _Right)
; 1670 : 		{	// merge in elements from _Right, both ordered by operator<
; 1671 : 		merge((_Myt&)_Right);
; 1672 : 		}
; 1673 : 
; 1674 : 	template<class _Pr2>
; 1675 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1676 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1677 : 		if (&_Right != this)
; 1678 : 			{	// safe to merge, do it
; 1679 : 			iterator _First1 = begin(), _Last1 = end();
; 1680 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1681 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1682 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1683 : 
; 1684 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1685 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1686 : 					{	// splice in an element from _Right
; 1687 : 					iterator _Mid2 = _First2;
; 1688 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1689 : 					_First2 = _Mid2;
; 1690 : 					}
; 1691 : 				else
; 1692 : 					++_First1;
; 1693 : 
; 1694 : 			if (_First2 != _Last2)
; 1695 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1696 : 					_Right._Mysize);	// splice remainder of _Right
; 1697 : 			}
; 1698 : 		}
; 1699 : 
; 1700 : 	template<class _Pr2>
; 1701 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1702 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1703 : 		merge((_Myt&)_Right, _Pred);
; 1704 : 		}
; 1705 : 
; 1706 : 	void sort()
; 1707 : 		{	// order sequence, using operator<
; 1708 : 		sort(less<>());
; 1709 : 		}
; 1710 : 
; 1711 : 	template<class _Pr2>
; 1712 : 		void sort(_Pr2 _Pred)
; 1713 : 		{	// order sequence, using _Pred
; 1714 : 		if (2 <= this->_Mysize)
; 1715 : 			{	// worth sorting, do it
; 1716 : 			const size_t _MAXBINS = 25;
; 1717 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1718 : 			size_t _Maxbin = 0;
; 1719 : 
; 1720 : 			while (!empty())
; 1721 : 				{	// sort another element, using bins
; 1722 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1723 : 					++begin(), 1);
; 1724 : 
; 1725 : 				size_t _Bin;
; 1726 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1727 : 					++_Bin)
; 1728 : 					{	// merge into ever larger bins
; 1729 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1730 : 					_Binlist[_Bin].swap(_Templist);
; 1731 : 					}
; 1732 : 
; 1733 : 				if (_Bin == _MAXBINS)
; 1734 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1735 : 				else
; 1736 : 					{	// spill to new bin, while they last
; 1737 : 					_Binlist[_Bin].swap(_Templist);
; 1738 : 					if (_Bin == _Maxbin)
; 1739 : 						++_Maxbin;
; 1740 : 					}
; 1741 : 				}
; 1742 : 
; 1743 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1744 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1745 : 					_Pred);	// merge up
; 1746 : 
; 1747 : 			_Analysis_assume_(0 < _Maxbin);
; 1748 : 
; 1749 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1750 : 			}
; 1751 : 		}
; 1752 : 
; 1753 : 	void reverse() _NOEXCEPT
; 1754 : 		{	// reverse sequence
; 1755 : 		const _Nodeptr _Phead = this->_Myhead;
; 1756 : 		_Nodeptr _Pnode = _Phead;
; 1757 : 
; 1758 : 		for (; ; )
; 1759 : 			{	// flip pointers in a node
; 1760 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1761 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1762 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1763 : 
; 1764 : 			if (_Pnext == _Phead)
; 1765 : 				break;
; 1766 : 			_Pnode = _Pnext;
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	void _Splice(const_iterator _Where,
; 1771 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1772 : 		size_type _Count)
; 1773 : 		{	// splice _Right [_First, _Last) before _Where
; 1774 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1775 : 		if (_Where._Getcont() != this)
; 1776 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1777 : 		if (this->_Getal() != _Right._Getal())
; 1778 : 			_DEBUG_ERROR("list containers incompatible for splice");
; 1779 : 
; 1780 : 		if (this != &_Right)
; 1781 : 			{	// transfer ownership
; 1782 : 			_Lockit _Lock(_LOCK_DEBUG);
; 1783 : 
; 1784 : 			const bool _One = _Count == 1;
; 1785 : 			const bool _All = _Count == _Right.size();
; 1786 : 			const bool _Some = !_One && !_All;
; 1787 : 
; 1788 : 			_Nodeptr _Oldprev = _First._Ptr->_Prev;
; 1789 : 
; 1790 : 			if (_Some)
; 1791 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1792 : 					_Ptr = _Ptr->_Next)
; 1793 : 					{	// mark _Prev pointers
; 1794 : 					_Ptr->_Prev = 0;
; 1795 : 					}
; 1796 : 
; 1797 : 			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();
; 1798 : 
; 1799 : 			if (_Pnext == 0)
; 1800 : 				_DEBUG_ERROR("list container corrupted");
; 1801 : 
; 1802 : 			while (*_Pnext != 0)
; 1803 : 				{	// check the iterator
; 1804 : 				const_iterator& _Iter = **_Pnext;
; 1805 : 
; 1806 : 				if ((_One && _Iter._Ptr == _First._Ptr)
; 1807 : 					|| (_All && _Iter._Ptr != _Right._Myhead)
; 1808 : 					|| (_Some && _Iter._Ptr->_Prev == 0))
; 1809 : 					{	// adopt the iterator
; 1810 : 					*_Pnext = (const_iterator *)_Iter._Mynextiter;
; 1811 : 					_Iter._Myproxy = this->_Myproxy;
; 1812 : 					_Iter._Mynextiter = this->_Myproxy->_Myfirstiter;
; 1813 : 					this->_Myproxy->_Myfirstiter = &_Iter;
; 1814 : 					}
; 1815 : 				else
; 1816 : 					{	// skip the iterator
; 1817 : 					_Pnext = (const_iterator **)_Iter._Getpnext();
; 1818 : 					}
; 1819 : 				}
; 1820 : 
; 1821 : 			if (_Some)
; 1822 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1823 : 					_Ptr = _Ptr->_Next)
; 1824 : 					{	// restore _Prev pointers
; 1825 : 					_Ptr->_Prev = _Oldprev;
; 1826 : 					_Oldprev = _Ptr;
; 1827 : 					}
; 1828 : 			}
; 1829 : 
; 1830 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1831 : 		if (this->_Getal() != _Right._Getal())
; 1832 : 			_XSTD terminate();
; 1833 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1834 : 
; 1835 : 		_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1836 : 		}
; 1837 : 
; 1838 : 	void _Splice_same(const_iterator _Where,
; 1839 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1840 : 		size_type _Count)
; 1841 : 		{	// splice _Right [_First, _Last) before _Where
; 1842 : 		if (this != &_Right)
; 1843 : 			{	// splicing from another list, adjust counts
; 1844 : 			_Incsize(_Count);
; 1845 : 			_Right._Mysize -= _Count;
; 1846 : 			}
; 1847 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1848 : 			_Last._Mynode();
; 1849 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1850 : 			_Where._Mynode();
; 1851 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1852 : 			_First._Mynode();
; 1853 : 
; 1854 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1855 : 		this->_Prevnode(_Where._Mynode()) =
; 1856 : 			this->_Prevnode(_Last._Mynode());
; 1857 : 		this->_Prevnode(_Last._Mynode()) =
; 1858 : 			this->_Prevnode(_First._Mynode());
; 1859 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1860 : 		}
; 1861 : 
; 1862 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1863 : 		_Unchecked_const_iterator _First,
; 1864 : 		_Unchecked_const_iterator _Last)
; 1865 : 		{	// splice [_First, _Last) before _Where
; 1866 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1867 : 			_Last._Mynode();
; 1868 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1869 : 			_Where._Mynode();
; 1870 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1871 : 			_First._Mynode();
; 1872 : 
; 1873 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1874 : 		this->_Prevnode(_Where._Mynode()) =
; 1875 : 			this->_Prevnode(_Last._Mynode());
; 1876 : 		this->_Prevnode(_Last._Mynode()) =
; 1877 : 			this->_Prevnode(_First._Mynode());
; 1878 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1879 : 		}
; 1880 : 
; 1881 : 	void _Tidy()
; 1882 : 		{	// free all storage
; 1883 : 		clear();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
  00012	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1096 : 		}

  00013	c3		 ret	 0
??1?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::~list<script::SArgumet,std::allocator<script::SArgumet> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?begin@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@2@XZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::begin, COMDAT
; _this$ = ecx

; 1115 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 44   : 		{	// construct with node pointer _Pnode

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@2@XZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?end@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@2@XZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::end, COMDAT
; _this$ = ecx

; 1125 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@2@XZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?size@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QBEIXZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::size, COMDAT
; _this$ = ecx

; 1236 : 		return (this->_Mysize);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1237 : 		}

  00003	c3		 ret	 0
?size@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QBEIXZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?empty@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QBE_NXZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::empty, COMDAT
; _this$ = ecx

; 1246 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  00005	0f 94 c0	 sete	 al

; 1247 : 		}

  00008	c3		 ret	 0
?empty@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QBE_NXZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??0?$CSingleton@VCPythonEventManager@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CSingleton@VCPythonEventManager@@@@QAE@XZ PROC	; CSingleton<CPythonEventManager>::CSingleton<CPythonEventManager>, COMDAT
; _this$ = ecx

; 11   : 	CSingleton()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCPythonEventManager@@@@6B@

; 12   : 	{ 
; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 
; 15   : 		ms_singleton = (T*) ((int) this + offset);
; 16   : 	} 

  00006	8b c1		 mov	 eax, ecx
  00008	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonEventManager@@@@0PAVCPythonEventManager@@A, ecx ; CSingleton<CPythonEventManager>::ms_singleton
  0000e	c3		 ret	 0
??0?$CSingleton@VCPythonEventManager@@@@QAE@XZ ENDP	; CSingleton<CPythonEventManager>::CSingleton<CPythonEventManager>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??1?$CSingleton@VCPythonEventManager@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CSingleton@VCPythonEventManager@@@@UAE@XZ PROC	; CSingleton<CPythonEventManager>::~CSingleton<CPythonEventManager>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCPythonEventManager@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonEventManager@@@@0PAVCPythonEventManager@@A, 0 ; CSingleton<CPythonEventManager>::ms_singleton

; 22   : 	}

  00010	c3		 ret	 0
??1?$CSingleton@VCPythonEventManager@@@@UAE@XZ ENDP	; CSingleton<CPythonEventManager>::~CSingleton<CPythonEventManager>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 95   : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 96   : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c3		 ret	 0
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
$T2 = 8							; size = 4
__Keyval$ = 8						; size = 4
??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[], COMDAT
; _this$ = ecx

; 173  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1575 : 		return (iterator(_Lbound(_Keyval), this));

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Keyval$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 173  : 		{	// find element matching _Keyval or insert with default mapped

  00009	8b d9		 mov	 ebx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1575 : 		return (iterator(_Lbound(_Keyval), this));

  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lbound

; 44   : 		{	// construct with node pointer _Pnode

  00011	8b f0		 mov	 esi, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00013	3b 33		 cmp	 esi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 176  : 			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

  00015	74 2a		 je	 SHORT $LN1@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00017	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  0001b	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

  0001e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 520  : 			: this->_Bx._Buf);

  00021	72 02		 jb	 SHORT $LN49@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN49@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));

  00025	51		 push	 ecx
  00026	50		 push	 eax
  00027	ff 77 10	 push	 DWORD PTR [edi+16]
  0002a	8b cf		 mov	 ecx, edi
  0002c	6a 00		 push	 0
  0002e	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);
; 2490 : 	}
; 2491 : 
; 2492 : template<class _Elem,
; 2493 : 	class _Traits,
; 2494 : 	class _Alloc> inline
; 2495 : 	bool operator!=(
; 2496 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2497 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2498 : 	{	// test for string inequality
; 2499 : 	return (!(_Left == _Right));
; 2500 : 	}
; 2501 : 
; 2502 : template<class _Elem,
; 2503 : 	class _Traits,
; 2504 : 	class _Alloc> inline
; 2505 : 	bool operator!=(
; 2506 : 		const _Elem *_Left,
; 2507 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2508 : 	{	// test for NTCS vs. string inequality
; 2509 : 	return (!(_Left == _Right));
; 2510 : 	}
; 2511 : 
; 2512 : template<class _Elem,
; 2513 : 	class _Traits,
; 2514 : 	class _Alloc> inline
; 2515 : 	bool operator!=(
; 2516 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2517 : 		const _Elem *_Right)
; 2518 : 	{	// test for string vs. NTCS inequality
; 2519 : 	return (!(_Left == _Right));
; 2520 : 	}
; 2521 : 
; 2522 : template<class _Elem,
; 2523 : 	class _Traits,
; 2524 : 	class _Alloc> inline
; 2525 : 	bool operator<(
; 2526 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2527 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2528 : 	{	// test if string < string
; 2529 : 	return (_Left.compare(_Right) < 0);

  00033	85 c0		 test	 eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 176  : 			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

  00035	78 0a		 js	 SHORT $LN1@operator

; 182  : 
; 183  : 
; 184  : 		return (_Where->second);

  00037	5f		 pop	 edi
  00038	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx

; 185  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN1@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

  00041	51		 push	 ecx
  00042	8d 45 08	 lea	 eax, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  00045	89 7d 08	 mov	 DWORD PTR $T2[ebp], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

  00048	50		 push	 eax
  00049	51		 push	 ecx
  0004a	8b cb		 mov	 ecx, ebx
  0004c	e8 00 00 00 00	 call	 ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  00051	50		 push	 eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00052	83 c0 10	 add	 eax, 16			; 00000010H

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  00055	8b cb		 mov	 ecx, ebx
  00057	50		 push	 eax
  00058	56		 push	 esi
  00059	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_hint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 181  : 				tuple<>());

  00062	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 182  : 
; 183  : 
; 184  : 		return (_Where->second);

  00067	83 c0 28	 add	 eax, 40			; 00000028H
  0006a	5b		 pop	 ebx

; 185  : 		}

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAH$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >, COMDAT
; _this$ = ecx

; 1191 : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1193 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 1221 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 1548 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Keyval$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	53		 push	 ebx

; 1548 : 		{	// find an element in mutable sequence that matches _Keyval

  0000a	8b f9		 mov	 edi, ecx

; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));

  0000c	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lbound

; 44   : 		{	// construct with node pointer _Pnode

  00011	8b f0		 mov	 esi, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00013	3b 37		 cmp	 esi, DWORD PTR [edi]

; 1553 : 					? end() : _Where);

  00015	74 34		 je	 SHORT $LN3@find
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00017	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  0001b	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

  0001e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 520  : 			: this->_Bx._Buf);

  00021	72 02		 jb	 SHORT $LN49@find
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN49@find:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));

  00025	51		 push	 ecx
  00026	50		 push	 eax
  00027	ff 73 10	 push	 DWORD PTR [ebx+16]
  0002a	8b cb		 mov	 ecx, ebx
  0002c	6a 00		 push	 0
  0002e	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);
; 2490 : 	}
; 2491 : 
; 2492 : template<class _Elem,
; 2493 : 	class _Traits,
; 2494 : 	class _Alloc> inline
; 2495 : 	bool operator!=(
; 2496 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2497 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2498 : 	{	// test for string inequality
; 2499 : 	return (!(_Left == _Right));
; 2500 : 	}
; 2501 : 
; 2502 : template<class _Elem,
; 2503 : 	class _Traits,
; 2504 : 	class _Alloc> inline
; 2505 : 	bool operator!=(
; 2506 : 		const _Elem *_Left,
; 2507 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2508 : 	{	// test for NTCS vs. string inequality
; 2509 : 	return (!(_Left == _Right));
; 2510 : 	}
; 2511 : 
; 2512 : template<class _Elem,
; 2513 : 	class _Traits,
; 2514 : 	class _Alloc> inline
; 2515 : 	bool operator!=(
; 2516 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2517 : 		const _Elem *_Right)
; 2518 : 	{	// test for string vs. NTCS inequality
; 2519 : 	return (!(_Left == _Right));
; 2520 : 	}
; 2521 : 
; 2522 : template<class _Elem,
; 2523 : 	class _Traits,
; 2524 : 	class _Alloc> inline
; 2525 : 	bool operator<(
; 2526 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2527 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2528 : 	{	// test if string < string
; 2529 : 	return (_Left.compare(_Right) < 0);

  00033	85 c0		 test	 eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1553 : 					? end() : _Where);

  00035	78 14		 js	 SHORT $LN3@find
  00037	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	8d 4d 0c	 lea	 ecx, DWORD PTR $T2[ebp]
  0003d	5f		 pop	 edi
  0003e	89 75 0c	 mov	 DWORD PTR $T1[ebp], esi
  00041	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00043	5e		 pop	 esi
  00044	89 08		 mov	 DWORD PTR [eax], ecx
  00046	5b		 pop	 ebx

; 1554 : 		}

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
$LN3@find:

; 44   : 		{	// construct with node pointer _Pnode

  0004b	8b 07		 mov	 eax, DWORD PTR [edi]

; 1553 : 					? end() : _Where);

  0004d	8d 4d 0c	 lea	 ecx, DWORD PTR $T2[ebp]

; 44   : 		{	// construct with node pointer _Pnode

  00050	89 45 0c	 mov	 DWORD PTR $T2[ebp], eax

; 1553 : 					? end() : _Where);

  00053	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00056	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	89 08		 mov	 DWORD PTR [eax], ecx
  0005c	5b		 pop	 ebx

; 1554 : 		}

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >, COMDAT
; _this$ = ecx

; 891  : 		{	// construct empty list

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 528  : 		this->_Mysize = 0;

  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buynode0

; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  00019	89 06		 mov	 DWORD PTR [esi], eax

; 892  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c3		 ret	 0
??0?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??1?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::~list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >, COMDAT
; _this$ = ecx

; 1094 : 		{	// destroy the object

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 07		 mov	 eax, DWORD PTR [edi]

; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00005	8b 10		 mov	 edx, DWORD PTR [eax]

; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00007	89 00		 mov	 DWORD PTR [eax], eax

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00009	8b 07		 mov	 eax, DWORD PTR [edi]

; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  0000b	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1499 : 		this->_Mysize = 0;

  0000e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00015	3b 17		 cmp	 edx, DWORD PTR [edi]
  00017	74 19		 je	 SHORT $LN5@list
  00019	56		 push	 esi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL7@list:

; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 32		 mov	 esi, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  0002b	8b d6		 mov	 edx, esi
  0002d	3b 37		 cmp	 esi, DWORD PTR [edi]
  0002f	75 ef		 jne	 SHORT $LL7@list
  00031	5e		 pop	 esi
$LN5@list:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00032	ff 37		 push	 DWORD PTR [edi]
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
  0003c	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1096 : 		}

  0003d	c3		 ret	 0
??1?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::~list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?begin@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::begin, COMDAT
; _this$ = ecx

; 1115 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 44   : 		{	// construct with node pointer _Pnode

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?end@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::end, COMDAT
; _this$ = ecx

; 1125 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?size@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QBEIXZ PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::size, COMDAT
; _this$ = ecx

; 1236 : 		return (this->_Mysize);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1237 : 		}

  00003	c3		 ret	 0
?size@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QBEIXZ ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?push_back@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXABUSTextLine@CPythonEventManager@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXABUSTextLine@CPythonEventManager@@@Z PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::push_back, COMDAT
; _this$ = ecx

; 1285 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();
; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 768  : 		}
; 769  : 
; 770  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 771  : 		{	// free head node using current allocator
; 772  : 		this->_Getal().destroy(
; 773  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 774  : 		this->_Getal().destroy(
; 775  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 776  : 		this->_Getal().deallocate(_Pnode, 1);
; 777  : 		}
; 778  : 
; 779  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 780  : 		_Nodeptr _Prev)
; 781  : 		{	// allocate a node and set links
; 782  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 783  : 
; 784  : 		if (_Next == _Nodeptr())
; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;
; 787  : 			_Prev = _Pnode;
; 788  : 			}
; 789  : 		_TRY_BEGIN
; 790  : 		this->_Getal().construct(
; 791  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 792  : 		this->_Getal().construct(
; 793  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 794  : 		_CATCH_ALL
; 795  : 		this->_Getal().deallocate(_Pnode, 1);
; 796  : 		_RERAISE;
; 797  : 		_CATCH_END
; 798  : 
; 799  : 		return (_Pnode);
; 800  : 		}
; 801  : 
; 802  : 	_Alty _Getal() const
; 803  : 		{	// get reference to allocator
; 804  : 		return (_Alty());
; 805  : 		}
; 806  : 	};
; 807  : 
; 808  : 		// TEMPLATE CLASS _List_buy
; 809  : template<class _Ty,
; 810  : 	class _Alloc>
; 811  : 	class _List_buy
; 812  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 813  : 			_List_base_types<_Ty, _Alloc> >
; 814  : 	{	// base class for list to hold buynode/freenode functions
; 815  : public:
; 816  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 817  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 818  : 	typedef typename _Mybase::_Alty _Alty;
; 819  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 820  : 
; 821  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 822  : 		: _Mybase(_Al)
; 823  : 		{	// construct from allocator
; 824  : 		}
; 825  : 
; 826  : 	template<class... _Valty>
; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 831  : 
; 832  : 		_TRY_BEGIN
; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);
; 836  : 		_CATCH_ALL
; 837  : 		this->_Getal().deallocate(_Pnode, 1);
; 838  : 		_RERAISE;
; 839  : 		_CATCH_END
; 840  : 
; 841  : 		return (_Pnode);
; 842  : 		}
; 843  : 
; 844  : 
; 845  : 	void _Freenode(_Nodeptr _Pnode)
; 846  : 		{	// give node back
; 847  : 		this->_Getal().destroy(
; 848  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Myval(_Pnode)));
; 853  : 		this->_Getal().deallocate(_Pnode, 1);
; 854  : 		}
; 855  : 	};
; 856  : 
; 857  : 		// TEMPLATE CLASS list
; 858  : template<class _Ty,
; 859  : 	class _Alloc = allocator<_Ty> >
; 860  : 	class list
; 861  : 		: public _List_buy<_Ty, _Alloc>
; 862  : 	{	// bidirectional linked list
; 863  : public:
; 864  : 	typedef list<_Ty, _Alloc> _Myt;
; 865  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 866  : 	typedef typename _Mybase::_Node _Node;
; 867  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 868  : 	typedef typename _Mybase::_Alty _Alty;
; 869  : 
; 870  : 	typedef _Alloc allocator_type;
; 871  : 	typedef typename _Mybase::size_type size_type;
; 872  : 	typedef typename _Mybase::difference_type difference_type;
; 873  : 	typedef typename _Mybase::pointer pointer;
; 874  : 	typedef typename _Mybase::const_pointer const_pointer;
; 875  : 	typedef typename _Mybase::reference reference;
; 876  : 	typedef typename _Mybase::const_reference const_reference;
; 877  : 	typedef typename _Mybase::value_type value_type;
; 878  : 
; 879  : 	typedef typename _Mybase::const_iterator const_iterator;
; 880  : 	typedef typename _Mybase::iterator iterator;
; 881  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 882  : 		_Unchecked_const_iterator;
; 883  : 	typedef typename _Mybase::_Unchecked_iterator
; 884  : 		_Unchecked_iterator;
; 885  : 
; 886  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 887  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 888  : 
; 889  : 	list()
; 890  : 		: _Mybase()
; 891  : 		{	// construct empty list
; 892  : 		}
; 893  : 
; 894  : 	explicit list(const _Alloc& _Al)
; 895  : 		: _Mybase(_Al)
; 896  : 		{	// construct empty list, allocator
; 897  : 		}
; 898  : 
; 899  : 	explicit list(size_type _Count)
; 900  : 		: _Mybase()
; 901  : 		{	// construct list from _Count * _Ty()
; 902  : 		resize(_Count);
; 903  : 		}
; 904  : 
; 905  : 	list(size_type _Count, const _Ty& _Val)
; 906  : 		: _Mybase()
; 907  : 		{	// construct list from _Count * _Val
; 908  : 		_Construct_n(_Count, _Val);
; 909  : 		}
; 910  : 
; 911  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 912  : 		: _Mybase(_Al)
; 913  : 		{	// construct list from _Count * _Val, allocator
; 914  : 		_Construct_n(_Count, _Val);
; 915  : 		}
; 916  : 
; 917  : 	list(const _Myt& _Right)
; 918  : 
; 919  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 920  : 
; 921  : 
; 922  : 		{	// construct list by copying _Right
; 923  : 		_TRY_BEGIN
; 924  : 		insert(begin(), _Right.begin(), _Right.end());
; 925  : 		_CATCH_ALL
; 926  : 		_Tidy();
; 927  : 		_RERAISE;
; 928  : 		_CATCH_END
; 929  : 		}
; 930  : 
; 931  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 932  : 		: _Mybase(_Al)
; 933  : 		{	// construct list by copying _Right, allocator
; 934  : 		_TRY_BEGIN
; 935  : 		insert(begin(), _Right.begin(), _Right.end());
; 936  : 		_CATCH_ALL
; 937  : 		_Tidy();
; 938  : 		_RERAISE;
; 939  : 		_CATCH_END
; 940  : 		}
; 941  : 
; 942  : 	template<class _Iter,
; 943  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 944  : 			void>::type>
; 945  : 		list(_Iter _First, _Iter _Last)
; 946  : 		: _Mybase()
; 947  : 		{	// construct list from [_First, _Last)
; 948  : 		_Construct(_First, _Last);
; 949  : 		}
; 950  : 
; 951  : 	template<class _Iter,
; 952  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 953  : 			void>::type>
; 954  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct list, allocator from [_First, _Last)
; 957  : 		_Construct(_First, _Last);
; 958  : 		}
; 959  : 
; 960  : 	template<class _Iter>
; 961  : 		void _Construct(_Iter _First, _Iter _Last)
; 962  : 		{	// construct list from [_First, _Last), input iterators
; 963  : 		_TRY_BEGIN
; 964  : 		insert(begin(), _First, _Last);
; 965  : 		_CATCH_ALL
; 966  : 		_Tidy();
; 967  : 		_RERAISE;
; 968  : 		_CATCH_END
; 969  : 		}
; 970  : 
; 971  : 	void _Construct_n(size_type _Count,
; 972  : 		const _Ty& _Val)
; 973  : 		{	// construct from _Count * _Val
; 974  : 		_TRY_BEGIN
; 975  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 976  : 		_CATCH_ALL
; 977  : 		_Tidy();
; 978  : 		_RERAISE;
; 979  : 		_CATCH_END
; 980  : 		}
; 981  : 
; 982  : 	list(_Myt&& _Right)
; 983  : 		: _Mybase(_Right._Getal())
; 984  : 		{	// construct list by moving _Right
; 985  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 986  : 		}
; 987  : 
; 988  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 989  : 		: _Mybase(_Al)
; 990  : 		{	// construct list by moving _Right, allocator
; 991  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 992  : 		}
; 993  : 
; 994  : 	_Myt& operator=(_Myt&& _Right)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Change_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1013 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != this)
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);

  00007	ff 75 08	 push	 DWORD PTR __Val$[ebp]

; 96   : 		return (_Ptr);

  0000a	8b 3e		 mov	 edi, DWORD PTR [esi]

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();
; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 768  : 		}
; 769  : 
; 770  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 771  : 		{	// free head node using current allocator
; 772  : 		this->_Getal().destroy(
; 773  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 774  : 		this->_Getal().destroy(
; 775  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 776  : 		this->_Getal().deallocate(_Pnode, 1);
; 777  : 		}
; 778  : 
; 779  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 780  : 		_Nodeptr _Prev)
; 781  : 		{	// allocate a node and set links
; 782  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 783  : 
; 784  : 		if (_Next == _Nodeptr())
; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;
; 787  : 			_Prev = _Pnode;
; 788  : 			}
; 789  : 		_TRY_BEGIN
; 790  : 		this->_Getal().construct(
; 791  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 792  : 		this->_Getal().construct(
; 793  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 794  : 		_CATCH_ALL
; 795  : 		this->_Getal().deallocate(_Pnode, 1);
; 796  : 		_RERAISE;
; 797  : 		_CATCH_END
; 798  : 
; 799  : 		return (_Pnode);
; 800  : 		}
; 801  : 
; 802  : 	_Alty _Getal() const
; 803  : 		{	// get reference to allocator
; 804  : 		return (_Alty());
; 805  : 		}
; 806  : 	};
; 807  : 
; 808  : 		// TEMPLATE CLASS _List_buy
; 809  : template<class _Ty,
; 810  : 	class _Alloc>
; 811  : 	class _List_buy
; 812  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 813  : 			_List_base_types<_Ty, _Alloc> >
; 814  : 	{	// base class for list to hold buynode/freenode functions
; 815  : public:
; 816  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 817  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 818  : 	typedef typename _Mybase::_Alty _Alty;
; 819  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 820  : 
; 821  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 822  : 		: _Mybase(_Al)
; 823  : 		{	// construct from allocator
; 824  : 		}
; 825  : 
; 826  : 	template<class... _Valty>
; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 831  : 
; 832  : 		_TRY_BEGIN
; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);
; 836  : 		_CATCH_ALL
; 837  : 		this->_Getal().deallocate(_Pnode, 1);
; 838  : 		_RERAISE;
; 839  : 		_CATCH_END
; 840  : 
; 841  : 		return (_Pnode);
; 842  : 		}
; 843  : 
; 844  : 
; 845  : 	void _Freenode(_Nodeptr _Pnode)
; 846  : 		{	// give node back
; 847  : 		this->_Getal().destroy(
; 848  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Myval(_Pnode)));
; 853  : 		this->_Getal().deallocate(_Pnode, 1);
; 854  : 		}
; 855  : 	};
; 856  : 
; 857  : 		// TEMPLATE CLASS list
; 858  : template<class _Ty,
; 859  : 	class _Alloc = allocator<_Ty> >
; 860  : 	class list
; 861  : 		: public _List_buy<_Ty, _Alloc>
; 862  : 	{	// bidirectional linked list
; 863  : public:
; 864  : 	typedef list<_Ty, _Alloc> _Myt;
; 865  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 866  : 	typedef typename _Mybase::_Node _Node;
; 867  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 868  : 	typedef typename _Mybase::_Alty _Alty;
; 869  : 
; 870  : 	typedef _Alloc allocator_type;
; 871  : 	typedef typename _Mybase::size_type size_type;
; 872  : 	typedef typename _Mybase::difference_type difference_type;
; 873  : 	typedef typename _Mybase::pointer pointer;
; 874  : 	typedef typename _Mybase::const_pointer const_pointer;
; 875  : 	typedef typename _Mybase::reference reference;
; 876  : 	typedef typename _Mybase::const_reference const_reference;
; 877  : 	typedef typename _Mybase::value_type value_type;
; 878  : 
; 879  : 	typedef typename _Mybase::const_iterator const_iterator;
; 880  : 	typedef typename _Mybase::iterator iterator;
; 881  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 882  : 		_Unchecked_const_iterator;
; 883  : 	typedef typename _Mybase::_Unchecked_iterator
; 884  : 		_Unchecked_iterator;
; 885  : 
; 886  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 887  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 888  : 
; 889  : 	list()
; 890  : 		: _Mybase()
; 891  : 		{	// construct empty list
; 892  : 		}
; 893  : 
; 894  : 	explicit list(const _Alloc& _Al)
; 895  : 		: _Mybase(_Al)
; 896  : 		{	// construct empty list, allocator
; 897  : 		}
; 898  : 
; 899  : 	explicit list(size_type _Count)
; 900  : 		: _Mybase()
; 901  : 		{	// construct list from _Count * _Ty()
; 902  : 		resize(_Count);
; 903  : 		}
; 904  : 
; 905  : 	list(size_type _Count, const _Ty& _Val)
; 906  : 		: _Mybase()
; 907  : 		{	// construct list from _Count * _Val
; 908  : 		_Construct_n(_Count, _Val);
; 909  : 		}
; 910  : 
; 911  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 912  : 		: _Mybase(_Al)
; 913  : 		{	// construct list from _Count * _Val, allocator
; 914  : 		_Construct_n(_Count, _Val);
; 915  : 		}
; 916  : 
; 917  : 	list(const _Myt& _Right)
; 918  : 
; 919  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 920  : 
; 921  : 
; 922  : 		{	// construct list by copying _Right
; 923  : 		_TRY_BEGIN
; 924  : 		insert(begin(), _Right.begin(), _Right.end());
; 925  : 		_CATCH_ALL
; 926  : 		_Tidy();
; 927  : 		_RERAISE;
; 928  : 		_CATCH_END
; 929  : 		}
; 930  : 
; 931  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 932  : 		: _Mybase(_Al)
; 933  : 		{	// construct list by copying _Right, allocator
; 934  : 		_TRY_BEGIN
; 935  : 		insert(begin(), _Right.begin(), _Right.end());
; 936  : 		_CATCH_ALL
; 937  : 		_Tidy();
; 938  : 		_RERAISE;
; 939  : 		_CATCH_END
; 940  : 		}
; 941  : 
; 942  : 	template<class _Iter,
; 943  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 944  : 			void>::type>
; 945  : 		list(_Iter _First, _Iter _Last)
; 946  : 		: _Mybase()
; 947  : 		{	// construct list from [_First, _Last)
; 948  : 		_Construct(_First, _Last);
; 949  : 		}
; 950  : 
; 951  : 	template<class _Iter,
; 952  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 953  : 			void>::type>
; 954  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct list, allocator from [_First, _Last)
; 957  : 		_Construct(_First, _Last);
; 958  : 		}
; 959  : 
; 960  : 	template<class _Iter>
; 961  : 		void _Construct(_Iter _First, _Iter _Last)
; 962  : 		{	// construct list from [_First, _Last), input iterators
; 963  : 		_TRY_BEGIN
; 964  : 		insert(begin(), _First, _Last);
; 965  : 		_CATCH_ALL
; 966  : 		_Tidy();
; 967  : 		_RERAISE;
; 968  : 		_CATCH_END
; 969  : 		}
; 970  : 
; 971  : 	void _Construct_n(size_type _Count,
; 972  : 		const _Ty& _Val)
; 973  : 		{	// construct from _Count * _Val
; 974  : 		_TRY_BEGIN
; 975  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 976  : 		_CATCH_ALL
; 977  : 		_Tidy();
; 978  : 		_RERAISE;
; 979  : 		_CATCH_END
; 980  : 		}
; 981  : 
; 982  : 	list(_Myt&& _Right)
; 983  : 		: _Mybase(_Right._Getal())
; 984  : 		{	// construct list by moving _Right
; 985  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 986  : 		}
; 987  : 
; 988  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 989  : 		: _Mybase(_Al)
; 990  : 		{	// construct list by moving _Right, allocator
; 991  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 992  : 		}
; 993  : 
; 994  : 	_Myt& operator=(_Myt&& _Right)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Change_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1013 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != this)
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);

  0000c	ff 77 04	 push	 DWORD PTR [edi+4]
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 ??$_Buynode@ABUSTextLine@CPythonEventManager@@@?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PAU21@0ABUSTextLine@CPythonEventManager@@@Z ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Buynode<CPythonEventManager::STextLine const &>
  00015	8b d0		 mov	 edx, eax

; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1499 : 		this->_Mysize = 0;
; 1500 : 
; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);
; 1504 : 			this->_Freenode(_Pnode);
; 1505 : 			}
; 1506 : 		}
; 1507 : 
; 1508 : 	void swap(_Myt& _Right)
; 1509 : 		{	// exchange contents with _Right
; 1510 : 		if (this == &_Right)
; 1511 : 			;	// same object, do nothing
; 1512 : 		else if (this->_Getal() == _Right._Getal())
; 1513 : 			{	// same allocator, swap control information
; 1514 : 			this->_Swap_all(_Right);
; 1515 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1516 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1517 : 			}
; 1518 : 
; 1519 : 		else if (_Alty::propagate_on_container_swap::value)
; 1520 : 			{	// swap allocators and control information
; 1521 : 			this->_Swap_alloc(_Right);
; 1522 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1523 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1524 : 			}
; 1525 : 
; 1526 : 		else	// containers are incompatible
; 1527 : 
; 1528 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1529 : 			_DEBUG_ERROR("list containers incompatible for swap");
; 1530 : 
; 1531 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1532 : 			_XSTD terminate();
; 1533 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1534 : 		}
; 1535 : 
; 1536 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1537 : 		{	// splice all of _Right at _Where
; 1538 : 		if (this != &_Right && !_Right.empty())
; 1539 : 			{	// worth splicing, do it
; 1540 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1541 : 				_Right._Mysize);
; 1542 : 			}
; 1543 : 		}
; 1544 : 
; 1545 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1546 : 		{	// splice all of _Right at _Where
; 1547 : 		splice(_Where, (_Myt&)_Right);
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1554 : 		if (_First == _Right.end())
; 1555 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1556 : 		else
; 1557 : 
; 1558 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1559 : 		if (_First != _Right.end())
; 1560 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1561 : 
; 1562 : 			{	// element exists, try splice
; 1563 : 			const_iterator _Last = _First;
; 1564 : 			++_Last;
; 1565 : 			if (this != &_Right
; 1566 : 				|| (_Where != _First && _Where != _Last))
; 1567 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1568 : 			}
; 1569 : 		}
; 1570 : 
; 1571 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1572 : 		const_iterator _First)
; 1573 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1574 : 		splice(_Where, (_Myt&)_Right, _First);
; 1575 : 		}
; 1576 : 
; 1577 : 	void splice(const_iterator _Where,
; 1578 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1579 : 		{	// splice _Right [_First, _Last) at _Where
; 1580 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1581 : 			{	// worth splicing, do it
; 1582 : 			size_type _Count = 0;
; 1583 : 
; 1584 : 			if (this == &_Right)
; 1585 : 				;	// just rearrange this list
; 1586 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1587 : 				_Count = _Right._Mysize;	// splice in whole list
; 1588 : 			else
; 1589 : 				{	// count nodes and check for knot
; 1590 : 				const_iterator _Next = _First;
; 1591 : 
; 1592 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1593 : 					if (_Next == _Right.end())
; 1594 : 						_Xlength_error("list<T> bad splice");
; 1595 : 				}
; 1596 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1597 : 			}
; 1598 : 		}
; 1599 : 
; 1600 : 	void splice(const_iterator _Where,
; 1601 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1602 : 		{	// splice _Right [_First, _Last) at _Where
; 1603 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1604 : 		}
; 1605 : 
; 1606 : 	void remove(const _Ty& _Val)
; 1607 : 		{	// erase each element matching _Val
; 1608 : 		iterator _Val_it = end();
; 1609 : 
; 1610 : 		for (iterator _First = begin(); _First != end(); )
; 1611 : 			if (*_First == _Val)
; 1612 : 				if (_STD addressof(*_First) == _STD addressof(_Val))
; 1613 : 					_Val_it = _First++;
; 1614 : 				else
; 1615 : 					_First = erase(_First);
; 1616 : 			else
; 1617 : 				++_First;
; 1618 : 
; 1619 : 		if (_Val_it != end())
; 1620 : 			erase(_Val_it);
; 1621 : 		}
; 1622 : 
; 1623 : 	template<class _Pr1>
; 1624 : 		void remove_if(_Pr1 _Pred)
; 1625 : 		{	// erase each element satisfying _Pred
; 1626 : 		for (iterator _First = begin(); _First != end(); )
; 1627 : 			if (_Pred(*_First))
; 1628 : 				_First = erase(_First);
; 1629 : 			else
; 1630 : 				++_First;
; 1631 : 		}
; 1632 : 
; 1633 : 	void unique()
; 1634 : 		{	// erase each element matching previous
; 1635 : 		unique(equal_to<>());
; 1636 : 		}
; 1637 : 
; 1638 : 	template<class _Pr2>
; 1639 : 		void unique(_Pr2 _Pred)
; 1640 : 		{	// erase each element satisfying _Pred with previous
; 1641 : 		const _Nodeptr _Phead = this->_Myhead;
; 1642 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1643 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1644 : 
; 1645 : 		while (_Pnode != _Phead)
; 1646 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1647 : 				{	// match, remove it
; 1648 : 				const _Nodeptr _Perase = _Pnode;
; 1649 : 				_Pnode = this->_Nextnode(_Pnode);
; 1650 : 
; 1651 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1652 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1653 : 				this->_Freenode(_Perase);
; 1654 : 
; 1655 : 				--this->_Mysize;
; 1656 : 				}
; 1657 : 			else
; 1658 : 				{	// no match, advance
; 1659 : 				_Pprev = _Pnode;
; 1660 : 				_Pnode = this->_Nextnode(_Pnode);
; 1661 : 				}
; 1662 : 		}
; 1663 : 
; 1664 : 	void merge(_Myt& _Right)
; 1665 : 		{	// merge in elements from _Right, both ordered by operator<
; 1666 : 		merge(_Right, less<>());
; 1667 : 		}
; 1668 : 
; 1669 : 	void merge(_Myt&& _Right)
; 1670 : 		{	// merge in elements from _Right, both ordered by operator<
; 1671 : 		merge((_Myt&)_Right);
; 1672 : 		}
; 1673 : 
; 1674 : 	template<class _Pr2>
; 1675 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1676 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1677 : 		if (&_Right != this)
; 1678 : 			{	// safe to merge, do it
; 1679 : 			iterator _First1 = begin(), _Last1 = end();
; 1680 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1681 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1682 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1683 : 
; 1684 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1685 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1686 : 					{	// splice in an element from _Right
; 1687 : 					iterator _Mid2 = _First2;
; 1688 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1689 : 					_First2 = _Mid2;
; 1690 : 					}
; 1691 : 				else
; 1692 : 					++_First1;
; 1693 : 
; 1694 : 			if (_First2 != _Last2)
; 1695 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1696 : 					_Right._Mysize);	// splice remainder of _Right
; 1697 : 			}
; 1698 : 		}
; 1699 : 
; 1700 : 	template<class _Pr2>
; 1701 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1702 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1703 : 		merge((_Myt&)_Right, _Pred);
; 1704 : 		}
; 1705 : 
; 1706 : 	void sort()
; 1707 : 		{	// order sequence, using operator<
; 1708 : 		sort(less<>());
; 1709 : 		}
; 1710 : 
; 1711 : 	template<class _Pr2>
; 1712 : 		void sort(_Pr2 _Pred)
; 1713 : 		{	// order sequence, using _Pred
; 1714 : 		if (2 <= this->_Mysize)
; 1715 : 			{	// worth sorting, do it
; 1716 : 			const size_t _MAXBINS = 25;
; 1717 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1718 : 			size_t _Maxbin = 0;
; 1719 : 
; 1720 : 			while (!empty())
; 1721 : 				{	// sort another element, using bins
; 1722 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1723 : 					++begin(), 1);
; 1724 : 
; 1725 : 				size_t _Bin;
; 1726 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1727 : 					++_Bin)
; 1728 : 					{	// merge into ever larger bins
; 1729 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1730 : 					_Binlist[_Bin].swap(_Templist);
; 1731 : 					}
; 1732 : 
; 1733 : 				if (_Bin == _MAXBINS)
; 1734 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1735 : 				else
; 1736 : 					{	// spill to new bin, while they last
; 1737 : 					_Binlist[_Bin].swap(_Templist);
; 1738 : 					if (_Bin == _Maxbin)
; 1739 : 						++_Maxbin;
; 1740 : 					}
; 1741 : 				}
; 1742 : 
; 1743 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1744 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1745 : 					_Pred);	// merge up
; 1746 : 
; 1747 : 			_Analysis_assume_(0 < _Maxbin);
; 1748 : 
; 1749 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1750 : 			}
; 1751 : 		}
; 1752 : 
; 1753 : 	void reverse() _NOEXCEPT
; 1754 : 		{	// reverse sequence
; 1755 : 		const _Nodeptr _Phead = this->_Myhead;
; 1756 : 		_Nodeptr _Pnode = _Phead;
; 1757 : 
; 1758 : 		for (; ; )
; 1759 : 			{	// flip pointers in a node
; 1760 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1761 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1762 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1763 : 
; 1764 : 			if (_Pnext == _Phead)
; 1765 : 				break;
; 1766 : 			_Pnode = _Pnext;
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	void _Splice(const_iterator _Where,
; 1771 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1772 : 		size_type _Count)
; 1773 : 		{	// splice _Right [_First, _Last) before _Where
; 1774 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1775 : 		if (_Where._Getcont() != this)
; 1776 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1777 : 		if (this->_Getal() != _Right._Getal())
; 1778 : 			_DEBUG_ERROR("list containers incompatible for splice");
; 1779 : 
; 1780 : 		if (this != &_Right)
; 1781 : 			{	// transfer ownership
; 1782 : 			_Lockit _Lock(_LOCK_DEBUG);
; 1783 : 
; 1784 : 			const bool _One = _Count == 1;
; 1785 : 			const bool _All = _Count == _Right.size();
; 1786 : 			const bool _Some = !_One && !_All;
; 1787 : 
; 1788 : 			_Nodeptr _Oldprev = _First._Ptr->_Prev;
; 1789 : 
; 1790 : 			if (_Some)
; 1791 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1792 : 					_Ptr = _Ptr->_Next)
; 1793 : 					{	// mark _Prev pointers
; 1794 : 					_Ptr->_Prev = 0;
; 1795 : 					}
; 1796 : 
; 1797 : 			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();
; 1798 : 
; 1799 : 			if (_Pnext == 0)
; 1800 : 				_DEBUG_ERROR("list container corrupted");
; 1801 : 
; 1802 : 			while (*_Pnext != 0)
; 1803 : 				{	// check the iterator
; 1804 : 				const_iterator& _Iter = **_Pnext;
; 1805 : 
; 1806 : 				if ((_One && _Iter._Ptr == _First._Ptr)
; 1807 : 					|| (_All && _Iter._Ptr != _Right._Myhead)
; 1808 : 					|| (_Some && _Iter._Ptr->_Prev == 0))
; 1809 : 					{	// adopt the iterator
; 1810 : 					*_Pnext = (const_iterator *)_Iter._Mynextiter;
; 1811 : 					_Iter._Myproxy = this->_Myproxy;
; 1812 : 					_Iter._Mynextiter = this->_Myproxy->_Myfirstiter;
; 1813 : 					this->_Myproxy->_Myfirstiter = &_Iter;
; 1814 : 					}
; 1815 : 				else
; 1816 : 					{	// skip the iterator
; 1817 : 					_Pnext = (const_iterator **)_Iter._Getpnext();
; 1818 : 					}
; 1819 : 				}
; 1820 : 
; 1821 : 			if (_Some)
; 1822 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1823 : 					_Ptr = _Ptr->_Next)
; 1824 : 					{	// restore _Prev pointers
; 1825 : 					_Ptr->_Prev = _Oldprev;
; 1826 : 					_Oldprev = _Ptr;
; 1827 : 					}
; 1828 : 			}
; 1829 : 
; 1830 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1831 : 		if (this->_Getal() != _Right._Getal())
; 1832 : 			_XSTD terminate();
; 1833 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1834 : 
; 1835 : 		_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1836 : 		}
; 1837 : 
; 1838 : 	void _Splice_same(const_iterator _Where,
; 1839 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1840 : 		size_type _Count)
; 1841 : 		{	// splice _Right [_First, _Last) before _Where
; 1842 : 		if (this != &_Right)
; 1843 : 			{	// splicing from another list, adjust counts
; 1844 : 			_Incsize(_Count);
; 1845 : 			_Right._Mysize -= _Count;
; 1846 : 			}
; 1847 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1848 : 			_Last._Mynode();
; 1849 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1850 : 			_Where._Mynode();
; 1851 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1852 : 			_First._Mynode();
; 1853 : 
; 1854 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1855 : 		this->_Prevnode(_Where._Mynode()) =
; 1856 : 			this->_Prevnode(_Last._Mynode());
; 1857 : 		this->_Prevnode(_Last._Mynode()) =
; 1858 : 			this->_Prevnode(_First._Mynode());
; 1859 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1860 : 		}
; 1861 : 
; 1862 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1863 : 		_Unchecked_const_iterator _First,
; 1864 : 		_Unchecked_const_iterator _Last)
; 1865 : 		{	// splice [_First, _Last) before _Where
; 1866 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1867 : 			_Last._Mynode();
; 1868 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1869 : 			_Where._Mynode();
; 1870 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1871 : 			_First._Mynode();
; 1872 : 
; 1873 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1874 : 		this->_Prevnode(_Where._Mynode()) =
; 1875 : 			this->_Prevnode(_Last._Mynode());
; 1876 : 		this->_Prevnode(_Last._Mynode()) =
; 1877 : 			this->_Prevnode(_First._Mynode());
; 1878 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1879 : 		}
; 1880 : 
; 1881 : 	void _Tidy()
; 1882 : 		{	// free all storage
; 1883 : 		clear();
; 1884 : 		}
; 1885 : 
; 1886 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1887 : 		size_type _Count, const _Ty& _Val)
; 1888 : 		{	// insert _Count * _Val at _Where
; 1889 : 		size_type _Countsave = _Count;
; 1890 : 
; 1891 : 		_TRY_BEGIN
; 1892 : 		for (; 0 < _Count; --_Count)
; 1893 : 			_Insert(_Where, _Val);
; 1894 : 		_CATCH_ALL
; 1895 : 		for (; _Count < _Countsave; ++_Count)
; 1896 : 			{	// undo inserts
; 1897 : 			_Unchecked_const_iterator _Before = _Where;
; 1898 : 			_Unchecked_erase(--_Before);
; 1899 : 			}
; 1900 : 		_RERAISE;
; 1901 : 		_CATCH_END
; 1902 : 		}
; 1903 : 
; 1904 : 	void _Incsize(size_type _Count)
; 1905 : 		{	// alter element count, with checking
; 1906 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00017	b9 cb cc cc 0c	 mov	 ecx, 214748363		; 0ccccccbH
  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	2b c8		 sub	 ecx, eax
  00021	83 f9 01	 cmp	 ecx, 1
  00024	72 12		 jb	 SHORT $LN41@push_back

; 1908 : 		this->_Mysize += _Count;

  00026	40		 inc	 eax
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;

  0002a	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi

; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  00032	89 10		 mov	 DWORD PTR [eax], edx

; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN41@push_back:

; 1907 : 			_Xlength_error("list<T> too long");

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@push_back:
$LN40@push_back:
  00042	cc		 int	 3
?push_back@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXABUSTextLine@CPythonEventManager@@@Z ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?clear@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXXZ PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::clear, COMDAT
; _this$ = ecx

; 1491 : 		{	// erase all

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 17		 mov	 edx, DWORD PTR [edi]

; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00005	8b 02		 mov	 eax, DWORD PTR [edx]

; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00007	89 12		 mov	 DWORD PTR [edx], edx

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00009	8b 17		 mov	 edx, DWORD PTR [edi]

; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  0000b	89 52 04	 mov	 DWORD PTR [edx+4], edx

; 1499 : 		this->_Mysize = 0;

  0000e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00015	3b 07		 cmp	 eax, DWORD PTR [edi]
  00017	74 19		 je	 SHORT $LN1@clear
  00019	56		 push	 esi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL3@clear:

; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 30		 mov	 esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  0002b	8b c6		 mov	 eax, esi
  0002d	3b 37		 cmp	 esi, DWORD PTR [edi]
  0002f	75 ef		 jne	 SHORT $LL3@clear
  00031	5e		 pop	 esi
$LN1@clear:
  00032	5f		 pop	 edi

; 1504 : 			this->_Freenode(_Pnode);
; 1505 : 			}
; 1506 : 		}

  00033	c3		 ret	 0
?clear@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXXZ ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEX$$QAPAUSEventSet@CPythonEventManager@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEX$$QAPAUSEventSet@CPythonEventManager@@@Z PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::push_back, COMDAT
; _this$ = ecx

; 865  : 		{	// insert by moving into element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 30		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2a		 ja	 SHORT $LN4@push_back

; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 869  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 08		 jne	 SHORT $LN3@push_back

; 870  : 				_Reserve(1);

  00021	51		 push	 ecx
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00029	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002c	85 c9		 test	 ecx, ecx
  0002e	74 29		 je	 SHORT $LN53@push_back
  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00035	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 883  : 			++this->_Mylast;

  00037	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi

; 884  : 			}
; 885  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN4@push_back:

; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)

  00041	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00044	75 08		 jne	 SHORT $LN1@push_back

; 879  : 				_Reserve(1);

  00046	51		 push	 ecx
  00047	8b ce		 mov	 ecx, esi
  00049	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0004e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00051	85 c9		 test	 ecx, ecx
  00053	74 04		 je	 SHORT $LN53@push_back
  00055	8b 07		 mov	 eax, DWORD PTR [edi]
  00057	89 01		 mov	 DWORD PTR [ecx], eax
$LN53@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 883  : 			++this->_Mylast;

  00059	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 884  : 			}
; 885  : 		}

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?push_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEX$$QAPAUSEventSet@CPythonEventManager@@@Z ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::~vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::~vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??A?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEAAPAUSEventSet@CPythonEventManager@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEAAPAUSEventSet@CPythonEventManager@@I@Z PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1210 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEAAPAUSEventSet@CPythonEventManager@@I@Z ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXXZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ??0?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAE@XZ PROC ; CDynamicPool<CPythonEventManager::SEventSet>::CDynamicPool<CPythonEventManager::SEventSet>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@

; 16   : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 14   : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 15   : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 16   : 		}

  00040	c3		 ret	 0
??0?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAE@XZ ENDP ; CDynamicPool<CPythonEventManager::SEventSet>::CDynamicPool<CPythonEventManager::SEventSet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ??1?$CDynamicPool@USEventSet@CPythonEventManager@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@USEventSet@CPythonEventManager@@@@UAE@XZ PROC ; CDynamicPool<CPythonEventManager::SEventSet>::~CDynamicPool<CPythonEventManager::SEventSet>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN5@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00020	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00027	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN5@CDynamicPo:

; 1623 : 		if (this->_Myfirst != pointer())

  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	85 c0		 test	 eax, eax
  00033	74 1e		 je	 SHORT $LN18@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004c	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN18@CDynamicPo:
  00053	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 26   : 		}

  00054	c3		 ret	 0
??1?$CDynamicPool@USEventSet@CPythonEventManager@@@@UAE@XZ ENDP ; CDynamicPool<CPythonEventManager::SEventSet>::~CDynamicPool<CPythonEventManager::SEventSet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ?Clear@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Clear@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXXZ PROC ; CDynamicPool<CPythonEventManager::SEventSet>::Clear, COMDAT
; _this$ = ecx

; 33   : 		{			

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 33   : 		{			

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN31@Clear
$LL33@Clear:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@USEventSet@CPythonEventManager@@@@KAXPAUSEventSet@CPythonEventManager@@@Z ; CDynamicPool<CPythonEventManager::SEventSet>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL33@Clear
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN31@Clear:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 35   : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Clear@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXXZ ENDP ; CDynamicPool<CPythonEventManager::SEventSet>::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
_pkNewData$3 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ PROC ; CDynamicPool<CPythonEventManager::SEventSet>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00026	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00029	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  0002c	75 52		 jne	 SHORT $LN1@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0002e	68 d4 00 00 00	 push	 212			; 000000d4H
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	85 c0		 test	 eax, eax
  00047	74 09		 je	 SHORT $LN4@Alloc
  00049	8b c8		 mov	 ecx, eax
  0004b	e8 00 00 00 00	 call	 ??0SEventSet@CPythonEventManager@@QAE@XZ ; CPythonEventManager::SEventSet::SEventSet
  00050	eb 02		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00052	33 c0		 xor	 eax, eax
$LN5@Alloc:
  00054	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  0005b	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0005e	89 45 f0	 mov	 DWORD PTR _pkNewData$3[ebp], eax
  00061	8d 45 f0	 lea	 eax, DWORD PTR _pkNewData$3[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?push_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXABQAUSEventSet@CPythonEventManager@@@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::push_back

; 67   : 				++m_uUsedCapacity;

  0006a	ff 46 20	 inc	 DWORD PTR [esi+32]

; 68   : 				return pkNewData;

  0006d	8b 45 f0	 mov	 eax, DWORD PTR _pkNewData$3[ebp]

; 74   : 		}

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5e		 pop	 esi
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN1@Alloc:

; 69   : 			}
; 70   : 
; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  00080	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00083	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1282 : 		--this->_Mylast;

  00086	83 46 14 fc	 add	 DWORD PTR [esi+20], -4	; fffffffcH
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 74   : 		}

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	5e		 pop	 esi
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEPAUSEventSet@CPythonEventManager@@XZ ENDP ; CDynamicPool<CPythonEventManager::SEventSet>::Alloc
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ?Free@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXPAUSEventSet@CPythonEventManager@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Free@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXPAUSEventSet@CPythonEventManager@@@Z PROC ; CDynamicPool<CPythonEventManager::SEventSet>::Free, COMDAT
; _this$ = ecx

; 76   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : #ifdef DYNAMIC_POOL_STRICT
; 78   : 			assert(__IsValidData(pkData));
; 79   : 			assert(!__IsFreeData(pkData));
; 80   : #endif
; 81   : 			m_kVct_pkFree.push_back(pkData);

  00003	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
  00006	83 c1 10	 add	 ecx, 16			; 00000010H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXABQAUSEventSet@CPythonEventManager@@@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::push_back

; 82   : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?Free@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXPAUSEventSet@CPythonEventManager@@@Z ENDP ; CDynamicPool<CPythonEventManager::SEventSet>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBEAAUSArgumet@script@@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBEAAUSArgumet@script@@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator*, COMDAT
; _this$ = ecx

; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}

  00005	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBEAAUSArgumet@script@@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator++, COMDAT
; _this$ = ecx

; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 375  : 		}

  00008	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator!=, COMDAT
; _this$ = ecx

; 302  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 303  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 303  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 304  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBEAAUSTextLine@CPythonEventManager@@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBEAAUSTextLine@CPythonEventManager@@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator*, COMDAT
; _this$ = ecx

; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}

  00005	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBEAAUSTextLine@CPythonEventManager@@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator++, COMDAT
; _this$ = ecx

; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 375  : 		}

  00008	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator!=, COMDAT
; _this$ = ecx

; 302  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 303  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 303  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 304  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator->, COMDAT
; _this$ = ecx

; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator==, COMDAT
; _this$ = ecx

; 322  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 337  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ PROC ; std::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >::~_List_buy<script::SArgumet,std::allocator<script::SArgumet> >, COMDAT
; _this$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ENDP ; std::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >::~_List_buy<script::SArgumet,std::allocator<script::SArgumet> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??_G?$CSingleton@VCPythonEventManager@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CSingleton@VCPythonEventManager@@@@UAEPAXI@Z PROC	; CSingleton<CPythonEventManager>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 21   : 		ms_singleton = 0; 

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonEventManager@@@@0PAVCPythonEventManager@@A, 0 ; CSingleton<CPythonEventManager>::ms_singleton
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCPythonEventManager@@@@6B@
  0001a	74 09		 je	 SHORT $LN6@scalar
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_G?$CSingleton@VCPythonEventManager@@@@UAEPAXI@Z ENDP	; CSingleton<CPythonEventManager>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::~_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >, COMDAT
; _this$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::~_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ PROC ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::~_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >, COMDAT
; _this$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ ENDP ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::~_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??_G?$CDynamicPool@USEventSet@CPythonEventManager@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@USEventSet@CPythonEventManager@@@@UAEPAXI@Z PROC ; CDynamicPool<CPythonEventManager::SEventSet>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 18   : 		{

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@USEventSet@CPythonEventManager@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0000c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000f	85 c0		 test	 eax, eax
  00011	74 1e		 je	 SHORT $LN8@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0001c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00023	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  0002a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@scalar:

; 1623 : 		if (this->_Myfirst != pointer())

  00031	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00034	85 c0		 test	 eax, eax
  00036	74 1e		 je	 SHORT $LN21@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00041	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN21@scalar:
  00056	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005a	74 09		 je	 SHORT $LN32@scalar
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00062	83 c4 04	 add	 esp, 4
$LN32@scalar:
  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
??_G?$CDynamicPool@USEventSet@CPythonEventManager@@@@UAEPAXI@Z ENDP ; CDynamicPool<CPythonEventManager::SEventSet>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ PROC ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@XZ ENDP ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::~_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ PROC ; CDynamicPool<CGraphicTextInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 38   : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z ; CDynamicPool<CGraphicTextInstance>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 53   : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ ENDP ; CDynamicPool<CGraphicTextInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBE_NXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEAAPAVCGraphicTextInstance@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEAAPAVCGraphicTextInstance@@XZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::back, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 04	 sub	 eax, 4

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

  00006	c3		 ret	 0
?back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEAAPAVCGraphicTextInstance@@XZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?pop_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::pop_back, COMDAT
; _this$ = ecx

; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

  00000	83 41 04 fc	 add	 DWORD PTR [ecx+4], -4	; fffffffcH

; 1283 : 		}

  00004	c3		 ret	 0
?pop_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear, COMDAT
; _this$ = ecx

; 1491 : 		{	// erase all

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00004	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00006	8b 30		 mov	 esi, DWORD PTR [eax]

; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00008	89 00		 mov	 DWORD PTR [eax], eax

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  0000a	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  0000c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1499 : 		this->_Mysize = 0;

  0000f	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00016	3b 33		 cmp	 esi, DWORD PTR [ebx]
  00018	74 5e		 je	 SHORT $LN1@clear
  0001a	57		 push	 edi
  0001b	eb 03 8d 49 00	 npad	 5
$LL3@clear:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00020	83 7e 34 10	 cmp	 DWORD PTR [esi+52], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1503 : 			_Pnext = this->_Nextnode(_Pnode);

  00024	8b 3e		 mov	 edi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00026	72 0b		 jb	 SHORT $LN65@clear
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00028	ff 76 20	 push	 DWORD PTR [esi+32]
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00030	83 c4 04	 add	 esp, 4
$LN65@clear:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00033	c7 46 34 0f 00
	00 00		 mov	 DWORD PTR [esi+52], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0003a	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00041	c6 46 20 00	 mov	 BYTE PTR [esi+32], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00045	83 7e 1c 10	 cmp	 DWORD PTR [esi+28], 16	; 00000010H
  00049	72 0b		 jb	 SHORT $LN97@clear
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0004b	ff 76 08	 push	 DWORD PTR [esi+8]
  0004e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00053	83 c4 04	 add	 esp, 4
$LN97@clear:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00056	c7 46 1c 0f 00
	00 00		 mov	 DWORD PTR [esi+28], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0005d	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00064	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00065	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00069	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00071	8b f7		 mov	 esi, edi
  00073	3b 3b		 cmp	 edi, DWORD PTR [ebx]
  00075	75 a9		 jne	 SHORT $LL3@clear
  00077	5f		 pop	 edi
$LN1@clear:
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx

; 1504 : 			this->_Freenode(_Pnode);
; 1505 : 			}
; 1506 : 		}

  0007a	c3		 ret	 0
?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy, COMDAT
; _this$ = ecx

; 1883 : 		clear();

  00000	e9 00 00 00 00	 jmp	 ?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear
?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@ABV?$allocator@USArgumet@script@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@ABV?$allocator@USArgumet@script@@@1@@Z PROC ; std::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >, COMDAT
; _this$ = ecx

; 823  : 		{	// construct from allocator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 528  : 		this->_Mysize = 0;

  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buynode0

; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  00019	89 06		 mov	 DWORD PTR [esi], eax

; 824  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??0?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@ABV?$allocator@USArgumet@script@@@1@@Z ENDP ; std::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@USArgumet@script@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@USArgumet@script@@@std@@QAE@XZ PROC	; std::allocator<script::SArgumet>::allocator<script::SArgumet>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@USArgumet@script@@@std@@QAE@XZ ENDP	; std::allocator<script::SArgumet>::allocator<script::SArgumet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??1?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::~_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 708  : 		}

  00008	c3		 ret	 0
??1?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::~_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Getal, COMDAT
; _this$ = ecx

; 803  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 804  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 805  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_Nextnode, COMDAT

; 532  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 534  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >, COMDAT
; _this$ = ecx

; 1066 : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 1067 : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1575 : 		return (iterator(_Lbound(_Keyval), this));

  00003	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00006	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lbound

; 44   : 		{	// construct with node pointer _Pnode

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	89 01		 mov	 DWORD PTR [ecx], eax

; 1575 : 		return (iterator(_Lbound(_Keyval), this));

  00010	8b c1		 mov	 eax, ecx

; 1576 : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2229 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2230 : 		erase(begin(), end());

  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	50		 push	 eax
  00007	ff 30		 push	 DWORD PTR [eax]
  00009	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase

; 2231 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Key, COMDAT
; _this$dead$ = ecx

; 2239 : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2241 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBE?AU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBE?AU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Getcomp, COMDAT
; _this$dead$ = ecx

; 1006 : 		{	// get ordering predicate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1007 : 		return (key_compare());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1008 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBE?AU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 779  : 		}

  00008	c3		 ret	 0
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Unchecked_end@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1147 : 		{	// return unchecked iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Unchecked_end@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@2@XZ ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Tidy@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXXZ PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Tidy, COMDAT
; _this$ = ecx

; 1882 : 		{	// free all storage

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 17		 mov	 edx, DWORD PTR [edi]

; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();
; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 768  : 		}
; 769  : 
; 770  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 771  : 		{	// free head node using current allocator
; 772  : 		this->_Getal().destroy(
; 773  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 774  : 		this->_Getal().destroy(
; 775  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 776  : 		this->_Getal().deallocate(_Pnode, 1);
; 777  : 		}
; 778  : 
; 779  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 780  : 		_Nodeptr _Prev)
; 781  : 		{	// allocate a node and set links
; 782  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 783  : 
; 784  : 		if (_Next == _Nodeptr())
; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;
; 787  : 			_Prev = _Pnode;
; 788  : 			}
; 789  : 		_TRY_BEGIN
; 790  : 		this->_Getal().construct(
; 791  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 792  : 		this->_Getal().construct(
; 793  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 794  : 		_CATCH_ALL
; 795  : 		this->_Getal().deallocate(_Pnode, 1);
; 796  : 		_RERAISE;
; 797  : 		_CATCH_END
; 798  : 
; 799  : 		return (_Pnode);
; 800  : 		}
; 801  : 
; 802  : 	_Alty _Getal() const
; 803  : 		{	// get reference to allocator
; 804  : 		return (_Alty());
; 805  : 		}
; 806  : 	};
; 807  : 
; 808  : 		// TEMPLATE CLASS _List_buy
; 809  : template<class _Ty,
; 810  : 	class _Alloc>
; 811  : 	class _List_buy
; 812  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 813  : 			_List_base_types<_Ty, _Alloc> >
; 814  : 	{	// base class for list to hold buynode/freenode functions
; 815  : public:
; 816  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 817  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 818  : 	typedef typename _Mybase::_Alty _Alty;
; 819  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 820  : 
; 821  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 822  : 		: _Mybase(_Al)
; 823  : 		{	// construct from allocator
; 824  : 		}
; 825  : 
; 826  : 	template<class... _Valty>
; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 831  : 
; 832  : 		_TRY_BEGIN
; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);
; 836  : 		_CATCH_ALL
; 837  : 		this->_Getal().deallocate(_Pnode, 1);
; 838  : 		_RERAISE;
; 839  : 		_CATCH_END
; 840  : 
; 841  : 		return (_Pnode);
; 842  : 		}
; 843  : 
; 844  : 
; 845  : 	void _Freenode(_Nodeptr _Pnode)
; 846  : 		{	// give node back
; 847  : 		this->_Getal().destroy(
; 848  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Myval(_Pnode)));
; 853  : 		this->_Getal().deallocate(_Pnode, 1);
; 854  : 		}
; 855  : 	};
; 856  : 
; 857  : 		// TEMPLATE CLASS list
; 858  : template<class _Ty,
; 859  : 	class _Alloc = allocator<_Ty> >
; 860  : 	class list
; 861  : 		: public _List_buy<_Ty, _Alloc>
; 862  : 	{	// bidirectional linked list
; 863  : public:
; 864  : 	typedef list<_Ty, _Alloc> _Myt;
; 865  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 866  : 	typedef typename _Mybase::_Node _Node;
; 867  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 868  : 	typedef typename _Mybase::_Alty _Alty;
; 869  : 
; 870  : 	typedef _Alloc allocator_type;
; 871  : 	typedef typename _Mybase::size_type size_type;
; 872  : 	typedef typename _Mybase::difference_type difference_type;
; 873  : 	typedef typename _Mybase::pointer pointer;
; 874  : 	typedef typename _Mybase::const_pointer const_pointer;
; 875  : 	typedef typename _Mybase::reference reference;
; 876  : 	typedef typename _Mybase::const_reference const_reference;
; 877  : 	typedef typename _Mybase::value_type value_type;
; 878  : 
; 879  : 	typedef typename _Mybase::const_iterator const_iterator;
; 880  : 	typedef typename _Mybase::iterator iterator;
; 881  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 882  : 		_Unchecked_const_iterator;
; 883  : 	typedef typename _Mybase::_Unchecked_iterator
; 884  : 		_Unchecked_iterator;
; 885  : 
; 886  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 887  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 888  : 
; 889  : 	list()
; 890  : 		: _Mybase()
; 891  : 		{	// construct empty list
; 892  : 		}
; 893  : 
; 894  : 	explicit list(const _Alloc& _Al)
; 895  : 		: _Mybase(_Al)
; 896  : 		{	// construct empty list, allocator
; 897  : 		}
; 898  : 
; 899  : 	explicit list(size_type _Count)
; 900  : 		: _Mybase()
; 901  : 		{	// construct list from _Count * _Ty()
; 902  : 		resize(_Count);
; 903  : 		}
; 904  : 
; 905  : 	list(size_type _Count, const _Ty& _Val)
; 906  : 		: _Mybase()
; 907  : 		{	// construct list from _Count * _Val
; 908  : 		_Construct_n(_Count, _Val);
; 909  : 		}
; 910  : 
; 911  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 912  : 		: _Mybase(_Al)
; 913  : 		{	// construct list from _Count * _Val, allocator
; 914  : 		_Construct_n(_Count, _Val);
; 915  : 		}
; 916  : 
; 917  : 	list(const _Myt& _Right)
; 918  : 
; 919  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 920  : 
; 921  : 
; 922  : 		{	// construct list by copying _Right
; 923  : 		_TRY_BEGIN
; 924  : 		insert(begin(), _Right.begin(), _Right.end());
; 925  : 		_CATCH_ALL
; 926  : 		_Tidy();
; 927  : 		_RERAISE;
; 928  : 		_CATCH_END
; 929  : 		}
; 930  : 
; 931  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 932  : 		: _Mybase(_Al)
; 933  : 		{	// construct list by copying _Right, allocator
; 934  : 		_TRY_BEGIN
; 935  : 		insert(begin(), _Right.begin(), _Right.end());
; 936  : 		_CATCH_ALL
; 937  : 		_Tidy();
; 938  : 		_RERAISE;
; 939  : 		_CATCH_END
; 940  : 		}
; 941  : 
; 942  : 	template<class _Iter,
; 943  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 944  : 			void>::type>
; 945  : 		list(_Iter _First, _Iter _Last)
; 946  : 		: _Mybase()
; 947  : 		{	// construct list from [_First, _Last)
; 948  : 		_Construct(_First, _Last);
; 949  : 		}
; 950  : 
; 951  : 	template<class _Iter,
; 952  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 953  : 			void>::type>
; 954  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 955  : 		: _Mybase(_Al)
; 956  : 		{	// construct list, allocator from [_First, _Last)
; 957  : 		_Construct(_First, _Last);
; 958  : 		}
; 959  : 
; 960  : 	template<class _Iter>
; 961  : 		void _Construct(_Iter _First, _Iter _Last)
; 962  : 		{	// construct list from [_First, _Last), input iterators
; 963  : 		_TRY_BEGIN
; 964  : 		insert(begin(), _First, _Last);
; 965  : 		_CATCH_ALL
; 966  : 		_Tidy();
; 967  : 		_RERAISE;
; 968  : 		_CATCH_END
; 969  : 		}
; 970  : 
; 971  : 	void _Construct_n(size_type _Count,
; 972  : 		const _Ty& _Val)
; 973  : 		{	// construct from _Count * _Val
; 974  : 		_TRY_BEGIN
; 975  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 976  : 		_CATCH_ALL
; 977  : 		_Tidy();
; 978  : 		_RERAISE;
; 979  : 		_CATCH_END
; 980  : 		}
; 981  : 
; 982  : 	list(_Myt&& _Right)
; 983  : 		: _Mybase(_Right._Getal())
; 984  : 		{	// construct list by moving _Right
; 985  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 986  : 		}
; 987  : 
; 988  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 989  : 		: _Mybase(_Al)
; 990  : 		{	// construct list by moving _Right, allocator
; 991  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 992  : 		}
; 993  : 
; 994  : 	_Myt& operator=(_Myt&& _Right)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Change_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1013 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != this)
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);
; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;
; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
; 1066 : 		}
; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00005	8b 02		 mov	 eax, DWORD PTR [edx]

; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00007	89 12		 mov	 DWORD PTR [edx], edx

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00009	8b 17		 mov	 edx, DWORD PTR [edi]

; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  0000b	89 52 04	 mov	 DWORD PTR [edx+4], edx

; 1499 : 		this->_Mysize = 0;

  0000e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00015	3b 07		 cmp	 eax, DWORD PTR [edi]
  00017	74 19		 je	 SHORT $LN3@Tidy
  00019	56		 push	 esi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL5@Tidy:

; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 30		 mov	 esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  0002b	8b c6		 mov	 eax, esi
  0002d	3b 37		 cmp	 esi, DWORD PTR [edi]
  0002f	75 ef		 jne	 SHORT $LL5@Tidy
  00031	5e		 pop	 esi
$LN3@Tidy:
  00032	5f		 pop	 edi

; 1883 : 		clear();
; 1884 : 		}

  00033	c3		 ret	 0
?_Tidy@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXXZ ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@ABV?$allocator@USTextLine@CPythonEventManager@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??0?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@ABV?$allocator@USTextLine@CPythonEventManager@@@1@@Z PROC ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >, COMDAT
; _this$ = ecx

; 823  : 		{	// construct from allocator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 528  : 		this->_Mysize = 0;

  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 703  : 		}
; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buynode0

; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);
; 544  : 		}
; 545  : 
; 546  : 	_Nodeptr _Myhead;	// pointer to head node
; 547  : 	size_type _Mysize;	// number of elements
; 548  : 	};
; 549  : 
; 550  : 		// TEMPLATE CLASS _List_alloc
; 551  : template<bool _Al_has_storage,
; 552  : 	class _Alloc_types>
; 553  : 	class _List_alloc
; 554  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 555  : 	{	// base class for list to hold allocator with storage
; 556  : public:
; 557  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 558  : 
; 559  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 560  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 561  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 562  : 	typedef typename _Alloc_types::_Node _Node;
; 563  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 564  : 
; 565  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 566  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 567  : 		: _Alnod(_Al)
; 568  : 		{	// construct head node, allocator from _Al
; 569  : 		this->_Myhead = _Buyheadnode();
; 570  : 		}
; 571  : 
; 572  : 	~_List_alloc() _NOEXCEPT
; 573  : 		{	// destroy head node
; 574  : 		_Freeheadnode(this->_Myhead);
; 575  : 		}
; 576  : 
; 577  : 	void _Change_alloc(const _Alty& _Al)
; 578  : 		{	// replace old allocator
; 579  : 		this->_Alnod = _Al;
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 585  : 		}
; 586  : 
; 587  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 588  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 589  : 		: _Alnod(_Al)
; 590  : 		{	// construct head node, allocator from _Al
; 591  : 		this->_Myhead = _Buyheadnode();
; 592  : 		_TRY_BEGIN
; 593  : 		_Alloc_proxy();
; 594  : 		_CATCH_ALL
; 595  : 		_Freeheadnode(this->_Myhead);
; 596  : 		_RERAISE;
; 597  : 		_CATCH_END
; 598  : 		}
; 599  : 
; 600  : 	~_List_alloc() _NOEXCEPT
; 601  : 		{	// destroy proxy
; 602  : 		_Freeheadnode(this->_Myhead);
; 603  : 		_Free_proxy();
; 604  : 		}
; 605  : 
; 606  : 	void _Change_alloc(const _Alty& _Al)
; 607  : 		{	// replace old allocator
; 608  : 		_Free_proxy();
; 609  : 		this->_Alnod = _Al;
; 610  : 		_Alloc_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Swap_alloc(_Myt& _Right)
; 614  : 		{	// swap allocators
; 615  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 616  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 617  : 		}
; 618  : 
; 619  : 	void _Alloc_proxy()
; 620  : 		{	// construct proxy from _Alnod
; 621  : 		typename _Alty::template rebind<_Container_proxy>::other
; 622  : 			_Alproxy(this->_Alnod);
; 623  : 		this->_Myproxy = _Alproxy.allocate(1);
; 624  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 625  : 		this->_Myproxy->_Mycont = this;
; 626  : 		}
; 627  : 
; 628  : 	void _Free_proxy()
; 629  : 		{	// destroy proxy
; 630  : 		typename _Alty::template rebind<_Container_proxy>::other
; 631  : 			_Alproxy(this->_Alnod);
; 632  : 		this->_Orphan_all();
; 633  : 		_Alproxy.destroy(this->_Myproxy);
; 634  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 635  : 		this->_Myproxy = 0;
; 636  : 		}
; 637  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 638  : 
; 639  : 	_Nodeptr _Buyheadnode()
; 640  : 		{	// get head node using current allocator
; 641  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 642  : 		}
; 643  : 
; 644  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 645  : 		{	// free head node using current allocator
; 646  : 		this->_Alnod.destroy(
; 647  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 648  : 		this->_Alnod.destroy(
; 649  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 650  : 		this->_Alnod.deallocate(_Pnode, 1);
; 651  : 		}
; 652  : 
; 653  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 654  : 		_Nodeptr _Prev)
; 655  : 		{	// allocate a node and set links
; 656  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 657  : 
; 658  : 		if (_Next == _Nodeptr())
; 659  : 			{	// point at self
; 660  : 			_Next = _Pnode;
; 661  : 			_Prev = _Pnode;
; 662  : 			}
; 663  : 		_TRY_BEGIN
; 664  : 		this->_Alnod.construct(
; 665  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 666  : 		this->_Alnod.construct(
; 667  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 668  : 		_CATCH_ALL
; 669  : 		this->_Alnod.deallocate(_Pnode, 1);
; 670  : 		_RERAISE;
; 671  : 		_CATCH_END
; 672  : 
; 673  : 		return (_Pnode);
; 674  : 		}
; 675  : 
; 676  : 	_Alty& _Getal()
; 677  : 		{	// get reference to allocator
; 678  : 		return (this->_Alnod);
; 679  : 		}
; 680  : 
; 681  : 	const _Alty& _Getal() const
; 682  : 		{	// get reference to allocator
; 683  : 		return (this->_Alnod);
; 684  : 		}
; 685  : 	};
; 686  : 
; 687  : 		// TEMPLATE CLASS _List_alloc
; 688  : template<class _Alloc_types>
; 689  : 	class _List_alloc<false, _Alloc_types>
; 690  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 691  : 	{	// base class for list to hold allocator with no storage
; 692  : public:
; 693  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 694  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 695  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 696  : 	typedef typename _Alloc_types::_Node _Node;
; 697  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 698  : 
; 699  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 700  : 	_List_alloc(const _Alloc& = _Alloc())
; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  00019	89 06		 mov	 DWORD PTR [esi], eax

; 824  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??0?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAE@ABV?$allocator@USTextLine@CPythonEventManager@@@1@@Z ENDP ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Freenode@?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z PROC ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Freenode, COMDAT
; _this$dead$ = ecx

; 846  : 		{	// give node back

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 854  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freenode@?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z ENDP ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@USTextLine@CPythonEventManager@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@USTextLine@CPythonEventManager@@@std@@QAE@XZ PROC ; std::allocator<CPythonEventManager::STextLine>::allocator<CPythonEventManager::STextLine>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@USTextLine@CPythonEventManager@@@std@@QAE@XZ ENDP ; std::allocator<CPythonEventManager::STextLine>::allocator<CPythonEventManager::STextLine>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??1?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::~_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 708  : 		}

  00008	c3		 ret	 0
??1?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::~_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Nextnode@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_Nextnode, COMDAT
; __Pnode$ = ecx

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00000	8b c1		 mov	 eax, ecx

; 534  : 		}

  00002	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Prevnode@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_Prevnode, COMDAT
; __Pnode$ = ecx

; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 539  : 		}

  00003	c3		 ret	 0
?_Prevnode@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBE_NXZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEAAPAUSEventSet@CPythonEventManager@@XZ
_TEXT	SEGMENT
?back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEAAPAUSEventSet@CPythonEventManager@@XZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::back, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 04	 sub	 eax, 4

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

  00006	c3		 ret	 0
?back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEAAPAUSEventSet@CPythonEventManager@@XZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXABQAUSEventSet@CPythonEventManager@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXABQAUSEventSet@CPythonEventManager@@@Z PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 30		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2a		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 08		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	51		 push	 ecx
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00029	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002c	85 c9		 test	 ecx, ecx
  0002e	74 29		 je	 SHORT $LN49@push_back
  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00035	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00037	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00041	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00044	75 08		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00046	51		 push	 ecx
  00047	8b ce		 mov	 ecx, esi
  00049	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  0004e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00051	85 c9		 test	 ecx, ecx
  00053	74 04		 je	 SHORT $LN49@push_back
  00055	8b 07		 mov	 eax, DWORD PTR [edi]
  00057	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

  00059	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?push_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXABQAUSEventSet@CPythonEventManager@@@Z ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?pop_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXXZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::pop_back, COMDAT
; _this$ = ecx

; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

  00000	83 41 04 fc	 add	 DWORD PTR [ecx+4], -4	; fffffffcH

; 1283 : 		}

  00004	c3		 ret	 0
?pop_back@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXPAPAUSEventSet@CPythonEventManager@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXPAPAUSEventSet@CPythonEventManager@@0@Z PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXPAPAUSEventSet@CPythonEventManager@@0@Z ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBE_NPBQAUSEventSet@CPythonEventManager@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBE_NPBQAUSEventSet@CPythonEventManager@@@Z PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBE_NPBQAUSEventSet@CPythonEventManager@@@Z ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reserve, COMDAT
; _this$ = ecx

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	8b c2		 mov	 eax, edx
  00005	56		 push	 esi
  00006	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00009	2b c6		 sub	 eax, esi
  0000b	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  0000e	83 f8 01	 cmp	 eax, 1
  00011	73 43		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00013	2b 31		 sub	 esi, DWORD PTR [ecx]
  00015	57		 push	 edi

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00016	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0001b	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001e	8b c7		 mov	 eax, edi
  00020	2b c6		 sub	 eax, esi
  00022	83 f8 01	 cmp	 eax, 1
  00025	72 33		 jb	 SHORT $LN42@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00027	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00029	46		 inc	 esi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002a	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0002d	8b c2		 mov	 eax, edx
  0002f	d1 e8		 shr	 eax, 1
  00031	2b f8		 sub	 edi, eax
  00033	3b fa		 cmp	 edi, edx
  00035	5f		 pop	 edi
  00036	73 11		 jae	 SHORT $LN27@Reserve
  00038	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0003a	3b d6		 cmp	 edx, esi
  0003c	0f 42 d6	 cmovb	 edx, esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reallocate
  00045	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00046	c2 04 00	 ret	 4
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00049	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  0004b	3b d6		 cmp	 edx, esi
  0004d	0f 42 d6	 cmovb	 edx, esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reallocate
$LN2@Reserve:

; 1618 : 			}
; 1619 : 		}

  00056	5e		 pop	 esi
  00057	c2 04 00	 ret	 4
$LN42@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0005f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN44@Reserve:
$LN41@Reserve:
  00064	cc		 int	 3
?_Reserve@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXXZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXXZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEXPAPAUSEventSet@CPythonEventManager@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEXPAPAUSEventSet@CPythonEventManager@@0@Z PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEXPAPAUSEventSet@CPythonEventManager@@0@Z ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAE@XZ PROC ; std::allocator<CPythonEventManager::SEventSet *>::allocator<CPythonEventManager::SEventSet *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAE@XZ ENDP ; std::allocator<CPythonEventManager::SEventSet *>::allocator<CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUSEventSet@CPythonEventManager@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUSEventSet@CPythonEventManager@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> > >::_Vector_alloc<0,std::_Vec_base_types<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUSEventSet@CPythonEventManager@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> > >::_Vector_alloc<0,std::_Vec_base_types<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> > >::_Getal, COMDAT
; _this$dead$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXXZ PROC ; CDynamicPool<CPythonEventManager::SEventSet>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 38   : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@USEventSet@CPythonEventManager@@@@KAXPAUSEventSet@CPythonEventManager@@@Z ; CDynamicPool<CPythonEventManager::SEventSet>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 53   : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPool@USEventSet@CPythonEventManager@@@@QAEXXZ ENDP ; CDynamicPool<CPythonEventManager::SEventSet>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >, COMDAT
; _this$ = ecx

; 345  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 346  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::_List_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBEABUSArgumet@script@@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBEABUSArgumet@script@@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator*, COMDAT
; _this$ = ecx

; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBEABUSArgumet@script@@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator++, COMDAT
; _this$ = ecx

; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 241  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 242  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator==, COMDAT
; _this$ = ecx

; 284  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 299  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >, COMDAT
; _this$ = ecx

; 345  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 346  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::_List_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBEABUSTextLine@CPythonEventManager@@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBEABUSTextLine@CPythonEventManager@@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator*, COMDAT
; _this$ = ecx

; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBEABUSTextLine@CPythonEventManager@@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator++, COMDAT
; _this$ = ecx

; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 241  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 242  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator==, COMDAT
; _this$ = ecx

; 284  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 299  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 385  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator*, COMDAT
; _this$ = ecx

; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 124  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@SAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@AAU32@@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@SAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> *>::pointer_to, COMDAT
; __Val$ = ecx

; 234  : 		return (_STD addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 235  : 		}

  00002	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@SAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z PROC ; CDynamicPool<CGraphicTextInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 110  : 			delete pkData;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pkData$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 06		 je	 SHORT $LN3@Delete
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	6a 01		 push	 1
  0000e	ff 10		 call	 DWORD PTR [eax]
$LN3@Delete:

; 111  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z ENDP ; CDynamicPool<CGraphicTextInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBE_NPBQAVCGraphicTextInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBE_NPBQAVCGraphicTextInstance@@@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBE_NPBQAVCGraphicTextInstance@@@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEXPAPAVCGraphicTextInstance@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEXPAPAVCGraphicTextInstance@@0@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEXPAPAVCGraphicTextInstance@@0@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicTextInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicTextInstance@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicTextInstance@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Freenode@?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@@Z PROC ; std::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >::_Freenode, COMDAT
; _this$ = ecx

; 846  : 		{	// give node back

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 543  : 		return ((reference)_Pnode->_Myval);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Pnode$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00007	83 7e 34 10	 cmp	 DWORD PTR [esi+52], 16	; 00000010H
  0000b	72 0b		 jb	 SHORT $LN52@Freenode
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 76 20	 push	 DWORD PTR [esi+32]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN52@Freenode:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00018	c7 46 34 0f 00
	00 00		 mov	 DWORD PTR [esi+52], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001f	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00026	c6 46 20 00	 mov	 BYTE PTR [esi+32], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0002a	83 7e 1c 10	 cmp	 DWORD PTR [esi+28], 16	; 00000010H
  0002e	72 0b		 jb	 SHORT $LN84@Freenode
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00030	ff 76 08	 push	 DWORD PTR [esi+8]
  00033	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00038	83 c4 04	 add	 esp, 4
$LN84@Freenode:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003b	c7 46 1c 0f 00
	00 00		 mov	 DWORD PTR [esi+28], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00042	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00049	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0004a	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0004e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00053	83 c4 04	 add	 esp, 4
  00056	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 854  : 		}

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?_Freenode@?$_List_buy@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@@Z ENDP ; std::_List_buy<script::SArgumet,std::allocator<script::SArgumet> >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAE@ABV?$allocator@USArgumet@script@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAE@ABV?$allocator@USArgumet@script@@@1@@Z PROC ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >, COMDAT
; _this$ = ecx

; 700  : 	_List_alloc(const _Alloc& = _Alloc())

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 528  : 		this->_Mysize = 0;

  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buynode0

; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  00019	89 06		 mov	 DWORD PTR [esi], eax

; 703  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??0?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAE@ABV?$allocator@USArgumet@script@@@1@@Z ENDP ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@@Z PROC ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 771  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 777  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@@Z ENDP ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_Prevnode, COMDAT

; 537  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 539  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAUSArgumet@script@@PAU?$_List_node@USArgumet@script@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAUSArgumet@script@@PAU?$_List_node@USArgumet@script@@PAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_Myval, COMDAT

; 542  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 543  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 544  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@SAAAUSArgumet@script@@PAU?$_List_node@USArgumet@script@@PAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 1211 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 44   : 		{	// construct with node pointer _Pnode

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 1511 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]

; 1512 : 		if (_First == begin() && _Last == end())

  00007	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0000d	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0000f	3b 01		 cmp	 eax, DWORD PTR [ecx]

; 1512 : 		if (_First == begin() && _Last == end())

  00011	75 33		 jne	 SHORT $LN115@erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00013	3b d1		 cmp	 edx, ecx

; 1512 : 		if (_First == begin() && _Last == end())

  00015	75 2f		 jne	 SHORT $LN115@erase

; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());

  00017	ff 71 04	 push	 DWORD PTR [ecx+4]
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Erase

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00021	8b 06		 mov	 eax, DWORD PTR [esi]

; 1541 : 		_Root() = this->_Myhead;

  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1542 : 		_Lmost() = this->_Myhead;

  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	89 00		 mov	 DWORD PTR [eax], eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]

; 1543 : 		_Rmost() = this->_Myhead;

  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]

; 1544 : 		this->_Mysize = 0;

  00031	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00038	5e		 pop	 esi

; 44   : 		{	// construct with node pointer _Pnode

  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003e	89 08		 mov	 DWORD PTR [eax], ecx

; 1522 : 			}
; 1523 : 		}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 0c 00	 ret	 12			; 0000000cH
$LN115@erase:

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00046	3b c2		 cmp	 eax, edx

; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

  00048	74 65		 je	 SHORT $LN1@erase
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL2@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00050	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;

  00054	8b c8		 mov	 ecx, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00056	75 43		 jne	 SHORT $LN77@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00058	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0005b	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0005f	75 1b		 jne	 SHORT $LN117@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00061	8b 02		 mov	 eax, DWORD PTR [edx]

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00063	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00067	75 2f		 jne	 SHORT $LN127@erase
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL92@erase:

; 617  : 			_Pnode = _Left(_Pnode);

  00070	8b d0		 mov	 edx, eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00072	8b 02		 mov	 eax, DWORD PTR [edx]

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00074	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00078	74 f6		 je	 SHORT $LL92@erase

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else

  0007a	eb 1c		 jmp	 SHORT $LN127@erase
$LN117@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0007c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0007f	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00083	75 13		 jne	 SHORT $LN127@erase
$LL76@erase:
  00085	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00088	75 0e		 jne	 SHORT $LN127@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0008a	8b c2		 mov	 eax, edx
  0008c	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
  0008f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00092	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00096	74 ed		 je	 SHORT $LL76@erase
$LN127@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00098	89 55 0c	 mov	 DWORD PTR __First$[ebp], edx
$LN77@erase:

; 1520 : 				erase(_First++);

  0009b	51		 push	 ecx
  0009c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0009f	8b ce		 mov	 ecx, esi
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  000a7	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  000aa	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]

; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

  000ad	75 a1		 jne	 SHORT $LL2@erase
$LN1@erase:

; 44   : 		{	// construct with node pointer _Pnode

  000af	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000b2	5e		 pop	 esi
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1521 : 			return (iterator(_First._Ptr, this));

  000b5	8b c1		 mov	 eax, ecx

; 1522 : 			}
; 1523 : 		}

  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Wherenode$1$ = -8					; size = 4
$T1 = -4						; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 2105 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00007	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00009	57		 push	 edi
  0000a	89 5d f8	 mov	 DWORD PTR __Wherenode$1$[ebp], ebx

; 2106 : 		_Nodeptr _Pnode = _Root();

  0000d	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00010	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00014	0f 85 b5 00 00
	00		 jne	 $LN77@Lbound
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0001a	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0001d	56		 push	 esi

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);

  0001e	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00021	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
$LL4@Lbound:

; 520  : 			: this->_Bx._Buf);

  00024	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  00028	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0002b	72 04		 jb	 SHORT $LN33@Lbound
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0002d	8b 32		 mov	 esi, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0002f	eb 02		 jmp	 SHORT $LN34@Lbound
$LN33@Lbound:
  00031	8b f2		 mov	 esi, edx
$LN34@Lbound:
  00033	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));

  00037	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]

; 520  : 			: this->_Bx._Buf);

  0003a	72 02		 jb	 SHORT $LN50@Lbound
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN50@Lbound:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2182 : 			_N0 < _Count ? _N0 : _Count);

  0003e	3b d9		 cmp	 ebx, ecx
  00040	8b d1		 mov	 edx, ecx
  00042	0f 42 d3	 cmovb	 edx, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 517  : 			: _CSTD memcmp(_First1, _First2, _Count));

  00045	85 d2		 test	 edx, edx
  00047	74 5a		 je	 SHORT $LN43@Lbound
  00049	83 ea 04	 sub	 edx, 4
  0004c	72 13		 jb	 SHORT $LN73@Lbound
  0004e	8b ff		 npad	 2
$LL74@Lbound:
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  00054	75 10		 jne	 SHORT $LN72@Lbound
  00056	83 c0 04	 add	 eax, 4
  00059	83 c6 04	 add	 esi, 4
  0005c	83 ea 04	 sub	 edx, 4
  0005f	73 ef		 jae	 SHORT $LL74@Lbound
$LN73@Lbound:
  00061	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00064	74 34		 je	 SHORT $LN71@Lbound
$LN72@Lbound:
  00066	8a 08		 mov	 cl, BYTE PTR [eax]
  00068	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0006a	75 27		 jne	 SHORT $LN75@Lbound
  0006c	83 fa fd	 cmp	 edx, -3			; fffffffdH
  0006f	74 29		 je	 SHORT $LN71@Lbound
  00071	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00074	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00077	75 1a		 jne	 SHORT $LN75@Lbound
  00079	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0007c	74 1c		 je	 SHORT $LN71@Lbound
  0007e	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00081	3a 4e 02	 cmp	 cl, BYTE PTR [esi+2]
  00084	75 0d		 jne	 SHORT $LN75@Lbound
  00086	83 fa ff	 cmp	 edx, -1
  00089	74 0f		 je	 SHORT $LN71@Lbound
  0008b	8a 40 03	 mov	 al, BYTE PTR [eax+3]
  0008e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00091	74 07		 je	 SHORT $LN71@Lbound
$LN75@Lbound:
  00093	1b c0		 sbb	 eax, eax
  00095	83 c8 01	 or	 eax, 1
  00098	eb 02		 jmp	 SHORT $LN76@Lbound
$LN71@Lbound:
  0009a	33 c0		 xor	 eax, eax
$LN76@Lbound:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2184 : 			: _N0 == _Count ? 0 : +1);

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0009f	85 c0		 test	 eax, eax
  000a1	75 0d		 jne	 SHORT $LN79@Lbound
$LN43@Lbound:
  000a3	3b d9		 cmp	 ebx, ecx
  000a5	72 14		 jb	 SHORT $LN70@Lbound
  000a7	33 c0		 xor	 eax, eax
  000a9	3b d9		 cmp	 ebx, ecx
  000ab	0f 95 c0	 setne	 al

; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);
; 2490 : 	}
; 2491 : 
; 2492 : template<class _Elem,
; 2493 : 	class _Traits,
; 2494 : 	class _Alloc> inline
; 2495 : 	bool operator!=(
; 2496 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2497 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2498 : 	{	// test for string inequality
; 2499 : 	return (!(_Left == _Right));
; 2500 : 	}
; 2501 : 
; 2502 : template<class _Elem,
; 2503 : 	class _Traits,
; 2504 : 	class _Alloc> inline
; 2505 : 	bool operator!=(
; 2506 : 		const _Elem *_Left,
; 2507 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2508 : 	{	// test for NTCS vs. string inequality
; 2509 : 	return (!(_Left == _Right));
; 2510 : 	}
; 2511 : 
; 2512 : template<class _Elem,
; 2513 : 	class _Traits,
; 2514 : 	class _Alloc> inline
; 2515 : 	bool operator!=(
; 2516 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2517 : 		const _Elem *_Right)
; 2518 : 	{	// test for string vs. NTCS inequality
; 2519 : 	return (!(_Left == _Right));
; 2520 : 	}
; 2521 : 
; 2522 : template<class _Elem,
; 2523 : 	class _Traits,
; 2524 : 	class _Alloc> inline
; 2525 : 	bool operator<(
; 2526 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2527 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2528 : 	{	// test if string < string
; 2529 : 	return (_Left.compare(_Right) < 0);

  000ae	85 c0		 test	 eax, eax
$LN79@Lbound:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  000b0	78 09		 js	 SHORT $LN70@Lbound

; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  000b2	8b df		 mov	 ebx, edi

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  000b4	8b 3f		 mov	 edi, DWORD PTR [edi]
  000b6	89 5d f8	 mov	 DWORD PTR __Wherenode$1$[ebp], ebx
  000b9	eb 06		 jmp	 SHORT $LN1@Lbound
$LN70@Lbound:

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  000bb	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  000be	8b 5d f8	 mov	 ebx, DWORD PTR __Wherenode$1$[ebp]
$LN1@Lbound:

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  000c1	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000c5	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  000c8	0f 84 56 ff ff
	ff		 je	 $LL4@Lbound
  000ce	5e		 pop	 esi
$LN77@Lbound:
  000cf	5f		 pop	 edi

; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate

  000d0	8b c3		 mov	 eax, ebx
  000d2	5b		 pop	 ebx

; 2119 : 		}

  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lbound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Kfn, COMDAT
; _this$dead$ = ecx

; 2234 : 		{	// get key from value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2235 : 		return (_Traits::_Kfn(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 2236 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >, COMDAT
; _this$ = ecx

; 1002 : 		{	// construct ordering predicate

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 1003 : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 08 00	 ret	 8
??0?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Tree_comp<0,std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Freeheadnode, COMDAT
; _this$dead$ = ecx

; 857  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 865  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Myval, COMDAT
; __Pnode$ = ecx

; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 605  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@ABV?$allocator@USTextLine@CPythonEventManager@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@ABV?$allocator@USTextLine@CPythonEventManager@@@1@@Z PROC ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >, COMDAT
; _this$ = ecx

; 700  : 	_List_alloc(const _Alloc& = _Alloc())

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0

; 527  : 		this->_Myhead = 0;

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 528  : 		this->_Mysize = 0;

  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 704  : 
; 705  : 	~_List_alloc() _NOEXCEPT
; 706  : 		{	// destroy head node
; 707  : 		_Freeheadnode(this->_Myhead);
; 708  : 		}
; 709  : 
; 710  : 	void _Change_alloc(const _Alty&)
; 711  : 		{	// replace old allocator
; 712  : 		}
; 713  : 
; 714  : 	void _Swap_alloc(_Myt&)
; 715  : 		{	// swap allocators
; 716  : 		}
; 717  : 
; 718  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 719  : 	_List_alloc(const _Alloc& = _Alloc())
; 720  : 		{	// construct allocators from _Al
; 721  : 		this->_Myhead = _Buyheadnode();
; 722  : 		_TRY_BEGIN
; 723  : 		_Alloc_proxy();
; 724  : 		_CATCH_ALL
; 725  : 		_Freeheadnode(this->_Myhead);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : 	~_List_alloc() _NOEXCEPT
; 731  : 		{	// destroy proxy
; 732  : 		_Freeheadnode(this->_Myhead);
; 733  : 		_Free_proxy();
; 734  : 		}
; 735  : 
; 736  : 	void _Change_alloc(const _Alty&)
; 737  : 		{	// replace old allocator
; 738  : 		}
; 739  : 
; 740  : 	void _Swap_alloc(_Myt& _Right)
; 741  : 		{	// swap allocators
; 742  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 743  : 		}
; 744  : 
; 745  : 	void _Alloc_proxy()
; 746  : 		{	// construct proxy from _Alnod
; 747  : 		typename _Alty::template rebind<_Container_proxy>::other
; 748  : 			_Alproxy;
; 749  : 		this->_Myproxy = _Alproxy.allocate(1);
; 750  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 751  : 		this->_Myproxy->_Mycont = this;
; 752  : 		}
; 753  : 
; 754  : 	void _Free_proxy()
; 755  : 		{	// destroy proxy
; 756  : 		typename _Alty::template rebind<_Container_proxy>::other
; 757  : 			_Alproxy;
; 758  : 		this->_Orphan_all();
; 759  : 		_Alproxy.destroy(this->_Myproxy);
; 760  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 761  : 		this->_Myproxy = 0;
; 762  : 		}
; 763  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 764  : 
; 765  : 	_Nodeptr _Buyheadnode()
; 766  : 		{	// get head node using current allocator
; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buynode0

; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

  00019	89 06		 mov	 DWORD PTR [esi], eax

; 703  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??0?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@ABV?$allocator@USTextLine@CPythonEventManager@@@1@@Z ENDP ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z PROC ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Freeheadnode, COMDAT
; _this$dead$ = ecx

; 771  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 777  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z ENDP ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Getal, COMDAT
; _this$dead$ = ecx

; 803  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 804  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 805  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAUSTextLine@CPythonEventManager@@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAUSTextLine@CPythonEventManager@@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_Myval, COMDAT
; __Pnode$ = ecx

; 543  : 		return ((reference)_Pnode->_Myval);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 544  : 		}

  00003	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@SAAAUSTextLine@CPythonEventManager@@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@2@XZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@2@XZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@2@XZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@2@XZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEII@Z PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEII@Z ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEXXZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IBEXXZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> >::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> >::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPool@USEventSet@CPythonEventManager@@@@KAXPAUSEventSet@CPythonEventManager@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@USEventSet@CPythonEventManager@@@@KAXPAUSEventSet@CPythonEventManager@@@Z PROC ; CDynamicPool<CPythonEventManager::SEventSet>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 110  : 			delete pkData;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pkData$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 06		 je	 SHORT $LN3@Delete
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	6a 01		 push	 1
  0000e	ff 10		 call	 DWORD PTR [eax]
$LN3@Delete:

; 111  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Delete@?$CDynamicPool@USEventSet@CPythonEventManager@@@@KAXPAUSEventSet@CPythonEventManager@@@Z ENDP ; CDynamicPool<CPythonEventManager::SEventSet>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >, COMDAT
; _this$ = ecx

; 187  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 188  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >, COMDAT
; _this$ = ecx

; 187  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 188  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 215  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator*, COMDAT
; _this$ = ecx

; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >, COMDAT
; _this$ = ecx

; 124  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 125  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicTextInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicTextInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicTextInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 376  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	c1 e0 02	 shl	 eax, 2
  0000b	2b c8		 sub	 ecx, eax

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEAAPAUSEventSet@CPythonEventManager@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEAAPAUSEventSet@CPythonEventManager@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEAAPAUSEventSet@CPythonEventManager@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$dead$ = 12					; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator-, COMDAT
; _this$ = ecx

; 376  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 170  : 		_Ptr += _Off;

  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	83 e9 04	 sub	 ecx, 4

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEII@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEII@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> >::_Vector_val<std::_Simple_types<CGraphicTextInstance *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> >::_Vector_val<std::_Simple_types<CGraphicTextInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@XZ PROC ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buynode0

; 768  : 		}

  00009	c3		 ret	 0
?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<script::SArgumet,void *> >::allocator<std::_List_node<script::SArgumet,void *> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<script::SArgumet,void *> >::allocator<std::_List_node<script::SArgumet,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_List_val<std::_List_simple_types<script::SArgumet> >, COMDAT
; _this$ = ecx

; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 528  : 		this->_Mysize = 0;
; 529  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<script::SArgumet> >::_List_val<std::_List_simple_types<script::SArgumet> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv990 = -8						; size = 4
tv971 = -8						; size = 4
__Pnode$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 1328 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	56		 push	 esi

; 1328 : 		{	// erase element at _Where

  0000b	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  0000e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00011	57		 push	 edi
  00012	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00017	8b 13		 mov	 edx, DWORD PTR [ebx]

; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00019	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0001d	74 05		 je	 SHORT $LN39@erase

; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  0001f	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00022	eb 1e		 jmp	 SHORT $LN351@erase
$LN39@erase:
  00024	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00027	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002b	74 04		 je	 SHORT $LN37@erase

; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  0002d	8b fa		 mov	 edi, edx

; 1349 : 		else

  0002f	eb 11		 jmp	 SHORT $LN351@erase
$LN37@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  00031	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00034	89 4d f8	 mov	 DWORD PTR __Pnode$1$[ebp], ecx

; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00037	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)

  0003a	3b cb		 cmp	 ecx, ebx
  0003c	0f 85 7e 00 00
	00		 jne	 $LN35@erase
$LN351@erase:

; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))

  00042	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00046	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00049	75 03		 jne	 SHORT $LN34@erase

; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  0004b	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0004e	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]

; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)

  00053	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00056	75 05		 jne	 SHORT $LN33@erase

; 1362 : 				_Root() = _Fixnode;	// link down from root

  00058	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  0005b	eb 0b		 jmp	 SHORT $LN30@erase
$LN33@erase:
  0005d	39 1e		 cmp	 DWORD PTR [esi], ebx
  0005f	75 04		 jne	 SHORT $LN31@erase

; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00061	89 3e		 mov	 DWORD PTR [esi], edi

; 1365 : 			else

  00063	eb 03		 jmp	 SHORT $LN30@erase
$LN31@erase:

; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right

  00065	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00068	8b 02		 mov	 eax, DWORD PTR [edx]

; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)

  0006a	39 18		 cmp	 DWORD PTR [eax], ebx
  0006c	75 22		 jne	 SHORT $LN29@erase

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0006e	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00072	74 04		 je	 SHORT $LN42@erase
  00074	8b ce		 mov	 ecx, esi
  00076	eb 16		 jmp	 SHORT $LN43@erase
$LN42@erase:

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00078	8b 07		 mov	 eax, DWORD PTR [edi]

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007a	8b cf		 mov	 ecx, edi

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0007c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00080	75 0a		 jne	 SHORT $LN92@erase
$LL93@erase:

; 617  : 			_Pnode = _Left(_Pnode);

  00082	8b c8		 mov	 ecx, eax

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00084	8b 01		 mov	 eax, DWORD PTR [ecx]

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00086	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0008a	74 f6		 je	 SHORT $LL93@erase
$LN92@erase:
  0008c	8b 02		 mov	 eax, DWORD PTR [edx]
$LN43@erase:

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0008e	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00090	8b 02		 mov	 eax, DWORD PTR [edx]
  00092	89 45 f8	 mov	 DWORD PTR tv971[ebp], eax

; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)

  00095	39 58 08	 cmp	 DWORD PTR [eax+8], ebx
  00098	0f 85 81 00 00
	00		 jne	 $LN170@erase

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  0009e	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000a2	74 0a		 je	 SHORT $LN44@erase
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR tv971[ebp]
  000a7	8b c6		 mov	 eax, esi
  000a9	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1378 : 			}
; 1379 : 		else

  000ac	eb 71		 jmp	 SHORT $LN170@erase
$LN44@erase:

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000ae	8b cf		 mov	 ecx, edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Max
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR tv971[ebp]
  000b8	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1378 : 			}
; 1379 : 		else

  000be	eb 5f		 jmp	 SHORT $LN170@erase
$LN35@erase:

; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up

  000c0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c5	89 01		 mov	 DWORD PTR [ecx], eax

; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 4b 08	 cmp	 ecx, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase

; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f1		 mov	 esi, ecx

; 1388 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase
$LN26@erase:

; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000d4	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000d7	75 03		 jne	 SHORT $LN24@erase

; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase:

; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000e1	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up

  000e4	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000e7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN25@erase:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000ea	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
  000ed	8b 02		 mov	 eax, DWORD PTR [edx]

; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)

  000ef	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  000f2	75 05		 jne	 SHORT $LN23@erase

; 1402 : 				_Root() = _Pnode;	// link down from root

  000f4	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f7	eb 0e		 jmp	 SHORT $LN20@erase
$LN23@erase:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  000f9	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000fc	39 18		 cmp	 DWORD PTR [eax], ebx
  000fe	75 04		 jne	 SHORT $LN21@erase

; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left

  00100	89 08		 mov	 DWORD PTR [eax], ecx

; 1406 : 			else

  00102	eb 03		 jmp	 SHORT $LN20@erase
$LN21@erase:

; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right

  00104	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN20@erase:

; 1411 : 				this->_Parent(_Erasednode);	// link successor up

  00107	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0010a	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1411 : 				this->_Parent(_Erasednode);	// link successor up

  0010d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00110	8a 43 0c	 mov	 al, BYTE PTR [ebx+12]
  00113	8a 49 0c	 mov	 cl, BYTE PTR [ecx+12]
  00116	88 42 0c	 mov	 BYTE PTR [edx+12], al
  00119	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]

; 54   : 	_Right = _Move(_Tmp);

  0011c	88 4b 0c	 mov	 BYTE PTR [ebx+12], cl
$LN170@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011f	80 7b 0c 01	 cmp	 BYTE PTR [ebx+12], 1
  00123	0f 85 25 01 00
	00		 jne	 $LN354@erase

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00129	8b 02		 mov	 eax, DWORD PTR [edx]
  0012b	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  0012e	0f 84 d3 00 00
	00		 je	 $LN356@erase
$LL18@erase:
  00134	80 7f 0c 01	 cmp	 BYTE PTR [edi+12], 1
  00138	0f 85 c9 00 00
	00		 jne	 $LN356@erase

; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  0013e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00140	3b f9		 cmp	 edi, ecx
  00142	75 7d		 jne	 SHORT $LN15@erase

; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);

  00144	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1424 : 					if (this->_Color(_Pnode) == this->_Red)

  00147	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0014b	75 16		 jne	 SHORT $LN14@erase

; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;

  0014d	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);

  00151	8b ca		 mov	 ecx, edx
  00153	56		 push	 esi
  00154	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  00158	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lrotate

; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00160	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN14@erase:

; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))

  00163	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00167	0f 85 8a 00 00
	00		 jne	 $LN357@erase

; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  0016d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016f	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00173	75 09		 jne	 SHORT $LN11@erase
  00175	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00178	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  0017c	74 75		 je	 SHORT $LN358@erase
$LN11@erase:

; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)

  0017e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00181	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00185	75 15		 jne	 SHORT $LN9@erase

; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  00187	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);

  00189	51		 push	 ecx
  0018a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0018e	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00192	8b ca		 mov	 ecx, edx
  00194	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Rrotate

; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);

  00199	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN9@erase:

; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0019c	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  0019f	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;

  001a2	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  001a6	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1454 : 						_Lrotate(_Fixnodeparent);

  001a9	56		 push	 esi
  001aa	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  001ad	8b ce		 mov	 ecx, esi
  001af	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  001b3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lrotate

; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  001b8	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
  001bc	e9 90 00 00 00	 jmp	 $LN19@erase
$LN15@erase:

; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)

  001c1	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001c5	75 15		 jne	 SHORT $LN7@erase

; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;

  001c7	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);

  001cb	8b ca		 mov	 ecx, edx
  001cd	56		 push	 esi
  001ce	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  001d2	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Rrotate

; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);

  001d7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001d9	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN7@erase:

; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))

  001dc	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001e0	75 15		 jne	 SHORT $LN357@erase

; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001e2	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001e5	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001e9	75 25		 jne	 SHORT $LN4@erase
  001eb	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ed	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001f1	75 1d		 jne	 SHORT $LN4@erase
$LN358@erase:

; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;

  001f3	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
$LN357@erase:

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001f7	8b 02		 mov	 eax, DWORD PTR [edx]

; 1476 : 						_Fixnode = _Fixnodeparent;

  001f9	8b fe		 mov	 edi, esi
  001fb	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001fe	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00201	0f 85 2d ff ff
	ff		 jne	 $LL18@erase
$LN356@erase:
  00207	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]

; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0020a	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
  0020e	eb 41		 jmp	 SHORT $LN19@erase
$LN4@erase:

; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00210	8b 01		 mov	 eax, DWORD PTR [ecx]
  00212	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00216	75 15		 jne	 SHORT $LN2@erase

; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00218	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);

  0021b	51		 push	 ecx
  0021c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00220	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00224	8b ca		 mov	 ecx, edx
  00226	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lrotate

; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);

  0022b	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN2@erase:

; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0022d	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  00230	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00233	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00237	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1491 : 						_Rrotate(_Fixnodeparent);

  00239	56		 push	 esi
  0023a	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  0023d	8b ce		 mov	 ecx, esi
  0023f	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00243	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Rrotate

; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00248	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
  0024c	eb 03		 jmp	 SHORT $LN19@erase
$LN354@erase:
  0024e	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
$LN19@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00251	83 7b 24 10	 cmp	 DWORD PTR [ebx+36], 16	; 00000010H
  00255	72 0b		 jb	 SHORT $LN317@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00257	ff 73 10	 push	 DWORD PTR [ebx+16]
  0025a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0025f	83 c4 04	 add	 esp, 4
$LN317@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00262	c7 43 24 0f 00
	00 00		 mov	 DWORD PTR [ebx+36], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00269	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00270	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00271	c6 43 10 00	 mov	 BYTE PTR [ebx+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00275	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1504 : 		if (0 < this->_Mysize)

  0027a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0027d	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

  00280	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]

; 1504 : 		if (0 < this->_Mysize)

  00283	85 c0		 test	 eax, eax
  00285	74 04		 je	 SHORT $LN353@erase

; 1505 : 			--this->_Mysize;

  00287	48		 dec	 eax
  00288	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN353@erase:

; 44   : 		{	// construct with node pointer _Pnode

  0028b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0028e	5f		 pop	 edi
  0028f	5e		 pop	 esi
  00290	5b		 pop	 ebx
  00291	89 08		 mov	 DWORD PTR [eax], ecx

; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}

  00293	8b e5		 mov	 esp, ebp
  00295	5d		 pop	 ebp
  00296	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 1535 : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Erase

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0000d	8b 06		 mov	 eax, DWORD PTR [esi]

; 1541 : 		_Root() = this->_Myhead;

  0000f	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1542 : 		_Lmost() = this->_Myhead;

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	89 00		 mov	 DWORD PTR [eax], eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]

; 1543 : 		_Rmost() = this->_Myhead;

  00018	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1544 : 		this->_Mysize = 0;

  0001b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00022	5e		 pop	 esi

; 1545 : 		}

  00023	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2123 : 		return (this->_Left(this->_Myhead));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2124 : 		}

  00002	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4

; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}

  00005	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??0?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 889  : 		{	// construct from allocator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 890  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Getal, COMDAT
; _this$dead$ = ecx

; 868  : 		{	// get allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 870  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Isnil, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8d 41 0d	 lea	 eax, DWORD PTR [ecx+13]

; 585  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Left, COMDAT
; __Pnode$ = ecx

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00000	8b c1		 mov	 eax, ecx

; 590  : 		}

  00002	c3		 ret	 0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Parent, COMDAT
; __Pnode$ = ecx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 595  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Right, COMDAT
; __Pnode$ = ecx

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 600  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@XZ PROC ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buyheadnode, COMDAT
; _this$dead$ = ecx

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buynode0

; 768  : 		}

  00009	c3		 ret	 0
?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >, COMDAT
; _this$ = ecx

; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 528  : 		this->_Mysize = 0;
; 529  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
?deallocate@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@I@Z PROC ; std::allocator<CPythonEventManager::SEventSet *>::deallocate, COMDAT
; _this$dead$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@I@Z ENDP ; std::allocator<CPythonEventManager::SEventSet *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEPAPAUSEventSet@CPythonEventManager@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEPAPAUSEventSet@CPythonEventManager@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::allocate, COMDAT
; _this$dead$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEPAPAUSEventSet@CPythonEventManager@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::max_size, COMDAT
; _this$dead$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USArgumet@script@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator++, COMDAT
; _this$ = ecx

; 276  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 277  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 271  : 		++(*(_Mybase *)this);

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator++

; 278  : 		++*this;
; 279  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 280  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 342  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicTextInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicTextInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicTextInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator-=, COMDAT
; _this$ = ecx

; 371  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 02	 shl	 eax, 2
  0000b	01 01		 add	 DWORD PTR [ecx], eax

; 372  : 		return (*this += -_Off);

  0000d	8b c1		 mov	 eax, ecx

; 373  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEABQAVCGraphicTextInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEABQAVCGraphicTextInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEABQAVCGraphicTextInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@PAPAUSEventSet@CPythonEventManager@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@PAPAUSEventSet@CPythonEventManager@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@PAPAUSEventSet@CPythonEventManager@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator-=, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	83 01 fc	 add	 DWORD PTR [ecx], -4	; fffffffcH

; 372  : 		return (*this += -_Off);

  00003	8b c1		 mov	 eax, ecx

; 373  : 		}

  00005	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEABQAUSEventSet@CPythonEventManager@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEABQAUSEventSet@CPythonEventManager@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEABQAUSEventSet@CPythonEventManager@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@0@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@0@Z PROC ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buynode0, COMDAT
; _this$ = ecx

; 781  : 		{	// allocate a node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00003	6a 38		 push	 56			; 00000038H
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
  0000d	85 c0		 test	 eax, eax
  0000f	74 1f		 je	 SHORT $LN76@Buynode0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 784  : 		if (_Next == _Nodeptr())

  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Next$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN74@Buynode0

; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;

  00018	8b c8		 mov	 ecx, eax

; 787  : 			_Prev = _Pnode;

  0001a	8b d0		 mov	 edx, eax
  0001c	eb 03		 jmp	 SHORT $LN2@Buynode0
$LN74@Buynode0:
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Prev$[ebp]
$LN2@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00021	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00023	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00026	85 c9		 test	 ecx, ecx
  00028	74 02		 je	 SHORT $LN3@Buynode0
  0002a	89 11		 mov	 DWORD PTR [ecx], edx
$LN3@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 800  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
$LN76@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00030	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN78@Buynode0:
$LN75@Buynode0:
  00035	cc		 int	 3
?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@0@Z ENDP ; std::_List_alloc<0,std::_List_base_types<script::SArgumet,std::allocator<script::SArgumet> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<script::SArgumet,void *> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAU?$_List_node@USArgumet@script@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<script::SArgumet,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2074 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;

  00005	8b 75 08	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b fe		 mov	 edi, esi

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000d	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00011	75 40		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));

  00013	ff 77 08	 push	 DWORD PTR [edi+8]
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0001d	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2079 : 			_Pnode = this->_Left(_Pnode);

  00021	8b 3f		 mov	 edi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00023	72 0b		 jb	 SHORT $LN49@Erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00025	ff 76 10	 push	 DWORD PTR [esi+16]
  00028	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002d	83 c4 04	 add	 esp, 4
$LN49@Erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00030	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00037	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0003e	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0003f	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00043	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00048	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0004b	8b f7		 mov	 esi, edi
  0004d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00051	74 c0		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2127 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi

; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00007	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Lrotate:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0d		 jne	 SHORT $LN4@Lrotate

; 2136 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0002a	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0002c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002f	5e		 pop	 esi

; 2144 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@Lrotate:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00037	3b 10		 cmp	 edx, DWORD PTR [eax]
  00039	75 0c		 jne	 SHORT $LN2@Lrotate

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003b	89 30		 mov	 DWORD PTR [eax], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0003d	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0003f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00042	5e		 pop	 esi

; 2144 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0004f	5e		 pop	 esi

; 2144 : 		}

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}

  00005	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2157 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Rrotate:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0e		 jne	 SHORT $LN4@Rrotate

; 2166 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0002a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  0002d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00030	5e		 pop	 esi

; 2174 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Rrotate:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00038	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003b	75 0e		 jne	 SHORT $LN2@Rrotate

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00043	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00046	5e		 pop	 esi

; 2174 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00053	5e		 pop	 esi

; 2174 : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >, COMDAT
; _this$ = ecx

; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 774  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@1@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Color, COMDAT
; __Pnode$ = ecx

; 579  : 		return ((char&)_Pnode->_Color);

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]

; 580  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Max, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00003	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00007	75 12		 jne	 SHORT $LN15@Max
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL2@Max:

; 610  : 			_Pnode = _Right(_Pnode);

  00010	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN15@Max:

; 611  : 		return (_Pnode);

  0001b	8b c1		 mov	 eax, ecx

; 612  : 		}

  0001d	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Min, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00002	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00006	75 0a		 jne	 SHORT $LN15@Min
$LL2@Min:

; 617  : 			_Pnode = _Left(_Pnode);

  00008	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0000c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00010	74 f6		 je	 SHORT $LL2@Min
$LN15@Min:

; 618  : 		return (_Pnode);

  00012	8b c1		 mov	 eax, ecx

; 619  : 		}

  00014	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@0@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@0@Z PROC ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buynode0, COMDAT
; _this$dead$ = ecx

; 781  : 		{	// allocate a node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00003	6a 14		 push	 20			; 00000014H
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
  0000d	85 c0		 test	 eax, eax
  0000f	74 1f		 je	 SHORT $LN76@Buynode0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 784  : 		if (_Next == _Nodeptr())

  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Next$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN74@Buynode0

; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;

  00018	8b c8		 mov	 ecx, eax

; 787  : 			_Prev = _Pnode;

  0001a	8b d0		 mov	 edx, eax
  0001c	eb 03		 jmp	 SHORT $LN2@Buynode0
$LN74@Buynode0:
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Prev$[ebp]
$LN2@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00021	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00023	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00026	85 c9		 test	 ecx, ecx
  00028	74 02		 je	 SHORT $LN3@Buynode0
  0002a	89 11		 mov	 DWORD PTR [ecx], edx
$LN3@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 800  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
$LN76@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00030	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN78@Buynode0:
$LN75@Buynode0:
  00035	cc		 int	 3
?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@0@Z ENDP ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEPAPAUSEventSet@CPythonEventManager@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEPAPAUSEventSet@CPythonEventManager@@I@Z PROC ; std::allocator<CPythonEventManager::SEventSet *>::allocate, COMDAT
; _this$dead$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEPAPAUSEventSet@CPythonEventManager@@I@Z ENDP ; std::allocator<CPythonEventManager::SEventSet *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAIABV?$allocator@PAUSEventSet@CPythonEventManager@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAIABV?$allocator@PAUSEventSet@CPythonEventManager@@@2@@Z PROC ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAIABV?$allocator@PAUSEventSet@CPythonEventManager@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator++, COMDAT
; _this$ = ecx

; 256  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 273  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 359  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 362  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicTextInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicTextInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicTextInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator+=, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	83 01 fc	 add	 DWORD PTR [ecx], -4	; fffffffcH

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 362  : 		}

  00005	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@PAPAUSEventSet@CPythonEventManager@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@PAPAUSEventSet@CPythonEventManager@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAE@PAPAUSEventSet@CPythonEventManager@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEPAPAVCGraphicTextInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEPAPAVCGraphicTextInstance@@I@Z PROC ; std::allocator<CGraphicTextInstance *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEPAPAVCGraphicTextInstance@@I@Z ENDP ; std::allocator<CGraphicTextInstance *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicTextInstance@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicTextInstance@@@2@@Z PROC ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicTextInstance@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 21		 je	 SHORT $LN1@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	81 f9 24 49 92
	04		 cmp	 ecx, 76695844		; 04924924H
  00012	77 1d		 ja	 SHORT $LN14@allocate
  00014	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 e0 03	 shl	 eax, 3
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	74 04		 je	 SHORT $LN14@allocate
$LN1@allocate:

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00036	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Buyheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 2c		 push	 44			; 0000002cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 00 00 00
	00		 je	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00012	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	85 c9		 test	 ecx, ecx
  00019	74 02		 je	 SHORT $LN61@Buyheadnod
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
$LN61@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0001d	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00020	85 c9		 test	 ecx, ecx
  00022	74 02		 je	 SHORT $LN83@Buyheadnod
  00024	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 851  : 		this->_Color(_Pnode) = this->_Black;

  00026	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}

  0002c	c3		 ret	 0
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >, COMDAT
; _this$ = ecx

; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 570  : 		this->_Mysize = 0;
; 571  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 14		 push	 20			; 00000014H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN15@allocate

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

  0000e	c2 04 00	 ret	 4
$LN15@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN17@allocate:
$LN14@allocate:
  00016	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QBEIXZ PROC ; std::allocator<CPythonEventManager::SEventSet *>::max_size, COMDAT
; _this$dead$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QBEIXZ ENDP ; std::allocator<CPythonEventManager::SEventSet *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

  00000	8b d1		 mov	 edx, ecx

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	75 42		 jne	 SHORT $LN41@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00011	75 1c		 jne	 SHORT $LN34@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	75 0f		 jne	 SHORT $LN17@operator
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator:

; 617  : 			_Pnode = _Left(_Pnode);

  00020	8b c8		 mov	 ecx, eax

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00022	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 f6		 je	 SHORT $LL18@operator
$LN17@operator:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0002a	89 0a		 mov	 DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

  0002c	8b c2		 mov	 eax, edx

; 74   : 		}

  0002e	c3		 ret	 0
$LN34@operator:

; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00036	75 12		 jne	 SHORT $LN1@operator
$LL2@operator:
  00038	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003a	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0003d	75 0b		 jne	 SHORT $LN1@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003f	89 02		 mov	 DWORD PTR [edx], eax
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00048	74 ee		 je	 SHORT $LL2@operator
$LN1@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  0004a	89 02		 mov	 DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

  0004c	8b c2		 mov	 eax, edx

; 74   : 		}

  0004e	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 153  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 171  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 172  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator+=, COMDAT
; _this$ = ecx

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00000	83 01 fc	 add	 DWORD PTR [ecx], -4	; fffffffcH

; 171  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 172  : 		}

  00005	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCGraphicTextInstance@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCGraphicTextInstance@@@std@@QBEIXZ PROC ; std::allocator<CGraphicTextInstance *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCGraphicTextInstance@@@std@@QBEIXZ ENDP ; std::allocator<CGraphicTextInstance *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<script::SArgumet,void *> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 21		 je	 SHORT $LN1@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	81 f9 24 49 92
	04		 cmp	 ecx, 76695844		; 04924924H
  00012	77 1d		 ja	 SHORT $LN11@allocate
  00014	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 e0 03	 shl	 eax, 3
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	74 04		 je	 SHORT $LN11@allocate
$LN1@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00036	cc		 int	 3
?allocate@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<script::SArgumet,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 2c		 push	 44			; 0000002cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN15@allocate

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

  0000e	c2 04 00	 ret	 4
$LN15@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN17@allocate:
$LN14@allocate:
  00016	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 14		 push	 20			; 00000014H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN12@allocate

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

  0000e	c2 04 00	 ret	 4
$LN12@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN14@allocate:
$LN11@allocate:
  00016	cc		 int	 3
?allocate@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 2c		 push	 44			; 0000002cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN12@allocate

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

  0000e	c2 04 00	 ret	 4
$LN12@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN14@allocate:
$LN11@allocate:
  00016	cc		 int	 3
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$forward_as_tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
??$forward_as_tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::forward_as_tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 628  : 	{	// forward arguments in a tuple

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   : 		{	// construct with argument

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$forward_as_tuple@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::forward_as_tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
_<_Val_0>$dead$ = 16					; size = 4
_<_Val_1>$ = 20						; size = 4
_<_Val_2>$dead$ = 24					; size = 4
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 1182 : 		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1183 : 		{	// insert value_type(_Val...) at _Where
; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

  00004	51		 push	 ecx
  00005	ff 75 14	 push	 DWORD PTR _<_Val_1>$[ebp]
  00008	8b f9		 mov	 edi, ecx
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  00010	50		 push	 eax

; 604  : 		return ((reference)_Pnode->_Myval);

  00011	83 c0 10	 add	 eax, 16			; 00000010H

; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));

  00014	8b cf		 mov	 ecx, edi
  00016	50		 push	 eax
  00017	ff 75 0c	 push	 DWORD PTR __Where$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_hint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	5f		 pop	 edi

; 1187 : 		}

  00026	5d		 pop	 ebp
  00027	c2 14 00	 ret	 20			; 00000014H
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??$_Insert@ABUSTextLine@CPythonEventManager@@@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@1@ABUSTextLine@CPythonEventManager@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Insert@ABUSTextLine@CPythonEventManager@@@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@1@ABUSTextLine@CPythonEventManager@@@Z PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Insert<CPythonEventManager::STextLine const &>, COMDAT
; _this$ = ecx

; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi

; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);

  00008	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  0000b	8b f9		 mov	 edi, ecx
  0000d	ff 76 04	 push	 DWORD PTR [esi+4]
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??$_Buynode@ABUSTextLine@CPythonEventManager@@@?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PAU21@0ABUSTextLine@CPythonEventManager@@@Z ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Buynode<CPythonEventManager::STextLine const &>
  00016	8b d0		 mov	 edx, eax

; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Change_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_iterator begin() const _NOEXCEPT
; 1120 : 		{	// return iterator for beginning of nonmutable sequence
; 1121 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1122 : 		}
; 1123 : 
; 1124 : 	iterator end() _NOEXCEPT
; 1125 : 		{	// return iterator for end of mutable sequence
; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}
; 1128 : 
; 1129 : 	const_iterator end() const _NOEXCEPT
; 1130 : 		{	// return iterator for end of nonmutable sequence
; 1131 : 		return (const_iterator(this->_Myhead, this));
; 1132 : 		}
; 1133 : 
; 1134 : 	_Unchecked_iterator _Unchecked_begin()
; 1135 : 		{	// return iterator for beginning of mutable sequence
; 1136 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1137 : 			this));
; 1138 : 		}
; 1139 : 
; 1140 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1141 : 		{	// return iterator for beginning of nonmutable sequence
; 1142 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1143 : 			this));
; 1144 : 		}
; 1145 : 
; 1146 : 	_Unchecked_iterator _Unchecked_end()
; 1147 : 		{	// return unchecked iterator for end of mutable sequence
; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1149 : 		}
; 1150 : 
; 1151 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1152 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1153 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1154 : 		}
; 1155 : 
; 1156 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1157 : 		{	// make iterator from const_iterator
; 1158 : 		return (iterator(_Where._Ptr, this));
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1162 : 		{	// make iterator from _Unchecked_const_iterator
; 1163 : 		return (iterator(_Where._Ptr, this));
; 1164 : 		}
; 1165 : 
; 1166 : 	reverse_iterator rbegin() _NOEXCEPT
; 1167 : 		{	// return iterator for beginning of reversed mutable sequence
; 1168 : 		return (reverse_iterator(end()));
; 1169 : 		}
; 1170 : 
; 1171 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1172 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1173 : 		return (const_reverse_iterator(end()));
; 1174 : 		}
; 1175 : 
; 1176 : 	reverse_iterator rend() _NOEXCEPT
; 1177 : 		{	// return iterator for end of reversed mutable sequence
; 1178 : 		return (reverse_iterator(begin()));
; 1179 : 		}
; 1180 : 
; 1181 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1182 : 		{	// return iterator for end of reversed nonmutable sequence
; 1183 : 		return (const_reverse_iterator(begin()));
; 1184 : 		}
; 1185 : 
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 : 
; 1206 : 	void resize(size_type _Newsize)
; 1207 : 		{	// determine new length, padding with _Ty() elements as needed
; 1208 : 		if (this->_Mysize < _Newsize)
; 1209 : 			{	// pad to make larger
; 1210 : 			size_type _Count = 0;
; 1211 : 			_TRY_BEGIN
; 1212 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1213 : 				_Insert(_Unchecked_end());
; 1214 : 			_CATCH_ALL
; 1215 : 			for (; 0 < _Count; --_Count)
; 1216 : 				pop_back();	// undo inserts
; 1217 : 			_RERAISE;
; 1218 : 			_CATCH_END
; 1219 : 			}
; 1220 : 		else
; 1221 : 			while (_Newsize < this->_Mysize)
; 1222 : 				pop_back();
; 1223 : 		}
; 1224 : 
; 1225 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1226 : 		{	// determine new length, padding with _Val elements as needed
; 1227 : 		if (this->_Mysize < _Newsize)
; 1228 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1229 : 		else
; 1230 : 			while (_Newsize < this->_Mysize)
; 1231 : 				pop_back();
; 1232 : 		}
; 1233 : 
; 1234 : 	size_type size() const _NOEXCEPT
; 1235 : 		{	// return length of sequence
; 1236 : 		return (this->_Mysize);
; 1237 : 		}
; 1238 : 
; 1239 : 	size_type max_size() const _NOEXCEPT
; 1240 : 		{	// return maximum possible length of sequence
; 1241 : 		return (this->_Getal().max_size());
; 1242 : 		}
; 1243 : 
; 1244 : 	bool empty() const _NOEXCEPT
; 1245 : 		{	// test if sequence is empty
; 1246 : 		return (this->_Mysize == 0);
; 1247 : 		}
; 1248 : 
; 1249 : 	allocator_type get_allocator() const _NOEXCEPT
; 1250 : 		{	// return allocator object for values
; 1251 : 		return (this->_Getal());
; 1252 : 		}
; 1253 : 
; 1254 : 	reference front()
; 1255 : 		{	// return first element of mutable sequence
; 1256 : 		return (*begin());
; 1257 : 		}
; 1258 : 
; 1259 : 	const_reference front() const
; 1260 : 		{	// return first element of nonmutable sequence
; 1261 : 		return (*begin());
; 1262 : 		}
; 1263 : 
; 1264 : 	reference back()
; 1265 : 		{	// return last element of mutable sequence
; 1266 : 		return (*(--end()));
; 1267 : 		}
; 1268 : 
; 1269 : 	const_reference back() const
; 1270 : 		{	// return last element of nonmutable sequence
; 1271 : 		return (*(--end()));
; 1272 : 		}
; 1273 : 
; 1274 : 	void push_front(const _Ty& _Val)
; 1275 : 		{	// insert element at beginning
; 1276 : 		_Insert(_Unchecked_begin(), _Val);
; 1277 : 		}
; 1278 : 
; 1279 : 	void pop_front()
; 1280 : 		{	// erase element at beginning
; 1281 : 		erase(begin());
; 1282 : 		}
; 1283 : 
; 1284 : 	void push_back(const _Ty& _Val)
; 1285 : 		{	// insert element at end
; 1286 : 		_Insert(_Unchecked_end(), _Val);
; 1287 : 		}
; 1288 : 
; 1289 : 	void pop_back()
; 1290 : 		{	// erase element at end
; 1291 : 		erase(--end());
; 1292 : 		}
; 1293 : 
; 1294 : 	template<class _Iter>
; 1295 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1296 : 			void>::type
; 1297 : 		assign(_Iter _First, _Iter _Last)
; 1298 : 		{	// assign [_First, _Last), input iterators
; 1299 : 		iterator _Old = begin();
; 1300 : 		_TRY_BEGIN
; 1301 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1302 : 			_Reusenode(_Old, *_First);
; 1303 : 		for (; _First != _Last; ++_First)
; 1304 : 			_Insert(_Unchecked_end(), *_First);
; 1305 : 		_CATCH_ALL
; 1306 : 		clear();
; 1307 : 		_RERAISE;
; 1308 : 		_CATCH_END
; 1309 : 		erase(_Old, end());
; 1310 : 		}
; 1311 : 
; 1312 : 	template<class _TArg>
; 1313 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1314 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1315 : 		_TRY_BEGIN
; 1316 : 		this->_Getal().destroy(
; 1317 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1318 : 		this->_Getal().construct(
; 1319 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1320 : 			_STD forward<_TArg>(_Arg));
; 1321 : 		_CATCH_ALL
; 1322 : 		_Unlinknode(_Where);
; 1323 : 		this->_Getal().destroy(
; 1324 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1325 : 		this->_Getal().destroy(
; 1326 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1327 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1328 : 		_RERAISE;
; 1329 : 		_CATCH_END
; 1330 : 		}
; 1331 : 
; 1332 : 	void assign(size_type _Count, const _Ty& _Val)
; 1333 : 		{	// assign _Count * _Val
; 1334 : 		clear();
; 1335 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1336 : 		}
; 1337 : 
; 1338 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1339 : 		{	// insert _Val at _Where
; 1340 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1341 : 		if (_Where._Getcont() != this)
; 1342 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1343 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1344 : 
; 1345 : 		_Insert(_Where._Unchecked(), _Val);
; 1346 : 		return (_Make_iter(--_Where));
; 1347 : 		}
; 1348 : 
; 1349 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1350 : 		{	// insert _Count * _Val at _Where
; 1351 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 		if (_Where._Getcont() != this)
; 1353 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1354 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1355 : 
; 1356 : 		iterator _Prev = _Make_iter(_Where);
; 1357 : 		if (_Prev == begin())
; 1358 : 			{	// insert sequence at beginning
; 1359 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1360 : 			return (begin());
; 1361 : 			}
; 1362 : 		else
; 1363 : 			{	// insert sequence not at beginning
; 1364 : 			--_Prev;
; 1365 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1366 : 			return (++_Prev);
; 1367 : 			}
; 1368 : 		}
; 1369 : 
; 1370 : 	template<class _Iter>
; 1371 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1372 : 			iterator>::type
; 1373 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1374 : 		{	// insert [_First, _Last) at _Where
; 1375 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1376 : 		if (_Where._Getcont() != this)
; 1377 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1378 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1379 : 
; 1380 : 		iterator _Prev = _Make_iter(_Where);
; 1381 : 		if (_Prev == begin())
; 1382 : 			{	// insert sequence at beginning
; 1383 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1384 : 				_Iter_cat(_First));
; 1385 : 			return (begin());
; 1386 : 			}
; 1387 : 		else
; 1388 : 			{	// insert sequence not at beginning
; 1389 : 			--_Prev;
; 1390 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1391 : 				_Iter_cat(_First));
; 1392 : 			return (++_Prev);
; 1393 : 			}
; 1394 : 		}
; 1395 : 
; 1396 : 	template<class _Iter>
; 1397 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1398 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1399 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1400 : 		size_type _Num = 0;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First, ++_Num)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; 0 < _Num; --_Num)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	template<class _Iter>
; 1416 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1417 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1418 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1419 : 		_DEBUG_RANGE(_First, _Last);
; 1420 : 		_Iter _Next = _First;
; 1421 : 
; 1422 : 		_TRY_BEGIN
; 1423 : 		for (; _First != _Last; ++_First)
; 1424 : 			_Insert(_Where, *_First);
; 1425 : 		_CATCH_ALL
; 1426 : 		for (; _Next != _First; ++_Next)
; 1427 : 			{	// undo inserts
; 1428 : 			_Unchecked_const_iterator _Before = _Where;
; 1429 : 			_Unchecked_erase(--_Before);
; 1430 : 			}
; 1431 : 		_RERAISE;
; 1432 : 		_CATCH_END
; 1433 : 		}
; 1434 : 
; 1435 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1436 : 		{	// unlink node at _Where from the list
; 1437 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1438 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1439 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1440 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1441 : 		_Orphan_ptr(*this, _Pnode);
; 1442 : 
; 1443 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1444 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1445 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1446 : 
; 1447 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1448 : 			this->_Nextnode(_Pnode);
; 1449 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1450 : 			this->_Prevnode(_Pnode);
; 1451 : 
; 1452 : 		--this->_Mysize;
; 1453 : 		return (_Pnode);
; 1454 : 		}
; 1455 : 
; 1456 : 	iterator erase(const_iterator _Where)
; 1457 : 		{	// erase element at _Where
; 1458 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1459 : 		this->_Freenode(_Pnode);
; 1460 : 		return (_Make_iter(_Where));
; 1461 : 		}
; 1462 : 
; 1463 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1464 : 		{	// erase element at _Where
; 1465 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1466 : 
; 1467 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1468 : 			this->_Nextnode(_Pnode);
; 1469 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1470 : 			this->_Prevnode(_Pnode);
; 1471 : 		this->_Freenode(_Pnode);
; 1472 : 		--this->_Mysize;
; 1473 : 		}
; 1474 : 
; 1475 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1476 : 		{	// erase [_First, _Last)
; 1477 : 		if (_First == begin() && _Last == end())
; 1478 : 			{	// erase all and return fresh iterator
; 1479 : 			clear();
; 1480 : 			return (end());
; 1481 : 			}
; 1482 : 		else
; 1483 : 			{	// erase subrange
; 1484 : 			while (_First != _Last)
; 1485 : 				_First = erase(_First);
; 1486 : 			return (_Make_iter(_Last));
; 1487 : 			}
; 1488 : 		}
; 1489 : 
; 1490 : 	void clear() _NOEXCEPT
; 1491 : 		{	// erase all
; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1499 : 		this->_Mysize = 0;
; 1500 : 
; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);
; 1504 : 			this->_Freenode(_Pnode);
; 1505 : 			}
; 1506 : 		}
; 1507 : 
; 1508 : 	void swap(_Myt& _Right)
; 1509 : 		{	// exchange contents with _Right
; 1510 : 		if (this == &_Right)
; 1511 : 			;	// same object, do nothing
; 1512 : 		else if (this->_Getal() == _Right._Getal())
; 1513 : 			{	// same allocator, swap control information
; 1514 : 			this->_Swap_all(_Right);
; 1515 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1516 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1517 : 			}
; 1518 : 
; 1519 : 		else if (_Alty::propagate_on_container_swap::value)
; 1520 : 			{	// swap allocators and control information
; 1521 : 			this->_Swap_alloc(_Right);
; 1522 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1523 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1524 : 			}
; 1525 : 
; 1526 : 		else	// containers are incompatible
; 1527 : 
; 1528 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1529 : 			_DEBUG_ERROR("list containers incompatible for swap");
; 1530 : 
; 1531 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1532 : 			_XSTD terminate();
; 1533 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1534 : 		}
; 1535 : 
; 1536 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1537 : 		{	// splice all of _Right at _Where
; 1538 : 		if (this != &_Right && !_Right.empty())
; 1539 : 			{	// worth splicing, do it
; 1540 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1541 : 				_Right._Mysize);
; 1542 : 			}
; 1543 : 		}
; 1544 : 
; 1545 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1546 : 		{	// splice all of _Right at _Where
; 1547 : 		splice(_Where, (_Myt&)_Right);
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1554 : 		if (_First == _Right.end())
; 1555 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1556 : 		else
; 1557 : 
; 1558 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1559 : 		if (_First != _Right.end())
; 1560 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1561 : 
; 1562 : 			{	// element exists, try splice
; 1563 : 			const_iterator _Last = _First;
; 1564 : 			++_Last;
; 1565 : 			if (this != &_Right
; 1566 : 				|| (_Where != _First && _Where != _Last))
; 1567 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1568 : 			}
; 1569 : 		}
; 1570 : 
; 1571 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1572 : 		const_iterator _First)
; 1573 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1574 : 		splice(_Where, (_Myt&)_Right, _First);
; 1575 : 		}
; 1576 : 
; 1577 : 	void splice(const_iterator _Where,
; 1578 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1579 : 		{	// splice _Right [_First, _Last) at _Where
; 1580 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1581 : 			{	// worth splicing, do it
; 1582 : 			size_type _Count = 0;
; 1583 : 
; 1584 : 			if (this == &_Right)
; 1585 : 				;	// just rearrange this list
; 1586 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1587 : 				_Count = _Right._Mysize;	// splice in whole list
; 1588 : 			else
; 1589 : 				{	// count nodes and check for knot
; 1590 : 				const_iterator _Next = _First;
; 1591 : 
; 1592 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1593 : 					if (_Next == _Right.end())
; 1594 : 						_Xlength_error("list<T> bad splice");
; 1595 : 				}
; 1596 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1597 : 			}
; 1598 : 		}
; 1599 : 
; 1600 : 	void splice(const_iterator _Where,
; 1601 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1602 : 		{	// splice _Right [_First, _Last) at _Where
; 1603 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1604 : 		}
; 1605 : 
; 1606 : 	void remove(const _Ty& _Val)
; 1607 : 		{	// erase each element matching _Val
; 1608 : 		iterator _Val_it = end();
; 1609 : 
; 1610 : 		for (iterator _First = begin(); _First != end(); )
; 1611 : 			if (*_First == _Val)
; 1612 : 				if (_STD addressof(*_First) == _STD addressof(_Val))
; 1613 : 					_Val_it = _First++;
; 1614 : 				else
; 1615 : 					_First = erase(_First);
; 1616 : 			else
; 1617 : 				++_First;
; 1618 : 
; 1619 : 		if (_Val_it != end())
; 1620 : 			erase(_Val_it);
; 1621 : 		}
; 1622 : 
; 1623 : 	template<class _Pr1>
; 1624 : 		void remove_if(_Pr1 _Pred)
; 1625 : 		{	// erase each element satisfying _Pred
; 1626 : 		for (iterator _First = begin(); _First != end(); )
; 1627 : 			if (_Pred(*_First))
; 1628 : 				_First = erase(_First);
; 1629 : 			else
; 1630 : 				++_First;
; 1631 : 		}
; 1632 : 
; 1633 : 	void unique()
; 1634 : 		{	// erase each element matching previous
; 1635 : 		unique(equal_to<>());
; 1636 : 		}
; 1637 : 
; 1638 : 	template<class _Pr2>
; 1639 : 		void unique(_Pr2 _Pred)
; 1640 : 		{	// erase each element satisfying _Pred with previous
; 1641 : 		const _Nodeptr _Phead = this->_Myhead;
; 1642 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1643 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1644 : 
; 1645 : 		while (_Pnode != _Phead)
; 1646 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1647 : 				{	// match, remove it
; 1648 : 				const _Nodeptr _Perase = _Pnode;
; 1649 : 				_Pnode = this->_Nextnode(_Pnode);
; 1650 : 
; 1651 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1652 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1653 : 				this->_Freenode(_Perase);
; 1654 : 
; 1655 : 				--this->_Mysize;
; 1656 : 				}
; 1657 : 			else
; 1658 : 				{	// no match, advance
; 1659 : 				_Pprev = _Pnode;
; 1660 : 				_Pnode = this->_Nextnode(_Pnode);
; 1661 : 				}
; 1662 : 		}
; 1663 : 
; 1664 : 	void merge(_Myt& _Right)
; 1665 : 		{	// merge in elements from _Right, both ordered by operator<
; 1666 : 		merge(_Right, less<>());
; 1667 : 		}
; 1668 : 
; 1669 : 	void merge(_Myt&& _Right)
; 1670 : 		{	// merge in elements from _Right, both ordered by operator<
; 1671 : 		merge((_Myt&)_Right);
; 1672 : 		}
; 1673 : 
; 1674 : 	template<class _Pr2>
; 1675 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1676 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1677 : 		if (&_Right != this)
; 1678 : 			{	// safe to merge, do it
; 1679 : 			iterator _First1 = begin(), _Last1 = end();
; 1680 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1681 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1682 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1683 : 
; 1684 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1685 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1686 : 					{	// splice in an element from _Right
; 1687 : 					iterator _Mid2 = _First2;
; 1688 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1689 : 					_First2 = _Mid2;
; 1690 : 					}
; 1691 : 				else
; 1692 : 					++_First1;
; 1693 : 
; 1694 : 			if (_First2 != _Last2)
; 1695 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1696 : 					_Right._Mysize);	// splice remainder of _Right
; 1697 : 			}
; 1698 : 		}
; 1699 : 
; 1700 : 	template<class _Pr2>
; 1701 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1702 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1703 : 		merge((_Myt&)_Right, _Pred);
; 1704 : 		}
; 1705 : 
; 1706 : 	void sort()
; 1707 : 		{	// order sequence, using operator<
; 1708 : 		sort(less<>());
; 1709 : 		}
; 1710 : 
; 1711 : 	template<class _Pr2>
; 1712 : 		void sort(_Pr2 _Pred)
; 1713 : 		{	// order sequence, using _Pred
; 1714 : 		if (2 <= this->_Mysize)
; 1715 : 			{	// worth sorting, do it
; 1716 : 			const size_t _MAXBINS = 25;
; 1717 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1718 : 			size_t _Maxbin = 0;
; 1719 : 
; 1720 : 			while (!empty())
; 1721 : 				{	// sort another element, using bins
; 1722 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1723 : 					++begin(), 1);
; 1724 : 
; 1725 : 				size_t _Bin;
; 1726 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1727 : 					++_Bin)
; 1728 : 					{	// merge into ever larger bins
; 1729 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1730 : 					_Binlist[_Bin].swap(_Templist);
; 1731 : 					}
; 1732 : 
; 1733 : 				if (_Bin == _MAXBINS)
; 1734 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1735 : 				else
; 1736 : 					{	// spill to new bin, while they last
; 1737 : 					_Binlist[_Bin].swap(_Templist);
; 1738 : 					if (_Bin == _Maxbin)
; 1739 : 						++_Maxbin;
; 1740 : 					}
; 1741 : 				}
; 1742 : 
; 1743 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1744 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1745 : 					_Pred);	// merge up
; 1746 : 
; 1747 : 			_Analysis_assume_(0 < _Maxbin);
; 1748 : 
; 1749 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1750 : 			}
; 1751 : 		}
; 1752 : 
; 1753 : 	void reverse() _NOEXCEPT
; 1754 : 		{	// reverse sequence
; 1755 : 		const _Nodeptr _Phead = this->_Myhead;
; 1756 : 		_Nodeptr _Pnode = _Phead;
; 1757 : 
; 1758 : 		for (; ; )
; 1759 : 			{	// flip pointers in a node
; 1760 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1761 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1762 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1763 : 
; 1764 : 			if (_Pnext == _Phead)
; 1765 : 				break;
; 1766 : 			_Pnode = _Pnext;
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	void _Splice(const_iterator _Where,
; 1771 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1772 : 		size_type _Count)
; 1773 : 		{	// splice _Right [_First, _Last) before _Where
; 1774 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1775 : 		if (_Where._Getcont() != this)
; 1776 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1777 : 		if (this->_Getal() != _Right._Getal())
; 1778 : 			_DEBUG_ERROR("list containers incompatible for splice");
; 1779 : 
; 1780 : 		if (this != &_Right)
; 1781 : 			{	// transfer ownership
; 1782 : 			_Lockit _Lock(_LOCK_DEBUG);
; 1783 : 
; 1784 : 			const bool _One = _Count == 1;
; 1785 : 			const bool _All = _Count == _Right.size();
; 1786 : 			const bool _Some = !_One && !_All;
; 1787 : 
; 1788 : 			_Nodeptr _Oldprev = _First._Ptr->_Prev;
; 1789 : 
; 1790 : 			if (_Some)
; 1791 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1792 : 					_Ptr = _Ptr->_Next)
; 1793 : 					{	// mark _Prev pointers
; 1794 : 					_Ptr->_Prev = 0;
; 1795 : 					}
; 1796 : 
; 1797 : 			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();
; 1798 : 
; 1799 : 			if (_Pnext == 0)
; 1800 : 				_DEBUG_ERROR("list container corrupted");
; 1801 : 
; 1802 : 			while (*_Pnext != 0)
; 1803 : 				{	// check the iterator
; 1804 : 				const_iterator& _Iter = **_Pnext;
; 1805 : 
; 1806 : 				if ((_One && _Iter._Ptr == _First._Ptr)
; 1807 : 					|| (_All && _Iter._Ptr != _Right._Myhead)
; 1808 : 					|| (_Some && _Iter._Ptr->_Prev == 0))
; 1809 : 					{	// adopt the iterator
; 1810 : 					*_Pnext = (const_iterator *)_Iter._Mynextiter;
; 1811 : 					_Iter._Myproxy = this->_Myproxy;
; 1812 : 					_Iter._Mynextiter = this->_Myproxy->_Myfirstiter;
; 1813 : 					this->_Myproxy->_Myfirstiter = &_Iter;
; 1814 : 					}
; 1815 : 				else
; 1816 : 					{	// skip the iterator
; 1817 : 					_Pnext = (const_iterator **)_Iter._Getpnext();
; 1818 : 					}
; 1819 : 				}
; 1820 : 
; 1821 : 			if (_Some)
; 1822 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1823 : 					_Ptr = _Ptr->_Next)
; 1824 : 					{	// restore _Prev pointers
; 1825 : 					_Ptr->_Prev = _Oldprev;
; 1826 : 					_Oldprev = _Ptr;
; 1827 : 					}
; 1828 : 			}
; 1829 : 
; 1830 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1831 : 		if (this->_Getal() != _Right._Getal())
; 1832 : 			_XSTD terminate();
; 1833 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1834 : 
; 1835 : 		_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1836 : 		}
; 1837 : 
; 1838 : 	void _Splice_same(const_iterator _Where,
; 1839 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1840 : 		size_type _Count)
; 1841 : 		{	// splice _Right [_First, _Last) before _Where
; 1842 : 		if (this != &_Right)
; 1843 : 			{	// splicing from another list, adjust counts
; 1844 : 			_Incsize(_Count);
; 1845 : 			_Right._Mysize -= _Count;
; 1846 : 			}
; 1847 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1848 : 			_Last._Mynode();
; 1849 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1850 : 			_Where._Mynode();
; 1851 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1852 : 			_First._Mynode();
; 1853 : 
; 1854 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1855 : 		this->_Prevnode(_Where._Mynode()) =
; 1856 : 			this->_Prevnode(_Last._Mynode());
; 1857 : 		this->_Prevnode(_Last._Mynode()) =
; 1858 : 			this->_Prevnode(_First._Mynode());
; 1859 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1860 : 		}
; 1861 : 
; 1862 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1863 : 		_Unchecked_const_iterator _First,
; 1864 : 		_Unchecked_const_iterator _Last)
; 1865 : 		{	// splice [_First, _Last) before _Where
; 1866 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1867 : 			_Last._Mynode();
; 1868 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1869 : 			_Where._Mynode();
; 1870 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1871 : 			_First._Mynode();
; 1872 : 
; 1873 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1874 : 		this->_Prevnode(_Where._Mynode()) =
; 1875 : 			this->_Prevnode(_Last._Mynode());
; 1876 : 		this->_Prevnode(_Last._Mynode()) =
; 1877 : 			this->_Prevnode(_First._Mynode());
; 1878 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1879 : 		}
; 1880 : 
; 1881 : 	void _Tidy()
; 1882 : 		{	// free all storage
; 1883 : 		clear();
; 1884 : 		}
; 1885 : 
; 1886 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1887 : 		size_type _Count, const _Ty& _Val)
; 1888 : 		{	// insert _Count * _Val at _Where
; 1889 : 		size_type _Countsave = _Count;
; 1890 : 
; 1891 : 		_TRY_BEGIN
; 1892 : 		for (; 0 < _Count; --_Count)
; 1893 : 			_Insert(_Where, _Val);
; 1894 : 		_CATCH_ALL
; 1895 : 		for (; _Count < _Countsave; ++_Count)
; 1896 : 			{	// undo inserts
; 1897 : 			_Unchecked_const_iterator _Before = _Where;
; 1898 : 			_Unchecked_erase(--_Before);
; 1899 : 			}
; 1900 : 		_RERAISE;
; 1901 : 		_CATCH_END
; 1902 : 		}
; 1903 : 
; 1904 : 	void _Incsize(size_type _Count)
; 1905 : 		{	// alter element count, with checking
; 1906 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00018	b9 cb cc cc 0c	 mov	 ecx, 214748363		; 0ccccccbH
  0001d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00020	2b c8		 sub	 ecx, eax
  00022	83 f9 01	 cmp	 ecx, 1
  00025	72 12		 jb	 SHORT $LN30@Insert

; 1908 : 		this->_Mysize += _Count;

  00027	40		 inc	 eax
  00028	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;

  0002b	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  00033	89 10		 mov	 DWORD PTR [eax], edx

; 1066 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN30@Insert:

; 1907 : 			_Xlength_error("list<T> too long");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN32@Insert:
$LN29@Insert:
  00043	cc		 int	 3
??$_Insert@ABUSTextLine@CPythonEventManager@@@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@1@ABUSTextLine@CPythonEventManager@@@Z ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Insert<CPythonEventManager::STextLine const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z
_TEXT	SEGMENT
??$addressof@PAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z PROC ; std::addressof<CPythonEventManager::SEventSet *>, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@PAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z ENDP ; std::addressof<CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PAUSEventSet@CPythonEventManager@@@std@@YA$$QAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z
_TEXT	SEGMENT
??$forward@PAUSEventSet@CPythonEventManager@@@std@@YA$$QAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z PROC ; std::forward<CPythonEventManager::SEventSet *>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@PAUSEventSet@CPythonEventManager@@@std@@YA$$QAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z ENDP ; std::forward<CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@$$QAPAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@$$QAPAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@$$QAPAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@P6AXPAVCGraphicTextInstance@@@Z@std@@YAP6AXPAVCGraphicTextInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@P6AXPAVCGraphicTextInstance@@@Z@std@@YAP6AXPAVCGraphicTextInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >,void (__cdecl*)(CGraphicTextInstance *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@P6AXPAVCGraphicTextInstance@@@Z@std@@YAP6AXPAVCGraphicTextInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >,void (__cdecl*)(CGraphicTextInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVCGraphicTextInstance@@@std@@YAPBQAVCGraphicTextInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCGraphicTextInstance@@@std@@YAPBQAVCGraphicTextInstance@@ABQAV1@@Z PROC ; std::addressof<CGraphicTextInstance * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCGraphicTextInstance@@@std@@YAPBQAVCGraphicTextInstance@@ABQAV1@@Z ENDP ; std::addressof<CGraphicTextInstance * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicTextInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicTextInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicTextInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCGraphicTextInstance@@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCGraphicTextInstance@@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::destroy<CGraphicTextInstance *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCGraphicTextInstance@@@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::destroy<CGraphicTextInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<CPythonEventManager::STextLine,void *> *>, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<CPythonEventManager::STextLine,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<std::_List_node<CPythonEventManager::STextLine,void *> *>, COMDAT
; _this$dead$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<std::_List_node<CPythonEventManager::STextLine,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@USTextLine@CPythonEventManager@@@std@@YAPAUSTextLine@CPythonEventManager@@AAU12@@Z
_TEXT	SEGMENT
??$addressof@USTextLine@CPythonEventManager@@@std@@YAPAUSTextLine@CPythonEventManager@@AAU12@@Z PROC ; std::addressof<CPythonEventManager::STextLine>, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@USTextLine@CPythonEventManager@@@std@@YAPAUSTextLine@CPythonEventManager@@AAU12@@Z ENDP ; std::addressof<CPythonEventManager::STextLine>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USTextLine@CPythonEventManager@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@USTextLine@CPythonEventManager@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<CPythonEventManager::STextLine>, COMDAT
; _this$dead$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@USTextLine@CPythonEventManager@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<CPythonEventManager::STextLine>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@QAUSEventSet@CPythonEventManager@@@std@@YAPBQAUSEventSet@CPythonEventManager@@ABQAU12@@Z
_TEXT	SEGMENT
??$addressof@QAUSEventSet@CPythonEventManager@@@std@@YAPBQAUSEventSet@CPythonEventManager@@ABQAU12@@Z PROC ; std::addressof<CPythonEventManager::SEventSet * const>, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@QAUSEventSet@CPythonEventManager@@@std@@YAPBQAUSEventSet@CPythonEventManager@@ABQAU12@@Z ENDP ; std::addressof<CPythonEventManager::SEventSet * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@AAPAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@AAPAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * &>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@AAPAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUSEventSet@CPythonEventManager@@ABQAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@ABQAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUSEventSet@CPythonEventManager@@ABQAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@ABQAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * const &>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAUSEventSet@CPythonEventManager@@ABQAU12@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@ABQAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAUSEventSet@CPythonEventManager@@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAUSEventSet@CPythonEventManager@@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@@Z PROC ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::destroy<CPythonEventManager::SEventSet *>, COMDAT
; _this$dead$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAUSEventSet@CPythonEventManager@@@?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> >::destroy<CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@P6AXPAUSEventSet@CPythonEventManager@@@Z@std@@YAP6AXPAUSEventSet@CPythonEventManager@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@P6AXPAUSEventSet@CPythonEventManager@@@Z@std@@YAP6AXPAUSEventSet@CPythonEventManager@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >,void (__cdecl*)(CPythonEventManager::SEventSet *)>, COMDAT
; __Func$dead$ = ecx

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 12		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@USEventSet@CPythonEventManager@@@@KAXPAUSEventSet@CPythonEventManager@@@Z ; CDynamicPool<CPythonEventManager::SEventSet>::Delete
  00029	47		 inc	 edi
  0002a	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b fb		 cmp	 edi, ebx
  00032	75 ee		 jne	 SHORT $LL13@for_each
$LN22@for_each:
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 34   : 
; 35   : 	return (_STD move(_Func));

  00036	b8 00 00 00 00	 mov	 eax, OFFSET ?Delete@?$CDynamicPool@USEventSet@CPythonEventManager@@@@KAXPAUSEventSet@CPythonEventManager@@@Z ; CDynamicPool<CPythonEventManager::SEventSet>::Delete
  0003b	5b		 pop	 ebx

; 36   : 	}

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@P6AXPAUSEventSet@CPythonEventManager@@@Z@std@@YAP6AXPAUSEventSet@CPythonEventManager@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >,void (__cdecl*)(CPythonEventManager::SEventSet *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@AAU10@@Z PROC ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@AAU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAPAPAU?$_List_node@USArgumet@script@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAPAPAU?$_List_node@USArgumet@script@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<script::SArgumet,void *> *>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAPAPAU?$_List_node@USArgumet@script@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<script::SArgumet,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<std::_List_node<script::SArgumet,void *> *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<std::_List_node<script::SArgumet,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@USArgumet@script@@@std@@YAPAUSArgumet@script@@AAU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@USArgumet@script@@@std@@YAPAUSArgumet@script@@AAU12@@Z PROC ; std::addressof<script::SArgumet>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@USArgumet@script@@@std@@YAPAUSArgumet@script@@AAU12@@Z ENDP ; std::addressof<script::SArgumet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USArgumet@script@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAUSArgumet@script@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@USArgumet@script@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAUSArgumet@script@@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<script::SArgumet>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00007	83 7e 2c 10	 cmp	 DWORD PTR [esi+44], 16	; 00000010H
  0000b	72 0b		 jb	 SHORT $LN32@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 76 18	 push	 DWORD PTR [esi+24]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN32@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00018	c7 46 2c 0f 00
	00 00		 mov	 DWORD PTR [esi+44], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001f	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00026	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0002a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0002e	72 0a		 jb	 SHORT $LN64@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00030	ff 36		 push	 DWORD PTR [esi]
  00032	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00037	83 c4 04	 add	 esp, 4
$LN64@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00041	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00048	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004b	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 880  : 		}

  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??$destroy@USArgumet@script@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAUSArgumet@script@@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<script::SArgumet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z PROC ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>, COMDAT
; __Val$ = ecx

; 58   : 		{	// extract key from element value
; 59   : 		return (_Val.first);

  00000	8b c1		 mov	 eax, ecx

; 60   : 		}

  00002	c3		 ret	 0
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z ENDP ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>, COMDAT
; _this$dead$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAUSEventSet@CPythonEventManager@@@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEPAPAUSEventSet@CPythonEventManager@@PAPAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAUSEventSet@CPythonEventManager@@@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEPAPAUSEventSet@CPythonEventManager@@PAPAU23@00@Z PROC ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Umove<CPythonEventManager::SEventSet * *>, COMDAT
; _this$dead$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAUSEventSet@CPythonEventManager@@@?$vector@PAUSEventSet@CPythonEventManager@@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@IAEPAPAUSEventSet@CPythonEventManager@@PAPAU23@00@Z ENDP ; std::vector<CPythonEventManager::SEventSet *,std::allocator<CPythonEventManager::SEventSet *> >::_Umove<CPythonEventManager::SEventSet * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEPAPAVCGraphicTextInstance@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEPAPAVCGraphicTextInstance@@PAPAV2@00@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Umove<CGraphicTextInstance * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEPAPAVCGraphicTextInstance@@PAPAV2@00@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Umove<CGraphicTextInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT
; _this$dead$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000b	72 0a		 jb	 SHORT $LN32@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
$LN32@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00017	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 880  : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::construct<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<script::SArgumet,void *> > >::construct<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<std::_List_node<CPythonEventManager::STextLine,void *> *,std::_List_node<CPythonEventManager::STextLine,void *> * &>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<std::_List_node<CPythonEventManager::STextLine,void *> *,std::_List_node<CPythonEventManager::STextLine,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@IPAPAU12@@Z
_TEXT	SEGMENT
??$_Allocate@PAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@IPAPAU12@@Z PROC ; std::_Allocate<CPythonEventManager::SEventSet *>, COMDAT
; __Count$ = ecx

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00006	77 14		 ja	 SHORT $LN1@Allocate
  00008	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	83 c4 04	 add	 esp, 4
  00018	85 c0		 test	 eax, eax
  0001a	75 05		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0001c	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00021	c3		 ret	 0
??$_Allocate@PAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@IPAPAU12@@Z ENDP ; std::_Allocate<CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@IPAPAV1@@Z PROC ; std::_Allocate<CGraphicTextInstance *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@IPAPAV1@@Z ENDP ; std::_Allocate<CGraphicTextInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_List_node@USArgumet@script@@PAX@std@@@std@@YAPAU?$_List_node@USArgumet@script@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$_List_node@USArgumet@script@@PAX@std@@@std@@YAPAU?$_List_node@USArgumet@script@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_List_node<script::SArgumet,void *> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 26		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	81 f9 24 49 92
	04		 cmp	 ecx, 76695844		; 04924924H
  00012	77 19		 ja	 SHORT $LN1@Allocate
  00014	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 e0 03	 shl	 eax, 3
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002d	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$_Allocate@U?$_List_node@USArgumet@script@@PAX@std@@@std@@YAPAU?$_List_node@USArgumet@script@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_List_node<script::SArgumet,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
??$_Allocate@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_List_node<CPythonEventManager::STextLine,void *> >, COMDAT
; __Count$ = ecx

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	81 f9 cc cc cc
	0c		 cmp	 ecx, 214748364		; 0cccccccH
  00006	77 13		 ja	 SHORT $LN1@Allocate
  00008	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0000b	c1 e0 02	 shl	 eax, 2
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	75 05		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0001b	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00020	c3		 ret	 0
??$_Allocate@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_List_node<CPythonEventManager::STextLine,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
??$_Allocate@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >, COMDAT
; __Count$ = ecx

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	81 f9 5d 74 d1
	05		 cmp	 ecx, 97612893		; 05d1745dH
  00006	77 10		 ja	 SHORT $LN1@Allocate
  00008	6b c1 2c	 imul	 eax, ecx, 44
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4
  00014	85 c0		 test	 eax, eax
  00016	75 05		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00018	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  0001d	c3		 ret	 0
??$_Allocate@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Incsize@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?_Incsize@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXI@Z PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Incsize, COMDAT
; _this$ = ecx

; 1906 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 cb cc cc 0c	 mov	 eax, 214748363		; 0ccccccbH
  00008	2b c2		 sub	 eax, edx
  0000a	83 f8 01	 cmp	 eax, 1
  0000d	72 09		 jb	 SHORT $LN15@Incsize

; 1908 : 		this->_Mysize += _Count;

  0000f	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00012	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1909 : 		}

  00015	c2 04 00	 ret	 4
$LN15@Incsize:

; 1907 : 			_Xlength_error("list<T> too long");

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0001d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN17@Incsize:
$LN14@Incsize:
  00022	cc		 int	 3
?_Incsize@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEXI@Z ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Incsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 96   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 97   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USTextLine@CPythonEventManager@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CPythonEventManager::STextLine> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ?max_size@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QBEIXZ PROC ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::max_size, COMDAT
; _this$dead$ = ecx

; 1241 : 		return (this->_Getal().max_size());

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 1242 : 		}

  00005	c3		 ret	 0
?max_size@?$list@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QBEIXZ ENDP ; std::list<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::max_size, COMDAT
; _this$dead$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 735  : 		return (_Al.max_size());

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::max_size, COMDAT
; _this$dead$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$$VPAPAX@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__This_arg$ = 8						; size = 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$$VPAPAX@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void * *>, COMDAT
; _this$ = ecx

; 233  : 		{	// construct from one or more moved elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   : 		{	// construct with argument

  00003	8b 45 08	 mov	 eax, DWORD PTR __This_arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 234  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$$VPAPAX@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,void * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z PROC ; std::forward<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&> >, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z ENDP ; std::forward<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
_<_Val_0>$dead$ = 8					; size = 4
_<_Val_1>$ = 12						; size = 4
_<_Val_2>$dead$ = 16					; size = 4
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();

  00005	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode0
  0000a	8b f0		 mov	 esi, eax

; 604  : 		return ((reference)_Pnode->_Myval);

  0000c	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]

; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;

  0000f	66 c7 46 0c 00
	00		 mov	 WORD PTR [esi+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00015	85 ff		 test	 edi, edi
  00017	74 15		 je	 SHORT $LN42@Buynode
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_1>$[ebp]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0001c	ff 31		 push	 DWORD PTR [ecx]
  0001e	8b cf		 mov	 ecx, edi
  00020	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00025	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 939  : 		return (_Pnode);

  0002c	8b c6		 mov	 eax, esi
$LN42@Buynode:

; 940  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 8
__Next$ = -24						; size = 4
$T3 = -17						; size = 1
$T4 = -17						; size = 1
$T5 = -17						; size = 1
$T6 = -17						; size = 1
$T7 = -17						; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_hint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>, COMDAT
; _this$ = ecx

; 1661 : 		iterator _Insert_hint(const_iterator _Where,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx

; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN

  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)

  00034	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00038	75 27		 jne	 SHORT $LN33@Insert_hin

; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree

  0003a	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0003d	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00040	51		 push	 ecx
  00041	ff 33		 push	 DWORD PTR [ebx]
  00043	6a 01		 push	 1
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
  0004b	8b c6		 mov	 eax, esi

; 1773 : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 10 00	 ret	 16			; 00000010H
$LN33@Insert_hin:

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00061	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00063	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00066	3b 01		 cmp	 eax, DWORD PTR [ecx]

; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())

  00068	75 51		 jne	 SHORT $LN14@Insert_hin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

  0006a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  0006d	83 c0 10	 add	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00070	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00074	72 02		 jb	 SHORT $LN286@Insert_hin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00076	8b 00		 mov	 eax, DWORD PTR [eax]
$LN286@Insert_hin:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));

  00078	51		 push	 ecx
  00079	50		 push	 eax
  0007a	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0007d	8b c8		 mov	 ecx, eax
  0007f	ff 70 10	 push	 DWORD PTR [eax+16]
  00082	6a 00		 push	 0
  00084	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);
; 2490 : 	}
; 2491 : 
; 2492 : template<class _Elem,
; 2493 : 	class _Traits,
; 2494 : 	class _Alloc> inline
; 2495 : 	bool operator!=(
; 2496 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2497 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2498 : 	{	// test for string inequality
; 2499 : 	return (!(_Left == _Right));
; 2500 : 	}
; 2501 : 
; 2502 : template<class _Elem,
; 2503 : 	class _Traits,
; 2504 : 	class _Alloc> inline
; 2505 : 	bool operator!=(
; 2506 : 		const _Elem *_Left,
; 2507 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2508 : 	{	// test for NTCS vs. string inequality
; 2509 : 	return (!(_Left == _Right));
; 2510 : 	}
; 2511 : 
; 2512 : template<class _Elem,
; 2513 : 	class _Traits,
; 2514 : 	class _Alloc> inline
; 2515 : 	bool operator!=(
; 2516 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2517 : 		const _Elem *_Right)
; 2518 : 	{	// test for string vs. NTCS inequality
; 2519 : 	return (!(_Left == _Right));
; 2520 : 	}
; 2521 : 
; 2522 : template<class _Elem,
; 2523 : 	class _Traits,
; 2524 : 	class _Alloc> inline
; 2525 : 	bool operator<(
; 2526 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2527 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2528 : 	{	// test if string < string
; 2529 : 	return (_Left.compare(_Right) < 0);

  00089	85 c0		 test	 eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  0008b	0f 89 84 01 00
	00		 jns	 $LN1@Insert_hin

; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));

  00091	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00094	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00097	51		 push	 ecx
  00098	ff 75 0c	 push	 DWORD PTR __Where$[ebp]
  0009b	8b cb		 mov	 ecx, ebx
  0009d	6a 01		 push	 1
  0009f	56		 push	 esi
  000a0	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
  000a5	8b c6		 mov	 eax, esi

; 1773 : 		}

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 10 00	 ret	 16			; 00000010H
$LN14@Insert_hin:

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  000bb	3b c1		 cmp	 eax, ecx

; 1731 : 				}
; 1732 : 			else if (_Where == end())

  000bd	75 46		 jne	 SHORT $LN11@Insert_hin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  000bf	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  000c2	8d 4d ef	 lea	 ecx, DWORD PTR $T7[ebp]
  000c5	ff 75 10	 push	 DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  000c8	83 c0 10	 add	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  000d1	84 c0		 test	 al, al
  000d3	0f 84 3c 01 00
	00		 je	 $LN1@Insert_hin

; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));

  000d9	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000dc	8b 03		 mov	 eax, DWORD PTR [ebx]
  000de	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000e1	51		 push	 ecx
  000e2	8b cb		 mov	 ecx, ebx
  000e4	ff 70 08	 push	 DWORD PTR [eax+8]
  000e7	6a 00		 push	 0
  000e9	56		 push	 esi
  000ea	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
  000ef	8b c6		 mov	 eax, esi

; 1773 : 		}

  000f1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fb	59		 pop	 ecx
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 10 00	 ret	 16			; 00000010H
$LN11@Insert_hin:

; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  00105	8b 7d 10	 mov	 edi, DWORD PTR __Val$[ebp]
  00108	8d 4d ef	 lea	 ecx, DWORD PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  0010b	83 c0 10	 add	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  0010e	50		 push	 eax
  0010f	57		 push	 edi
  00110	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  00115	84 c0		 test	 al, al
  00117	74 77		 je	 SHORT $LN8@Insert_hin
  00119	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  0011c	8d 4d e8	 lea	 ecx, DWORD PTR __Next$[ebp]

; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  0011f	89 45 e8	 mov	 DWORD PTR __Next$[ebp], eax

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  00122	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator--
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  00127	8b 75 e8	 mov	 esi, DWORD PTR __Next$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  0012a	8d 4d ef	 lea	 ecx, DWORD PTR $T5[ebp]
  0012d	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  0012e	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  00137	84 c0		 test	 al, al
  00139	74 55		 je	 SHORT $LN8@Insert_hin

; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  0013b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));

  0013e	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00141	51		 push	 ecx
  00142	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00146	8b cb		 mov	 ecx, ebx
  00148	74 22		 je	 SHORT $LN7@Insert_hin
$LN441@Insert_hin:
  0014a	56		 push	 esi
  0014b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0014e	6a 00		 push	 0
  00150	56		 push	 esi
  00151	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
  00156	8b c6		 mov	 eax, esi

; 1773 : 		}

  00158	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0015b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00162	59		 pop	 ecx
  00163	5f		 pop	 edi
  00164	5e		 pop	 esi
  00165	5b		 pop	 ebx
  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c2 10 00	 ret	 16			; 00000010H
$LN7@Insert_hin:

; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));

  0016c	ff 75 0c	 push	 DWORD PTR __Where$[ebp]
  0016f	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00172	6a 01		 push	 1
  00174	56		 push	 esi
  00175	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
  0017a	8b c6		 mov	 eax, esi

; 1773 : 		}

  0017c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0017f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00186	59		 pop	 ecx
  00187	5f		 pop	 edi
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx
  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c2 10 00	 ret	 16			; 00000010H
$LN8@Insert_hin:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  00190	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  00193	8d 4d ef	 lea	 ecx, DWORD PTR $T4[ebp]
  00196	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  00197	83 c0 10	 add	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  001a0	84 c0		 test	 al, al
  001a2	74 71		 je	 SHORT $LN1@Insert_hin
  001a4	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]

; 271  : 		++(*(_Mybase *)this);

  001a7	8d 4d e8	 lea	 ecx, DWORD PTR __Next$[ebp]

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  001aa	89 75 e8	 mov	 DWORD PTR __Next$[ebp], esi

; 271  : 		++(*(_Mybase *)this);

  001ad	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator++

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  001b2	8b 7d e8	 mov	 edi, DWORD PTR __Next$[ebp]
  001b5	3b 3b		 cmp	 edi, DWORD PTR [ebx]

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  001b7	74 16		 je	 SHORT $LN3@Insert_hin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  001b9	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  001bc	50		 push	 eax
  001bd	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  001c0	8d 4d ef	 lea	 ecx, DWORD PTR $T3[ebp]
  001c3	e8 00 00 00 00	 call	 ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
  001c8	84 c0		 test	 al, al
  001ca	74 49		 je	 SHORT $LN1@Insert_hin
  001cc	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
$LN3@Insert_hin:

; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  001cf	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));

  001d2	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  001d5	51		 push	 ecx
  001d6	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001da	8b cb		 mov	 ecx, ebx
  001dc	0f 85 68 ff ff
	ff		 jne	 $LN441@Insert_hin

; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));

  001e2	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  001e5	57		 push	 edi
  001e6	6a 01		 push	 1
  001e8	56		 push	 esi
  001e9	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
  001ee	8b c6		 mov	 eax, esi

; 1773 : 		}

  001f0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001f3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001fa	59		 pop	 ecx
  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
  001fe	8b e5		 mov	 esp, ebp
  00200	5d		 pop	 ebp
  00201	c2 10 00	 ret	 16			; 00000010H
__catch$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z$0:

; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);

  00204	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00207	e8 00 00 00 00	 call	 ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Destroy_if_not_nil

; 1768 : 		_RERAISE;

  0020c	6a 00		 push	 0
  0020e	6a 00		 push	 0
  00210	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN442@Insert_hin:
$LN1@Insert_hin:

; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);

  00215	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00218	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  0021b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00222	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00225	51		 push	 ecx
  00226	50		 push	 eax
  00227	8b cb		 mov	 ecx, ebx
  00229	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
  0022e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00230	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00233	89 08		 mov	 DWORD PTR [eax], ecx

; 1773 : 		}

  00235	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00238	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0023f	59		 pop	 ecx
  00240	5f		 pop	 edi
  00241	5e		 pop	 esi
  00242	5b		 pop	 ebx
  00243	8b e5		 mov	 esp, ebp
  00245	5d		 pop	 ebp
  00246	c2 10 00	 ret	 16			; 00000010H
$LN440@Insert_hin:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_hint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_hint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABUSTextLine@CPythonEventManager@@@std@@YAABUSTextLine@CPythonEventManager@@ABU12@@Z
_TEXT	SEGMENT
??$forward@ABUSTextLine@CPythonEventManager@@@std@@YAABUSTextLine@CPythonEventManager@@ABU12@@Z PROC ; std::forward<CPythonEventManager::STextLine const &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@ABUSTextLine@CPythonEventManager@@@std@@YAABUSTextLine@CPythonEventManager@@ABU12@@Z ENDP ; std::forward<CPythonEventManager::STextLine const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list
;	COMDAT ??$_Buynode@ABUSTextLine@CPythonEventManager@@@?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PAU21@0ABUSTextLine@CPythonEventManager@@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$_Buynode@ABUSTextLine@CPythonEventManager@@@?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PAU21@0ABUSTextLine@CPythonEventManager@@@Z PROC ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Buynode<CPythonEventManager::STextLine const &>, COMDAT
; _this$dead$ = ecx

; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

  00003	ff 75 0c	 push	 DWORD PTR __Prev$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Next$[ebp]
  00009	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> > >::_Buynode0

; 543  : 		return ((reference)_Pnode->_Myval);

  0000e	8d 50 08	 lea	 edx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00011	85 d2		 test	 edx, edx
  00013	74 11		 je	 SHORT $LN26@Buynode
  00015	8b 4d 10	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
  00018	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  0001c	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00020	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00023	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN26@Buynode:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\list

; 842  : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Buynode@ABUSTextLine@CPythonEventManager@@@?$_List_buy@USTextLine@CPythonEventManager@@V?$allocator@USTextLine@CPythonEventManager@@@std@@@std@@QAEPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@PAU21@0ABUSTextLine@CPythonEventManager@@@Z ENDP ; std::_List_buy<CPythonEventManager::STextLine,std::allocator<CPythonEventManager::STextLine> >::_Buynode<CPythonEventManager::STextLine const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@$$QAPAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@$$QAPAU34@@Z PROC ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 07		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 02		 mov	 DWORD PTR [edx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@$$QAPAU34@@Z ENDP ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCGraphicTextInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCGraphicTextInstance@@0AAP6AXPAV1@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCGraphicTextInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCGraphicTextInstance@@0AAP6AXPAV1@@Z@Z PROC ; std::_For_each<CGraphicTextInstance * *,void (__cdecl*)(CGraphicTextInstance *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCGraphicTextInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCGraphicTextInstance@@0AAP6AXPAV1@@Z@Z ENDP ; std::_For_each<CGraphicTextInstance * *,void (__cdecl*)(CGraphicTextInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCGraphicTextInstance@@@Z@std@@YA$$QAP6AXPAVCGraphicTextInstance@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCGraphicTextInstance@@@Z@std@@YA$$QAP6AXPAVCGraphicTextInstance@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(CGraphicTextInstance *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCGraphicTextInstance@@@Z@std@@YA$$QAP6AXPAVCGraphicTextInstance@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(CGraphicTextInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCGraphicTextInstance@@@std@@YAAAPAVCGraphicTextInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCGraphicTextInstance@@@std@@YAAAPAVCGraphicTextInstance@@AAPAV1@@Z PROC ; std::forward<CGraphicTextInstance * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCGraphicTextInstance@@@std@@YAAAPAVCGraphicTextInstance@@AAPAV1@@Z ENDP ; std::forward<CGraphicTextInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCGraphicTextInstance@@@std@@YAABQAVCGraphicTextInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCGraphicTextInstance@@@std@@YAABQAVCGraphicTextInstance@@ABQAV1@@Z PROC ; std::forward<CGraphicTextInstance * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCGraphicTextInstance@@@std@@YAABQAVCGraphicTextInstance@@ABQAV1@@Z ENDP ; std::forward<CGraphicTextInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicTextInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCGraphicTextInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCGraphicTextInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::construct<CGraphicTextInstance *,CGraphicTextInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCGraphicTextInstance@@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVCGraphicTextInstance@@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@@Z PROC ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::destroy<CGraphicTextInstance *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAVCGraphicTextInstance@@@?$allocator_traits@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicTextInstance@@@1@PAPAVCGraphicTextInstance@@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicTextInstance *> >::destroy<CGraphicTextInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z
_TEXT	SEGMENT
??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<std::_List_node<CPythonEventManager::STextLine,void *> *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<std::_List_node<CPythonEventManager::STextLine,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USTextLine@CPythonEventManager@@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAUSTextLine@CPythonEventManager@@@Z
_TEXT	SEGMENT
??$destroy@USTextLine@CPythonEventManager@@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAUSTextLine@CPythonEventManager@@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<CPythonEventManager::STextLine>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@USTextLine@CPythonEventManager@@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAUSTextLine@CPythonEventManager@@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::destroy<CPythonEventManager::STextLine>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAUSEventSet@CPythonEventManager@@@std@@YAAAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z
_TEXT	SEGMENT
??$forward@AAPAUSEventSet@CPythonEventManager@@@std@@YAAAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z PROC ; std::forward<CPythonEventManager::SEventSet * &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAPAUSEventSet@CPythonEventManager@@@std@@YAAAPAUSEventSet@CPythonEventManager@@AAPAU12@@Z ENDP ; std::forward<CPythonEventManager::SEventSet * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@AAPAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@AAPAU34@@Z PROC ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 07		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 02		 mov	 DWORD PTR [edx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@AAPAU34@@Z ENDP ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAUSEventSet@CPythonEventManager@@@std@@YAABQAUSEventSet@CPythonEventManager@@ABQAU12@@Z
_TEXT	SEGMENT
??$forward@ABQAUSEventSet@CPythonEventManager@@@std@@YAABQAUSEventSet@CPythonEventManager@@ABQAU12@@Z PROC ; std::forward<CPythonEventManager::SEventSet * const &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@ABQAUSEventSet@CPythonEventManager@@@std@@YAABQAUSEventSet@CPythonEventManager@@ABQAU12@@Z ENDP ; std::forward<CPythonEventManager::SEventSet * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUSEventSet@CPythonEventManager@@ABQAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@ABQAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAUSEventSet@CPythonEventManager@@ABQAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@ABQAU34@@Z PROC ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	85 d2		 test	 edx, edx
  00005	74 07		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 02		 mov	 DWORD PTR [edx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$construct@PAUSEventSet@CPythonEventManager@@ABQAU12@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@ABQAU34@@Z ENDP ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAUSEventSet@CPythonEventManager@@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@@Z
_TEXT	SEGMENT
??$destroy@PAUSEventSet@CPythonEventManager@@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@@Z PROC ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::destroy<CPythonEventManager::SEventSet *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAUSEventSet@CPythonEventManager@@@?$allocator_traits@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@SAXAAV?$allocator@PAUSEventSet@CPythonEventManager@@@1@PAPAUSEventSet@CPythonEventManager@@@Z ENDP ; std::allocator_traits<std::allocator<CPythonEventManager::SEventSet *> >::destroy<CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAUSEventSet@CPythonEventManager@@PAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSEventSet@CPythonEventManager@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAUSEventSet@CPythonEventManager@@PAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSEventSet@CPythonEventManager@@0@Z PROC ; std::_Ptr_cat<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAUSEventSet@CPythonEventManager@@PAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSEventSet@CPythonEventManager@@0@Z ENDP ; std::_Ptr_cat<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAUSEventSet@CPythonEventManager@@P6AXPAU12@@Z@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAP6AXPAU12@@Z@Z
_TEXT	SEGMENT
__Func$ = 8						; size = 4
??$_For_each@PAPAUSEventSet@CPythonEventManager@@P6AXPAU12@@Z@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAP6AXPAU12@@Z@Z PROC ; std::_For_each<CPythonEventManager::SEventSet * *,void (__cdecl*)(CPythonEventManager::SEventSet *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b da		 mov	 ebx, edx
  00009	2b de		 sub	 ebx, esi
  0000b	33 c0		 xor	 eax, eax
  0000d	83 c3 03	 add	 ebx, 3
  00010	c1 eb 02	 shr	 ebx, 2
  00013	57		 push	 edi
  00014	33 ff		 xor	 edi, edi
  00016	3b f2		 cmp	 esi, edx
  00018	0f 47 d8	 cmova	 ebx, eax

; 23   : 	for (; _First != _Last; ++_First)

  0001b	85 db		 test	 ebx, ebx
  0001d	74 15		 je	 SHORT $LN1@For_each
  0001f	90		 npad	 1
$LL3@For_each:

; 24   : 		_Func(*_First);

  00020	8b 45 08	 mov	 eax, DWORD PTR __Func$[ebp]
  00023	ff 36		 push	 DWORD PTR [esi]
  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	ff d0		 call	 eax
  00029	47		 inc	 edi
  0002a	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b fb		 cmp	 edi, ebx
  00032	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 25   : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_For_each@PAPAUSEventSet@CPythonEventManager@@P6AXPAU12@@Z@std@@YAXPAPAUSEventSet@CPythonEventManager@@0AAP6AXPAU12@@Z@Z ENDP ; std::_For_each<CPythonEventManager::SEventSet * *,void (__cdecl*)(CPythonEventManager::SEventSet *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAUSEventSet@CPythonEventManager@@@Z@std@@YA$$QAP6AXPAUSEventSet@CPythonEventManager@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
??$move@AAP6AXPAUSEventSet@CPythonEventManager@@@Z@std@@YA$$QAP6AXPAUSEventSet@CPythonEventManager@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(CPythonEventManager::SEventSet *)>, COMDAT
; __Arg$ = ecx

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1521 : 	}

  00002	c3		 ret	 0
??$move@AAP6AXPAUSEventSet@CPythonEventManager@@@Z@std@@YA$$QAP6AXPAUSEventSet@CPythonEventManager@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(CPythonEventManager::SEventSet *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAPAU?$_List_node@USArgumet@script@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAPAU?$_List_node@USArgumet@script@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<std::_List_node<script::SArgumet,void *> *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAPAU?$_List_node@USArgumet@script@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<std::_List_node<script::SArgumet,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USArgumet@script@@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAUSArgumet@script@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@USArgumet@script@@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAUSArgumet@script@@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<script::SArgumet>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00007	83 7e 2c 10	 cmp	 DWORD PTR [esi+44], 16	; 00000010H
  0000b	72 0b		 jb	 SHORT $LN30@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 76 18	 push	 DWORD PTR [esi+24]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN30@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00018	c7 46 2c 0f 00
	00 00		 mov	 DWORD PTR [esi+44], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001f	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00026	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0002a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0002e	72 0a		 jb	 SHORT $LN62@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00030	ff 36		 push	 DWORD PTR [esi]
  00032	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00037	83 c4 04	 add	 esp, 4
$LN62@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00041	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00048	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004b	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 731  : 		}

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$destroy@USArgumet@script@@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAUSArgumet@script@@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<script::SArgumet,void *> > >::destroy<script::SArgumet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
_TEXT	SEGMENT
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUSEventSet@CPythonEventManager@@PAPAU12@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAUSEventSet@CPythonEventManager@@PAPAU12@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CPythonEventManager::SEventSet * *,CPythonEventManager::SEventSet * *,std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	2b d1		 sub	 edx, ecx
  00005	c1 fa 02	 sar	 edx, 2
  00008	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00009	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]
  00010	56		 push	 esi
  00011	51		 push	 ecx
  00012	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	03 c6		 add	 eax, esi
  0001f	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninitialized_move@PAPAUSEventSet@CPythonEventManager@@PAPAU12@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CPythonEventManager::SEventSet * *,CPythonEventManager::SEventSet * *,std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCGraphicTextInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCGraphicTextInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicTextInstance * *,CGraphicTextInstance * *,std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCGraphicTextInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicTextInstance * *,CGraphicTextInstance * *,std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00003	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00007	72 0a		 jb	 SHORT $LN30@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$LN30@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00013	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00021	c6 06 00	 mov	 BYTE PTR [esi], 0
  00024	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 731  : 		}

  00025	c3		 ret	 0
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAAAPAU?$_List_node@USArgumet@script@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAAAPAU?$_List_node@USArgumet@script@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<script::SArgumet,void *> * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAAAPAU?$_List_node@USArgumet@script@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<script::SArgumet,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<script::SArgumet,void *> > >::construct<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<script::SArgumet,void *> > >::construct<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<CPythonEventManager::STextLine,void *> * &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@YAAAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<CPythonEventManager::STextLine,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<std::_List_node<CPythonEventManager::STextLine,void *> *,std::_List_node<CPythonEventManager::STextLine,void *> * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 07		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 02		 mov	 DWORD PTR [edx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<std::_List_node<CPythonEventManager::STextLine,void *> *,std::_List_node<CPythonEventManager::STextLine,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 07		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 02		 mov	 DWORD PTR [edx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@ABQAV3@@Z PROC ; std::allocator<CGraphicTextInstance *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@ABQAV3@@Z ENDP ; std::allocator<CGraphicTextInstance *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::size, COMDAT
; _this$ = ecx

; 1272 : 		return (this->_Mysize);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1273 : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$dead$ = ecx

; 1648 : 		{	// node exists, destroy it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 604  : 		return ((reference)_Pnode->_Myval);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newnode$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00007	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0000b	72 0b		 jb	 SHORT $LN40@Destroy_if
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 76 10	 push	 DWORD PTR [esi+16]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN40@Destroy_if:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00018	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001f	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00026	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00027	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0002b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00030	83 c4 04	 add	 esp, 4
  00033	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1653 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ PROC ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode0, COMDAT
; _this$ = ecx

; 893  : 		{	// allocate a non-value node

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00001	6a 2c		 push	 44			; 0000002cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 893  : 		{	// allocate a non-value node

  00003	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	8b d0		 mov	 edx, eax
  0000c	83 c4 04	 add	 esp, 4
  0000f	85 d2		 test	 edx, edx
  00011	74 1e		 je	 SHORT $LN96@Buynode0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00015	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00018	89 02		 mov	 DWORD PTR [edx], eax
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 04		 je	 SHORT $LN61@Buynode0
  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	89 01		 mov	 DWORD PTR [ecx], eax
$LN61@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00022	8d 4a 08	 lea	 ecx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00025	85 c9		 test	 ecx, ecx
  00027	74 04		 je	 SHORT $LN83@Buynode0
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 908  : 		return (_Pnode);

  0002d	8b c2		 mov	 eax, edx
  0002f	5e		 pop	 esi

; 909  : 		}

  00030	c3		 ret	 0
$LN96@Buynode0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN98@Buynode0:
$LN95@Buynode0:
  00036	cc		 int	 3
?_Buynode0@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@XZ ENDP ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z PROC ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Freenode0, COMDAT
; _this$dead$ = ecx

; 912  : 		{	// free non-value node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 920  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freenode0@?$_Tree_buy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ENDP ; std::_Tree_buy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@ABQAU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@ABQAU34@@Z PROC ; std::allocator<CPythonEventManager::SEventSet *>::construct, COMDAT
; _this$dead$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@ABQAU34@@Z ENDP ; std::allocator<CPythonEventManager::SEventSet *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 210  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator--, COMDAT
; _this$ = ecx

; 283  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator--

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 312  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicTextInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicTextInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicTextInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEPAPAUSEventSet@CPythonEventManager@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEPAPAUSEventSet@CPythonEventManager@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@QBEPAPAUSEventSet@CPythonEventManager@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPythonEventManager::SEventSet *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 40   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

  00000	8b d1		 mov	 edx, ecx

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	74 08		 je	 SHORT $LN8@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	89 02		 mov	 DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

  0000f	8b c2		 mov	 eax, edx

; 102  : 		}

  00011	c3		 ret	 0
$LN8@operator:

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00014	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00018	75 19		 jne	 SHORT $LN40@operator

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0001a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  0001d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00021	75 36		 jne	 SHORT $LN21@operator
$LL22@operator:

; 610  : 			_Pnode = _Right(_Pnode);

  00023	8b c8		 mov	 ecx, eax

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00025	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00028	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002c	74 f5		 je	 SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002e	89 0a		 mov	 DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

  00030	8b c2		 mov	 eax, edx

; 102  : 		}

  00032	c3		 ret	 0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0003a	75 15		 jne	 SHORT $LN3@operator
  0003c	8d 64 24 00	 npad	 4
$LL4@operator:
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00044	75 0b		 jne	 SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00046	89 0a		 mov	 DWORD PTR [edx], ecx
  00048	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0004f	74 ef		 je	 SHORT $LL4@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00057	75 02		 jne	 SHORT $LN47@operator
$LN21@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  00059	89 0a		 mov	 DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

  0005b	8b c2		 mov	 eax, edx

; 102  : 		}

  0005d	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tuple_val@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tuple_val@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 80   : 		{	// construct with argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 81   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tuple_val@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::_Tuple_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 13		 je	 SHORT $LN19@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  0000b	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0000e	8b ce		 mov	 ecx, esi
  00010	ff 30		 push	 DWORD PTR [eax]
  00012	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00017	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN19@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 873  : 		}

  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@YAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@YAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@AAU10@@Z PROC ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@YAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@0@AAU10@@Z ENDP ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$dead$ = 20					; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>, COMDAT
; _this$ = ecx

; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)

  00008	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000b	3d 5c 74 d1 05	 cmp	 eax, 97612892		; 05d1745cH
  00010	72 12		 jb	 SHORT $LN17@Insert_at

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00012	8b 75 18	 mov	 esi, DWORD PTR __Node$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00015	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  00019	0f 82 b6 01 00
	00		 jb	 $LN69@Insert_at
  0001f	e9 a6 01 00 00	 jmp	 $LN390@Insert_at
$LN17@Insert_at:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1845 : 		_Newnode->_Parent = _Wherenode;

  00024	8b 5d 18	 mov	 ebx, DWORD PTR __Node$[ebp]
  00027	40		 inc	 eax
  00028	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0002b	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0002e	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)

  00031	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00033	3b c1		 cmp	 eax, ecx
  00035	75 0e		 jne	 SHORT $LN16@Insert_at

; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;

  00037	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0003a	8b 07		 mov	 eax, DWORD PTR [edi]

; 1850 : 			_Lmost() = _Newnode;

  0003c	89 18		 mov	 DWORD PTR [eax], ebx

; 1851 : 			_Rmost() = _Newnode;

  0003e	8b 07		 mov	 eax, DWORD PTR [edi]
  00040	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00043	eb 1f		 jmp	 SHORT $LN11@Insert_at
$LN16@Insert_at:

; 1852 : 			}
; 1853 : 		else if (_Addleft)

  00045	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00049	74 0c		 je	 SHORT $LN14@Insert_at

; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;

  0004b	89 18		 mov	 DWORD PTR [eax], ebx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0004d	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1856 : 			if (_Wherenode == _Lmost())

  0004f	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00051	75 11		 jne	 SHORT $LN11@Insert_at

; 1857 : 				_Lmost() = _Newnode;

  00053	89 19		 mov	 DWORD PTR [ecx], ebx

; 1858 : 			}
; 1859 : 		else

  00055	eb 0d		 jmp	 SHORT $LN11@Insert_at
$LN14@Insert_at:

; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;

  00057	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0005a	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1862 : 			if (_Wherenode == _Rmost())

  0005c	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0005f	75 03		 jne	 SHORT $LN11@Insert_at

; 1863 : 				_Rmost() = _Newnode;

  00061	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00064	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00067	8b f3		 mov	 esi, ebx
  00069	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0006d	0f 85 42 01 00
	00		 jne	 $LN9@Insert_at
$LL10@Insert_at:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00073	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00076	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00079	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0007b	3b c1		 cmp	 eax, ecx
  0007d	0f 85 a8 00 00
	00		 jne	 $LN8@Insert_at

; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00083	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]

; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)

  00086	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0008a	0f 84 a1 00 00
	00		 je	 $LN389@Insert_at

; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  00090	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00093	75 3a		 jne	 SHORT $LN170@Insert_at

; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);

  00095	8b f0		 mov	 esi, eax

; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00097	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0009a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009c	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0009f	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  000a1	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000a5	75 03		 jne	 SHORT $LN169@Insert_at

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  000a7	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN169@Insert_at:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  000aa	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ad	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000b0	8b 07		 mov	 eax, DWORD PTR [edi]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  000b2	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  000b5	75 05		 jne	 SHORT $LN168@Insert_at

; 2136 : 			_Root() = _Pnode;

  000b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000ba	eb 0e		 jmp	 SHORT $LN165@Insert_at
$LN168@Insert_at:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  000bc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000bf	3b 30		 cmp	 esi, DWORD PTR [eax]
  000c1	75 04		 jne	 SHORT $LN166@Insert_at

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000c3	89 08		 mov	 DWORD PTR [eax], ecx

; 2139 : 		else

  000c5	eb 03		 jmp	 SHORT $LN165@Insert_at
$LN166@Insert_at:

; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000c7	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN165@Insert_at:

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  000ca	89 31		 mov	 DWORD PTR [ecx], esi

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  000cc	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN170@Insert_at:

; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up

  000cf	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000d2	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;

  000d6	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  000e0	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  000e6	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  000e8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000eb	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  000ed	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  000f0	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000f4	75 03		 jne	 SHORT $LN232@Insert_at

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  000f6	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN232@Insert_at:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  000f9	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fc	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000ff	8b 07		 mov	 eax, DWORD PTR [edi]

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  00101	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00104	75 0b		 jne	 SHORT $LN231@Insert_at

; 2166 : 			_Root() = _Pnode;

  00106	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00109	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  0010c	e9 94 00 00 00	 jmp	 $LN388@Insert_at
$LN231@Insert_at:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00111	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00114	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00117	75 0b		 jne	 SHORT $LN229@Insert_at

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00119	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0011c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  0011f	e9 81 00 00 00	 jmp	 $LN388@Insert_at
$LN229@Insert_at:

; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00124	89 10		 mov	 DWORD PTR [eax], edx

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00126	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  00129	eb 7a		 jmp	 SHORT $LN388@Insert_at
$LN8@Insert_at:

; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)

  0012b	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0012f	75 1a		 jne	 SHORT $LN3@Insert_at
$LN389@Insert_at:

; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00131	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1902 : 					this->_Color(_Wherenode) = this->_Black;

  00135	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;

  00139	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0013c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013f	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00143	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00146	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 1906 : 					}
; 1907 : 				else

  00149	eb 5d		 jmp	 SHORT $LN326@Insert_at
$LN3@Insert_at:

; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  0014b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0014d	75 0a		 jne	 SHORT $LN1@Insert_at

; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);

  0014f	8b f0		 mov	 esi, eax

; 1912 : 						_Rrotate(_Pnode);

  00151	8b cf		 mov	 ecx, edi
  00153	56		 push	 esi
  00154	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Rrotate
$LN1@Insert_at:

; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up

  00159	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0015c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;

  00160	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00163	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00166	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  0016a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0016d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00170	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  00173	8b 02		 mov	 eax, DWORD PTR [edx]
  00175	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00178	8b 02		 mov	 eax, DWORD PTR [edx]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0017a	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0017e	75 03		 jne	 SHORT $LN325@Insert_at

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00180	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN325@Insert_at:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00183	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00186	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00189	8b 07		 mov	 eax, DWORD PTR [edi]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  0018b	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0018e	75 05		 jne	 SHORT $LN324@Insert_at

; 2136 : 			_Root() = _Pnode;

  00190	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00193	eb 0e		 jmp	 SHORT $LN321@Insert_at
$LN324@Insert_at:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00195	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00198	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0019a	75 04		 jne	 SHORT $LN322@Insert_at

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0019c	89 10		 mov	 DWORD PTR [eax], edx

; 2139 : 		else

  0019e	eb 03		 jmp	 SHORT $LN321@Insert_at
$LN322@Insert_at:

; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  001a0	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN321@Insert_at:

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  001a3	89 0a		 mov	 DWORD PTR [edx], ecx
$LN388@Insert_at:

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  001a5	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN326@Insert_at:

; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  001a8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001ab	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  001af	0f 84 be fe ff
	ff		 je	 $LL10@Insert_at
$LN9@Insert_at:

; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  001b5	8b 07		 mov	 eax, DWORD PTR [edi]
  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001bc	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 44   : 		{	// construct with node pointer _Pnode

  001c0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001c3	89 18		 mov	 DWORD PTR [eax], ebx
  001c5	5b		 pop	 ebx

; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}

  001c6	5d		 pop	 ebp
  001c7	c2 14 00	 ret	 20			; 00000014H
$LN390@Insert_at:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001ca	ff 76 10	 push	 DWORD PTR [esi+16]
  001cd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d2	83 c4 04	 add	 esp, 4
$LN69@Insert_at:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  001d5	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  001dc	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001e3	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  001e4	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001e8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001ed	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1839 : 			_Xlength_error("map/set<T> too long");

  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  001f5	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN392@Insert_at:
$LN387@Insert_at:
  001fa	cc		 int	 3
??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
_TEXT	SEGMENT
tv978 = -28						; size = 4
_this$1$ = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Leftish$dead$ = 12					; size = 1
__Wherenode$1$ = 16					; size = 4
$T3 = 16						; size = 4
__Where$4 = 16						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>, COMDAT
; _this$ = ecx

; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d1		 mov	 edx, ecx
  0002d	89 55 e8	 mov	 DWORD PTR _this$1$[ebp], edx

; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN

  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty

  00037	b0 01		 mov	 al, 1

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00039	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;

  0003b	8b f9		 mov	 edi, ecx
  0003d	8b 5d 10	 mov	 ebx, DWORD PTR __Val$[ebp]

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00040	89 4d e4	 mov	 DWORD PTR tv978[ebp], ecx

; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty

  00043	88 45 ec	 mov	 BYTE PTR __Addleft$2[ebp], al
  00046	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]

; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))

  00049	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0004d	75 6b		 jne	 SHORT $LN11@Insert_noh
  0004f	90		 npad	 1
$LL12@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00050	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  00054	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

  00057	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1787 : 			_Wherenode = _Trynode;

  0005a	89 75 10	 mov	 DWORD PTR __Wherenode$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0005d	72 02		 jb	 SHORT $LN102@Insert_noh
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0005f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN102@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00061	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00065	72 04		 jb	 SHORT $LN118@Insert_noh
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00067	8b 13		 mov	 edx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00069	eb 02		 jmp	 SHORT $LN119@Insert_noh
$LN118@Insert_noh:
  0006b	8b d3		 mov	 edx, ebx
$LN119@Insert_noh:

; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);

  0006d	39 7b 10	 cmp	 DWORD PTR [ebx+16], edi
  00070	8b c7		 mov	 eax, edi
  00072	0f 42 43 10	 cmovb	 eax, DWORD PTR [ebx+16]
  00076	50		 push	 eax
  00077	51		 push	 ecx
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);

  00081	85 c0		 test	 eax, eax
  00083	75 15		 jne	 SHORT $LN283@Insert_noh
  00085	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00088	3b d7		 cmp	 edx, edi
  0008a	73 05		 jae	 SHORT $LN109@Insert_noh
  0008c	83 c8 ff	 or	 eax, -1
  0008f	eb 07		 jmp	 SHORT $LN110@Insert_noh
$LN109@Insert_noh:
  00091	33 c0		 xor	 eax, eax
  00093	3b d7		 cmp	 edx, edi
  00095	0f 95 c0	 setne	 al
$LN110@Insert_noh:

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);
; 2490 : 	}
; 2491 : 
; 2492 : template<class _Elem,
; 2493 : 	class _Traits,
; 2494 : 	class _Alloc> inline
; 2495 : 	bool operator!=(
; 2496 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2497 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2498 : 	{	// test for string inequality
; 2499 : 	return (!(_Left == _Right));
; 2500 : 	}
; 2501 : 
; 2502 : template<class _Elem,
; 2503 : 	class _Traits,
; 2504 : 	class _Alloc> inline
; 2505 : 	bool operator!=(
; 2506 : 		const _Elem *_Left,
; 2507 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2508 : 	{	// test for NTCS vs. string inequality
; 2509 : 	return (!(_Left == _Right));
; 2510 : 	}
; 2511 : 
; 2512 : template<class _Elem,
; 2513 : 	class _Traits,
; 2514 : 	class _Alloc> inline
; 2515 : 	bool operator!=(
; 2516 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2517 : 		const _Elem *_Right)
; 2518 : 	{	// test for string vs. NTCS inequality
; 2519 : 	return (!(_Left == _Right));
; 2520 : 	}
; 2521 : 
; 2522 : template<class _Elem,
; 2523 : 	class _Traits,
; 2524 : 	class _Alloc> inline
; 2525 : 	bool operator<(
; 2526 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2527 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2528 : 	{	// test if string < string
; 2529 : 	return (_Left.compare(_Right) < 0);

  00098	85 c0		 test	 eax, eax
$LN283@Insert_noh:
  0009a	0f 98 c0	 sets	 al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0009d	88 45 ec	 mov	 BYTE PTR __Addleft$2[ebp], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1797 : 				: this->_Right(_Trynode);

  000a0	84 c0		 test	 al, al
  000a2	74 04		 je	 SHORT $LN16@Insert_noh
  000a4	8b 36		 mov	 esi, DWORD PTR [esi]
  000a6	eb 03		 jmp	 SHORT $LN17@Insert_noh
$LN16@Insert_noh:
  000a8	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
$LN17@Insert_noh:

; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))

  000ab	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  000af	74 9f		 je	 SHORT $LL12@Insert_noh
  000b1	8b 7d 10	 mov	 edi, DWORD PTR __Wherenode$1$[ebp]
  000b4	8b 4d e4	 mov	 ecx, DWORD PTR tv978[ebp]
  000b7	8b 55 e8	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN11@Insert_noh:

; 44   : 		{	// construct with node pointer _Pnode

  000ba	8b f7		 mov	 esi, edi
  000bc	89 75 10	 mov	 DWORD PTR __Where$4[ebp], esi

; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)

  000bf	84 c0		 test	 al, al
  000c1	74 40		 je	 SHORT $LN171@Insert_noh

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  000c3	3b 39		 cmp	 edi, DWORD PTR [ecx]

; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())

  000c5	75 31		 jne	 SHORT $LN4@Insert_noh

; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,

  000c7	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000ca	51		 push	 ecx
  000cb	57		 push	 edi
  000cc	6a 01		 push	 1
  000ce	8b ca		 mov	 ecx, edx
$LN285@Insert_noh:
  000d0	8d 45 10	 lea	 eax, DWORD PTR $T3[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  000d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000db	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000de	89 08		 mov	 DWORD PTR [eax], ecx
  000e0	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1829 : 		}

  000e4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000e7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ee	59		 pop	 ecx
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 10 00	 ret	 16			; 00000010H
$LN4@Insert_noh:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  000f8	8d 4d 10	 lea	 ecx, DWORD PTR __Where$4[ebp]
  000fb	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator--
  00100	8b 75 10	 mov	 esi, DWORD PTR __Where$4[ebp]
$LN171@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00103	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 59   : 		return (_Val.first);

  00107	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

  0010a	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]

; 520  : 			: this->_Bx._Buf);

  0010d	72 02		 jb	 SHORT $LN200@Insert_noh
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0010f	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN200@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));

  00111	50		 push	 eax
  00112	53		 push	 ebx
  00113	ff 71 10	 push	 DWORD PTR [ecx+16]
  00116	6a 00		 push	 0
  00118	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));
; 2450 : 	}
; 2451 : 
; 2452 : template<class _Elem,
; 2453 : 	class _Traits,
; 2454 : 	class _Alloc> inline
; 2455 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2456 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2457 : 		const _Elem _Right)
; 2458 : 	{	// return string + character
; 2459 : 	return (_STD move(_Left.append(1, _Right)));
; 2460 : 	}
; 2461 : 
; 2462 : template<class _Elem,
; 2463 : 	class _Traits,
; 2464 : 	class _Alloc> inline
; 2465 : 	bool operator==(
; 2466 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2467 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2468 : 	{	// test for string equality
; 2469 : 	return (_Left.compare(_Right) == 0);
; 2470 : 	}
; 2471 : 
; 2472 : template<class _Elem,
; 2473 : 	class _Traits,
; 2474 : 	class _Alloc> inline
; 2475 : 	bool operator==(
; 2476 : 		const _Elem * _Left,
; 2477 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2478 : 	{	// test for NTCS vs. string equality
; 2479 : 	return (_Right.compare(_Left) == 0);
; 2480 : 	}
; 2481 : 
; 2482 : template<class _Elem,
; 2483 : 	class _Traits,
; 2484 : 	class _Alloc> inline
; 2485 : 	bool operator==(
; 2486 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2487 : 		const _Elem *_Right)
; 2488 : 	{	// test for string vs. NTCS equality
; 2489 : 	return (_Left.compare(_Right) == 0);
; 2490 : 	}
; 2491 : 
; 2492 : template<class _Elem,
; 2493 : 	class _Traits,
; 2494 : 	class _Alloc> inline
; 2495 : 	bool operator!=(
; 2496 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2497 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2498 : 	{	// test for string inequality
; 2499 : 	return (!(_Left == _Right));
; 2500 : 	}
; 2501 : 
; 2502 : template<class _Elem,
; 2503 : 	class _Traits,
; 2504 : 	class _Alloc> inline
; 2505 : 	bool operator!=(
; 2506 : 		const _Elem *_Left,
; 2507 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2508 : 	{	// test for NTCS vs. string inequality
; 2509 : 	return (!(_Left == _Right));
; 2510 : 	}
; 2511 : 
; 2512 : template<class _Elem,
; 2513 : 	class _Traits,
; 2514 : 	class _Alloc> inline
; 2515 : 	bool operator!=(
; 2516 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2517 : 		const _Elem *_Right)
; 2518 : 	{	// test for string vs. NTCS inequality
; 2519 : 	return (!(_Left == _Right));
; 2520 : 	}
; 2521 : 
; 2522 : template<class _Elem,
; 2523 : 	class _Traits,
; 2524 : 	class _Alloc> inline
; 2525 : 	bool operator<(
; 2526 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2527 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2528 : 	{	// test if string < string
; 2529 : 	return (_Left.compare(_Right) < 0);

  0011d	85 c0		 test	 eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

  0011f	79 0d		 jns	 SHORT $LN2@Insert_noh

; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  00121	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00124	51		 push	 ecx
  00125	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00128	57		 push	 edi
  00129	ff 75 ec	 push	 DWORD PTR __Addleft$2[ebp]
  0012c	eb a2		 jmp	 SHORT $LN285@Insert_noh
$LN2@Insert_noh:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  0012e	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00131	83 7f 24 10	 cmp	 DWORD PTR [edi+36], 16	; 00000010H
  00135	72 0b		 jb	 SHORT $LN250@Insert_noh
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00137	ff 77 10	 push	 DWORD PTR [edi+16]
  0013a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0013f	83 c4 04	 add	 esp, 4
$LN250@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00142	c7 47 24 0f 00
	00 00		 mov	 DWORD PTR [edi+36], 15	; 0000000fH

; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00149	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00150	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00151	c6 47 10 00	 mov	 BYTE PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00155	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  0015a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0015d	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

  00160	89 30		 mov	 DWORD PTR [eax], esi
  00162	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1829 : 		}

  00166	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00169	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00170	59		 pop	 ecx
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx
  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c2 10 00	 ret	 16			; 00000010H
__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z$0:

; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);

  0017a	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0017d	e8 00 00 00 00	 call	 ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Destroy_if_not_nil

; 1827 : 		_RERAISE;

  00182	6a 00		 push	 0
  00184	6a 00		 push	 0
  00186	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN286@Insert_noh:
$LN282@Insert_noh:
  0018b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USTextLine@CPythonEventManager@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@ABU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USTextLine@CPythonEventManager@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@ABU23@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<CPythonEventManager::STextLine,CPythonEventManager::STextLine const &>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@USTextLine@CPythonEventManager@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@ABU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<CPythonEventManager::STextLine,CPythonEventManager::STextLine const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@$$QAPAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@$$QAPAU23@@Z PROC ; std::allocator<CPythonEventManager::SEventSet *>::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAUSEventSet@CPythonEventManager@@PAU12@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@$$QAPAU23@@Z ENDP ; std::allocator<CPythonEventManager::SEventSet *>::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@AAPAV2@@Z PROC ; std::allocator<CGraphicTextInstance *>::construct<CGraphicTextInstance *,CGraphicTextInstance * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicTextInstance@@AAPAV1@@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@AAPAV2@@Z ENDP ; std::allocator<CGraphicTextInstance *>::construct<CGraphicTextInstance *,CGraphicTextInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCGraphicTextInstance@@@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCGraphicTextInstance@@@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@@Z PROC ; std::allocator<CGraphicTextInstance *>::destroy<CGraphicTextInstance *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCGraphicTextInstance@@@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@@Z ENDP ; std::allocator<CGraphicTextInstance *>::destroy<CGraphicTextInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z PROC ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::destroy<std::_List_node<CPythonEventManager::STextLine,void *> *>, COMDAT
; _this$dead$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@@Z ENDP ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::destroy<std::_List_node<CPythonEventManager::STextLine,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USTextLine@CPythonEventManager@@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@USTextLine@CPythonEventManager@@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@@Z PROC ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::destroy<CPythonEventManager::STextLine>, COMDAT
; _this$dead$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@USTextLine@CPythonEventManager@@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@@Z ENDP ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::destroy<CPythonEventManager::STextLine>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@AAPAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@AAPAU23@@Z PROC ; std::allocator<CPythonEventManager::SEventSet *>::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * &>, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAUSEventSet@CPythonEventManager@@AAPAU12@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@AAPAU23@@Z ENDP ; std::allocator<CPythonEventManager::SEventSet *>::construct<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAUSEventSet@CPythonEventManager@@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAUSEventSet@CPythonEventManager@@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@@Z PROC ; std::allocator<CPythonEventManager::SEventSet *>::destroy<CPythonEventManager::SEventSet *>, COMDAT
; _this$dead$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAUSEventSet@CPythonEventManager@@@?$allocator@PAUSEventSet@CPythonEventManager@@@std@@QAEXPAPAUSEventSet@CPythonEventManager@@@Z ENDP ; std::allocator<CPythonEventManager::SEventSet *>::destroy<CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@@Z PROC ; std::allocator<std::_List_node<script::SArgumet,void *> >::destroy<std::_List_node<script::SArgumet,void *> *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@USArgumet@script@@PAX@std@@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@@Z ENDP ; std::allocator<std::_List_node<script::SArgumet,void *> >::destroy<std::_List_node<script::SArgumet,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USArgumet@script@@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAUSArgumet@script@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@USArgumet@script@@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAUSArgumet@script@@@Z PROC ; std::allocator<std::_List_node<script::SArgumet,void *> >::destroy<script::SArgumet>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00007	83 7e 2c 10	 cmp	 DWORD PTR [esi+44], 16	; 00000010H
  0000b	72 0b		 jb	 SHORT $LN28@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 76 18	 push	 DWORD PTR [esi+24]
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$LN28@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00018	c7 46 2c 0f 00
	00 00		 mov	 DWORD PTR [esi+44], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001f	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00026	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0002a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0002e	72 0a		 jb	 SHORT $LN60@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00030	ff 36		 push	 DWORD PTR [esi]
  00032	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00037	83 c4 04	 add	 esp, 4
$LN60@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00041	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00048	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004b	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 608  : 		}

  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??$destroy@USArgumet@script@@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAUSArgumet@script@@@Z ENDP ; std::allocator<std::_List_node<script::SArgumet,void *> >::destroy<script::SArgumet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>, COMDAT
; _this$dead$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@@Z
_TEXT	SEGMENT
??$_Unchecked@PAPAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@@Z PROC ; std::_Unchecked<CPythonEventManager::SEventSet * *>, COMDAT
; __Src$ = ecx

; 281  : 	return (_Src);

  00000	8b c1		 mov	 eax, ecx

; 282  : 	}

  00002	c3		 ret	 0
??$_Unchecked@PAPAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@@Z ENDP ; std::_Unchecked<CPythonEventManager::SEventSet * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAUSEventSet@CPythonEventManager@@PAPAU12@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninit_move@PAPAUSEventSet@CPythonEventManager@@PAPAU12@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z PROC ; std::_Uninit_move<CPythonEventManager::SEventSet * *,CPythonEventManager::SEventSet * *,std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	2b d1		 sub	 edx, ecx
  00005	c1 fa 02	 sar	 edx, 2
  00008	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00009	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]
  00010	56		 push	 esi
  00011	51		 push	 ecx
  00012	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	03 c6		 add	 eax, esi
  0001f	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninit_move@PAPAUSEventSet@CPythonEventManager@@PAPAU12@U?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@std@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@@Z ENDP ; std::_Uninit_move<CPythonEventManager::SEventSet * *,CPythonEventManager::SEventSet * *,std::_Wrap_alloc<std::allocator<CPythonEventManager::SEventSet *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAUSEventSet@CPythonEventManager@@PAPAU12@@std@@YAAAPAPAUSEventSet@CPythonEventManager@@AAPAPAU12@PAPAU12@@Z
_TEXT	SEGMENT
??$_Rechecked@PAPAUSEventSet@CPythonEventManager@@PAPAU12@@std@@YAAAPAPAUSEventSet@CPythonEventManager@@AAPAPAU12@PAPAU12@@Z PROC ; std::_Rechecked<CPythonEventManager::SEventSet * *,CPythonEventManager::SEventSet * *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 289  : 	_Dest = _Src;

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 290  : 	return (_Dest);

  00002	8b c1		 mov	 eax, ecx

; 291  : 	}

  00004	c3		 ret	 0
??$_Rechecked@PAPAUSEventSet@CPythonEventManager@@PAPAU12@@std@@YAAAPAPAUSEventSet@CPythonEventManager@@AAPAPAU12@PAPAU12@@Z ENDP ; std::_Rechecked<CPythonEventManager::SEventSet * *,CPythonEventManager::SEventSet * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@@Z PROC ; std::_Unchecked<CGraphicTextInstance * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@@Z ENDP ; std::_Unchecked<CGraphicTextInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCGraphicTextInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCGraphicTextInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z PROC ; std::_Uninit_move<CGraphicTextInstance * *,CGraphicTextInstance * *,std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCGraphicTextInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z ENDP ; std::_Uninit_move<CGraphicTextInstance * *,CGraphicTextInstance * *,std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicTextInstance@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicTextInstance@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CGraphicTextInstance * *,CGraphicTextInstance * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicTextInstance@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CGraphicTextInstance * *,CGraphicTextInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >, COMDAT
; _this$dead$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000b	72 0a		 jb	 SHORT $LN28@destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
$LN28@destroy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00017	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 608  : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_List_node<script::SArgumet,void *> >::construct<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USArgumet@script@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_List_node<script::SArgumet,void *> >::construct<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::construct<std::_List_node<CPythonEventManager::STextLine,void *> *,std::_List_node<CPythonEventManager::STextLine,void *> * &>, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USTextLine@CPythonEventManager@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::construct<std::_List_node<CPythonEventManager::STextLine,void *> *,std::_List_node<CPythonEventManager::STextLine,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??_GSArgumet@script@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GSArgumet@script@@QAEPAXI@Z PROC			; script::SArgumet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00006	83 7e 2c 10	 cmp	 DWORD PTR [esi+44], 16	; 00000010H
  0000a	72 0b		 jb	 SHORT $LN26@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000c	ff 76 18	 push	 DWORD PTR [esi+24]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
$LN26@scalar:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00017	c7 46 2c 0f 00
	00 00		 mov	 DWORD PTR [esi+44], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001e	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00025	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00029	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0002d	72 0a		 jb	 SHORT $LN58@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0002f	ff 36		 push	 DWORD PTR [esi]
  00031	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00036	83 c4 04	 add	 esp, 4
$LN58@scalar:
  00039	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00044	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0004b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004e	74 09		 je	 SHORT $LN70@scalar
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4
$LN70@scalar:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
??_GSArgumet@script@@QAEPAXI@Z ENDP			; script::SArgumet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAEPAXI@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00003	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00007	72 0a		 jb	 SHORT $LN26@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$LN26@scalar:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00013	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001a	8b c6		 mov	 eax, esi

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00023	c6 06 00	 mov	 BYTE PTR [esi], 0
  00026	5e		 pop	 esi
  00027	c2 04 00	 ret	 4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAEPAXI@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??1SArgumet@script@@QAE@XZ
_TEXT	SEGMENT
??1SArgumet@script@@QAE@XZ PROC				; script::SArgumet::~SArgumet, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00003	83 7e 2c 10	 cmp	 DWORD PTR [esi+44], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN23@SArgumet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	ff 76 18	 push	 DWORD PTR [esi+24]
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN23@SArgumet:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00014	c7 46 2c 0f 00
	00 00		 mov	 DWORD PTR [esi+44], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001b	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00022	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00026	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0002a	72 0a		 jb	 SHORT $LN55@SArgumet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0002c	ff 36		 push	 DWORD PTR [esi]
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00033	83 c4 04	 add	 esp, 4
$LN55@SArgumet:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0003d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00044	c6 06 00	 mov	 BYTE PTR [esi], 0
  00047	5e		 pop	 esi
  00048	c3		 ret	 0
??1SArgumet@script@@QAE@XZ ENDP				; script::SArgumet::~SArgumet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00003	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00007	72 0a		 jb	 SHORT $LN23@pair
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$LN23@pair:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00013	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00021	c6 06 00	 mov	 BYTE PTR [esi], 0
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1277 : 		return (this->_Getal().max_size());

  00000	b8 5d 74 d1 05	 mov	 eax, 97612893		; 05d1745dH

; 1278 : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >,std::_Iterator_base0>::operator--

; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 427  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::max_size, COMDAT
; _this$dead$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 5d 74 d1 05	 mov	 eax, 97612893		; 05d1745dH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 735  : 		return (_Al.max_size());

  00000	b8 5d 74 d1 05	 mov	 eax, 97612893		; 05d1745dH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::max_size, COMDAT
; _this$dead$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 5d 74 d1 05	 mov	 eax, 97612893		; 05d1745dH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
_<_Args_0>$dead$ = 8					; size = 4
_<_Args_1>$ = 12					; size = 4
_<_Args_2>$dead$ = 16					; size = 4
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f2		 mov	 esi, edx

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00006	85 f6		 test	 esi, esi
  00008	74 13		 je	 SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0000d	8b ce		 mov	 ecx, esi
  0000f	ff 30		 push	 DWORD PTR [eax]
  00011	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00016	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 724  : 		}

  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Buynode_if_nil<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &>, COMDAT
; _this$dead$ = ecx

; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Node$[ebp]

; 1639 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
??$_Buynode_if_nil@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::_Buynode_if_nil<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > > &,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > > &,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USTextLine@CPythonEventManager@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAUSTextLine@CPythonEventManager@@ABU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@USTextLine@CPythonEventManager@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAUSTextLine@CPythonEventManager@@ABU34@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<CPythonEventManager::STextLine,CPythonEventManager::STextLine const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 11		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0000e	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00012	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00015	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$construct@USTextLine@CPythonEventManager@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@1@PAUSTextLine@CPythonEventManager@@ABU34@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> > >::construct<CPythonEventManager::STextLine,CPythonEventManager::STextLine const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@@Z
_TEXT	SEGMENT
??$_Val_type@PAPAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@@Z PROC ; std::_Val_type<CPythonEventManager::SEventSet * *>, COMDAT
; ___formal$dead$ = ecx

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAUSEventSet@CPythonEventManager@@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@@Z ENDP ; std::_Val_type<CPythonEventManager::SEventSet * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUSEventSet@CPythonEventManager@@PAU12@PAU12@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$dead$ = 16					; size = 4
___formal$ = 20						; size = 1
??$_Uninit_move@PAUSEventSet@CPythonEventManager@@PAU12@PAU12@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	2b d1		 sub	 edx, ecx
  00005	c1 fa 02	 sar	 edx, 2
  00008	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00009	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]
  00010	56		 push	 esi
  00011	51		 push	 ecx
  00012	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	03 c6		 add	 eax, esi
  0001f	5e		 pop	 esi

; 475  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninit_move@PAUSEventSet@CPythonEventManager@@PAU12@PAU12@@std@@YAPAPAUSEventSet@CPythonEventManager@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUSEventSet@CPythonEventManager@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *,CPythonEventManager::SEventSet *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@@Z PROC ; std::_Val_type<CGraphicTextInstance * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@@Z ENDP ; std::_Val_type<CGraphicTextInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCGraphicTextInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCGraphicTextInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CGraphicTextInstance *,CGraphicTextInstance *,CGraphicTextInstance *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCGraphicTextInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CGraphicTextInstance *,CGraphicTextInstance *,CGraphicTextInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 13		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple

; 80   : 		{	// construct with argument

  0000b	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]

; 81   : 		}
; 82   : 
; 83   : 	template<class _Other>
; 84   : 		_Tuple_val& operator=(_Other&& _Right)
; 85   : 		{	// assign
; 86   : 		_Val = _STD forward<_Other>(_Right);
; 87   : 		return (*this);
; 88   : 		}
; 89   : 
; 90   : 	template<class _Alloc,
; 91   : 		class... _Other>
; 92   : 		_Tuple_val(const _Alloc&,
; 93   : 			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
; 94   : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 95   : 		: _Val(_STD forward<_Other>(_Arg)...)
; 96   : 		{	// construct with optional arguments, no allocator
; 97   : 		}
; 98   : 
; 99   : 	template<class _Alloc,
; 100  : 		class... _Other>
; 101  : 		_Tuple_val(const _Alloc& _Al,
; 102  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 103  : 				&& is_constructible<_Ty,
; 104  : 					allocator_arg_t, _Alloc>::value,
; 105  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 106  : 		: _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...)
; 107  : 		{	// construct with optional arguments, leading allocator
; 108  : 		}
; 109  : 
; 110  : 	template<class _Alloc,
; 111  : 		class... _Other>
; 112  : 		_Tuple_val(const _Alloc& _Al,
; 113  : 			typename enable_if<uses_allocator<_Ty, _Alloc>::value
; 114  : 				&& !is_constructible<_Ty,
; 115  : 					allocator_arg_t, _Alloc>::value,
; 116  : 				_Tuple_alloc_t>::type, _Other&&... _Arg)
; 117  : 		: _Val(_STD forward<_Other>(_Arg)..., _Al)
; 118  : 		{	// construct with optional arguments, trailing allocator
; 119  : 		}
; 120  : 
; 121  : 
; 122  : 	_Ty _Val;
; 123  : 	};
; 124  : 
; 125  : 	// CLASS tuple
; 126  : template<class... _Types>
; 127  : 	class tuple;
; 128  : 
; 129  : template<>
; 130  : 	class tuple<>
; 131  : 	{	// empty tuple
; 132  : public:
; 133  : 	typedef tuple<> _Myt;
; 134  : 
; 135  : 	tuple()
; 136  : 		{	// default construct
; 137  : 		}
; 138  : 
; 139  : 	template<class _Alloc>
; 140  : 		tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT
; 141  : 		{	// default construct, allocator
; 142  : 		}
; 143  : 
; 144  : 	tuple(const tuple&) _NOEXCEPT
; 145  : 		{	// copy construct
; 146  : 		}
; 147  : 
; 148  : 	template<class _Alloc>
; 149  : 		tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT
; 150  : 		{	// copy construct, allocator
; 151  : 		}
; 152  : 
; 153  : 	void swap(_Myt&) _NOEXCEPT
; 154  : 		{	// swap elements
; 155  : 		}
; 156  : 
; 157  : 	bool _Equals(const _Myt&) const _NOEXCEPT
; 158  : 		{	// test if *this == _Right
; 159  : 		return (true);
; 160  : 		}
; 161  : 
; 162  : 	bool _Less(const _Myt&) const _NOEXCEPT
; 163  : 		{	// test if *this < _Right
; 164  : 		return (false);
; 165  : 		}
; 166  : 	};
; 167  : 
; 168  : template<class _This,
; 169  : 	class... _Rest>
; 170  : 	class tuple<_This, _Rest...>
; 171  : 		: private tuple<_Rest...>
; 172  : 	{	// recursive tuple definition
; 173  : public:
; 174  : 	typedef _This _This_type;
; 175  : 	typedef tuple<_This, _Rest...> _Myt;
; 176  : 	typedef tuple<_Rest...> _Mybase;
; 177  : 	static const size_t _Mysize = 1 + sizeof...(_Rest);
; 178  : 
; 179  : 	tuple()
; 180  : 		: _Mybase(),
; 181  : 			_Myfirst()
; 182  : 		{	// construct default
; 183  : 		}
; 184  : 
; 185  : 	template<class... _Rest2>
; 186  : 		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
; 187  : 			: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 188  : 				_Myfirst(allocator_arg)
; 189  : 		{	// construct smuggled allocator_arg_t element
; 190  : 		}
; 191  : 
; 192  : 	template<class... _Other,
; 193  : 		class = typename _Tuple_enable<
; 194  : 			tuple<const _Other&...>, _Myt>::type>
; 195  : 		tuple(const tuple<_Other...>& _Right)
; 196  : 		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
; 197  : 		{	// construct by copying same size tuple
; 198  : 		}
; 199  : 
; 200  : 	template<class _Alloc,
; 201  : 		class... _Other,
; 202  : 		class = typename _Tuple_enable<
; 203  : 			tuple<const _Other&...>, _Myt>::type>
; 204  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 205  : 			const tuple<_Other...>& _Right)
; 206  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 207  : 			_Myfirst(_Al, _Tuple_alloc,
; 208  : 				_Right._Myfirst._Val)
; 209  : 		{	// construct by copying same size tuple, allocator
; 210  : 		}
; 211  : 
; 212  : 	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
; 213  : 		: _Mybase(_Rest_arg...),
; 214  : 			_Myfirst(_This_arg)
; 215  : 		{	// construct from one or more copied elements
; 216  : 		}
; 217  : 
; 218  : 	template<class _Alloc>
; 219  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 220  : 			const _This& _This_arg, const _Rest&... _Rest_arg)
; 221  : 		: _Mybase(allocator_arg, _Al, _Rest_arg...),
; 222  : 			_Myfirst(_Al, _Tuple_alloc, _This_arg)
; 223  : 		{	// construct from one or more copied elements, allocator
; 224  : 		}
; 225  : 
; 226  : 	template<class _This2,
; 227  : 		class... _Rest2,
; 228  : 		class = typename _Tuple_enable<
; 229  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 230  : 		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 231  : 		: _Mybase(_STD forward<_Rest2>(_Rest_arg)...),
; 232  : 			_Myfirst(_STD forward<_This2>(_This_arg))
; 233  : 		{	// construct from one or more moved elements
; 234  : 		}
; 235  : 
; 236  : 	template<class _Alloc,
; 237  : 		class _This2,
; 238  : 		class... _Rest2,
; 239  : 		class = typename _Tuple_enable<
; 240  : 			tuple<_This2, _Rest2...>, _Myt>::type>
; 241  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 242  : 			_This2&& _This_arg, _Rest2&&... _Rest_arg)
; 243  : 		: _Mybase(allocator_arg, _Al,
; 244  : 				_STD forward<_Rest2>(_Rest_arg)...),
; 245  : 			_Myfirst(_Al, _Tuple_alloc,
; 246  : 				_STD forward<_This2>(_This_arg))
; 247  : 		{	// construct from one or more moved elements, allocator
; 248  : 		}
; 249  : 
; 250  : 	template<class... _Other,
; 251  : 		class = typename _Tuple_enable<
; 252  : 			tuple<_Other...>, _Myt>::type>
; 253  : 		tuple(tuple<_Other...>&& _Right)
; 254  : 		: _Mybase(_STD forward<typename tuple<_Other...>::_Mybase>
; 255  : 			(_Right._Get_rest())),
; 256  : 			_Myfirst(_STD forward<typename tuple<_Other...>::_This_type>
; 257  : 				(_Right._Myfirst._Val))
; 258  : 		{	// construct by moving same size tuple
; 259  : 		}
; 260  : 
; 261  : 	template<class _Alloc,
; 262  : 		class... _Other,
; 263  : 		class = typename _Tuple_enable<
; 264  : 			tuple<_Other...>, _Myt>::type>
; 265  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 266  : 			tuple<_Other...>&& _Right)
; 267  : 		: _Mybase(allocator_arg, _Al,
; 268  : 				_STD forward<typename tuple<_Other...>::_Mybase>
; 269  : 					(_Right._Get_rest())),
; 270  : 			_Myfirst(_Al, _Tuple_alloc,
; 271  : 				_STD forward<typename tuple<_Other...>::_This_type>
; 272  : 					(_Right._Myfirst._Val))
; 273  : 		{	// construct by moving same size tuple, allocator
; 274  : 		}
; 275  : 
; 276  : 	template<class... _Other>
; 277  : 		_Myt& operator=(const tuple<_Other...>& _Right)
; 278  : 		{	// assign by copying same size tuple
; 279  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 280  : 		(_Mybase&)*this = _Right._Get_rest();
; 281  : 		return (*this);
; 282  : 		}
; 283  : 
; 284  : 	template<class... _Other>
; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)
; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);
; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());
; 291  : 		return (*this);
; 292  : 		}
; 293  : 
; 294  : 	template<class... _Other>
; 295  : 		bool _Equals(const tuple<_Other...>& _Right) const
; 296  : 		{	// test if *this == _Right
; 297  : 		static_assert(_Mysize == sizeof...(_Other),
; 298  : 			"comparing tuple to object with different size");
; 299  : 		return (_Myfirst._Val == _Right._Myfirst._Val
; 300  : 			&& _Mybase::_Equals(_Right._Get_rest()));
; 301  : 		}
; 302  : 
; 303  : 	template<class... _Other>
; 304  : 		bool _Less(const tuple<_Other...>& _Right) const
; 305  : 		{	// test if *this < _Right
; 306  : 		static_assert(_Mysize == sizeof...(_Other),
; 307  : 			"comparing tuple to object with different size");
; 308  : 		return (_Myfirst._Val < _Right._Myfirst._Val
; 309  : 			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
; 310  : 				&& _Mybase::_Less(_Right._Get_rest())));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc>
; 314  : 		tuple(allocator_arg_t, const _Alloc& _Al)
; 315  : 		: _Mybase(allocator_arg, _Al),
; 316  : 			_Myfirst(_Al, _Tuple_alloc)
; 317  : 		{	// construct default, allocator
; 318  : 		}
; 319  : 
; 320  : 	template<class _Alloc>
; 321  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 322  : 			const _Myt& _Right)
; 323  : 		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
; 324  : 			_Myfirst(_Al, _Tuple_alloc,
; 325  : 				_Right._Myfirst._Val)
; 326  : 		{	// construct by copying, allocator
; 327  : 		}
; 328  : 
; 329  : 	template<class _First,
; 330  : 		class _Second,
; 331  : 		class = typename _Tuple_enable<
; 332  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 333  : 		tuple(const pair<_First, _Second>& _Right)
; 334  : 
; 335  : 		: _Mybase(tuple<_Second>(_Right.second)),
; 336  : 			_Myfirst(_Right.first)
; 337  : 		{	// construct by copying pair
; 338  : 		// no static_assert necessary
; 339  : 		}
; 340  : 
; 341  : 	template<class _Alloc,
; 342  : 		class _First,
; 343  : 		class _Second,
; 344  : 		class = typename _Tuple_enable<
; 345  : 			tuple<const _First&, const _Second&>, _Myt>::type>
; 346  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 347  : 			const pair<_First, _Second>& _Right)
; 348  : 
; 349  : 		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
; 350  : 			_Myfirst(_Al, _Tuple_alloc,
; 351  : 				_Right.first)
; 352  : 		{	// construct by copying pair, allocator
; 353  : 		// no static_assert necessary
; 354  : 		}
; 355  : 
; 356  : 	_Myt& operator=(const _Myt& _Right)
; 357  : 		{	// assign
; 358  : 		_Myfirst._Val = _Right._Myfirst._Val;
; 359  : 		(_Mybase&)*this = _Right._Get_rest();
; 360  : 		return (*this);
; 361  : 		}
; 362  : 
; 363  : 	template<class _First,
; 364  : 		class _Second>
; 365  : 		_Myt& operator=(const pair<_First, _Second>& _Right)
; 366  : 		{	// assign by copying pair
; 367  : 		static_assert(_Mysize == 2,
; 368  : 			"assigning to tuple from object with different size");
; 369  : 		_Myfirst._Val = _Right.first;
; 370  : 		(_Mybase&)*this = tuple<_Second>(_Right.second);
; 371  : 		return (*this);
; 372  : 		}
; 373  : 
; 374  : 	template<class _Alloc>
; 375  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 376  : 			_Myt&& _Right)
; 377  : 		: _Mybase(allocator_arg, _Al,
; 378  : 				_STD forward<_Mybase>(_Right._Get_rest())),
; 379  : 			_Myfirst(_Al, _Tuple_alloc,
; 380  : 				_STD forward<_This>(_Right._Myfirst._Val))
; 381  : 		{	// construct by moving, allocator
; 382  : 		}
; 383  : 
; 384  : 	template<class _First,
; 385  : 		class _Second,
; 386  : 		class = typename _Tuple_enable<
; 387  : 			tuple<_First, _Second>, _Myt>::type>
; 388  : 		tuple(pair<_First, _Second>&& _Right)
; 389  : 
; 390  : 		: _Mybase(tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 391  : 			_Myfirst(_STD forward<_First>(_Right.first))
; 392  : 		{	// construct by moving pair
; 393  : 		// no static_assert necessary
; 394  : 		}
; 395  : 
; 396  : 	template<class _Alloc,
; 397  : 		class _First,
; 398  : 		class _Second,
; 399  : 		class = typename _Tuple_enable<
; 400  : 			tuple<_First, _Second>, _Myt>::type>
; 401  : 		tuple(allocator_arg_t, const _Alloc& _Al,
; 402  : 			pair<_First, _Second>&& _Right)
; 403  : 
; 404  : 		: _Mybase(allocator_arg, _Al,
; 405  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))),
; 406  : 			_Myfirst(_Al, _Tuple_alloc,
; 407  : 				_STD forward<_First>(_Right.first))
; 408  : 		{	// construct by moving pair, allocator
; 409  : 		// no static_assert necessary
; 410  : 		}
; 411  : 
; 412  : 	_Myt& operator=(_Myt&& _Right)
; 413  : 		_NOEXCEPT_OP(is_nothrow_move_assignable<_This>::value
; 414  : 			&& is_nothrow_move_assignable<_Mybase>::value)
; 415  : 		{	// assign by moving
; 416  : 		_Myfirst = _STD forward<_This>(_Right._Myfirst._Val);
; 417  : 		(_Mybase&)*this = _STD forward<_Mybase>(_Right._Get_rest());
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	template<class _First,
; 422  : 		class _Second>
; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)
; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);
; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));
; 434  : 		return (*this);
; 435  : 		}
; 436  : 
; 437  : 	_Mybase& _Get_rest()
; 438  : 		{	// get reference to rest of elements
; 439  : 		return (*this);
; 440  : 		}
; 441  : 
; 442  : 	const _Mybase& _Get_rest() const
; 443  : 		{	// get const reference to rest of elements
; 444  : 		return (*this);
; 445  : 		}
; 446  : 
; 447  : 	void swap(tuple& _Right)
; 448  : 		_NOEXCEPT_OP(
; 449  : 			_NOEXCEPT_OP(_Swap_adl(_Myfirst._Val, _Myfirst._Val))
; 450  : 			&& _NOEXCEPT_OP(_Swap_adl((_Mybase&)_Right, (_Mybase&)_Right)))
; 451  : 		{	// swap *this and _Right
; 452  : 		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
; 453  : 		_Mybase::swap((_Mybase&)_Right);
; 454  : 		}
; 455  : 
; 456  : 	_Tuple_val<_This> _Myfirst;	// the stored element
; 457  : 	};
; 458  : 
; 459  : 
; 460  : 	// OPERATORS FOR tuple
; 461  : 
; 462  : template<class... _Types1,
; 463  : 	class... _Types2> inline
; 464  : 	bool operator==(const tuple<_Types1...>& _Left,
; 465  : 		const tuple<_Types2...>& _Right)
; 466  : 	{	// test if _Left == _Right
; 467  : 	return (_Left._Equals(_Right));
; 468  : 	}
; 469  : 
; 470  : template<class... _Types1,
; 471  : 	class... _Types2> inline
; 472  : 	bool operator!=(const tuple<_Types1...>& _Left,
; 473  : 		const tuple<_Types2...>& _Right)
; 474  : 	{	// test if _Left != _Right
; 475  : 	return (!(_Left == _Right));
; 476  : 	}
; 477  : 
; 478  : template<class... _Types1,
; 479  : 	class... _Types2> inline
; 480  : 	bool operator<(const tuple<_Types1...>& _Left,
; 481  : 		const tuple<_Types2...>& _Right)
; 482  : 	{	// test if _Left < _Right
; 483  : 	return (_Left._Less(_Right));
; 484  : 	}
; 485  : 
; 486  : template<class... _Types1,
; 487  : 	class... _Types2> inline
; 488  : 	bool operator>=(const tuple<_Types1...>& _Left,
; 489  : 		const tuple<_Types2...>& _Right)
; 490  : 	{	// test if _Left >= _Right
; 491  : 	return (!(_Left < _Right));
; 492  : 	}
; 493  : 
; 494  : template<class... _Types1,
; 495  : 	class... _Types2> inline
; 496  : 	bool operator>(const tuple<_Types1...>& _Left,
; 497  : 		const tuple<_Types2...>& _Right)
; 498  : 	{	// test if _Left > _Right
; 499  : 	return (_Right < _Left);
; 500  : 	}
; 501  : 
; 502  : template<class... _Types1,
; 503  : 	class... _Types2> inline
; 504  : 	bool operator<=(const tuple<_Types1...>& _Left,
; 505  : 		const tuple<_Types2...>& _Right)
; 506  : 	{	// test if _Left <= _Right
; 507  : 	return (!(_Right < _Left));
; 508  : 	}
; 509  : 
; 510  : template<class... _Types> inline
; 511  : 	void swap(tuple<_Types...>& _Left,
; 512  : 		tuple<_Types...>& _Right)
; 513  : 			_NOEXCEPT_OP(_NOEXCEPT_OP(_Left.swap(_Right)))
; 514  : 	{	// swap _Left and _Right
; 515  : 	return (_Left.swap(_Right));
; 516  : 	}
; 517  : 
; 518  : 
; 519  : 	// CLASS tuple_element
; 520  : template<size_t _Index,
; 521  : 	class _Tuple>
; 522  : 	struct tuple_element;
; 523  : 
; 524  : template<class _This,
; 525  : 	class... _Rest>
; 526  : 	struct tuple_element<0, tuple<_This, _Rest...> >
; 527  : 	{	// select first element
; 528  : 	typedef _This type;
; 529  : 	typedef typename add_lvalue_reference<const _This>::type _Ctype;
; 530  : 	typedef typename add_lvalue_reference<_This>::type _Rtype;
; 531  : 	typedef typename add_rvalue_reference<_This>::type _RRtype;
; 532  : 	typedef tuple<_This, _Rest...> _Ttype;
; 533  : 	};
; 534  : 
; 535  : template<size_t _Index,
; 536  : 	class _This,
; 537  : 	class... _Rest>
; 538  : 	struct tuple_element<_Index, tuple<_This, _Rest...> >
; 539  : 		: public tuple_element<_Index - 1, tuple<_Rest...> >
; 540  : 	{	// recursive tuple_element definition
; 541  : 	};
; 542  : 
; 543  : 
; 544  : template<size_t _Index,
; 545  : 	class _Tuple>
; 546  : 	struct tuple_element<_Index, const _Tuple>
; 547  : 	: public tuple_element<_Index, _Tuple>
; 548  : 	{	// tuple_element for const
; 549  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 550  : 	typedef typename add_const<typename _Mybase::type>::type type;
; 551  : 	};
; 552  : 
; 553  : template<size_t _Index,
; 554  : 	class _Tuple>
; 555  : 	struct tuple_element<_Index, volatile _Tuple>
; 556  : 	: public tuple_element<_Index, _Tuple>
; 557  : 	{	// tuple element for volatile
; 558  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 559  : 	typedef typename add_volatile<typename _Mybase::type>::type type;
; 560  : 	};
; 561  : 
; 562  : template<size_t _Index,
; 563  : 	class _Tuple>
; 564  : 	struct tuple_element<_Index, const volatile _Tuple>
; 565  : 	: public tuple_element<_Index, _Tuple>
; 566  : 	{	// tuple_element for const volatile
; 567  : 	typedef tuple_element<_Index, _Tuple> _Mybase;
; 568  : 	typedef typename add_cv<typename _Mybase::type>::type type;
; 569  : 	};
; 570  : 
; 571  : 	// FUNCTION get
; 572  : template<size_t _Index,
; 573  : 	class... _Types> inline
; 574  : 	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
; 575  : 		get(tuple<_Types...>& _Tuple)
; 576  : 	{	// get reference to _Index element of tuple
; 577  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 578  : 		_Ttype;
; 579  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 580  : 	}
; 581  : 
; 582  : template<size_t _Index,
; 583  : 	class... _Types> inline
; 584  : 	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
; 585  : 		get(const tuple<_Types...>& _Tuple)
; 586  : 	{	// get const reference to _Index element of tuple
; 587  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 588  : 		_Ttype;
; 589  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 590  : 	}
; 591  : 
; 592  : template<size_t _Index,
; 593  : 	class... _Types> inline
; 594  : 	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 595  : 		get(tuple<_Types...>&& _Tuple)
; 596  : 	{	// get rvalue reference to _Index element of tuple
; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 602  : 	}
; 603  : 
; 604  : 	// FUNCTION make_tuple
; 605  : template<class... _Types> inline
; 606  : 	tuple<typename _Unrefwrap<_Types>::type...>
; 607  : 		make_tuple(_Types&&... _Args)
; 608  : 	{	// make tuple from elements
; 609  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 610  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 611  : 	}
; 612  : 
; 613  : 	// FUNCTION tie
; 614  : template<class... _Types> inline
; 615  : 	tuple<_Types&...>
; 616  : 		tie(_Types&... _Args) _NOEXCEPT
; 617  : 	{	// make tuple from elements
; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));
; 620  : 	}
; 621  : 
; 622  : 
; 623  : 	// TEMPLATE FUNCTION forward_as_tuple
; 624  : 
; 625  : template<class... _Types> inline
; 626  : 	tuple<_Types&&...>
; 627  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 628  : 	{	// forward arguments in a tuple
; 629  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 630  : 	}
; 631  : 
; 632  : 
; 633  : 	// TEMPLATE STRUCT _Make_arg_idx AND HELPERS
; 634  : template<class _Arg_idx_type,
; 635  : 	class... _Types>
; 636  : 	struct _Make_arg_idx1
; 637  : 	{	// ends recursion and defines type
; 638  : 	typedef _Arg_idx_type type;
; 639  : 	};
; 640  : 
; 641  : template<size_t... _Indexes,
; 642  : 	class _Ty,
; 643  : 	class... _Types>
; 644  : 	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
; 645  : 		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
; 646  : 	{	// counts a type and recurses
; 647  : 	};
; 648  : 
; 649  : template<class... _Types>
; 650  : 	struct _Make_arg_idx
; 651  : 		: _Make_arg_idx1<_Arg_idx<>, _Types...>
; 652  : 	{	// defines type as _Arg_idx<0, 1, 2... (sizeof...(_Types))-1>
; 653  : 	};
; 654  : 
; 655  : template<class _Arg_idx_type1,
; 656  : 	class _Arg_idx_type2>
; 657  : 	struct _Cat_arg_idx;
; 658  : 
; 659  : template<size_t... _Indexes1,
; 660  : 	size_t... _Indexes2>
; 661  : 	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
; 662  : 	{	// concatenates two _Arg_idx types
; 663  : 	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
; 664  : 	};
; 665  : 
; 666  : template<size_t _Nx,
; 667  : 	class _Ty>
; 668  : 	struct _Repeat_for
; 669  : 		: integral_constant<size_t, _Nx>
; 670  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 671  : 	};
; 672  : 
; 673  : 	// FUNCTION tuple_cat
; 674  : template<class _Ret,
; 675  : 	class _Kx_arg,
; 676  : 	class _Ix_arg,
; 677  : 	size_t _Ix_next,
; 678  : 	class... _Tuples>
; 679  : 	struct _Tuple_cat2
; 680  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 681  : 	static_assert(sizeof...(_Tuples) == 0,
; 682  : 		"Unsupported tuple_cat arguments.");
; 683  : 	typedef _Ret type;
; 684  : 	typedef _Kx_arg _Kx_arg_idx;
; 685  : 	typedef _Ix_arg _Ix_arg_idx;
; 686  : 	};
; 687  : 
; 688  : template<class... _Types1,
; 689  : 	class _Kx_arg,
; 690  : 	size_t... _Ix,
; 691  : 	size_t _Ix_next,
; 692  : 	class... _Types2,
; 693  : 	class... _Rest>
; 694  : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
; 695  : 		tuple<_Types2...>, _Rest...>
; 696  : 		: _Tuple_cat2<
; 697  : 			tuple<_Types1..., _Types2...>,
; 698  : 			typename _Cat_arg_idx<_Kx_arg,
; 699  : 				typename _Make_arg_idx<_Types2...>::type>::type,
; 700  : 			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 701  : 			_Ix_next + 1,
; 702  : 			_Rest...>
; 703  : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 704  : 	};
; 705  : 
; 706  : template<class... _Tuples>
; 707  : 	struct _Tuple_cat1
; 708  : 		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
; 709  : 			typename decay<_Tuples>::type...>
; 710  : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 711  : 	};
; 712  : 
; 713  : template<class _Ret,
; 714  : 	size_t... _Kx,
; 715  : 	size_t... _Ix,
; 716  : 	class _Ty> inline
; 717  : 	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
; 718  : 	{	// concatenate tuples
; 719  : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 720  : 	}
; 721  : 
; 722  : template<class... _Tuples> inline
; 723  : 	typename _Tuple_cat1<_Tuples...>::type
; 724  : 		tuple_cat(_Tuples&&... _Tpls)
; 725  : 	{	// concatenate tuples
; 726  : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 727  : 	return (_Tuple_cat<typename _Cat1::type>(
; 728  : 		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
; 729  : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 730  : 	}
; 731  : 
; 732  : 
; 733  : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, _Arg_idx, _Arg_idx)
; 734  : template<class _Ty1,
; 735  : 	class _Ty2>
; 736  : 	template<class _Tuple1,
; 737  : 		class _Tuple2,
; 738  : 		size_t... _Indexes1,
; 739  : 		size_t... _Indexes2> inline
; 740  : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 741  : 			_Tuple2& _Val2,
; 742  : 			_Arg_idx<_Indexes1...>,
; 743  : 			_Arg_idx<_Indexes2...>)
; 744  : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),
; 745  : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)
; 746  : 		{	// construct from pair of tuples

  0000e	8b ce		 mov	 ecx, esi
  00010	ff 30		 push	 DWORD PTR [eax]
  00012	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00017	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 601  : 		}

  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$$V@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,void *> >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > > >, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > > &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USTextLine@CPythonEventManager@@ABU12@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@ABU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USTextLine@CPythonEventManager@@ABU12@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@ABU23@@Z PROC ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::construct<CPythonEventManager::STextLine,CPythonEventManager::STextLine const &>, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 601  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@USTextLine@CPythonEventManager@@ABU12@@?$allocator@U?$_List_node@USTextLine@CPythonEventManager@@PAX@std@@@std@@QAEXPAUSTextLine@CPythonEventManager@@ABU23@@Z ENDP ; std::allocator<std::_List_node<CPythonEventManager::STextLine,void *> >::construct<CPythonEventManager::STextLine,CPythonEventManager::STextLine const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAX@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAX@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&,void * *>, COMDAT
; _this$ = ecx

; 258  : 		{	// construct by moving same size tuple

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   : 		{	// construct with argument

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 259  : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAX@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&,void * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$$V@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$$V@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>, COMDAT
; _this$ = ecx

; 762  : 		{	// construct from pair of tuples

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 746  : 		{	// construct from pair of tuples

  00004	ff 75 0c	 push	 DWORD PTR __Val1$[ebp]

; 762  : 		{	// construct from pair of tuples

  00007	8b f1		 mov	 esi, ecx

; 746  : 		{	// construct from pair of tuples

  00009	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0000e	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 763  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$$V@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ?_Get_rest@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEAAV?$tuple@$$$V@2@XZ
_TEXT	SEGMENT
?_Get_rest@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEAAV?$tuple@$$$V@2@XZ PROC ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::_Get_rest, COMDAT
; _this$ = ecx

; 439  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 440  : 		}

  00002	c3		 ret	 0
?_Get_rest@?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEAAV?$tuple@$$$V@2@XZ ENDP ; std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$?0V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@AAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$?0V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@AAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int><std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<>,0>, COMDAT
; _this$ = ecx

; 746  : 		{	// construct from pair of tuples

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	ff 30		 push	 DWORD PTR [eax]
  0000b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 747  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	5d		 pop	 ebp
  0001b	c2 10 00	 ret	 16			; 00000010H
??$?0V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$$V@1@$0A@$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@QAE@AAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AAV?$tuple@$$$V@1@U?$_Arg_idx@$0A@@1@U?$_Arg_idx@$S@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int><std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z PROC ; std::move<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&> &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z ENDP ; std::move<std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\tuple
;	COMDAT ??$get@$0A@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::get<0,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>, COMDAT

; 596  : 	{	// get rvalue reference to _Index element of tuple

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 597  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 598  : 		_Ttype;
; 599  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
; 600  : 		_RRtype;
; 601  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Tuple$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 602  : 	}

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$get@$0A@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::get<0,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CGraphicTextInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 18   : 		{

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0000c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000f	85 c0		 test	 eax, eax
  00011	74 1e		 je	 SHORT $LN8@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0001c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00023	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  0002a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@scalar:

; 1623 : 		if (this->_Myfirst != pointer())

  00031	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00034	85 c0		 test	 eax, eax
  00036	74 1e		 je	 SHORT $LN21@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00041	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN21@scalar:
  00056	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005a	74 09		 je	 SHORT $LN32@scalar
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00062	83 c4 04	 add	 esp, 4
$LN32@scalar:
  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CGraphicTextInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCGraphicTextInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicTextInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCGraphicTextInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicTextInstance@@0@Z PROC ; std::_Ptr_cat<CGraphicTextInstance *,CGraphicTextInstance *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCGraphicTextInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicTextInstance@@0@Z ENDP ; std::_Ptr_cat<CGraphicTextInstance *,CGraphicTextInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXPAPAVCGraphicTextInstance@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXPAPAVCGraphicTextInstance@@0@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXPAPAVCGraphicTextInstance@@0@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@I@Z PROC ; std::allocator<CGraphicTextInstance *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXPAPAVCGraphicTextInstance@@I@Z ENDP ; std::allocator<CGraphicTextInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXPAPAVCGraphicTextInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCGraphicTextInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCGraphicTextInstance@@@std@@QAE@XZ PROC ; std::allocator<CGraphicTextInstance *>::allocator<CGraphicTextInstance *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCGraphicTextInstance@@@std@@QAE@XZ ENDP ; std::allocator<CGraphicTextInstance *>::allocator<CGraphicTextInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >::_Wrap_alloc<std::allocator<CGraphicTextInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicTextInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::~vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::~vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h
;	COMDAT ??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ PROC	; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN5@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00020	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00027	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN5@CDynamicPo:

; 1623 : 		if (this->_Myfirst != pointer())

  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	85 c0		 test	 eax, eax
  00033	74 1e		 je	 SHORT $LN18@CDynamicPo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004c	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN18@CDynamicPo:
  00053	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterlib\pool.h

; 26   : 		}

  00054	c3		 ret	 0
??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ ENDP	; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1682 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 513  : 			: this->_Bx._Buf);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1691 : 		return (this->_Myptr()[_Off]);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]

; 513  : 			: this->_Bx._Buf);

  0000a	72 02		 jb	 SHORT $LN5@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1691 : 		return (this->_Myptr()[_Off]);

  0000e	03 c1		 add	 eax, ecx

; 1692 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
END
