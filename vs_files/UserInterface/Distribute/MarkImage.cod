; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\MarkImage.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initiali@ ; `string'
PUBLIC	??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fil@ ; `string'
PUBLIC	??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5b@ ; `string'
PUBLIC	??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must?5@ ; `string'
PUBLIC	??_C@_0DM@NNKMJGHN@CGuildMarkImage?3?3CopyMarkFromDat@ ; `string'
PUBLIC	??_C@_0BG@PFKANOHB@PutMark?5pos?5?$CFu?5?$CFux?$CFu?6?$AA@ ; `string'
PUBLIC	??_C@_0FG@IJMAAEIA@CGuildMarkImage?3?3CopyBlockFromCo@ ; `string'
PUBLIC	??_C@_0FG@JNKKBOCL@CGuildMarkImage?3?3CopyBlockFromCo@ ; `string'
PUBLIC	??_C@_0CA@JFLGBLGM@CGuildMarkImage?3?3BuildAllBlocks?$AA@ ; `string'
PUBLIC	??_C@_0CK@BGEKGKPD@SGuildMarkBlock?3?3Compress?3?5Error@ ; `string'
PUBLIC	??_R2CGuildMarkImage@@8				; CGuildMarkImage::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGuildMarkImage@@8		; CGuildMarkImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CGuildMarkImage@@8				; CGuildMarkImage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCGuildMarkImage@@@8			; CGuildMarkImage `RTTI Type Descriptor'
PUBLIC	??_R4CGuildMarkImage@@6B@			; CGuildMarkImage::`RTTI Complete Object Locator'
PUBLIC	?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A	; CSingleton<CLZO>::ms_singleton
PUBLIC	??_7CGuildMarkImage@@6B@			; CGuildMarkImage::`vftable'
EXTRN	_lzo1x_999_compress:PROC
EXTRN	?GetCRC32@@YAKPBDI@Z:PROC			; GetCRC32
EXTRN	?GetWorkMemory@CLZO@@QAEPAEXZ:PROC		; CLZO::GetWorkMemory
EXTRN	_lzo1x_decompress_safe:PROC
EXTRN	_printf:PROC
EXTRN	__imp__ilSetPixels@36:PROC
EXTRN	_free:PROC
EXTRN	__imp__ilTexImage@28:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__ilSave@8:PROC
;	COMDAT ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A DD 01H DUP (?) ; CSingleton<CLZO>::ms_singleton
_BSS	ENDS
;	COMDAT ??_7CGuildMarkImage@@6B@
CONST	SEGMENT
??_7CGuildMarkImage@@6B@ DD FLAT:??_R4CGuildMarkImage@@6B@ ; CGuildMarkImage::`vftable'
	DD	FLAT:??_ECGuildMarkImage@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CGuildMarkImage@@6B@
rdata$r	SEGMENT
??_R4CGuildMarkImage@@6B@ DD 00H			; CGuildMarkImage::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGuildMarkImage@@@8
	DD	FLAT:??_R3CGuildMarkImage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGuildMarkImage@@@8
data$r	SEGMENT
??_R0?AVCGuildMarkImage@@@8 DD FLAT:??_7type_info@@6B@	; CGuildMarkImage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGuildMarkImage@@', 00H
data$r	ENDS
;	COMDAT ??_R3CGuildMarkImage@@8
rdata$r	SEGMENT
??_R3CGuildMarkImage@@8 DD 00H				; CGuildMarkImage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGuildMarkImage@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGuildMarkImage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGuildMarkImage@@8 DD FLAT:??_R0?AVCGuildMarkImage@@@8 ; CGuildMarkImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGuildMarkImage@@8
rdata$r	ENDS
;	COMDAT ??_R2CGuildMarkImage@@8
rdata$r	SEGMENT
??_R2CGuildMarkImage@@8 DD FLAT:??_R1A@?0A@EA@CGuildMarkImage@@8 ; CGuildMarkImage::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_C@_0CK@BGEKGKPD@SGuildMarkBlock?3?3Compress?3?5Error@
CONST	SEGMENT
??_C@_0CK@BGEKGKPD@SGuildMarkBlock?3?3Compress?3?5Error@ DB 'SGuildMarkBl'
	DB	'ock::Compress: Error! %u > %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JFLGBLGM@CGuildMarkImage?3?3BuildAllBlocks?$AA@
CONST	SEGMENT
??_C@_0CA@JFLGBLGM@CGuildMarkImage?3?3BuildAllBlocks?$AA@ DB 'CGuildMarkI'
	DB	'mage::BuildAllBlocks', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@JNKKBOCL@CGuildMarkImage?3?3CopyBlockFromCo@
CONST	SEGMENT
??_C@_0FG@JNKKBOCL@CGuildMarkImage?3?3CopyBlockFromCo@ DB 'CGuildMarkImag'
	DB	'e::CopyBlockFromCompressedData: image corrupted, decompressed'
	DB	' size = %u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@IJMAAEIA@CGuildMarkImage?3?3CopyBlockFromCo@
CONST	SEGMENT
??_C@_0FG@IJMAAEIA@CGuildMarkImage?3?3CopyBlockFromCo@ DB 'CGuildMarkImag'
	DB	'e::CopyBlockFromCompressedData: cannot decompress, compressed'
	DB	' size = %u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PFKANOHB@PutMark?5pos?5?$CFu?5?$CFux?$CFu?6?$AA@
CONST	SEGMENT
??_C@_0BG@PFKANOHB@PutMark?5pos?5?$CFu?5?$CFux?$CFu?6?$AA@ DB 'PutMark po'
	DB	's %u %ux%u', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@NNKMJGHN@CGuildMarkImage?3?3CopyMarkFromDat@
CONST	SEGMENT
??_C@_0DM@NNKMJGHN@CGuildMarkImage?3?3CopyMarkFromDat@ DB 'CGuildMarkImag'
	DB	'e::CopyMarkFromData: Invalid mark position %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must?5@
CONST	SEGMENT
??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must?5@ DB 'CGuildMa'
	DB	'rkImage: %s height must be %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5b@
CONST	SEGMENT
??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5b@ DB 'CGuildMa'
	DB	'rkImage: %s width must be %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fil@
CONST	SEGMENT
??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fil@ DB 'CGuildMarkIm'
	DB	'age: cannot open file for writing %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initiali@
CONST	SEGMENT
??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initiali@ DB 'CGuildMarkIma'
	DB	'ge: cannot initialize image', 00H		; `string'
PUBLIC	??R?$less@E@std@@QBE_NABE0@Z			; std::less<unsigned char>::operator()
PUBLIC	?Instance@?$CSingleton@VCLZO@@@@SAAAVCLZO@@XZ	; CSingleton<CLZO>::Instance
PUBLIC	?Compress@SGuildMarkBlock@@QAEXPBK@Z		; SGuildMarkBlock::Compress
PUBLIC	?CopyFrom@SGuildMarkBlock@@QAEXPBEKK@Z		; SGuildMarkBlock::CopyFrom
PUBLIC	?GetCRC@SGuildMarkBlock@@QBEKXZ			; SGuildMarkBlock::GetCRC
PUBLIC	?GetBlockCRCList@CGuildMarkImage@@QAEXPAK@Z	; CGuildMarkImage::GetBlockCRCList
PUBLIC	?BuildAllBlocks@CGuildMarkImage@@AAEXXZ		; CGuildMarkImage::BuildAllBlocks
PUBLIC	?SaveBlockFromCompressedData@CGuildMarkImage@@QAE_NKPBEK@Z ; CGuildMarkImage::SaveBlockFromCompressedData
PUBLIC	?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z		; CGuildMarkImage::GetData
PUBLIC	?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z		; CGuildMarkImage::PutData
PUBLIC	?Load@CGuildMarkImage@@QAE_NPBD@Z		; CGuildMarkImage::Load
PUBLIC	?Build@CGuildMarkImage@@QAE_NPBD@Z		; CGuildMarkImage::Build
PUBLIC	?Save@CGuildMarkImage@@QAE_NPBD@Z		; CGuildMarkImage::Save
PUBLIC	?Create@CGuildMarkImage@@QAEXXZ			; CGuildMarkImage::Create
PUBLIC	?Destroy@CGuildMarkImage@@QAEXXZ		; CGuildMarkImage::Destroy
PUBLIC	??1CGuildMarkImage@@UAE@XZ			; CGuildMarkImage::~CGuildMarkImage
PUBLIC	??_GCGuildMarkImage@@UAEPAXI@Z			; CGuildMarkImage::`scalar deleting destructor'
PUBLIC	??0CGuildMarkImage@@QAE@XZ			; CGuildMarkImage::CGuildMarkImage
EXTRN	??_ECGuildMarkImage@@UAEPAXI@Z:PROC		; CGuildMarkImage::`vector deleting destructor'
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ??0CGuildMarkImage@@QAE@XZ
_TEXT	SEGMENT
??0CGuildMarkImage@@QAE@XZ PROC				; CGuildMarkImage::CGuildMarkImage, COMDAT
; _this$ = ecx

; 28   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CGuildMarkImage@@6B@

; 29   : 	m_uImg = INVALID_HANDLE;
; 30   : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 81 c4 07 5f
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+6227908], -1
  00012	c3		 ret	 0
??0CGuildMarkImage@@QAE@XZ ENDP				; CGuildMarkImage::CGuildMarkImage
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCGuildMarkImage@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCGuildMarkImage@@UAEPAXI@Z PROC			; CGuildMarkImage::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CGuildMarkImage@@UAE@XZ ; CGuildMarkImage::~CGuildMarkImage
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCGuildMarkImage@@UAEPAXI@Z ENDP			; CGuildMarkImage::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ??1CGuildMarkImage@@UAE@XZ
_TEXT	SEGMENT
??1CGuildMarkImage@@UAE@XZ PROC				; CGuildMarkImage::~CGuildMarkImage, COMDAT
; _this$ = ecx

; 33   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CGuildMarkImage@@6B@

; 34   : 	Destroy();

  00006	e9 00 00 00 00	 jmp	 ?Destroy@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Destroy
??1CGuildMarkImage@@UAE@XZ ENDP				; CGuildMarkImage::~CGuildMarkImage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?Destroy@CGuildMarkImage@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CGuildMarkImage@@QAEXXZ PROC			; CGuildMarkImage::Destroy, COMDAT
; _this$ = ecx

; 39   : 	if (INVALID_HANDLE == m_uImg)

  00000	83 b9 c4 07 5f
	00 ff		 cmp	 DWORD PTR [ecx+6227908], -1
  00007	56		 push	 esi
  00008	8d b1 c4 07 5f
	00		 lea	 esi, DWORD PTR [ecx+6227908]
  0000e	74 0f		 je	 SHORT $LN2@Destroy

; 40   : 		return;
; 41   : 
; 42   : 	ilDeleteImages(1, &m_uImg);

  00010	56		 push	 esi
  00011	6a 01		 push	 1
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilDeleteImages@8

; 43   : 	m_uImg = INVALID_HANDLE;

  00019	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN2@Destroy:
  0001f	5e		 pop	 esi

; 44   : }

  00020	c3		 ret	 0
?Destroy@CGuildMarkImage@@QAEXXZ ENDP			; CGuildMarkImage::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?Create@CGuildMarkImage@@QAEXXZ
_TEXT	SEGMENT
?Create@CGuildMarkImage@@QAEXXZ PROC			; CGuildMarkImage::Create, COMDAT
; _this$ = ecx

; 48   : 	if (INVALID_HANDLE != m_uImg)

  00000	81 c1 c4 07 5f
	00		 add	 ecx, 6227908		; 005f07c4H
  00006	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00009	75 09		 jne	 SHORT $LN2@Create

; 49   : 		return;
; 50   : 
; 51   : 	ilGenImages(1, &m_uImg);

  0000b	51		 push	 ecx
  0000c	6a 01		 push	 1
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilGenImages@8
$LN2@Create:

; 52   : }

  00014	c3		 ret	 0
?Create@CGuildMarkImage@@QAEXXZ ENDP			; CGuildMarkImage::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?Save@CGuildMarkImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?Save@CGuildMarkImage@@QAE_NPBD@Z PROC			; CGuildMarkImage::Save, COMDAT
; _this$ = ecx

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 56   : 	ilEnable(IL_FILE_OVERWRITE);

  00004	68 20 06 00 00	 push	 1568			; 00000620H
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 57   : 	ilBindImage(m_uImg);

  00011	ff b6 c4 07 5f
	00		 push	 DWORD PTR [esi+6227908]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 58   : 
; 59   : 	if (!ilSave(IL_TGA, (const ILstring)c_szFileName))

  0001d	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00020	68 2d 04 00 00	 push	 1069			; 0000042dH
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilSave@8
  0002b	84 c0		 test	 al, al
  0002d	5e		 pop	 esi
  0002e	0f 95 c0	 setne	 al

; 60   : 		return false;
; 61   : 
; 62   : 	return true;
; 63   : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?Save@CGuildMarkImage@@QAE_NPBD@Z ENDP			; CGuildMarkImage::Save
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?Build@CGuildMarkImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?Build@CGuildMarkImage@@QAE_NPBD@Z PROC			; CGuildMarkImage::Build, COMDAT
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 67   : 	Destroy();

  00006	e8 00 00 00 00	 call	 ?Destroy@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Destroy

; 68   : 	Create();

  0000b	8b ce		 mov	 ecx, esi
  0000d	e8 00 00 00 00	 call	 ?Create@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Create

; 69   : 
; 70   : 	ilBindImage(m_uImg);

  00012	ff b6 c4 07 5f
	00		 push	 DWORD PTR [esi+6227908]
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 71   : 	ilEnable(IL_ORIGIN_SET);

  0001e	68 00 06 00 00	 push	 1536			; 00000600H
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 72   : 	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);

  00029	68 02 06 00 00	 push	 1538			; 00000602H
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilOriginFunc@4

; 73   : 
; 74   : 	BYTE * data = (BYTE *) malloc(sizeof(Pixel) * WIDTH * HEIGHT);

  00034	68 00 00 10 00	 push	 1048576			; 00100000H
  00039	e8 00 00 00 00	 call	 _malloc

; 75   : 	memset(data, 0, sizeof(Pixel) * WIDTH * HEIGHT);

  0003e	68 00 00 10 00	 push	 1048576			; 00100000H
  00043	8b f0		 mov	 esi, eax
  00045	6a 00		 push	 0
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 _memset
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 76   : 
; 77   : 	if (!ilTexImage(WIDTH, HEIGHT, 1, 4, IL_BGRA, IL_UNSIGNED_BYTE, data))

  00050	56		 push	 esi
  00051	68 01 14 00 00	 push	 5121			; 00001401H
  00056	68 e1 80 00 00	 push	 32993			; 000080e1H
  0005b	6a 04		 push	 4
  0005d	6a 01		 push	 1
  0005f	68 00 02 00 00	 push	 512			; 00000200H
  00064	68 00 02 00 00	 push	 512			; 00000200H
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilTexImage@28
  0006f	84 c0		 test	 al, al
  00071	75 14		 jne	 SHORT $LN2@Build

; 78   : 	{
; 79   : 		sys_err("CGuildMarkImage: cannot initialize image");

  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initiali@
  00078	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0007d	83 c4 04	 add	 esp, 4

; 80   : 		return false;

  00080	32 c0		 xor	 al, al
  00082	5e		 pop	 esi

; 88   : 		return false;
; 89   : 
; 90   : 	return true;
; 91   : }

  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
$LN2@Build:

; 81   : 	}
; 82   : 
; 83   : 	free(data);

  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 _free
  0008d	83 c4 04	 add	 esp, 4

; 84   : 
; 85   : 	ilEnable(IL_FILE_OVERWRITE);

  00090	68 20 06 00 00	 push	 1568			; 00000620H
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 86   : 
; 87   : 	if (!ilSave(IL_TGA, (const ILstring)c_szFileName))

  0009b	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  0009e	68 2d 04 00 00	 push	 1069			; 0000042dH
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilSave@8
  000a9	84 c0		 test	 al, al
  000ab	5e		 pop	 esi
  000ac	0f 95 c0	 setne	 al

; 88   : 		return false;
; 89   : 
; 90   : 	return true;
; 91   : }

  000af	5d		 pop	 ebp
  000b0	c2 04 00	 ret	 4
?Build@CGuildMarkImage@@QAE_NPBD@Z ENDP			; CGuildMarkImage::Build
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?Load@CGuildMarkImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?Load@CGuildMarkImage@@QAE_NPBD@Z PROC			; CGuildMarkImage::Load, COMDAT
; _this$ = ecx

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 95   : 	Destroy();

  00007	e8 00 00 00 00	 call	 ?Destroy@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Destroy

; 96   : 	Create();	

  0000c	8b cf		 mov	 ecx, edi
  0000e	e8 00 00 00 00	 call	 ?Create@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Create

; 97   : 
; 98   : 	ilBindImage(m_uImg);

  00013	ff b7 c4 07 5f
	00		 push	 DWORD PTR [edi+6227908]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 99   : 	ilEnable(IL_ORIGIN_SET);

  0001f	68 00 06 00 00	 push	 1536			; 00000600H
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 100  : 	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);

  0002a	68 02 06 00 00	 push	 1538			; 00000602H
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilOriginFunc@4

; 101  : 
; 102  : 	if (!ilLoad(IL_TYPE_UNKNOWN, (const ILstring) c_szFileName))

  00035	8b 75 08	 mov	 esi, DWORD PTR _c_szFileName$[ebp]
  00038	56		 push	 esi
  00039	6a 00		 push	 0
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilLoad@8
  00041	84 c0		 test	 al, al
  00043	75 2a		 jne	 SHORT $LN3@Load

; 103  : 	{
; 104  : 		Build(c_szFileName);

  00045	56		 push	 esi
  00046	8b cf		 mov	 ecx, edi
  00048	e8 00 00 00 00	 call	 ?Build@CGuildMarkImage@@QAE_NPBD@Z ; CGuildMarkImage::Build

; 105  : 		
; 106  : 		if (!Load(c_szFileName))

  0004d	56		 push	 esi
  0004e	8b cf		 mov	 ecx, edi
  00050	e8 00 00 00 00	 call	 ?Load@CGuildMarkImage@@QAE_NPBD@Z ; CGuildMarkImage::Load
  00055	84 c0		 test	 al, al
  00057	75 16		 jne	 SHORT $LN3@Load

; 107  : 		{
; 108  : 			sys_err("CGuildMarkImage: cannot open file for writing %s", c_szFileName);

  00059	56		 push	 esi
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fil@
  0005f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00064	83 c4 08	 add	 esp, 8

; 109  : 			return false;

  00067	32 c0		 xor	 al, al
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi

; 129  : }

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
$LN3@Load:

; 110  : 		}
; 111  : 	}
; 112  : 
; 113  : 	if (ilGetInteger(IL_IMAGE_WIDTH) != WIDTH)	

  0006f	68 e4 0d 00 00	 push	 3556			; 00000de4H
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilGetInteger@4
  0007a	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  0007f	74 1b		 je	 SHORT $LN2@Load

; 114  : 	{
; 115  : 		sys_err("CGuildMarkImage: %s width must be %u", c_szFileName, WIDTH);

  00081	68 00 02 00 00	 push	 512			; 00000200H
  00086	56		 push	 esi
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5b@
  0008c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 116  : 		return false;

  00094	32 c0		 xor	 al, al
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi

; 129  : }

  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
$LN2@Load:

; 117  : 	}
; 118  : 
; 119  : 	if (ilGetInteger(IL_IMAGE_HEIGHT) != HEIGHT)

  0009c	68 e5 0d 00 00	 push	 3557			; 00000de5H
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilGetInteger@4
  000a7	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  000ac	74 1b		 je	 SHORT $LN1@Load

; 120  : 	{
; 121  : 		sys_err("CGuildMarkImage: %s height must be %u", c_szFileName, HEIGHT);

  000ae	68 00 02 00 00	 push	 512			; 00000200H
  000b3	56		 push	 esi
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must?5@
  000b9	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 122  : 		return false;

  000c1	32 c0		 xor	 al, al
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi

; 129  : }

  000c5	5d		 pop	 ebp
  000c6	c2 04 00	 ret	 4
$LN1@Load:

; 123  : 	}
; 124  : 
; 125  : 	ilConvertImage(IL_BGRA, IL_UNSIGNED_BYTE);

  000c9	68 01 14 00 00	 push	 5121			; 00001401H
  000ce	68 e1 80 00 00	 push	 32993			; 000080e1H
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilConvertImage@8

; 126  : 
; 127  : 	BuildAllBlocks();

  000d9	8b cf		 mov	 ecx, edi
  000db	e8 00 00 00 00	 call	 ?BuildAllBlocks@CGuildMarkImage@@AAEXXZ ; CGuildMarkImage::BuildAllBlocks
  000e0	5f		 pop	 edi

; 128  : 	return true;

  000e1	b0 01		 mov	 al, 1
  000e3	5e		 pop	 esi

; 129  : }

  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
?Load@CGuildMarkImage@@QAE_NPBD@Z ENDP			; CGuildMarkImage::Load
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$dead$ = 16					; size = 4
_height$dead$ = 20					; size = 4
_data$ = 24						; size = 4
?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z PROC		; CGuildMarkImage::PutData, COMDAT
; _this$ = ecx

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 133  : 	ilBindImage(m_uImg);

  00003	ff b1 c4 07 5f
	00		 push	 DWORD PTR [ecx+6227908]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 134  : 	ilSetPixels(x, y, 0, width, height, 1, IL_BGRA, IL_UNSIGNED_BYTE, data);

  0000f	ff 75 18	 push	 DWORD PTR _data$[ebp]
  00012	68 01 14 00 00	 push	 5121			; 00001401H
  00017	68 e1 80 00 00	 push	 32993			; 000080e1H
  0001c	6a 01		 push	 1
  0001e	6a 30		 push	 48			; 00000030H
  00020	6a 40		 push	 64			; 00000040H
  00022	6a 00		 push	 0
  00024	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00027	ff 75 08	 push	 DWORD PTR _x$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilSetPixels@36

; 135  : }

  00030	5d		 pop	 ebp
  00031	c2 14 00	 ret	 20			; 00000014H
?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z ENDP		; CGuildMarkImage::PutData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$dead$ = 16					; size = 4
_height$dead$ = 20					; size = 4
_data$ = 24						; size = 4
?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z PROC		; CGuildMarkImage::GetData, COMDAT
; _this$ = ecx

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  : 	ilBindImage(m_uImg);

  00003	ff b1 c4 07 5f
	00		 push	 DWORD PTR [ecx+6227908]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 140  : 	ilCopyPixels(x, y, 0, width, height, 1, IL_BGRA, IL_UNSIGNED_BYTE, data);	

  0000f	ff 75 18	 push	 DWORD PTR _data$[ebp]
  00012	68 01 14 00 00	 push	 5121			; 00001401H
  00017	68 e1 80 00 00	 push	 32993			; 000080e1H
  0001c	6a 01		 push	 1
  0001e	6a 30		 push	 48			; 00000030H
  00020	6a 40		 push	 64			; 00000040H
  00022	6a 00		 push	 0
  00024	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00027	ff 75 08	 push	 DWORD PTR _x$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilCopyPixels@36

; 141  : }

  00030	5d		 pop	 ebp
  00031	c2 14 00	 ret	 20			; 00000014H
?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z ENDP		; CGuildMarkImage::GetData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?SaveBlockFromCompressedData@CGuildMarkImage@@QAE_NKPBEK@Z
_TEXT	SEGMENT
_pbComp$GSCopy$1$ = -12304				; size = 4
_sizeBuf$ = -12300					; size = 4
_this$GSCopy$1$ = -12296				; size = 4
_apxBuf$ = -12292					; size = 12288
__$ArrayPad$ = -4					; size = 4
_posBlock$ = 8						; size = 4
_pbComp$ = 12						; size = 4
_dwCompSize$ = 16					; size = 4
?SaveBlockFromCompressedData@CGuildMarkImage@@QAE_NKPBEK@Z PROC ; CGuildMarkImage::SaveBlockFromCompressedData, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 10 30 00 00	 mov	 eax, 12304		; 00003010H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _pbComp$[ebp]
  0001b	57		 push	 edi

; 184  : 	if (posBlock >= BLOCK_TOTAL_COUNT)

  0001c	8b 7d 08	 mov	 edi, DWORD PTR _posBlock$[ebp]
  0001f	89 8d f8 cf ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00025	89 b5 f0 cf ff
	ff		 mov	 DWORD PTR _pbComp$GSCopy$1$[ebp], esi
  0002b	83 ff 50	 cmp	 edi, 80			; 00000050H
  0002e	72 14		 jb	 SHORT $LN3@SaveBlockF

; 185  : 		return false;

  00030	5f		 pop	 edi
  00031	32 c0		 xor	 al, al
  00033	5e		 pop	 esi

; 208  : 	return true;
; 209  : }

  00034	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00037	33 cd		 xor	 ecx, ebp
  00039	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 0c 00	 ret	 12			; 0000000cH
$LN3@SaveBlockF:

; 186  : 
; 187  : 	Pixel apxBuf[SGuildMarkBlock::SIZE];
; 188  : 	size_t sizeBuf = sizeof(apxBuf);
; 189  : 
; 190  : 	if (LZO_E_OK != lzo1x_decompress_safe(pbComp, dwCompSize, (BYTE *) apxBuf, (lzo_uint*) &sizeBuf, CLZO::Instance().GetWorkMemory()))

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  0004a	53		 push	 ebx
  0004b	c7 85 f4 cf ff
	ff 00 30 00 00	 mov	 DWORD PTR _sizeBuf$[ebp], 12288 ; 00003000H
  00055	e8 00 00 00 00	 call	 ?GetWorkMemory@CLZO@@QAEPAEXZ ; CLZO::GetWorkMemory
  0005a	8b 5d 10	 mov	 ebx, DWORD PTR _dwCompSize$[ebp]
  0005d	50		 push	 eax
  0005e	8d 85 f4 cf ff
	ff		 lea	 eax, DWORD PTR _sizeBuf$[ebp]
  00064	50		 push	 eax
  00065	8d 85 fc cf ff
	ff		 lea	 eax, DWORD PTR _apxBuf$[ebp]
  0006b	50		 push	 eax
  0006c	53		 push	 ebx
  0006d	56		 push	 esi
  0006e	e8 00 00 00 00	 call	 _lzo1x_decompress_safe
  00073	83 c4 14	 add	 esp, 20			; 00000014H
  00076	85 c0		 test	 eax, eax
  00078	74 23		 je	 SHORT $LN2@SaveBlockF

; 191  : 	{
; 192  : 		sys_err("CGuildMarkImage::CopyBlockFromCompressedData: cannot decompress, compressed size = %u", dwCompSize);

  0007a	53		 push	 ebx
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@IJMAAEIA@CGuildMarkImage?3?3CopyBlockFromCo@
  00080	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00085	83 c4 08	 add	 esp, 8

; 193  : 		return false;

  00088	32 c0		 xor	 al, al
  0008a	5b		 pop	 ebx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi

; 208  : 	return true;
; 209  : }

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00090	33 cd		 xor	 ecx, ebp
  00092	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SaveBlockF:

; 194  : 	}
; 195  : 
; 196  : 	if (sizeBuf != sizeof(apxBuf))

  0009d	8b 85 f4 cf ff
	ff		 mov	 eax, DWORD PTR _sizeBuf$[ebp]
  000a3	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  000a8	74 23		 je	 SHORT $LN1@SaveBlockF

; 197  : 	{
; 198  : 		sys_err("CGuildMarkImage::CopyBlockFromCompressedData: image corrupted, decompressed size = %u", sizeBuf);

  000aa	50		 push	 eax
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@JNKKBOCL@CGuildMarkImage?3?3CopyBlockFromCo@
  000b0	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000b5	83 c4 08	 add	 esp, 8

; 199  : 		return false;

  000b8	32 c0		 xor	 al, al
  000ba	5b		 pop	 ebx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi

; 208  : 	return true;
; 209  : }

  000bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c0	33 cd		 xor	 ecx, ebp
  000c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 0c 00	 ret	 12			; 0000000cH
$LN1@SaveBlockF:

; 200  : 	}
; 201  : 
; 202  : 	DWORD rowBlock = posBlock / BLOCK_COL_COUNT;
; 203  : 	DWORD colBlock = posBlock % BLOCK_COL_COUNT;
; 204  : 
; 205  : 	PutData(colBlock * SGuildMarkBlock::WIDTH, rowBlock * SGuildMarkBlock::HEIGHT, SGuildMarkBlock::WIDTH, SGuildMarkBlock::HEIGHT, apxBuf);

  000cd	8b 8d f8 cf ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000d3	8d 85 fc cf ff
	ff		 lea	 eax, DWORD PTR _apxBuf$[ebp]
  000d9	50		 push	 eax
  000da	8b f7		 mov	 esi, edi
  000dc	83 ec 08	 sub	 esp, 8
  000df	c1 ee 03	 shr	 esi, 3
  000e2	83 e7 07	 and	 edi, 7
  000e5	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  000e8	c1 e0 04	 shl	 eax, 4
  000eb	50		 push	 eax
  000ec	8b c7		 mov	 eax, edi
  000ee	c1 e0 06	 shl	 eax, 6
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 ?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z ; CGuildMarkImage::PutData

; 206  : 
; 207  : 	m_aakBlock[rowBlock][colBlock].CopyFrom(pbComp, dwCompSize, GetCRC32((const char *) apxBuf, sizeof(Pixel) * SGuildMarkBlock::SIZE));

  000f7	8d 85 fc cf ff
	ff		 lea	 eax, DWORD PTR _apxBuf$[ebp]
  000fd	68 00 30 00 00	 push	 12288			; 00003000H
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  00108	8b 8d f8 cf ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0010e	83 c4 08	 add	 esp, 8
  00111	83 c1 04	 add	 ecx, 4
  00114	50		 push	 eax
  00115	8d 04 f7	 lea	 eax, DWORD PTR [edi+esi*8]
  00118	69 c0 4c 63 00
	00		 imul	 eax, eax, 25420
  0011e	53		 push	 ebx
  0011f	ff b5 f0 cf ff
	ff		 push	 DWORD PTR _pbComp$GSCopy$1$[ebp]
  00125	03 c8		 add	 ecx, eax
  00127	e8 00 00 00 00	 call	 ?CopyFrom@SGuildMarkBlock@@QAEXPBEKK@Z ; SGuildMarkBlock::CopyFrom

; 208  : 	return true;
; 209  : }

  0012c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012f	b0 01		 mov	 al, 1
  00131	5b		 pop	 ebx
  00132	5f		 pop	 edi
  00133	33 cd		 xor	 ecx, ebp
  00135	5e		 pop	 esi
  00136	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 0c 00	 ret	 12			; 0000000cH
?SaveBlockFromCompressedData@CGuildMarkImage@@QAE_NKPBEK@Z ENDP ; CGuildMarkImage::SaveBlockFromCompressedData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?BuildAllBlocks@CGuildMarkImage@@AAEXXZ
_TEXT	SEGMENT
_this$GSCopy$1$ = -12296				; size = 4
_apxBuf$ = -12292					; size = 12288
__$ArrayPad$ = -4					; size = 4
?BuildAllBlocks@CGuildMarkImage@@AAEXXZ PROC		; CGuildMarkImage::BuildAllBlocks, COMDAT
; _this$ = ecx

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 08 30 00 00	 mov	 eax, 12296		; 00003008H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b c1		 mov	 eax, ecx
  0001a	33 db		 xor	 ebx, ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 85 f8 cf ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax
  00024	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
$LL6@BuildAllBl:

; 217  : 		for (UINT col = 0; col < BLOCK_COL_COUNT; ++col)

  00027	33 f6		 xor	 esi, esi
  00029	8d a4 24 00 00
	00 00		 npad	 7
$LL3@BuildAllBl:

; 218  : 		{
; 219  : 			GetData(col * SGuildMarkBlock::WIDTH, row * SGuildMarkBlock::HEIGHT, SGuildMarkBlock::WIDTH, SGuildMarkBlock::HEIGHT, apxBuf);

  00030	8d 8d fc cf ff
	ff		 lea	 ecx, DWORD PTR _apxBuf$[ebp]
  00036	51		 push	 ecx
  00037	83 ec 08	 sub	 esp, 8
  0003a	8b c8		 mov	 ecx, eax
  0003c	53		 push	 ebx
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 ?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z ; CGuildMarkImage::GetData

; 220  : 			m_aakBlock[row][col].Compress(apxBuf);

  00043	8d 85 fc cf ff
	ff		 lea	 eax, DWORD PTR _apxBuf$[ebp]
  00049	8b cf		 mov	 ecx, edi
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?Compress@SGuildMarkBlock@@QAEXPBK@Z ; SGuildMarkBlock::Compress
  00051	8b 85 f8 cf ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00057	83 c6 40	 add	 esi, 64			; 00000040H
  0005a	81 c7 4c 63 00
	00		 add	 edi, 25420		; 0000634cH
  00060	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  00066	72 c8		 jb	 SHORT $LL3@BuildAllBl

; 213  : 	Pixel apxBuf[SGuildMarkBlock::SIZE];
; 214  : 	sys_log(0, "CGuildMarkImage::BuildAllBlocks");
; 215  : 
; 216  : 	for (UINT row = 0; row < BLOCK_ROW_COUNT; ++row)

  00068	83 c3 30	 add	 ebx, 48			; 00000030H
  0006b	81 fb e0 01 00
	00		 cmp	 ebx, 480		; 000001e0H
  00071	72 b4		 jb	 SHORT $LL6@BuildAllBl

; 221  : 		}
; 222  : }

  00073	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	33 cd		 xor	 ecx, ebp
  0007a	5b		 pop	 ebx
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?BuildAllBlocks@CGuildMarkImage@@AAEXXZ ENDP		; CGuildMarkImage::BuildAllBlocks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?GetBlockCRCList@CGuildMarkImage@@QAEXPAK@Z
_TEXT	SEGMENT
_crcList$ = 8						; size = 4
?GetBlockCRCList@CGuildMarkImage@@QAEXPAK@Z PROC	; CGuildMarkImage::GetBlockCRCList, COMDAT
; _this$ = ecx

; 259  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 260  : 	for (DWORD row = 0; row < BLOCK_ROW_COUNT; ++row)

  00003	8b 55 08	 mov	 edx, DWORD PTR _crcList$[ebp]
  00006	83 c1 04	 add	 ecx, 4
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
$LL6@GetBlockCR:

; 261  : 		for (DWORD col = 0; col < BLOCK_COL_COUNT; ++col)

  00010	be 08 00 00 00	 mov	 esi, 8
$LL3@GetBlockCR:

; 262  : 			*(crcList++) = m_aakBlock[row][col].GetCRC();

  00015	e8 00 00 00 00	 call	 ?GetCRC@SGuildMarkBlock@@QBEKXZ ; SGuildMarkBlock::GetCRC
  0001a	89 02		 mov	 DWORD PTR [edx], eax
  0001c	81 c1 4c 63 00
	00		 add	 ecx, 25420		; 0000634cH
  00022	83 c2 04	 add	 edx, 4
  00025	4e		 dec	 esi
  00026	75 ed		 jne	 SHORT $LL3@GetBlockCR

; 260  : 	for (DWORD row = 0; row < BLOCK_ROW_COUNT; ++row)

  00028	4f		 dec	 edi
  00029	75 e5		 jne	 SHORT $LL6@GetBlockCR
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi

; 263  : }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?GetBlockCRCList@CGuildMarkImage@@QAEXPAK@Z ENDP	; CGuildMarkImage::GetBlockCRCList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?GetCRC@SGuildMarkBlock@@QBEKXZ
_TEXT	SEGMENT
?GetCRC@SGuildMarkBlock@@QBEKXZ PROC			; SGuildMarkBlock::GetCRC, COMDAT
; _this$ = ecx

; 284  : 	return m_crc;

  00000	8b 81 48 63 00
	00		 mov	 eax, DWORD PTR [ecx+25416]

; 285  : }

  00006	c3		 ret	 0
?GetCRC@SGuildMarkBlock@@QBEKXZ ENDP			; SGuildMarkBlock::GetCRC
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?CopyFrom@SGuildMarkBlock@@QAEXPBEKK@Z
_TEXT	SEGMENT
_pbCompBuf$ = 8						; size = 4
_dwCompSize$ = 12					; size = 4
_crc$ = 16						; size = 4
?CopyFrom@SGuildMarkBlock@@QAEXPBEKK@Z PROC		; SGuildMarkBlock::CopyFrom, COMDAT
; _this$ = ecx

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	if (dwCompSize > MAX_COMP_SIZE)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _dwCompSize$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3d 43 33 00 00	 cmp	 eax, 13123		; 00003343H
  0000e	77 22		 ja	 SHORT $LN2@CopyFrom

; 290  : 		return;
; 291  : 
; 292  : 	m_sizeCompBuf = dwCompSize;
; 293  : 	thecore_memcpy(m_abCompBuf, pbCompBuf, dwCompSize);

  00010	50		 push	 eax
  00011	ff 75 08	 push	 DWORD PTR _pbCompBuf$[ebp]
  00014	89 86 44 63 00
	00		 mov	 DWORD PTR [esi+25412], eax
  0001a	8d 86 00 30 00
	00		 lea	 eax, DWORD PTR [esi+12288]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _memcpy

; 294  : 	m_crc = crc;

  00026	8b 45 10	 mov	 eax, DWORD PTR _crc$[ebp]
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	89 86 48 63 00
	00		 mov	 DWORD PTR [esi+25416], eax
$LN2@CopyFrom:
  00032	5e		 pop	 esi

; 295  : 	//printf("SGuildMarkBlock::CopyFrom: %u > %u crc %u\n", sizeof(Pixel) * SGuildMarkBlock::SIZE, m_sizeCompBuf, m_crc);
; 296  : }

  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?CopyFrom@SGuildMarkBlock@@QAEXPBEKK@Z ENDP		; SGuildMarkBlock::CopyFrom
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\markimage.cpp
;	COMDAT ?Compress@SGuildMarkBlock@@QAEXPBK@Z
_TEXT	SEGMENT
_pxBuf$ = 8						; size = 4
?Compress@SGuildMarkBlock@@QAEXPBK@Z PROC		; SGuildMarkBlock::Compress, COMDAT
; _this$ = ecx

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 300  : 	m_sizeCompBuf = MAX_COMP_SIZE;

  00007	8d b7 44 63 00
	00		 lea	 esi, DWORD PTR [edi+25412]
  0000d	c7 06 43 33 00
	00		 mov	 DWORD PTR [esi], 13123	; 00003343H

; 301  : 
; 302  : 	if (LZO_E_OK != lzo1x_999_compress((const BYTE *) pxBuf,
; 303  : 		sizeof(Pixel) * SGuildMarkBlock::SIZE, m_abCompBuf,
; 304  : 		(lzo_uint*) &m_sizeCompBuf,
; 305  : 		CLZO::Instance().GetWorkMemory()))

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  00019	e8 00 00 00 00	 call	 ?GetWorkMemory@CLZO@@QAEPAEXZ ; CLZO::GetWorkMemory
  0001e	50		 push	 eax
  0001f	56		 push	 esi
  00020	8d 87 00 30 00
	00		 lea	 eax, DWORD PTR [edi+12288]
  00026	50		 push	 eax
  00027	68 00 30 00 00	 push	 12288			; 00003000H
  0002c	ff 75 08	 push	 DWORD PTR _pxBuf$[ebp]
  0002f	e8 00 00 00 00	 call	 _lzo1x_999_compress
  00034	83 c4 14	 add	 esp, 20			; 00000014H
  00037	85 c0		 test	 eax, eax
  00039	74 1a		 je	 SHORT $LN1@Compress

; 306  : 	{
; 307  : 		sys_err("SGuildMarkBlock::Compress: Error! %u > %u", sizeof(Pixel) * SGuildMarkBlock::SIZE, m_sizeCompBuf);

  0003b	ff 36		 push	 DWORD PTR [esi]
  0003d	68 00 30 00 00	 push	 12288			; 00003000H
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BGEKGKPD@SGuildMarkBlock?3?3Compress?3?5Error@
  00047	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 313  : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN1@Compress:

; 308  : 		return;
; 309  : 	}
; 310  : 
; 311  : 	//sys_log(0, "SGuildMarkBlock::Compress %u > %u", sizeof(Pixel) * SGuildMarkBlock::SIZE, m_sizeCompBuf);
; 312  : 	m_crc = GetCRC32((const char *) pxBuf, sizeof(Pixel) * SGuildMarkBlock::SIZE);

  00055	68 00 30 00 00	 push	 12288			; 00003000H
  0005a	ff 75 08	 push	 DWORD PTR _pxBuf$[ebp]
  0005d	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  00062	83 c4 08	 add	 esp, 8
  00065	89 87 48 63 00
	00		 mov	 DWORD PTR [edi+25416], eax
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi

; 313  : }

  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
?Compress@SGuildMarkBlock@@QAEXPBK@Z ENDP		; SGuildMarkBlock::Compress
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCLZO@@@@SAAAVCLZO@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCLZO@@@@SAAAVCLZO@@XZ PROC	; CSingleton<CLZO>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCLZO@@@@SAAAVCLZO@@XZ ENDP	; CSingleton<CLZO>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??R?$less@E@std@@QBE_NABE0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@E@std@@QBE_NABE0@Z PROC			; std::less<unsigned char>::operator(), COMDAT
; _this$ = ecx

; 192  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3a 08		 cmp	 cl, BYTE PTR [eax]
  0000d	1b c0		 sbb	 eax, eax
  0000f	f7 d8		 neg	 eax

; 194  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??R?$less@E@std@@QBE_NABE0@Z ENDP			; std::less<unsigned char>::operator()
_TEXT	ENDS
END
