; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	D:\Metin2\Metin2\client_source_clean\client_source_clean\source\UserInterface\PythonApplication.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?ms_pInstance@CPythonApplication@@1PAV1@A	; CPythonApplication::ms_pInstance
PUBLIC	??_C@_0GN@LLBDNFAM@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0M@EHJKIBDK@Abort?$CB?$CB?$CB?$CB?6?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@OHHAPIAL@perf_game_render?4txt?$AA@	; `string'
PUBLIC	??_C@_0BH@GCCBAEAA@GR?4Total?5?$CFd?5?$CITime?5?$CFd?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0L@EGAPCDKD@GR?4DFM?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0O@PLGAMGBI@GR?4EFT?4UP?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0L@MCADEBDB@GR?4SHW?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@OEOJMFCF@GR?4STT?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@CDOGKGFB@GR?4CLL?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0O@HPKPMDPE@GR?4BG?4SKY?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0O@JENIKJAN@GR?4BG?4LEN?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0O@HJPLNNBE@GR?4BG?4CLD?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0P@EJKDFAIB@GR?4BG?4MAIN?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0L@OOHFOBKJ@GR?4CHR?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0O@LENBOK@GR?4BG?4WTR?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0O@BIDCIJEG@GR?4BG?4EFT?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0L@KOHMHAGO@GR?4EFT?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@CNELLLJF@GR?4ITM?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@DIBNDLBN@GR?4FLY?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0O@EEAHGPFP@GR?4BG?4BLK?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BF@NHIIGIH@perf_game_update?4txt?$AA@	; `string'
PUBLIC	??_C@_0BH@HPIDKEA@GU?4Total?5?$CFd?5?$CITime?5?$CFd?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0L@JHBDHKIG@GU?4GMP?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@HCBFJPAB@GU?4SCR?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@IGEOOJOO@GU?4MPS?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_09JGPPFKPH@GU?4BG?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@BLLECFKE@GU?4GEM?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@MKJPKNA@GU?4CHR?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@EMKAGLBH@GU?4EFT?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@NKMBCAGE@GU?4FLY?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@MPJHKAOM@GU?4ITM?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@KNCOIAL@GU?4PLR?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0L@PAGGCBDD@GU?4POS?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0BD@OJBILBDC@FrameSkip?5?$LK?$LI?A?$KE?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@NOHKOOIE@WARN_BAD_DRIVER?$AA@		; `string'
PUBLIC	??_C@_0M@MOGGPFAH@WARN_NO_TNL?$AA@		; `string'
PUBLIC	??_C@_0BN@OAKBEJJN@CREATE_NO_APPROPRIATE_DEVICE?$AA@ ; `string'
PUBLIC	??_C@_0CD@GGLEAAKE@CreateDevice?3?5Enum?5?$CG?5Detect?5fail@ ; `string'
PUBLIC	??_C@_0BC@NKAKBNDM@CREATE_NO_DIRECTX?$AA@	; `string'
PUBLIC	??_C@_0DK@GACPAJMM@CreateDevice?3?5DirectX?58?41?5or?5gre@ ; `string'
PUBLIC	??_C@_0O@CMPMDOEH@CREATE_DEVICE?$AA@		; `string'
PUBLIC	??_C@_0CK@KMPBIDGP@CreateDevice?3?5GraphicDevice?5crea@ ; `string'
PUBLIC	??_C@_0O@DAEHMKOB@CREATE_FORMAT?$AA@		; `string'
PUBLIC	??_C@_0CH@DEBFNBPL@CreateDevice?3?5Change?5the?5screen?5@ ; `string'
PUBLIC	??_C@_0BC@IMJEDJEA@GetDevCaps?5failed?$AA@	; `string'
PUBLIC	??_C@_0CA@DLHDILBB@CreateDevice?3?5GetDevCaps?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BD@IHNLMMLJ@GetDevCaps2?5failed?$AA@	; `string'
PUBLIC	??_C@_0CB@JLAAEKGJ@CreateDevice?3?5GetDevCaps2?5failed@ ; `string'
PUBLIC	??_C@_0O@BAEJJDKB@UNKNOWN_ERROR?$AA@		; `string'
PUBLIC	??_C@_0BN@JAHEKIGK@CreateDevice?3?5Unknown?5Error?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BB@EOELDOLA@?$CFs?1item_list?4txt?$AA@	; `string'
PUBLIC	??_C@_0O@MEMEPBB@?$CFs?1item_proto?$AA@		; `string'
PUBLIC	??_C@_0BA@BIDKFLDM@?$CFs?1itemdesc?4txt?$AA@	; `string'
PUBLIC	??_C@_0N@KCBCHIHM@?$CFs?1mob_proto?$AA@		; `string'
PUBLIC	??_C@_0BB@JDMIHPNN@?$CFs?1SkillDesc?4txt?$AA@	; `string'
PUBLIC	??_C@_0BC@NLEJCAEF@?$CFs?1SkillTable?4txt?$AA@	; `string'
PUBLIC	??_C@_0O@JEIJHCCG@?$CFs?1insult?4txt?$AA@	; `string'
PUBLIC	??_C@_0CI@MGBDCDJE@LoadLocaleData?5?9?5LoadItemList?$CI?$CFs@ ; `string'
PUBLIC	??_C@_0CJ@MIFDPICO@LoadLocaleData?5?9?5LoadItemProto?$CI?$CF@ ; `string'
PUBLIC	??_C@_0CI@FLOPHKEN@LoadLocaleData?5?9?5LoadItemDesc?$CI?$CFs@ ; `string'
PUBLIC	??_C@_0CI@PNCAMHEJ@LoadLocaleData?5?9?5LoadMobProto?$CI?$CFs@ ; `string'
PUBLIC	??_C@_0CN@NIKOAAJF@LoadLocaleData?5?9?5RegisterSkillDe@ ; `string'
PUBLIC	??_C@_0CO@HCDPLHIO@LoadLocaleData?5?9?5RegisterSkillTa@ ; `string'
PUBLIC	??_C@_0DO@PNDPPMDH@CPythonApplication?5?9?5CPythonNetw@ ; `string'
PUBLIC	??_C@_0O@GCNBGGIE@?$CFs?1lang?$CFd?4cvt?$AA@	; `string'
PUBLIC	??_C@_0EI@FFMLHANM@LoadLocaleData?5?9?5CPythonNetworkS@ ; `string'
PUBLIC	??_C@_0BJ@DBNNLGNG@CMSWindow?3?3Create?5failed?$AA@ ; `string'
PUBLIC	??_C@_0O@NOBMPFEG@CREATE_WINDOW?$AA@		; `string'
PUBLIC	??_C@_0CA@FFOMJBHN@CMSWindow?3?3Cursors?5Create?5Error?$AA@ ; `string'
PUBLIC	??_C@_0BA@GLLECKCO@?$CCCREATE_CURSOR?$CC?$AA@	; `string'
PUBLIC	??_C@_0BJ@CJEBNOLC@NetDevice?3?3Create?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BB@EJLMKODK@?$CCCREATE_NETWORK?$CC?$AA@	; `string'
PUBLIC	??_C@_0CD@KIIBIHOG@d?3?1ymir?5work?1special?1spheremap?4j@ ; `string'
PUBLIC	??_C@_0CF@CBFEMJII@d?3?1ymir?5work?1special?1spheremap01@ ; `string'
PUBLIC	??_R2CPythonApplication@@8			; CPythonApplication::`RTTI Base Class Array'
PUBLIC	??_R2CInputKeyboard@@8				; CInputKeyboard::`RTTI Base Class Array'
PUBLIC	??_R2CInputDevice@@8				; CInputDevice::`RTTI Base Class Array'
PUBLIC	??_R2CMSApplication@@8				; CMSApplication::`RTTI Base Class Array'
PUBLIC	??_R2CMSWindow@@8				; CMSWindow::`RTTI Base Class Array'
PUBLIC	??_R2CMovieMan@@8				; CMovieMan::`RTTI Base Class Array'
PUBLIC	??_R2?$CSingleton@VCMovieMan@@@@8		; CSingleton<CMovieMan>::`RTTI Base Class Array'
PUBLIC	??_R2IAbstractApplication@@8			; IAbstractApplication::`RTTI Base Class Array'
PUBLIC	??_R2?$TAbstractSingleton@VIAbstractApplication@@@@8 ; TAbstractSingleton<IAbstractApplication>::`RTTI Base Class Array'
PUBLIC	??_R1CA@?0A@EA@?$TAbstractSingleton@VIAbstractApplication@@@@8 ; TAbstractSingleton<IAbstractApplication>::`RTTI Base Class Descriptor at (32,-1,0,64)'
PUBLIC	??_R1CA@?0A@EA@IAbstractApplication@@8		; IAbstractApplication::`RTTI Base Class Descriptor at (32,-1,0,64)'
PUBLIC	??_R1BM@?0A@EA@CInputDevice@@8			; CInputDevice::`RTTI Base Class Descriptor at (28,-1,0,64)'
PUBLIC	??_R1BM@?0A@EA@CInputKeyboard@@8		; CInputKeyboard::`RTTI Base Class Descriptor at (28,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CPythonApplication@@8		; CPythonApplication::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CInputKeyboard@@8			; CInputKeyboard::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CInputDevice@@8			; CInputDevice::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CMSApplication@@8			; CMSApplication::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CMSWindow@@8			; CMSWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CMovieMan@@8			; CMovieMan::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCMovieMan@@@@8	; CSingleton<CMovieMan>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IAbstractApplication@@8		; IAbstractApplication::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$TAbstractSingleton@VIAbstractApplication@@@@8 ; TAbstractSingleton<IAbstractApplication>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CInputDevice@@8				; CInputDevice::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCInputDevice@@@8			; CInputDevice `RTTI Type Descriptor'
PUBLIC	??_R3CInputKeyboard@@8				; CInputKeyboard::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCInputKeyboard@@@8			; CInputKeyboard `RTTI Type Descriptor'
PUBLIC	??_R3CMSApplication@@8				; CMSApplication::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCMSApplication@@@8			; CMSApplication `RTTI Type Descriptor'
PUBLIC	??_R3CMSWindow@@8				; CMSWindow::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCMSWindow@@@8				; CMSWindow `RTTI Type Descriptor'
PUBLIC	??_R3CPythonApplication@@8			; CPythonApplication::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCPythonApplication@@@8			; CPythonApplication `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VCMovieMan@@@@8		; CSingleton<CMovieMan>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$CSingleton@VCMovieMan@@@@@8		; CSingleton<CMovieMan> `RTTI Type Descriptor'
PUBLIC	??_R3CMovieMan@@8				; CMovieMan::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCMovieMan@@@8				; CMovieMan `RTTI Type Descriptor'
PUBLIC	??_R3?$TAbstractSingleton@VIAbstractApplication@@@@8 ; TAbstractSingleton<IAbstractApplication>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$TAbstractSingleton@VIAbstractApplication@@@@@8 ; TAbstractSingleton<IAbstractApplication> `RTTI Type Descriptor'
PUBLIC	??_R3IAbstractApplication@@8			; IAbstractApplication::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVIAbstractApplication@@@8		; IAbstractApplication `RTTI Type Descriptor'
PUBLIC	??_R4CPythonApplication@@6BIAbstractApplication@@@ ; CPythonApplication::`RTTI Complete Object Locator'
PUBLIC	??_R4CPythonApplication@@6BCInputKeyboard@@@	; CPythonApplication::`RTTI Complete Object Locator'
PUBLIC	??_R4CPythonApplication@@6BCMSApplication@@@	; CPythonApplication::`RTTI Complete Object Locator'
PUBLIC	??_R4?$CSingleton@VCMovieMan@@@@6B@		; CSingleton<CMovieMan>::`RTTI Complete Object Locator'
PUBLIC	??_R4CMovieMan@@6B@				; CMovieMan::`RTTI Complete Object Locator'
PUBLIC	??_R4?$TAbstractSingleton@VIAbstractApplication@@@@6B@ ; TAbstractSingleton<IAbstractApplication>::`RTTI Complete Object Locator'
PUBLIC	??_R4IAbstractApplication@@6B@			; IAbstractApplication::`RTTI Complete Object Locator'
PUBLIC	?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A ; CSingleton<CMovieMan>::ms_singleton
PUBLIC	??_7?$CSingleton@VCMovieMan@@@@6B@		; CSingleton<CMovieMan>::`vftable'
PUBLIC	??_7?$TAbstractSingleton@VIAbstractApplication@@@@6B@ ; TAbstractSingleton<IAbstractApplication>::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCPythonIME@@@@0PAVCPythonIME@@A ; CSingleton<CPythonIME>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCPythonSkill@@@@0PAVCPythonSkill@@A ; CSingleton<CPythonSkill>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
PUBLIC	?PERF_CHECKER_RENDER_GAME@@3_NA			; PERF_CHECKER_RENDER_GAME
PUBLIC	??_7CPythonApplication@@6BIAbstractApplication@@@ ; CPythonApplication::`vftable'
PUBLIC	??_7CPythonApplication@@6BCInputKeyboard@@@	; CPythonApplication::`vftable'
PUBLIC	??_7CPythonApplication@@6BCMSApplication@@@	; CPythonApplication::`vftable'
PUBLIC	?c_fDefaultCameraZoomSpeed@@3MA			; c_fDefaultCameraZoomSpeed
PUBLIC	?c_fDefaultCameraPitchSpeed@@3MA		; c_fDefaultCameraPitchSpeed
PUBLIC	?c_fDefaultCameraRotateSpeed@@3MA		; c_fDefaultCameraRotateSpeed
PUBLIC	?g_specularSpd@@3NA				; g_specularSpd
PUBLIC	?MIN_FOG@@3MA					; MIN_FOG
PUBLIC	??_7CMovieMan@@6B@				; CMovieMan::`vftable'
PUBLIC	??_7IAbstractApplication@@6B@			; IAbstractApplication::`vftable'
EXTRN	?GRAPHICS_CAPS_SOFTWARE_TILING@@3_NA:BYTE	; GRAPHICS_CAPS_SOFTWARE_TILING
EXTRN	?OnSize@CMSWindow@@UAEXIJ@Z:PROC		; CMSWindow::OnSize
EXTRN	?Destroy@CMSWindow@@QAEXXZ:PROC			; CMSWindow::Destroy
EXTRN	?DestroySystem@CTextFileLoader@@SAXXZ:PROC	; CTextFileLoader::DestroySystem
EXTRN	?DestroySystem@CAttributeInstance@@SAXXZ:PROC	; CAttributeInstance::DestroySystem
EXTRN	?Destroy@CGraphicDevice@@QAEXXZ:PROC		; CGraphicDevice::Destroy
EXTRN	?Destroy@CSoundManager@@QAEXXZ:PROC		; CSoundManager::Destroy
EXTRN	?DestroySystem@CGraphicImageInstance@@SAXXZ:PROC ; CGraphicImageInstance::DestroySystem
EXTRN	?DestroySystem@CGrannyModelInstance@@SAXXZ:PROC	; CGrannyModelInstance::DestroySystem
EXTRN	?Destroy@CPythonResource@@QAEXXZ:PROC		; CPythonResource::Destroy
EXTRN	?Destroy@CPythonGraphic@@QAEXXZ:PROC		; CPythonGraphic::Destroy
EXTRN	?GrannyDestroySharedDeformBuffer@@YAXXZ:PROC	; GrannyDestroySharedDeformBuffer
EXTRN	?Destroy@CLightManager@@QAEXXZ:PROC		; CLightManager::Destroy
EXTRN	?Destroy@CEffectManager@@QAEXXZ:PROC		; CEffectManager::Destroy
EXTRN	?Destroy@CRaceManager@@QAEXXZ:PROC		; CRaceManager::Destroy
EXTRN	?Destroy@CFlyingManager@@QAEXXZ:PROC		; CFlyingManager::Destroy
EXTRN	?DestroyCollisionInstanceSystem@@YAXXZ:PROC	; DestroyCollisionInstanceSystem
EXTRN	?Destroy@CWindowManager@UI@@QAEXXZ:PROC		; UI::CWindowManager::Destroy
EXTRN	?DestroySphereMap@CGrannyMaterial@@SAXXZ:PROC	; CGrannyMaterial::DestroySphereMap
EXTRN	_WebBrowser_Destroy:PROC
EXTRN	__time32:PROC
EXTRN	?CreateSphereMap@CGrannyMaterial@@SAXIPBD@Z:PROC ; CGrannyMaterial::CreateSphereMap
EXTRN	__imp__SystemParametersInfoA@16:PROC
EXTRN	?CreateSystem@CGraphicImageInstance@@SAXI@Z:PROC ; CGraphicImageInstance::CreateSystem
EXTRN	?Initialize@CLightManager@@QAEXXZ:PROC		; CLightManager::Initialize
EXTRN	?SetText@CIME@@QAEXPBDH@Z:PROC			; CIME::SetText
EXTRN	?Create@CNetworkDevice@@QAE_NXZ:PROC		; CNetworkDevice::Create
EXTRN	?InitializeKeyboard@CInputKeyboard@@QAE_NPAUHWND__@@@Z:PROC ; CInputKeyboard::InitializeKeyboard
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	?SetVisibleMode@CMSWindow@@QAEX_N@Z:PROC	; CMSWindow::SetVisibleMode
EXTRN	?ReserveSoftwareTilingEnable@CMapManager@@QAEX_N@Z:PROC ; CMapManager::ReserveSoftwareTilingEnable
EXTRN	?IsFastTNL@CGraphicBase@@SA_NXZ:PROC		; CGraphicBase::IsFastTNL
EXTRN	?GrannyCreateSharedDeformBuffer@@YAXXZ:PROC	; GrannyCreateSharedDeformBuffer
EXTRN	?Create@CSoundManager@@QAEHXZ:PROC		; CSoundManager::Create
EXTRN	?GetScreenWidth@CMSWindow@@QAEHXZ:PROC		; CMSWindow::GetScreenWidth
EXTRN	?GetScreenHeight@CMSWindow@@QAEHXZ:PROC		; CMSWindow::GetScreenHeight
EXTRN	?SetPosition@CMSWindow@@QAEXHH@Z:PROC		; CMSWindow::SetPosition
EXTRN	?AdjustSize@CMSWindow@@QAEXHH@Z:PROC		; CMSWindow::AdjustSize
EXTRN	?UseDefaultIME@CIME@@QAEXXZ:PROC		; CIME::UseDefaultIME
EXTRN	?GetInstance@CMSWindow@@QAEPAUHINSTANCE__@@XZ:PROC ; CMSWindow::GetInstance
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	?Create@CMSWindow@@QAE_NPBDHKKPAUHICON__@@H@Z:PROC ; CMSWindow::Create
EXTRN	__imp__FindWindowA@8:PROC
EXTRN	?LoadItemDesc@CItemManager@@QAE_NPBD@Z:PROC	; CItemManager::LoadItemDesc
EXTRN	?LoadItemTable@CItemManager@@QAE_NPBD@Z:PROC	; CItemManager::LoadItemTable
EXTRN	?LoadItemList@CItemManager@@QAE_NPBD@Z:PROC	; CItemManager::LoadItemList
EXTRN	?Destroy@CItemManager@@QAEXXZ:PROC		; CItemManager::Destroy
EXTRN	?MessageProcess@CMSApplication@@QAE_NXZ:PROC	; CMSApplication::MessageProcess
EXTRN	?IsMessage@CMSApplication@@QAE_NXZ:PROC		; CMSApplication::IsMessage
EXTRN	?SetMinLODMode@CGrannyLODController@@SAX_N@Z:PROC ; CGrannyLODController::SetMinLODMode
EXTRN	__imp__PyExc_RuntimeError:DWORD
EXTRN	__imp__PyErr_SetString:PROC
EXTRN	?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z:PROC ; CGraphicDevice::Create
EXTRN	?RegisterWarningString@CGraphicDevice@@QAEXIPBD@Z:PROC ; CGraphicDevice::RegisterWarningString
EXTRN	?InitBackBufferCount@CGraphicDevice@@QAEXI@Z:PROC ; CGraphicDevice::InitBackBufferCount
EXTRN	?Reset@CGraphicDevice@@QAE_NXZ:PROC		; CGraphicDevice::Reset
EXTRN	?GetDeviceState@CGraphicDevice@@QAE?AW4EDeviceState@1@XZ:PROC ; CGraphicDevice::GetDeviceState
EXTRN	?GetClientRect@CMSWindow@@QAEXPAUtagRECT@@@Z:PROC ; CMSWindow::GetClientRect
EXTRN	?ResetFaceCount@CGraphicBase@@QAEXXZ:PROC	; CGraphicBase::ResetFaceCount
EXTRN	?GetFaceCount@CGraphicBase@@QAEKXZ:PROC		; CGraphicBase::GetFaceCount
EXTRN	?Show@CScreen@@QAEXPAUHWND__@@@Z:PROC		; CScreen::Show
EXTRN	?End@CScreen@@QAEXXZ:PROC			; CScreen::End
EXTRN	?SetInterfaceRenderState@CPythonGraphic@@QAEXXZ:PROC ; CPythonGraphic::SetInterfaceRenderState
EXTRN	?ClearDepthBuffer@CScreen@@QAEXXZ:PROC		; CScreen::ClearDepthBuffer
EXTRN	?Begin@CScreen@@QAE_NXZ:PROC			; CScreen::Begin
EXTRN	?Update@CCullingManager@@QAEXXZ:PROC		; CCullingManager::Update
EXTRN	?IsActive@CMSWindow@@QAE_NXZ:PROC		; CMSWindow::IsActive
EXTRN	?RestoreDevice@CScreen@@QAEHXZ:PROC		; CScreen::RestoreDevice
EXTRN	?IsLostDevice@CScreen@@QAEHXZ:PROC		; CScreen::IsLostDevice
EXTRN	?TranslateSpecularMatrix@CGrannyMaterial@@SAXMMM@Z:PROC ; CGrannyMaterial::TranslateSpecularMatrix
EXTRN	?Adjust@CTimer@@QAEXH@Z:PROC			; CTimer::Adjust
EXTRN	?Update@CResourceManager@@QAEXXZ:PROC		; CResourceManager::Update
EXTRN	__imp__ScreenToClient@8:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	?UpdateKeyboard@CInputKeyboard@@QAEXXZ:PROC	; CInputKeyboard::UpdateKeyboard
EXTRN	?GetElapsedMilliecond@CTimer@@QAEKXZ:PROC	; CTimer::GetElapsedMilliecond
EXTRN	?GetElapsedSecond@CTimer@@QAEMXZ:PROC		; CTimer::GetElapsedSecond
EXTRN	?GetCurrentSecond@CTimer@@QAEMXZ:PROC		; CTimer::GetCurrentSecond
EXTRN	?Advance@CTimer@@QAEXXZ:PROC			; CTimer::Advance
EXTRN	?ELTimer_SetFrameMSec@@YAXXZ:PROC		; ELTimer_SetFrameMSec
EXTRN	?Update@CFlyingManager@@QAEXXZ:PROC		; CFlyingManager::Update
EXTRN	?UpdateSound@CEffectManager@@QAEXXZ:PROC	; CEffectManager::UpdateSound
EXTRN	?Update@CGameEventManager@@QAEXXZ:PROC		; CGameEventManager::Update
EXTRN	?SetCenterPosition@CGameEventManager@@QAEXMMM@Z:PROC ; CGameEventManager::SetCenterPosition
EXTRN	?BuildViewFrustum@CScreen@@QAEXXZ:PROC		; CScreen::BuildViewFrustum
EXTRN	?Hyperlink_UpdateMousePos@CGraphicTextInstance@@SAXHH@Z:PROC ; CGraphicTextInstance::Hyperlink_UpdateMousePos
EXTRN	_fflush:PROC
EXTRN	?Render@CFlyingManager@@QAEXXZ:PROC		; CFlyingManager::Render
EXTRN	?Render@CEffectManager@@QAEXXZ:PROC		; CEffectManager::Render
EXTRN	?EndEnvironment@CMapManager@@QAEXXZ:PROC	; CMapManager::EndEnvironment
EXTRN	?BeginEnvironment@CMapManager@@QAEXXZ:PROC	; CMapManager::BeginEnvironment
EXTRN	?SetCursorPosition@CPythonGraphic@@QAEXHH@Z:PROC ; CPythonGraphic::SetCursorPosition
EXTRN	?GetMousePosition@CWindowManager@UI@@QAEXAAJ0@Z:PROC ; UI::CWindowManager::GetMousePosition
EXTRN	?PushState@CPythonGraphic@@QAEXXZ:PROC		; CPythonGraphic::PushState
EXTRN	?SetGameRenderState@CPythonGraphic@@QAEXXZ:PROC	; CPythonGraphic::SetGameRenderState
EXTRN	?Update@CEffectManager@@QAEXXZ:PROC		; CEffectManager::Update
EXTRN	?Process@CCullingManager@@QAEXXZ:PROC		; CCullingManager::Process
EXTRN	?SetPerspective@CGraphicBase@@QAEXMMMM@Z:PROC	; CGraphicBase::SetPerspective
EXTRN	?GetAspect@CWindowManager@UI@@QAEMXZ:PROC	; UI::CWindowManager::GetAspect
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	?GetInfo@CEffectManager@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CEffectManager::GetInfo
EXTRN	__vsnprintf:PROC
EXTRN	?GetMousePosition@CMSWindow@@QAEXPAUtagPOINT@@@Z:PROC ; CMSWindow::GetMousePosition
EXTRN	?AddCamera@CCameraManager@@QAE_NE@Z:PROC	; CCameraManager::AddCamera
EXTRN	?UseCustomTime@CTimer@@QAEXXZ:PROC		; CTimer::UseCustomTime
EXTRN	?SetEterExceptionHandler@@YAXXZ:PROC		; SetEterExceptionHandler
EXTRN	??1CNetworkDevice@@UAE@XZ:PROC			; CNetworkDevice::~CNetworkDevice
EXTRN	??0CNetworkDevice@@QAE@XZ:PROC			; CNetworkDevice::CNetworkDevice
EXTRN	??1CGraphicDevice@@UAE@XZ:PROC			; CGraphicDevice::~CGraphicDevice
EXTRN	??0CGraphicDevice@@QAE@XZ:PROC			; CGraphicDevice::CGraphicDevice
EXTRN	??1CPythonResource@@UAE@XZ:PROC			; CPythonResource::~CPythonResource
EXTRN	??0CPythonResource@@QAE@XZ:PROC			; CPythonResource::CPythonResource
EXTRN	??1CPythonGraphic@@UAE@XZ:PROC			; CPythonGraphic::~CPythonGraphic
EXTRN	??0CPythonGraphic@@QAE@XZ:PROC			; CPythonGraphic::CPythonGraphic
EXTRN	??1CEffectManager@@UAE@XZ:PROC			; CEffectManager::~CEffectManager
EXTRN	??0CEffectManager@@QAE@XZ:PROC			; CEffectManager::CEffectManager
EXTRN	??1CWindowManager@UI@@UAE@XZ:PROC		; UI::CWindowManager::~CWindowManager
EXTRN	??0CWindowManager@UI@@QAE@XZ:PROC		; UI::CWindowManager::CWindowManager
EXTRN	??1CItemManager@@UAE@XZ:PROC			; CItemManager::~CItemManager
EXTRN	??0CItemManager@@QAE@XZ:PROC			; CItemManager::CItemManager
EXTRN	??1CGameEventManager@@UAE@XZ:PROC		; CGameEventManager::~CGameEventManager
EXTRN	??0CGameEventManager@@QAE@XZ:PROC		; CGameEventManager::CGameEventManager
EXTRN	??1CRaceManager@@UAE@XZ:PROC			; CRaceManager::~CRaceManager
EXTRN	??0CRaceManager@@QAE@XZ:PROC			; CRaceManager::CRaceManager
EXTRN	??1CFlyingManager@@UAE@XZ:PROC			; CFlyingManager::~CFlyingManager
EXTRN	??0CFlyingManager@@QAE@XZ:PROC			; CFlyingManager::CFlyingManager
EXTRN	??1CSoundManager@@UAE@XZ:PROC			; CSoundManager::~CSoundManager
EXTRN	??0CSoundManager@@QAE@XZ:PROC			; CSoundManager::CSoundManager
EXTRN	??1CLightManager@@UAE@XZ:PROC			; CLightManager::~CLightManager
EXTRN	??0CLightManager@@QAE@XZ:PROC			; CLightManager::CLightManager
EXTRN	??1CTimer@@UAE@XZ:PROC				; CTimer::~CTimer
EXTRN	??0CTimer@@QAE@XZ:PROC				; CTimer::CTimer
EXTRN	??1CInputKeyboard@@UAE@XZ:PROC			; CInputKeyboard::~CInputKeyboard
EXTRN	??0CInputKeyboard@@QAE@XZ:PROC			; CInputKeyboard::CInputKeyboard
EXTRN	??1CMSApplication@@UAE@XZ:PROC			; CMSApplication::~CMSApplication
EXTRN	??0CMSApplication@@QAE@XZ:PROC			; CMSApplication::CMSApplication
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitialize@4:PROC
?ms_pInstance@CPythonApplication@@1PAV1@A DD 01H DUP (?) ; CPythonApplication::ms_pInstance
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A DD 01H DUP (?) ; CSingleton<CMovieMan>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonIME@@@@0PAVCPythonIME@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonIME@@@@0PAVCPythonIME@@A DD 01H DUP (?) ; CSingleton<CPythonIME>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonSkill@@@@0PAVCPythonSkill@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonSkill@@@@0PAVCPythonSkill@@A DD 01H DUP (?) ; CSingleton<CPythonSkill>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A DD 01H DUP (?) ; CSingleton<UI::CWindowManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A DD 01H DUP (?) ; CSingleton<CTimer>::ms_singleton
_BSS	ENDS
;	COMDAT ?s_fBufRenderTime@?DC@??Process@CPythonApplication@@QAE_NXZ@4MA
_BSS	SEGMENT
?s_fBufRenderTime@?DC@??Process@CPythonApplication@@QAE_NXZ@4MA DD 01H DUP (?) ; `CPythonApplication::Process'::`50'::s_fBufRenderTime
_BSS	ENDS
;	COMDAT ?s_dwRenderRangeFrame@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA
_BSS	SEGMENT
?s_dwRenderRangeFrame@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA DD 01H DUP (?) ; `CPythonApplication::Process'::`41'::s_dwRenderRangeFrame
_BSS	ENDS
;	COMDAT ?s_dwRenderRangeTime@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA
_BSS	SEGMENT
?s_dwRenderRangeTime@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA DD 01H DUP (?) ; `CPythonApplication::Process'::`41'::s_dwRenderRangeTime
_BSS	ENDS
;	COMDAT ?s_bFrameSkip@?4??Process@CPythonApplication@@QAE_NXZ@4HA
_BSS	SEGMENT
?s_bFrameSkip@?4??Process@CPythonApplication@@QAE_NXZ@4HA DD 01H DUP (?) ; `CPythonApplication::Process'::`5'::s_bFrameSkip
_BSS	ENDS
;	COMDAT ?s_dwFaceCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA
_BSS	SEGMENT
?s_dwFaceCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA DD 01H DUP (?) ; `CPythonApplication::Process'::`2'::s_dwFaceCount
_BSS	ENDS
;	COMDAT ?s_uiLoad@?1??Process@CPythonApplication@@QAE_NXZ@4IA
_BSS	SEGMENT
?s_uiLoad@?1??Process@CPythonApplication@@QAE_NXZ@4IA DD 01H DUP (?) ; `CPythonApplication::Process'::`2'::s_uiLoad
_BSS	ENDS
;	COMDAT ?s_dwRenderFrameCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA
_BSS	SEGMENT
?s_dwRenderFrameCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA DD 01H DUP (?) ; `CPythonApplication::Process'::`2'::s_dwRenderFrameCount
_BSS	ENDS
;	COMDAT ?s_dwUpdateFrameCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA
_BSS	SEGMENT
?s_dwUpdateFrameCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA DD 01H DUP (?) ; `CPythonApplication::Process'::`2'::s_dwUpdateFrameCount
?PERF_CHECKER_RENDER_GAME@@3_NA DB 01H DUP (?)		; PERF_CHECKER_RENDER_GAME
_BSS	ENDS
;	COMDAT ??_7IAbstractApplication@@6B@
CONST	SEGMENT
??_7IAbstractApplication@@6B@ DD FLAT:??_R4IAbstractApplication@@6B@ ; IAbstractApplication::`vftable'
	DD	FLAT:??_EIAbstractApplication@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7CMovieMan@@6B@
CONST	SEGMENT
??_7CMovieMan@@6B@ DD FLAT:??_R4CMovieMan@@6B@		; CMovieMan::`vftable'
	DD	FLAT:??_ECMovieMan@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CPythonApplication@@6BCMSApplication@@@
CONST	SEGMENT
??_7CPythonApplication@@6BCMSApplication@@@ DD FLAT:??_R4CPythonApplication@@6BCMSApplication@@@ ; CPythonApplication::`vftable'
	DD	FLAT:??_ECPythonApplication@@UAEPAXI@Z
	DD	FLAT:?WindowProcedure@CPythonApplication@@MAEJPAUHWND__@@IIJ@Z
	DD	FLAT:?OnSize@CMSWindow@@UAEXIJ@Z
CONST	ENDS
;	COMDAT ??_7CPythonApplication@@6BCInputKeyboard@@@
CONST	SEGMENT
??_7CPythonApplication@@6BCInputKeyboard@@@ DD FLAT:??_R4CPythonApplication@@6BCInputKeyboard@@@ ; CPythonApplication::`vftable'
	DD	FLAT:??_ECPythonApplication@@WBM@AEPAXI@Z
	DD	FLAT:?OnKeyDown@CPythonApplication@@MAEXH@Z
	DD	FLAT:?OnKeyUp@CPythonApplication@@MAEXH@Z
CONST	ENDS
;	COMDAT ??_7CPythonApplication@@6BIAbstractApplication@@@
CONST	SEGMENT
??_7CPythonApplication@@6BIAbstractApplication@@@ DD FLAT:??_R4CPythonApplication@@6BIAbstractApplication@@@ ; CPythonApplication::`vftable'
	DD	FLAT:??_ECPythonApplication@@WCA@AEPAXI@Z
	DD	FLAT:?GetMousePosition@CPythonApplication@@UAEXPAUtagPOINT@@@Z
	DD	FLAT:?GetGlobalTime@CPythonApplication@@UAEMXZ
	DD	FLAT:?GetGlobalElapsedTime@CPythonApplication@@UAEMXZ
	DD	FLAT:?SkipRenderBuffering@CPythonApplication@@UAEXK@Z
	DD	FLAT:?SetServerTime@CPythonApplication@@UAEXJ@Z
	DD	FLAT:?SetCenterPosition@CPythonApplication@@UAEXMMM@Z
	DD	FLAT:?SetEventCamera@CPythonApplication@@UAEXABUSCameraSetting@IAbstractApplication@@@Z
	DD	FLAT:?BlendEventCamera@CPythonApplication@@UAEXABUSCameraSetting@IAbstractApplication@@M@Z
	DD	FLAT:?SetDefaultCamera@CPythonApplication@@UAEXXZ
	DD	FLAT:?RunIMEUpdate@CPythonApplication@@UAEXXZ
	DD	FLAT:?RunIMETabEvent@CPythonApplication@@UAEXXZ
	DD	FLAT:?RunIMEReturnEvent@CPythonApplication@@UAEXXZ
	DD	FLAT:?RunIMEChangeCodePage@CPythonApplication@@UAEXXZ
	DD	FLAT:?RunIMEOpenCandidateListEvent@CPythonApplication@@UAEXXZ
	DD	FLAT:?RunIMECloseCandidateListEvent@CPythonApplication@@UAEXXZ
	DD	FLAT:?RunIMEOpenReadingWndEvent@CPythonApplication@@UAEXXZ
	DD	FLAT:?RunIMECloseReadingWndEvent@CPythonApplication@@UAEXXZ
CONST	ENDS
;	COMDAT ?s_fAveRenderTime@?EL@??Process@CPythonApplication@@QAE_NXZ@4MA
_DATA	SEGMENT
?s_fAveRenderTime@?EL@??Process@CPythonApplication@@QAE_NXZ@4MA DD 041800000r ; 16 ; `CPythonApplication::Process'::`75'::s_fAveRenderTime
_DATA	ENDS
;	COMDAT ??_7?$TAbstractSingleton@VIAbstractApplication@@@@6B@
CONST	SEGMENT
??_7?$TAbstractSingleton@VIAbstractApplication@@@@6B@ DD FLAT:??_R4?$TAbstractSingleton@VIAbstractApplication@@@@6B@ ; TAbstractSingleton<IAbstractApplication>::`vftable'
	DD	FLAT:??_E?$TAbstractSingleton@VIAbstractApplication@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCMovieMan@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCMovieMan@@@@6B@ DD FLAT:??_R4?$CSingleton@VCMovieMan@@@@6B@ ; CSingleton<CMovieMan>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCMovieMan@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4IAbstractApplication@@6B@
rdata$r	SEGMENT
??_R4IAbstractApplication@@6B@ DD 00H			; IAbstractApplication::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIAbstractApplication@@@8
	DD	FLAT:??_R3IAbstractApplication@@8
rdata$r	ENDS
;	COMDAT ??_R4?$TAbstractSingleton@VIAbstractApplication@@@@6B@
rdata$r	SEGMENT
??_R4?$TAbstractSingleton@VIAbstractApplication@@@@6B@ DD 00H ; TAbstractSingleton<IAbstractApplication>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$TAbstractSingleton@VIAbstractApplication@@@@@8
	DD	FLAT:??_R3?$TAbstractSingleton@VIAbstractApplication@@@@8
rdata$r	ENDS
;	COMDAT ??_R4CMovieMan@@6B@
rdata$r	SEGMENT
??_R4CMovieMan@@6B@ DD 00H				; CMovieMan::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMovieMan@@@8
	DD	FLAT:??_R3CMovieMan@@8
rdata$r	ENDS
;	COMDAT ??_R4?$CSingleton@VCMovieMan@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCMovieMan@@@@6B@ DD 00H		; CSingleton<CMovieMan>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCMovieMan@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCMovieMan@@@@8
rdata$r	ENDS
;	COMDAT ??_R4CPythonApplication@@6BCMSApplication@@@
rdata$r	SEGMENT
??_R4CPythonApplication@@6BCMSApplication@@@ DD 00H	; CPythonApplication::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPythonApplication@@@8
	DD	FLAT:??_R3CPythonApplication@@8
rdata$r	ENDS
;	COMDAT ??_R4CPythonApplication@@6BCInputKeyboard@@@
rdata$r	SEGMENT
??_R4CPythonApplication@@6BCInputKeyboard@@@ DD 00H	; CPythonApplication::`RTTI Complete Object Locator'
	DD	01cH
	DD	00H
	DD	FLAT:??_R0?AVCPythonApplication@@@8
	DD	FLAT:??_R3CPythonApplication@@8
rdata$r	ENDS
;	COMDAT ??_R4CPythonApplication@@6BIAbstractApplication@@@
rdata$r	SEGMENT
??_R4CPythonApplication@@6BIAbstractApplication@@@ DD 00H ; CPythonApplication::`RTTI Complete Object Locator'
	DD	020H
	DD	00H
	DD	FLAT:??_R0?AVCPythonApplication@@@8
	DD	FLAT:??_R3CPythonApplication@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIAbstractApplication@@@8
data$r	SEGMENT
??_R0?AVIAbstractApplication@@@8 DD FLAT:??_7type_info@@6B@ ; IAbstractApplication `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIAbstractApplication@@', 00H
data$r	ENDS
;	COMDAT ??_R3IAbstractApplication@@8
rdata$r	SEGMENT
??_R3IAbstractApplication@@8 DD 00H			; IAbstractApplication::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IAbstractApplication@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$TAbstractSingleton@VIAbstractApplication@@@@@8
data$r	SEGMENT
??_R0?AV?$TAbstractSingleton@VIAbstractApplication@@@@@8 DD FLAT:??_7type_info@@6B@ ; TAbstractSingleton<IAbstractApplication> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$TAbstractSingleton@VIAbstractApplication@@@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$TAbstractSingleton@VIAbstractApplication@@@@8
rdata$r	SEGMENT
??_R3?$TAbstractSingleton@VIAbstractApplication@@@@8 DD 00H ; TAbstractSingleton<IAbstractApplication>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$TAbstractSingleton@VIAbstractApplication@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMovieMan@@@8
data$r	SEGMENT
??_R0?AVCMovieMan@@@8 DD FLAT:??_7type_info@@6B@	; CMovieMan `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMovieMan@@', 00H
data$r	ENDS
;	COMDAT ??_R3CMovieMan@@8
rdata$r	SEGMENT
??_R3CMovieMan@@8 DD 00H				; CMovieMan::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CMovieMan@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCMovieMan@@@@@8
data$r	SEGMENT
??_R0?AV?$CSingleton@VCMovieMan@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CMovieMan> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCMovieMan@@@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCMovieMan@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCMovieMan@@@@8 DD 00H		; CSingleton<CMovieMan>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCMovieMan@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPythonApplication@@@8
data$r	SEGMENT
??_R0?AVCPythonApplication@@@8 DD FLAT:??_7type_info@@6B@ ; CPythonApplication `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPythonApplication@@', 00H
data$r	ENDS
;	COMDAT ??_R3CPythonApplication@@8
rdata$r	SEGMENT
??_R3CPythonApplication@@8 DD 00H			; CPythonApplication::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	07H
	DD	FLAT:??_R2CPythonApplication@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMSWindow@@@8
data$r	SEGMENT
??_R0?AVCMSWindow@@@8 DD FLAT:??_7type_info@@6B@	; CMSWindow `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMSWindow@@', 00H
data$r	ENDS
;	COMDAT ??_R3CMSWindow@@8
rdata$r	SEGMENT
??_R3CMSWindow@@8 DD 00H				; CMSWindow::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMSWindow@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMSApplication@@@8
data$r	SEGMENT
??_R0?AVCMSApplication@@@8 DD FLAT:??_7type_info@@6B@	; CMSApplication `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMSApplication@@', 00H
data$r	ENDS
;	COMDAT ??_R3CMSApplication@@8
rdata$r	SEGMENT
??_R3CMSApplication@@8 DD 00H				; CMSApplication::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CMSApplication@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCInputKeyboard@@@8
data$r	SEGMENT
??_R0?AVCInputKeyboard@@@8 DD FLAT:??_7type_info@@6B@	; CInputKeyboard `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCInputKeyboard@@', 00H
data$r	ENDS
;	COMDAT ??_R3CInputKeyboard@@8
rdata$r	SEGMENT
??_R3CInputKeyboard@@8 DD 00H				; CInputKeyboard::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CInputKeyboard@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCInputDevice@@@8
data$r	SEGMENT
??_R0?AVCInputDevice@@@8 DD FLAT:??_7type_info@@6B@	; CInputDevice `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCInputDevice@@', 00H
data$r	ENDS
;	COMDAT ??_R3CInputDevice@@8
rdata$r	SEGMENT
??_R3CInputDevice@@8 DD 00H				; CInputDevice::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CInputDevice@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$TAbstractSingleton@VIAbstractApplication@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$TAbstractSingleton@VIAbstractApplication@@@@8 DD FLAT:??_R0?AV?$TAbstractSingleton@VIAbstractApplication@@@@@8 ; TAbstractSingleton<IAbstractApplication>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$TAbstractSingleton@VIAbstractApplication@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IAbstractApplication@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IAbstractApplication@@8 DD FLAT:??_R0?AVIAbstractApplication@@@8 ; IAbstractApplication::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IAbstractApplication@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCMovieMan@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCMovieMan@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCMovieMan@@@@@8 ; CSingleton<CMovieMan>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCMovieMan@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CMovieMan@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMovieMan@@8 DD FLAT:??_R0?AVCMovieMan@@@8 ; CMovieMan::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMovieMan@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CMSWindow@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMSWindow@@8 DD FLAT:??_R0?AVCMSWindow@@@8 ; CMSWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMSWindow@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CMSApplication@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMSApplication@@8 DD FLAT:??_R0?AVCMSApplication@@@8 ; CMSApplication::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMSApplication@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CInputDevice@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CInputDevice@@8 DD FLAT:??_R0?AVCInputDevice@@@8 ; CInputDevice::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CInputDevice@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CInputKeyboard@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CInputKeyboard@@8 DD FLAT:??_R0?AVCInputKeyboard@@@8 ; CInputKeyboard::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CInputKeyboard@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPythonApplication@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPythonApplication@@8 DD FLAT:??_R0?AVCPythonApplication@@@8 ; CPythonApplication::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPythonApplication@@8
rdata$r	ENDS
;	COMDAT ??_R1BM@?0A@EA@CInputKeyboard@@8
rdata$r	SEGMENT
??_R1BM@?0A@EA@CInputKeyboard@@8 DD FLAT:??_R0?AVCInputKeyboard@@@8 ; CInputKeyboard::`RTTI Base Class Descriptor at (28,-1,0,64)'
	DD	01H
	DD	01cH
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CInputKeyboard@@8
rdata$r	ENDS
;	COMDAT ??_R1BM@?0A@EA@CInputDevice@@8
rdata$r	SEGMENT
??_R1BM@?0A@EA@CInputDevice@@8 DD FLAT:??_R0?AVCInputDevice@@@8 ; CInputDevice::`RTTI Base Class Descriptor at (28,-1,0,64)'
	DD	00H
	DD	01cH
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CInputDevice@@8
rdata$r	ENDS
;	COMDAT ??_R1CA@?0A@EA@IAbstractApplication@@8
rdata$r	SEGMENT
??_R1CA@?0A@EA@IAbstractApplication@@8 DD FLAT:??_R0?AVIAbstractApplication@@@8 ; IAbstractApplication::`RTTI Base Class Descriptor at (32,-1,0,64)'
	DD	01H
	DD	020H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IAbstractApplication@@8
rdata$r	ENDS
;	COMDAT ??_R1CA@?0A@EA@?$TAbstractSingleton@VIAbstractApplication@@@@8
rdata$r	SEGMENT
??_R1CA@?0A@EA@?$TAbstractSingleton@VIAbstractApplication@@@@8 DD FLAT:??_R0?AV?$TAbstractSingleton@VIAbstractApplication@@@@@8 ; TAbstractSingleton<IAbstractApplication>::`RTTI Base Class Descriptor at (32,-1,0,64)'
	DD	00H
	DD	020H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$TAbstractSingleton@VIAbstractApplication@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$TAbstractSingleton@VIAbstractApplication@@@@8
rdata$r	SEGMENT
??_R2?$TAbstractSingleton@VIAbstractApplication@@@@8 DD FLAT:??_R1A@?0A@EA@?$TAbstractSingleton@VIAbstractApplication@@@@8 ; TAbstractSingleton<IAbstractApplication>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2IAbstractApplication@@8
rdata$r	SEGMENT
??_R2IAbstractApplication@@8 DD FLAT:??_R1A@?0A@EA@IAbstractApplication@@8 ; IAbstractApplication::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$TAbstractSingleton@VIAbstractApplication@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCMovieMan@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCMovieMan@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCMovieMan@@@@8 ; CSingleton<CMovieMan>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CMovieMan@@8
rdata$r	SEGMENT
??_R2CMovieMan@@8 DD FLAT:??_R1A@?0A@EA@CMovieMan@@8	; CMovieMan::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VCMovieMan@@@@8
rdata$r	ENDS
;	COMDAT ??_R2CMSWindow@@8
rdata$r	SEGMENT
??_R2CMSWindow@@8 DD FLAT:??_R1A@?0A@EA@CMSWindow@@8	; CMSWindow::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CMSApplication@@8
rdata$r	SEGMENT
??_R2CMSApplication@@8 DD FLAT:??_R1A@?0A@EA@CMSApplication@@8 ; CMSApplication::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CMSWindow@@8
rdata$r	ENDS
;	COMDAT ??_R2CInputDevice@@8
rdata$r	SEGMENT
??_R2CInputDevice@@8 DD FLAT:??_R1A@?0A@EA@CInputDevice@@8 ; CInputDevice::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CInputKeyboard@@8
rdata$r	SEGMENT
??_R2CInputKeyboard@@8 DD FLAT:??_R1A@?0A@EA@CInputKeyboard@@8 ; CInputKeyboard::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CInputDevice@@8
rdata$r	ENDS
;	COMDAT ??_R2CPythonApplication@@8
rdata$r	SEGMENT
??_R2CPythonApplication@@8 DD FLAT:??_R1A@?0A@EA@CPythonApplication@@8 ; CPythonApplication::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CMSApplication@@8
	DD	FLAT:??_R1A@?0A@EA@CMSWindow@@8
	DD	FLAT:??_R1BM@?0A@EA@CInputKeyboard@@8
	DD	FLAT:??_R1BM@?0A@EA@CInputDevice@@8
	DD	FLAT:??_R1CA@?0A@EA@IAbstractApplication@@8
	DD	FLAT:??_R1CA@?0A@EA@?$TAbstractSingleton@VIAbstractApplication@@@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CF@CBFEMJII@d?3?1ymir?5work?1special?1spheremap01@
CONST	SEGMENT
??_C@_0CF@CBFEMJII@d?3?1ymir?5work?1special?1spheremap01@ DB 'd:/ymir wor'
	DB	'k/special/spheremap01.jpg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KIIBIHOG@d?3?1ymir?5work?1special?1spheremap?4j@
CONST	SEGMENT
??_C@_0CD@KIIBIHOG@d?3?1ymir?5work?1special?1spheremap?4j@ DB 'd:/ymir wo'
	DB	'rk/special/spheremap.jpg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EJLMKODK@?$CCCREATE_NETWORK?$CC?$AA@
CONST	SEGMENT
??_C@_0BB@EJLMKODK@?$CCCREATE_NETWORK?$CC?$AA@ DB '"CREATE_NETWORK"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CJEBNOLC@NetDevice?3?3Create?5failed?$AA@
CONST	SEGMENT
??_C@_0BJ@CJEBNOLC@NetDevice?3?3Create?5failed?$AA@ DB 'NetDevice::Create'
	DB	' failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GLLECKCO@?$CCCREATE_CURSOR?$CC?$AA@
CONST	SEGMENT
??_C@_0BA@GLLECKCO@?$CCCREATE_CURSOR?$CC?$AA@ DB '"CREATE_CURSOR"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FFOMJBHN@CMSWindow?3?3Cursors?5Create?5Error?$AA@
CONST	SEGMENT
??_C@_0CA@FFOMJBHN@CMSWindow?3?3Cursors?5Create?5Error?$AA@ DB 'CMSWindow'
	DB	'::Cursors Create Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NOBMPFEG@CREATE_WINDOW?$AA@
CONST	SEGMENT
??_C@_0O@NOBMPFEG@CREATE_WINDOW?$AA@ DB 'CREATE_WINDOW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DBNNLGNG@CMSWindow?3?3Create?5failed?$AA@
CONST	SEGMENT
??_C@_0BJ@DBNNLGNG@CMSWindow?3?3Create?5failed?$AA@ DB 'CMSWindow::Create'
	DB	' failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@FFMLHANM@LoadLocaleData?5?9?5CPythonNetworkS@
CONST	SEGMENT
??_C@_0EI@FFMLHANM@LoadLocaleData?5?9?5CPythonNetworkS@ DB 'LoadLocaleDat'
	DB	'a - CPythonNetworkStream::LoadConvertTable(%d, %s) FAILURE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GCNBGGIE@?$CFs?1lang?$CFd?4cvt?$AA@
CONST	SEGMENT
??_C@_0O@GCNBGGIE@?$CFs?1lang?$CFd?4cvt?$AA@ DB '%s/lang%d.cvt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PNDPPMDH@CPythonApplication?5?9?5CPythonNetw@
CONST	SEGMENT
??_C@_0DO@PNDPPMDH@CPythonApplication?5?9?5CPythonNetw@ DB 'CPythonApplic'
	DB	'ation - CPythonNetworkStream::LoadInsultList(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HCDPLHIO@LoadLocaleData?5?9?5RegisterSkillTa@
CONST	SEGMENT
??_C@_0CO@HCDPLHIO@LoadLocaleData?5?9?5RegisterSkillTa@ DB 'LoadLocaleDat'
	DB	'a - RegisterSkillTable(%s) Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NIKOAAJF@LoadLocaleData?5?9?5RegisterSkillDe@
CONST	SEGMENT
??_C@_0CN@NIKOAAJF@LoadLocaleData?5?9?5RegisterSkillDe@ DB 'LoadLocaleDat'
	DB	'a - RegisterSkillDesc(%s) Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PNCAMHEJ@LoadLocaleData?5?9?5LoadMobProto?$CI?$CFs@
CONST	SEGMENT
??_C@_0CI@PNCAMHEJ@LoadLocaleData?5?9?5LoadMobProto?$CI?$CFs@ DB 'LoadLoc'
	DB	'aleData - LoadMobProto(%s) Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FLOPHKEN@LoadLocaleData?5?9?5LoadItemDesc?$CI?$CFs@
CONST	SEGMENT
??_C@_0CI@FLOPHKEN@LoadLocaleData?5?9?5LoadItemDesc?$CI?$CFs@ DB 'LoadLoc'
	DB	'aleData - LoadItemDesc(%s) Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MIFDPICO@LoadLocaleData?5?9?5LoadItemProto?$CI?$CF@
CONST	SEGMENT
??_C@_0CJ@MIFDPICO@LoadLocaleData?5?9?5LoadItemProto?$CI?$CF@ DB 'LoadLoc'
	DB	'aleData - LoadItemProto(%s) Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MGBDCDJE@LoadLocaleData?5?9?5LoadItemList?$CI?$CFs@
CONST	SEGMENT
??_C@_0CI@MGBDCDJE@LoadLocaleData?5?9?5LoadItemList?$CI?$CFs@ DB 'LoadLoc'
	DB	'aleData - LoadItemList(%s) Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JEIJHCCG@?$CFs?1insult?4txt?$AA@
CONST	SEGMENT
??_C@_0O@JEIJHCCG@?$CFs?1insult?4txt?$AA@ DB '%s/insult.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NLEJCAEF@?$CFs?1SkillTable?4txt?$AA@
CONST	SEGMENT
??_C@_0BC@NLEJCAEF@?$CFs?1SkillTable?4txt?$AA@ DB '%s/SkillTable.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JDMIHPNN@?$CFs?1SkillDesc?4txt?$AA@
CONST	SEGMENT
??_C@_0BB@JDMIHPNN@?$CFs?1SkillDesc?4txt?$AA@ DB '%s/SkillDesc.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KCBCHIHM@?$CFs?1mob_proto?$AA@
CONST	SEGMENT
??_C@_0N@KCBCHIHM@?$CFs?1mob_proto?$AA@ DB '%s/mob_proto', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BIDKFLDM@?$CFs?1itemdesc?4txt?$AA@
CONST	SEGMENT
??_C@_0BA@BIDKFLDM@?$CFs?1itemdesc?4txt?$AA@ DB '%s/itemdesc.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEMEPBB@?$CFs?1item_proto?$AA@
CONST	SEGMENT
??_C@_0O@MEMEPBB@?$CFs?1item_proto?$AA@ DB '%s/item_proto', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EOELDOLA@?$CFs?1item_list?4txt?$AA@
CONST	SEGMENT
??_C@_0BB@EOELDOLA@?$CFs?1item_list?4txt?$AA@ DB '%s/item_list.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JAHEKIGK@CreateDevice?3?5Unknown?5Error?$CB?$AA@
CONST	SEGMENT
??_C@_0BN@JAHEKIGK@CreateDevice?3?5Unknown?5Error?$CB?$AA@ DB 'CreateDevi'
	DB	'ce: Unknown Error!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BAEJJDKB@UNKNOWN_ERROR?$AA@
CONST	SEGMENT
??_C@_0O@BAEJJDKB@UNKNOWN_ERROR?$AA@ DB 'UNKNOWN_ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JLAAEKGJ@CreateDevice?3?5GetDevCaps2?5failed@
CONST	SEGMENT
??_C@_0CB@JLAAEKGJ@CreateDevice?3?5GetDevCaps2?5failed@ DB 'CreateDevice:'
	DB	' GetDevCaps2 failed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IHNLMMLJ@GetDevCaps2?5failed?$AA@
CONST	SEGMENT
??_C@_0BD@IHNLMMLJ@GetDevCaps2?5failed?$AA@ DB 'GetDevCaps2 failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DLHDILBB@CreateDevice?3?5GetDevCaps?5failed?$AA@
CONST	SEGMENT
??_C@_0CA@DLHDILBB@CreateDevice?3?5GetDevCaps?5failed?$AA@ DB 'CreateDevi'
	DB	'ce: GetDevCaps failed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IMJEDJEA@GetDevCaps?5failed?$AA@
CONST	SEGMENT
??_C@_0BC@IMJEDJEA@GetDevCaps?5failed?$AA@ DB 'GetDevCaps failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DEBFNBPL@CreateDevice?3?5Change?5the?5screen?5@
CONST	SEGMENT
??_C@_0CH@DEBFNBPL@CreateDevice?3?5Change?5the?5screen?5@ DB 'CreateDevic'
	DB	'e: Change the screen format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DAEHMKOB@CREATE_FORMAT?$AA@
CONST	SEGMENT
??_C@_0O@DAEHMKOB@CREATE_FORMAT?$AA@ DB 'CREATE_FORMAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KMPBIDGP@CreateDevice?3?5GraphicDevice?5crea@
CONST	SEGMENT
??_C@_0CK@KMPBIDGP@CreateDevice?3?5GraphicDevice?5crea@ DB 'CreateDevice:'
	DB	' GraphicDevice create failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CMPMDOEH@CREATE_DEVICE?$AA@
CONST	SEGMENT
??_C@_0O@CMPMDOEH@CREATE_DEVICE?$AA@ DB 'CREATE_DEVICE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@GACPAJMM@CreateDevice?3?5DirectX?58?41?5or?5gre@
CONST	SEGMENT
??_C@_0DK@GACPAJMM@CreateDevice?3?5DirectX?58?41?5or?5gre@ DB 'CreateDevi'
	DB	'ce: DirectX 8.1 or greater required to run game', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NKAKBNDM@CREATE_NO_DIRECTX?$AA@
CONST	SEGMENT
??_C@_0BC@NKAKBNDM@CREATE_NO_DIRECTX?$AA@ DB 'CREATE_NO_DIRECTX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GGLEAAKE@CreateDevice?3?5Enum?5?$CG?5Detect?5fail@
CONST	SEGMENT
??_C@_0CD@GGLEAAKE@CreateDevice?3?5Enum?5?$CG?5Detect?5fail@ DB 'CreateDe'
	DB	'vice: Enum & Detect failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OAKBEJJN@CREATE_NO_APPROPRIATE_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BN@OAKBEJJN@CREATE_NO_APPROPRIATE_DEVICE?$AA@ DB 'CREATE_NO_APPROP'
	DB	'RIATE_DEVICE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MOGGPFAH@WARN_NO_TNL?$AA@
CONST	SEGMENT
??_C@_0M@MOGGPFAH@WARN_NO_TNL?$AA@ DB 'WARN_NO_TNL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NOHKOOIE@WARN_BAD_DRIVER?$AA@
CONST	SEGMENT
??_C@_0BA@NOHKOOIE@WARN_BAD_DRIVER?$AA@ DB 'WARN_BAD_DRIVER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OJBILBDC@FrameSkip?5?$LK?$LI?A?$KE?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BD@OJBILBDC@FrameSkip?5?$LK?$LI?A?$KE?5?$CFd?6?$AA@ DB 'FrameSkip '
	DB	0baH, 0b8H, 0c1H, 0a4H, ' %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PAGGCBDD@GU?4POS?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@PAGGCBDD@GU?4POS?5?$CFd?6?$AA@ DB 'GU.POS %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KNCOIAL@GU?4PLR?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@KNCOIAL@GU?4PLR?5?$CFd?6?$AA@ DB 'GU.PLR %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPJHKAOM@GU?4ITM?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@MPJHKAOM@GU?4ITM?5?$CFd?6?$AA@ DB 'GU.ITM %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NKMBCAGE@GU?4FLY?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@NKMBCAGE@GU?4FLY?5?$CFd?6?$AA@ DB 'GU.FLY %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EMKAGLBH@GU?4EFT?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@EMKAGLBH@GU?4EFT?5?$CFd?6?$AA@ DB 'GU.EFT %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MKJPKNA@GU?4CHR?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@MKJPKNA@GU?4CHR?5?$CFd?6?$AA@ DB 'GU.CHR %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BLLECFKE@GU?4GEM?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@BLLECFKE@GU?4GEM?5?$CFd?6?$AA@ DB 'GU.GEM %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JGPPFKPH@GU?4BG?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_09JGPPFKPH@GU?4BG?5?$CFd?6?$AA@ DB 'GU.BG %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IGEOOJOO@GU?4MPS?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@IGEOOJOO@GU?4MPS?5?$CFd?6?$AA@ DB 'GU.MPS %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HCBFJPAB@GU?4SCR?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@HCBFJPAB@GU?4SCR?5?$CFd?6?$AA@ DB 'GU.SCR %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JHBDHKIG@GU?4GMP?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@JHBDHKIG@GU?4GMP?5?$CFd?6?$AA@ DB 'GU.GMP %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HPIDKEA@GU?4Total?5?$CFd?5?$CITime?5?$CFd?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BH@HPIDKEA@GU?4Total?5?$CFd?5?$CITime?5?$CFd?$CJ?6?$AA@ DB 'GU.Tot'
	DB	'al %d (Time %d)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NHIIGIH@perf_game_update?4txt?$AA@
CONST	SEGMENT
??_C@_0BF@NHIIGIH@perf_game_update?4txt?$AA@ DB 'perf_game_update.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EEAHGPFP@GR?4BG?4BLK?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0O@EEAHGPFP@GR?4BG?4BLK?5?$CFd?6?$AA@ DB 'GR.BG.BLK %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DIBNDLBN@GR?4FLY?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@DIBNDLBN@GR?4FLY?5?$CFd?6?$AA@ DB 'GR.FLY %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CNELLLJF@GR?4ITM?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@CNELLLJF@GR?4ITM?5?$CFd?6?$AA@ DB 'GR.ITM %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KOHMHAGO@GR?4EFT?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@KOHMHAGO@GR?4EFT?5?$CFd?6?$AA@ DB 'GR.EFT %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BIDCIJEG@GR?4BG?4EFT?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0O@BIDCIJEG@GR?4BG?4EFT?5?$CFd?6?$AA@ DB 'GR.BG.EFT %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LENBOK@GR?4BG?4WTR?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0O@LENBOK@GR?4BG?4WTR?5?$CFd?6?$AA@ DB 'GR.BG.WTR %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OOHFOBKJ@GR?4CHR?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@OOHFOBKJ@GR?4CHR?5?$CFd?6?$AA@ DB 'GR.CHR %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EJKDFAIB@GR?4BG?4MAIN?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0P@EJKDFAIB@GR?4BG?4MAIN?5?$CFd?6?$AA@ DB 'GR.BG.MAIN %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HJPLNNBE@GR?4BG?4CLD?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0O@HJPLNNBE@GR?4BG?4CLD?5?$CFd?6?$AA@ DB 'GR.BG.CLD %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JENIKJAN@GR?4BG?4LEN?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0O@JENIKJAN@GR?4BG?4LEN?5?$CFd?6?$AA@ DB 'GR.BG.LEN %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HPKPMDPE@GR?4BG?4SKY?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0O@HPKPMDPE@GR?4BG?4SKY?5?$CFd?6?$AA@ DB 'GR.BG.SKY %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CDOGKGFB@GR?4CLL?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@CDOGKGFB@GR?4CLL?5?$CFd?6?$AA@ DB 'GR.CLL %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OEOJMFCF@GR?4STT?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@OEOJMFCF@GR?4STT?5?$CFd?6?$AA@ DB 'GR.STT %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCADEBDB@GR?4SHW?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@MCADEBDB@GR?4SHW?5?$CFd?6?$AA@ DB 'GR.SHW %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PLGAMGBI@GR?4EFT?4UP?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0O@PLGAMGBI@GR?4EFT?4UP?5?$CFd?6?$AA@ DB 'GR.EFT.UP %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EGAPCDKD@GR?4DFM?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0L@EGAPCDKD@GR?4DFM?5?$CFd?6?$AA@ DB 'GR.DFM %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GCCBAEAA@GR?4Total?5?$CFd?5?$CITime?5?$CFd?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BH@GCCBAEAA@GR?4Total?5?$CFd?5?$CITime?5?$CFd?$CJ?6?$AA@ DB 'GR.To'
	DB	'tal %d (Time %d)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OHHAPIAL@perf_game_render?4txt?$AA@
CONST	SEGMENT
??_C@_0BF@OHHAPIAL@perf_game_render?4txt?$AA@ DB 'perf_game_render.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EHJKIBDK@Abort?$CB?$CB?$CB?$CB?6?6?$AA@
CONST	SEGMENT
??_C@_0M@EHJKIBDK@Abort?$CB?$CB?$CB?$CB?6?6?$AA@ DB 'Abort!!!!', 0aH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GN@LLBDNFAM@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0GN@LLBDNFAM@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '='
	DB	'============================================================='
	DB	'==============================================', 00H ; `string'
?c_fDefaultCameraZoomSpeed@@3MA DD 03d4ccccdr	; 0.05	; c_fDefaultCameraZoomSpeed
?c_fDefaultCameraPitchSpeed@@3MA DD 03fc00000r	; 1.5	; c_fDefaultCameraPitchSpeed
?c_fDefaultCameraRotateSpeed@@3MA DD 03fc00000r	; 1.5	; c_fDefaultCameraRotateSpeed
?g_specularSpd@@3NA DQ 03f7cac0840000000r	; 0.007	; g_specularSpd
?MIN_FOG@@3MA DD 045160000r			; 2400	; MIN_FOG
PUBLIC	??_ECPythonApplication@@WCA@AEPAXI@Z		; [thunk]:CPythonApplication::`vector deleting destructor'
PUBLIC	??_ECPythonApplication@@WBM@AEPAXI@Z		; [thunk]:CPythonApplication::`vector deleting destructor'
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::construct<std::_Tree_node<std::pair<int const ,void *>,void *> *,std::_Tree_node<std::pair<int const ,void *>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBHPAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::destroy<std::pair<int const ,void *> >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::destroy<std::_Tree_node<std::pair<int const ,void *>,void *> *>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,void *>,void *> *,std::_Tree_node<std::pair<int const ,void *>,void *> * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,void *>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBHPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAU?$pair@$$CBHPAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::pair<int const ,void *> >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,void *>,void *> *>
PUBLIC	??$_Allocate@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<int const ,void *>,void *> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,void *>,void *> *,std::_Tree_node<std::pair<int const ,void *>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBHPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::pair<int const ,void *> >
PUBLIC	??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z ; std::addressof<std::pair<int const ,void *> >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,void *>,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<int const ,void *>,void *> *>
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::allocate
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::operator++
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >
PUBLIC	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Buyheadnode
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator++
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Min
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Max
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Myval
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Isnil
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Color
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >
PUBLIC	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Erase
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator!=
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator==
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator++
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Right
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Parent
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Left
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::deallocate
PUBLIC	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Getal
PUBLIC	??0?$_Tree_buy@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >::_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::clear
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
PUBLIC	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Freeheadnode
PUBLIC	??0?$_Tree_comp@$0A@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::begin
PUBLIC	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >
PUBLIC	??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tidy
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
PUBLIC	??1?$_Tree_buy@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ ; std::_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >::~_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >
PUBLIC	??1?$_Tree_comp@$0A@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
PUBLIC	??_G?$CSingleton@VCMovieMan@@@@UAEPAXI@Z	; CSingleton<CMovieMan>::`scalar deleting destructor'
PUBLIC	??_G?$TAbstractSingleton@VIAbstractApplication@@@@UAEPAXI@Z ; TAbstractSingleton<IAbstractApplication>::`scalar deleting destructor'
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
PUBLIC	??0?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >
PUBLIC	??1?$CSingleton@VCMovieMan@@@@UAE@XZ		; CSingleton<CMovieMan>::~CSingleton<CMovieMan>
PUBLIC	??0?$CSingleton@VCMovieMan@@@@QAE@XZ		; CSingleton<CMovieMan>::CSingleton<CMovieMan>
PUBLIC	??1?$TAbstractSingleton@VIAbstractApplication@@@@UAE@XZ ; TAbstractSingleton<IAbstractApplication>::~TAbstractSingleton<IAbstractApplication>
PUBLIC	??0?$TAbstractSingleton@VIAbstractApplication@@@@QAE@XZ ; TAbstractSingleton<IAbstractApplication>::TAbstractSingleton<IAbstractApplication>
PUBLIC	?Instance@?$CSingleton@VCPythonIME@@@@SAAAVCPythonIME@@XZ ; CSingleton<CPythonIME>::Instance
PUBLIC	?Instance@?$CSingleton@VCPythonSkill@@@@SAAAVCPythonSkill@@XZ ; CSingleton<CPythonSkill>::Instance
PUBLIC	?Instance@?$CSingleton@VCWindowManager@UI@@@@SAAAVCWindowManager@UI@@XZ ; CSingleton<UI::CWindowManager>::Instance
PUBLIC	?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ; CSingleton<CTimer>::Instance
PUBLIC	?Destroy@CPythonApplication@@QAEXXZ		; CPythonApplication::Destroy
PUBLIC	?Clear@CPythonApplication@@QAEXXZ		; CPythonApplication::Clear
PUBLIC	?SetForceSightRange@CPythonApplication@@QAEXH@Z	; CPythonApplication::SetForceSightRange
PUBLIC	?SetCameraSpeed@CPythonApplication@@QAEXH@Z	; CPythonApplication::SetCameraSpeed
PUBLIC	?EnableSpecialCameraMode@CPythonApplication@@QAEXXZ ; CPythonApplication::EnableSpecialCameraMode
PUBLIC	?GetConnectData@CPythonApplication@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAH@Z ; CPythonApplication::GetConnectData
PUBLIC	?SetConnectData@CPythonApplication@@QAEXPBDH@Z	; CPythonApplication::SetConnectData
PUBLIC	?SetFPS@CPythonApplication@@QAEXH@Z		; CPythonApplication::SetFPS
PUBLIC	?GetGlobalElapsedTime@CPythonApplication@@UAEMXZ ; CPythonApplication::GetGlobalElapsedTime
PUBLIC	?GetGlobalTime@CPythonApplication@@UAEMXZ	; CPythonApplication::GetGlobalTime
PUBLIC	?GetServerTimeStamp@CPythonApplication@@QAEJXZ	; CPythonApplication::GetServerTimeStamp
PUBLIC	?GetServerTime@CPythonApplication@@QAEJXZ	; CPythonApplication::GetServerTime
PUBLIC	?SetServerTime@CPythonApplication@@UAEXJ@Z	; CPythonApplication::SetServerTime
PUBLIC	?GetCenterPosition@CPythonApplication@@QAEXPAUD3DXVECTOR3@@@Z ; CPythonApplication::GetCenterPosition
PUBLIC	?SetCenterPosition@CPythonApplication@@UAEXMMM@Z ; CPythonApplication::SetCenterPosition
PUBLIC	?SetGlobalCenterPosition@CPythonApplication@@QAEXJJ@Z ; CPythonApplication::SetGlobalCenterPosition
PUBLIC	?Create@CPythonApplication@@QAE_NPAU_object@@PBDHHH@Z ; CPythonApplication::Create
PUBLIC	?__GetWindowMode@@YAI_N@Z			; __GetWindowMode
PUBLIC	?LoadLocaleData@@YA_NPBD@Z			; LoadLocaleData
PUBLIC	?Loop@CPythonApplication@@QAEXXZ		; CPythonApplication::Loop
PUBLIC	?CreateDevice@CPythonApplication@@QAE_NHHHHH@Z	; CPythonApplication::CreateDevice
PUBLIC	?SetMouseHandler@CPythonApplication@@QAEXPAU_object@@@Z ; CPythonApplication::SetMouseHandler
PUBLIC	?Process@CPythonApplication@@QAE_NXZ		; CPythonApplication::Process
PUBLIC	?SkipRenderBuffering@CPythonApplication@@UAEXK@Z ; CPythonApplication::SkipRenderBuffering
PUBLIC	?UpdateGame@CPythonApplication@@QAEXXZ		; CPythonApplication::UpdateGame
PUBLIC	?RenderGame@CPythonApplication@@QAEXXZ		; CPythonApplication::RenderGame
PUBLIC	?Exit@CPythonApplication@@QAEXXZ		; CPythonApplication::Exit
PUBLIC	?Abort@CPythonApplication@@QAEXXZ		; CPythonApplication::Abort
PUBLIC	?GetInfo@CPythonApplication@@QAEXIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPythonApplication::GetInfo
PUBLIC	?SetFrameSkip@CPythonApplication@@QAEX_N@Z	; CPythonApplication::SetFrameSkip
PUBLIC	?SetMinFog@CPythonApplication@@QAEXM@Z		; CPythonApplication::SetMinFog
PUBLIC	?GetMousePosition@CPythonApplication@@UAEXPAUtagPOINT@@@Z ; CPythonApplication::GetMousePosition
PUBLIC	??1CPythonApplication@@UAE@XZ			; CPythonApplication::~CPythonApplication
PUBLIC	??1?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::~map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >
PUBLIC	??_GCPythonApplication@@UAEPAXI@Z		; CPythonApplication::`scalar deleting destructor'
PUBLIC	??0CPythonApplication@@QAE@XZ			; CPythonApplication::CPythonApplication
PUBLIC	??0SCameraSpeed@CPythonApplication@@QAE@XZ	; CPythonApplication::SCameraSpeed::SCameraSpeed
PUBLIC	??_GCMovieMan@@UAEPAXI@Z			; CMovieMan::`scalar deleting destructor'
PUBLIC	??1CMovieMan@@UAE@XZ				; CMovieMan::~CMovieMan
PUBLIC	??0CMovieMan@@QAE@XZ				; CMovieMan::CMovieMan
PUBLIC	??_GIAbstractApplication@@UAEPAXI@Z		; IAbstractApplication::`scalar deleting destructor'
PUBLIC	??1IAbstractApplication@@UAE@XZ			; IAbstractApplication::~IAbstractApplication
PUBLIC	??0IAbstractApplication@@QAE@XZ			; IAbstractApplication::IAbstractApplication
PUBLIC	??0SCameraSetting@IAbstractApplication@@QAE@XZ	; IAbstractApplication::SCameraSetting::SCameraSetting
PUBLIC	??0SCameraPos@IAbstractApplication@@QAE@XZ	; IAbstractApplication::SCameraPos::SCameraPos
PUBLIC	?SetMapManagerPtr@CFlyingManager@@QAEXPAVCMapManager@@@Z ; CFlyingManager::SetMapManagerPtr
EXTRN	??_EIAbstractApplication@@UAEPAXI@Z:PROC	; IAbstractApplication::`vector deleting destructor'
EXTRN	??_E?$TAbstractSingleton@VIAbstractApplication@@@@UAEPAXI@Z:PROC ; TAbstractSingleton<IAbstractApplication>::`vector deleting destructor'
EXTRN	??_ECMovieMan@@UAEPAXI@Z:PROC			; CMovieMan::`vector deleting destructor'
EXTRN	??_E?$CSingleton@VCMovieMan@@@@UAEPAXI@Z:PROC	; CSingleton<CMovieMan>::`vector deleting destructor'
EXTRN	??_ECPythonApplication@@UAEPAXI@Z:PROC		; CPythonApplication::`vector deleting destructor'
_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?$S1@?L@??RenderGame@CPythonApplication@@QAEXXZ@4IA
_BSS	SEGMENT
?$S1@?L@??RenderGame@CPythonApplication@@QAEXXZ@4IA DD 01H DUP (?) ; `CPythonApplication::RenderGame'::`11'::$S1
_BSS	ENDS
;	COMDAT ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
_BSS	SEGMENT
?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A DD 01H DUP (?) ; `CPythonApplication::RenderGame'::`11'::fp
_BSS	ENDS
;	COMDAT ?$S2@?8??UpdateGame@CPythonApplication@@QAEXXZ@4IA
_BSS	SEGMENT
?$S2@?8??UpdateGame@CPythonApplication@@QAEXXZ@4IA DD 01H DUP (?) ; `CPythonApplication::UpdateGame'::`9'::$S2
_BSS	ENDS
;	COMDAT ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
_BSS	SEGMENT
?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A DD 01H DUP (?) ; `CPythonApplication::UpdateGame'::`9'::fp
_BSS	ENDS
;	COMDAT ?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA
_BSS	SEGMENT
?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA DD 01H DUP (?) ; `CPythonApplication::Process'::`2'::$S3
_BSS	ENDS
;	COMDAT ?s_dwCheckTime@?1??Process@CPythonApplication@@QAE_NXZ@4KA
_BSS	SEGMENT
?s_dwCheckTime@?1??Process@CPythonApplication@@QAE_NXZ@4KA DD 01H DUP (?) ; `CPythonApplication::Process'::`2'::s_dwCheckTime
_BSS	ENDS
;	COMDAT ?s_uiNextFrameTime@?4??Process@CPythonApplication@@QAE_NXZ@4IA
_BSS	SEGMENT
?s_uiNextFrameTime@?4??Process@CPythonApplication@@QAE_NXZ@4IA DD 01H DUP (?) ; `CPythonApplication::Process'::`5'::s_uiNextFrameTime
_BSS	ENDS
;	COMDAT ?s_dwRenderCheckTime@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA
_BSS	SEGMENT
?s_dwRenderCheckTime@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA DD 01H DUP (?) ; `CPythonApplication::Process'::`41'::s_dwRenderCheckTime
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CPythonApplication@@QAE@XZ DD 019930522H
	DD	02bH
	DD	FLAT:__unwindtable$??0CPythonApplication@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0CPythonApplication@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$18
	DD	012H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$19
	DD	013H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$20
	DD	014H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$21
	DD	015H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$22
	DD	016H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$23
	DD	017H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$24
	DD	018H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$25
	DD	019H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$26
	DD	01aH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$27
	DD	01bH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$28
	DD	01cH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$29
	DD	01dH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$30
	DD	01eH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$31
	DD	01fH
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$32
	DD	020H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$33
	DD	021H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$34
	DD	022H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$35
	DD	023H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$36
	DD	024H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$37
	DD	025H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$38
	DD	026H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$39
	DD	027H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$40
	DD	028H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$41
	DD	029H
	DD	FLAT:__unwindfunclet$??0CPythonApplication@@QAE@XZ$42
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CPythonApplication@@UAE@XZ DD 019930522H
	DD	027H
	DD	FLAT:__unwindtable$??1CPythonApplication@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??1CPythonApplication@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$18
	DD	012H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$19
	DD	013H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$20
	DD	014H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$21
	DD	015H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$22
	DD	016H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$23
	DD	017H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$24
	DD	018H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$25
	DD	019H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$26
	DD	01aH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$27
	DD	01bH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$28
	DD	01cH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$29
	DD	01dH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$30
	DD	01eH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$31
	DD	01fH
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$32
	DD	020H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$33
	DD	021H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$34
	DD	022H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$35
	DD	023H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$36
	DD	024H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$37
	DD	025H
	DD	FLAT:__unwindfunclet$??1CPythonApplication@@UAE@XZ$38
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?UpdateGame@CPythonApplication@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateGame@CPythonApplication@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?UpdateGame@CPythonApplication@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateGame@CPythonApplication@@QAEXXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Process@CPythonApplication@@QAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Process@CPythonApplication@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Process@CPythonApplication@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Process@CPythonApplication@@QAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Process@CPythonApplication@@QAE_NXZ$1
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyingobjectmanager.h
;	COMDAT ?SetMapManagerPtr@CFlyingManager@@QAEXPAVCMapManager@@@Z
_TEXT	SEGMENT
_pMapManager$ = 8					; size = 4
?SetMapManagerPtr@CFlyingManager@@QAEXPAVCMapManager@@@Z PROC ; CFlyingManager::SetMapManagerPtr, COMDAT
; _this$ = ecx

; 38   : 	void SetMapManagerPtr(CMapManager * pMapManager) { m_pMapManager = pMapManager; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _pMapManager$[ebp]
  00006	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetMapManagerPtr@CFlyingManager@@QAEXPAVCMapManager@@@Z ENDP ; CFlyingManager::SetMapManagerPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
;	COMDAT ??0SCameraPos@IAbstractApplication@@QAE@XZ
_TEXT	SEGMENT
??0SCameraPos@IAbstractApplication@@QAE@XZ PROC		; IAbstractApplication::SCameraPos::SCameraPos, COMDAT
; _this$ = ecx

; 14   : 			SCameraPos() : m_fUpDir(0.0f), m_fViewDir(0.0f), m_fCrossDir(0.0f) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0SCameraPos@IAbstractApplication@@QAE@XZ ENDP		; IAbstractApplication::SCameraPos::SCameraPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
;	COMDAT ??0SCameraSetting@IAbstractApplication@@QAE@XZ
_TEXT	SEGMENT
??0SCameraSetting@IAbstractApplication@@QAE@XZ PROC	; IAbstractApplication::SCameraSetting::SCameraSetting, COMDAT
; _this$ = ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h

; 28   : 								fZoom(0.0f) {}

  00006	8b c1		 mov	 eax, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 181  :     y = fy;

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 182  :     z = fz;

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h

; 14   : 			SCameraPos() : m_fUpDir(0.0f), m_fViewDir(0.0f), m_fCrossDir(0.0f) {}

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 28   : 								fZoom(0.0f) {}

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00040	c3		 ret	 0
??0SCameraSetting@IAbstractApplication@@QAE@XZ ENDP	; IAbstractApplication::SCameraSetting::SCameraSetting
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
;	COMDAT ??0IAbstractApplication@@QAE@XZ
_TEXT	SEGMENT
??0IAbstractApplication@@QAE@XZ PROC			; IAbstractApplication::IAbstractApplication, COMDAT
; _this$ = ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h

; 13   : 		ms_singleton = (T*) ((int) this + offset);

  00000	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A, ecx ; TAbstractSingleton<IAbstractApplication>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h

; 32   : 		IAbstractApplication() {}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IAbstractApplication@@6B@
  0000e	c3		 ret	 0
??0IAbstractApplication@@QAE@XZ ENDP			; IAbstractApplication::IAbstractApplication
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
;	COMDAT ??1IAbstractApplication@@UAE@XZ
_TEXT	SEGMENT
??1IAbstractApplication@@UAE@XZ PROC			; IAbstractApplication::~IAbstractApplication, COMDAT
; _this$ = ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h

; 17   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$TAbstractSingleton@VIAbstractApplication@@@@6B@

; 18   : 		assert(ms_singleton);
; 19   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A, 0 ; TAbstractSingleton<IAbstractApplication>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h

; 33   : 		virtual ~IAbstractApplication() {}

  00010	c3		 ret	 0
??1IAbstractApplication@@UAE@XZ ENDP			; IAbstractApplication::~IAbstractApplication
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
;	COMDAT ??_GIAbstractApplication@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GIAbstractApplication@@UAEPAXI@Z PROC		; IAbstractApplication::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 19   : 		ms_singleton = 0; 

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A, 0 ; TAbstractSingleton<IAbstractApplication>::ms_singleton
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$TAbstractSingleton@VIAbstractApplication@@@@6B@
  0001a	74 09		 je	 SHORT $LN8@scalar
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$LN8@scalar:
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_GIAbstractApplication@@UAEPAXI@Z ENDP		; IAbstractApplication::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h
;	COMDAT ??0CMovieMan@@QAE@XZ
_TEXT	SEGMENT
??0CMovieMan@@QAE@XZ PROC				; CMovieMan::CMovieMan, COMDAT
; _this$ = ecx

; 31   : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 32   : 		CoInitialize(NULL);

  00003	6a 00		 push	 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  00005	89 35 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A, esi ; CSingleton<CMovieMan>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h

; 31   : 	{

  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CMovieMan@@6B@
  00011	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00015	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001c	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00023	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  0002a	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 32   : 		CoInitialize(NULL);

  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitialize@4

; 33   : 	};

  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi
  0003a	c3		 ret	 0
??0CMovieMan@@QAE@XZ ENDP				; CMovieMan::CMovieMan
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h
;	COMDAT ??1CMovieMan@@UAE@XZ
_TEXT	SEGMENT
??1CMovieMan@@UAE@XZ PROC				; CMovieMan::~CMovieMan, COMDAT
; _this$ = ecx

; 36   : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CMovieMan@@6B@

; 37   : 		CoUninitialize();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 19   : 	{ 

  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCMovieMan@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00015	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A, 0 ; CSingleton<CMovieMan>::ms_singleton
  0001f	5e		 pop	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h

; 38   : 	};

  00020	c3		 ret	 0
??1CMovieMan@@UAE@XZ ENDP				; CMovieMan::~CMovieMan
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??_GCMovieMan@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMovieMan@@UAEPAXI@Z PROC				; CMovieMan::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h

; 36   : 	{

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CMovieMan@@6B@

; 37   : 		CoUninitialize();

  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
  00012	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 19   : 	{ 

  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCMovieMan@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  0001c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A, 0 ; CSingleton<CMovieMan>::ms_singleton
  00026	74 09		 je	 SHORT $LN8@scalar
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4
$LN8@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_GCMovieMan@@UAEPAXI@Z ENDP				; CMovieMan::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.h
;	COMDAT ??0SCameraSpeed@CPythonApplication@@QAE@XZ
_TEXT	SEGMENT
??0SCameraSpeed@CPythonApplication@@QAE@XZ PROC		; CPythonApplication::SCameraSpeed::SCameraSpeed, COMDAT
; _this$ = ecx

; 121  : 			SCameraSpeed() : m_fUpDir(0.0f), m_fViewDir(0.0f), m_fCrossDir(0.0f) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0SCameraSpeed@CPythonApplication@@QAE@XZ ENDP		; CPythonApplication::SCameraSpeed::SCameraSpeed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyingobjectmanager.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ??0CPythonApplication@@QAE@XZ
_TEXT	SEGMENT
$T2 = -36						; size = 12
$T3 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CPythonApplication@@QAE@XZ PROC			; CPythonApplication::CPythonApplication, COMDAT
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CPythonApplication@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	e8 00 00 00 00	 call	 ??0CMSApplication@@QAE@XZ ; CMSApplication::CMSApplication
  00031	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003b	e8 00 00 00 00	 call	 ??0CInputKeyboard@@QAE@XZ ; CInputKeyboard::CInputKeyboard
  00040	8d 47 20	 lea	 eax, DWORD PTR [edi+32]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h

; 32   : 		IAbstractApplication() {}

  00043	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IAbstractApplication@@6B@
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h

; 13   : 		ms_singleton = (T*) ((int) this + offset);

  00049	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A, eax ; TAbstractSingleton<IAbstractApplication>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 47   : {

  0004e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00052	8d 4f 60	 lea	 ecx, DWORD PTR [edi+96]
  00055	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CPythonApplication@@6BCMSApplication@@@
  0005b	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], OFFSET ??_7CPythonApplication@@6BCInputKeyboard@@@
  00062	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CPythonApplication@@6BIAbstractApplication@@@
  00068	e8 00 00 00 00	 call	 ??0CTimer@@QAE@XZ	; CTimer::CTimer
  0006d	8d 4f 7c	 lea	 ecx, DWORD PTR [edi+124]
  00070	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00074	e8 00 00 00 00	 call	 ??0CLightManager@@QAE@XZ ; CLightManager::CLightManager
  00079	8d 8f e8 00 00
	00		 lea	 ecx, DWORD PTR [edi+232]
  0007f	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00083	e8 00 00 00 00	 call	 ??0CSoundManager@@QAE@XZ ; CSoundManager::CSoundManager
  00088	8d 8f 5c 01 00
	00		 lea	 ecx, DWORD PTR [edi+348]
  0008e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00092	e8 00 00 00 00	 call	 ??0CFlyingManager@@QAE@XZ ; CFlyingManager::CFlyingManager
  00097	8d 8f 80 01 00
	00		 lea	 ecx, DWORD PTR [edi+384]
  0009d	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  000a1	e8 00 00 00 00	 call	 ??0CRaceManager@@QAE@XZ	; CRaceManager::CRaceManager
  000a6	8d 8f b8 01 00
	00		 lea	 ecx, DWORD PTR [edi+440]
  000ac	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  000b0	e8 00 00 00 00	 call	 ??0CGameEventManager@@QAE@XZ ; CGameEventManager::CGameEventManager
  000b5	8d 8f cc 01 00
	00		 lea	 ecx, DWORD PTR [edi+460]
  000bb	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  000bf	e8 00 00 00 00	 call	 ??0CItemManager@@QAE@XZ	; CItemManager::CItemManager
  000c4	8d 87 e8 01 00
	00		 lea	 eax, DWORD PTR [edi+488]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h

; 31   : 	{

  000ca	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMovieMan@@6B@

; 32   : 		CoInitialize(NULL);

  000d0	6a 00		 push	 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  000d2	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A, eax ; CSingleton<CMovieMan>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h

; 31   : 	{

  000d7	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000db	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  000e2	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  000e9	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  000f0	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 32   : 		CoInitialize(NULL);

  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitialize@4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 47   : {

  000fd	8d 8f 10 02 00
	00		 lea	 ecx, DWORD PTR [edi+528]
  00103	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00107	e8 00 00 00 00	 call	 ??0CWindowManager@UI@@QAE@XZ ; UI::CWindowManager::CWindowManager
  0010c	8d 8f b0 02 00
	00		 lea	 ecx, DWORD PTR [edi+688]
  00112	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00116	e8 00 00 00 00	 call	 ??0CEffectManager@@QAE@XZ ; CEffectManager::CEffectManager
  0011b	8d 8f d8 02 00
	00		 lea	 ecx, DWORD PTR [edi+728]
  00121	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00125	e8 00 00 00 00	 call	 ??0CPythonCharacterManager@@QAE@XZ ; CPythonCharacterManager::CPythonCharacterManager
  0012a	8d 8f 10 07 00
	00		 lea	 ecx, DWORD PTR [edi+1808]
  00130	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00134	e8 00 00 00 00	 call	 ??0CServerStateChecker@@QAE@XZ ; CServerStateChecker::CServerStateChecker
  00139	8d 8f 9c 07 00
	00		 lea	 ecx, DWORD PTR [edi+1948]
  0013f	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00143	e8 00 00 00 00	 call	 ??0CPythonGraphic@@QAE@XZ ; CPythonGraphic::CPythonGraphic
  00148	8d 8f 40 08 00
	00		 lea	 ecx, DWORD PTR [edi+2112]
  0014e	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00152	e8 00 00 00 00	 call	 ??0CPythonNetworkStream@@QAE@XZ ; CPythonNetworkStream::CPythonNetworkStream
  00157	8d 8f 90 81 00
	00		 lea	 ecx, DWORD PTR [edi+33168]
  0015d	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  00161	e8 00 00 00 00	 call	 ??0CPythonPlayer@@QAE@XZ ; CPythonPlayer::CPythonPlayer
  00166	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  0016a	8d 8f dc 8b 01
	00		 lea	 ecx, DWORD PTR [edi+101340]
  00170	e8 00 00 00 00	 call	 ??0CPythonIME@@QAE@XZ	; CPythonIME::CPythonIME
  00175	8d 8f 08 94 01
	00		 lea	 ecx, DWORD PTR [edi+103432]
  0017b	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  0017f	e8 00 00 00 00	 call	 ??0CPythonItem@@QAE@XZ	; CPythonItem::CPythonItem
  00184	8d 8f 14 95 01
	00		 lea	 ecx, DWORD PTR [edi+103700]
  0018a	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  0018e	e8 00 00 00 00	 call	 ??0CPythonShop@@QAE@XZ	; CPythonShop::CPythonShop
  00193	8d 8f ac a9 01
	00		 lea	 ecx, DWORD PTR [edi+108972]
  00199	e8 00 00 00 00	 call	 ??0CPythonExchange@@QAE@XZ ; CPythonExchange::CPythonExchange
  0019e	8d 8f 8c ad 01
	00		 lea	 ecx, DWORD PTR [edi+109964]
  001a4	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  001a8	e8 00 00 00 00	 call	 ??0CPythonChat@@QAE@XZ	; CPythonChat::CPythonChat
  001ad	8d 8f 60 ae 01
	00		 lea	 ecx, DWORD PTR [edi+110176]
  001b3	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  001b7	e8 00 00 00 00	 call	 ??0CPythonTextTail@@QAE@XZ ; CPythonTextTail::CPythonTextTail
  001bc	8d 8f b0 ae 01
	00		 lea	 ecx, DWORD PTR [edi+110256]
  001c2	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
  001c6	e8 00 00 00 00	 call	 ??0CPythonNonPlayer@@QAE@XZ ; CPythonNonPlayer::CPythonNonPlayer
  001cb	8d 8f bc ae 01
	00		 lea	 ecx, DWORD PTR [edi+110268]
  001d1	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  001d5	e8 00 00 00 00	 call	 ??0CPythonMiniMap@@QAE@XZ ; CPythonMiniMap::CPythonMiniMap
  001da	8d 8f f4 ba 01
	00		 lea	 ecx, DWORD PTR [edi+113396]
  001e0	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H
  001e4	e8 00 00 00 00	 call	 ??0CPythonEventManager@@QAE@XZ ; CPythonEventManager::CPythonEventManager
  001e9	8d b7 74 bb 01
	00		 lea	 esi, DWORD PTR [edi+113524]
  001ef	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  001f3	8b ce		 mov	 ecx, esi
  001f5	e8 00 00 00 00	 call	 ??0CPythonBackground@@QAE@XZ ; CPythonBackground::CPythonBackground
  001fa	8d 8f 7c d1 01
	00		 lea	 ecx, DWORD PTR [edi+119164]
  00200	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
  00204	e8 00 00 00 00	 call	 ??0CPythonSkill@@QAE@XZ	; CPythonSkill::CPythonSkill
  00209	8d 8f c8 d1 01
	00		 lea	 ecx, DWORD PTR [edi+119240]
  0020f	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  00213	e8 00 00 00 00	 call	 ??0CPythonResource@@QAE@XZ ; CPythonResource::CPythonResource
  00218	8d 8f 10 d2 01
	00		 lea	 ecx, DWORD PTR [edi+119312]
  0021e	e8 00 00 00 00	 call	 ??0CPythonQuest@@QAE@XZ	; CPythonQuest::CPythonQuest
  00223	8d 8f 20 d2 01
	00		 lea	 ecx, DWORD PTR [edi+119328]
  00229	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+8], 30 ; 0000001eH
  0022d	e8 00 00 00 00	 call	 ??0CPythonMessenger@@QAE@XZ ; CPythonMessenger::CPythonMessenger
  00232	8d 8f 38 d2 01
	00		 lea	 ecx, DWORD PTR [edi+119352]
  00238	e8 00 00 00 00	 call	 ??0CPythonSafeBox@@QAE@XZ ; CPythonSafeBox::CPythonSafeBox
  0023d	8d 8f 58 d2 01
	00		 lea	 ecx, DWORD PTR [edi+119384]
  00243	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
  00247	e8 00 00 00 00	 call	 ??0CPythonGuild@@QAE@XZ	; CPythonGuild::CPythonGuild
  0024c	8d 8f f0 d2 01
	00		 lea	 ecx, DWORD PTR [edi+119536]
  00252	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
  00256	e8 00 00 00 00	 call	 ??0CGuildMarkManager@@QAE@XZ ; CGuildMarkManager::CGuildMarkManager
  0025b	8d 8f 2c d3 01
	00		 lea	 ecx, DWORD PTR [edi+119596]
  00261	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
  00265	e8 00 00 00 00	 call	 ??0CGuildMarkDownloader@@QAE@XZ ; CGuildMarkDownloader::CGuildMarkDownloader
  0026a	8d 8f dc d3 01
	00		 lea	 ecx, DWORD PTR [edi+119772]
  00270	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+8], 35 ; 00000023H
  00274	e8 00 00 00 00	 call	 ??0CGuildMarkUploader@@QAE@XZ ; CGuildMarkUploader::CGuildMarkUploader
  00279	8d 8f 7c d7 01
	00		 lea	 ecx, DWORD PTR [edi+120700]
  0027f	c6 45 fc 24	 mov	 BYTE PTR __$EHRec$[ebp+8], 36 ; 00000024H
  00283	e8 00 00 00 00	 call	 ??0CAccountConnector@@QAE@XZ ; CAccountConnector::CAccountConnector
  00288	8d 8f 54 d8 01
	00		 lea	 ecx, DWORD PTR [edi+120916]
  0028e	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+8], 37 ; 00000025H
  00292	e8 00 00 00 00	 call	 ??0CGraphicDevice@@QAE@XZ ; CGraphicDevice::CGraphicDevice
  00297	8d 8f 68 d8 01
	00		 lea	 ecx, DWORD PTR [edi+120936]
  0029d	c6 45 fc 26	 mov	 BYTE PTR __$EHRec$[ebp+8], 38 ; 00000026H
  002a1	e8 00 00 00 00	 call	 ??0CNetworkDevice@@QAE@XZ ; CNetworkDevice::CNetworkDevice
  002a6	8d 8f 70 d8 01
	00		 lea	 ecx, DWORD PTR [edi+120944]
  002ac	c6 45 fc 27	 mov	 BYTE PTR __$EHRec$[ebp+8], 39 ; 00000027H
  002b0	e8 00 00 00 00	 call	 ??0CPythonSystem@@QAE@XZ ; CPythonSystem::CPythonSystem
  002b5	c6 45 fc 28	 mov	 BYTE PTR __$EHRec$[ebp+8], 40 ; 00000028H
  002b9	0f 57 c0	 xorps	 xmm0, xmm0
  002bc	c7 87 60 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130912], 0
  002c6	c7 87 74 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130932], 0
  002d0	c7 87 8c ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130956], 0
  002da	c7 87 9c ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130972], 0
  002e4	c7 87 a0 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130976], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 180  :     x = fx;

  002ee	c7 87 a4 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130980], 0

; 181  :     y = fy;

  002f8	c7 87 a8 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130984], 0

; 182  :     z = fz;

  00302	c7 87 ac ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130988], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h

; 14   : 			SCameraPos() : m_fUpDir(0.0f), m_fViewDir(0.0f), m_fCrossDir(0.0f) {}

  0030c	c7 87 b0 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130992], 0
  00316	c7 87 b4 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130996], 0
  00320	c7 87 b8 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131000], 0

; 15   : 		};
; 16   : 
; 17   : 		struct SCameraSetting
; 18   : 		{
; 19   : 			D3DXVECTOR3				v3CenterPosition;
; 20   : 			SCameraPos				kCmrPos;
; 21   : 			float					fRotation;
; 22   : 			float					fPitch;
; 23   : 			float					fZoom;
; 24   : 
; 25   : 			SCameraSetting() :	v3CenterPosition(0.0f, 0.0f, 0.0f),
; 26   : 								fRotation(0.0f),
; 27   : 								fPitch(0.0f),
; 28   : 								fZoom(0.0f) {}

  0032a	c7 87 bc ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131004], 0
  00334	c7 87 c0 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131008], 0
  0033e	c7 87 c4 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131012], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00348	c7 87 c8 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131016], 0

; 181  :     y = fy;

  00352	c7 87 cc ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131020], 0

; 182  :     z = fz;

  0035c	c7 87 d0 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131024], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h

; 14   : 			SCameraPos() : m_fUpDir(0.0f), m_fViewDir(0.0f), m_fCrossDir(0.0f) {}

  00366	c7 87 d4 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131028], 0
  00370	c7 87 d8 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131032], 0
  0037a	c7 87 dc ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131036], 0

; 15   : 		};
; 16   : 
; 17   : 		struct SCameraSetting
; 18   : 		{
; 19   : 			D3DXVECTOR3				v3CenterPosition;
; 20   : 			SCameraPos				kCmrPos;
; 21   : 			float					fRotation;
; 22   : 			float					fPitch;
; 23   : 			float					fZoom;
; 24   : 
; 25   : 			SCameraSetting() :	v3CenterPosition(0.0f, 0.0f, 0.0f),
; 26   : 								fRotation(0.0f),
; 27   : 								fPitch(0.0f),
; 28   : 								fZoom(0.0f) {}

  00384	c7 87 e0 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131040], 0
  0038e	c7 87 e4 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131044], 0
  00398	c7 87 e8 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131048], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 180  :     x = fx;

  003a2	c7 87 f8 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131064], 0

; 181  :     y = fy;

  003ac	c7 87 fc ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131068], 0

; 182  :     z = fz;

  003b6	c7 87 00 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131072], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractapplication.h

; 14   : 			SCameraPos() : m_fUpDir(0.0f), m_fViewDir(0.0f), m_fCrossDir(0.0f) {}

  003c0	c7 87 04 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131076], 0
  003ca	c7 87 08 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131080], 0
  003d4	c7 87 0c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131084], 0

; 15   : 		};
; 16   : 
; 17   : 		struct SCameraSetting
; 18   : 		{
; 19   : 			D3DXVECTOR3				v3CenterPosition;
; 20   : 			SCameraPos				kCmrPos;
; 21   : 			float					fRotation;
; 22   : 			float					fPitch;
; 23   : 			float					fZoom;
; 24   : 
; 25   : 			SCameraSetting() :	v3CenterPosition(0.0f, 0.0f, 0.0f),
; 26   : 								fRotation(0.0f),
; 27   : 								fPitch(0.0f),
; 28   : 								fZoom(0.0f) {}

  003de	c7 87 10 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131088], 0
  003e8	c7 87 14 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131092], 0
  003f2	c7 87 18 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131096], 0

; 14   : 			SCameraPos() : m_fUpDir(0.0f), m_fViewDir(0.0f), m_fCrossDir(0.0f) {}

  003fc	c7 87 34 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131124], 0
  00406	c7 87 38 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131128], 0
  00410	c7 87 3c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131132], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.h

; 121  : 			SCameraSpeed() : m_fUpDir(0.0f), m_fViewDir(0.0f), m_fCrossDir(0.0f) {}

  0041a	c7 87 40 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131136], 0
  00424	c7 87 44 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131140], 0
  0042e	c7 87 48 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131144], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 47   : {

  00438	c7 87 64 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131172], 0
  00442	c7 87 68 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131176], 0
  0044c	c7 87 6c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131180], 0
  00456	c7 87 70 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131184], 0
  00460	66 0f d6 45 e8	 movq	 QWORD PTR $T3[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00465	c7 87 78 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131192], 0

; 570  : 		this->_Mysize = 0;

  0046f	c7 87 7c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131196], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00479	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Buyheadnode
  0047e	89 87 78 00 02
	00		 mov	 DWORD PTR [edi+131192], eax
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 47   : {

  00484	c7 87 84 00 02
	00 01 00 00 00	 mov	 DWORD PTR [edi+131204], 1
  0048e	c6 87 88 00 02
	00 00		 mov	 BYTE PTR [edi+131208], 0
  00495	c7 87 8c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131212], 0
  0049f	66 c7 87 90 00
	02 00 00 00	 mov	 WORD PTR [edi+131216], 0
  004a8	c7 87 a8 00 02
	00 0f 00 00 00	 mov	 DWORD PTR [edi+131240], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  004b2	c7 87 a4 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131236], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  004bc	c6 87 94 00 02
	00 00		 mov	 BYTE PTR [edi+131220], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 47   : {

  004c3	c6 45 fc 2a	 mov	 BYTE PTR __$EHRec$[ebp+8], 42 ; 0000002aH

; 48   : #ifndef _DEBUG
; 49   : 	SetEterExceptionHandler();

  004c7	e8 00 00 00 00	 call	 ?SetEterExceptionHandler@@YAXXZ ; SetEterExceptionHandler

; 50   : #endif
; 51   : 
; 52   : 	CTimer::Instance().UseCustomTime();

  004cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  004d2	e8 00 00 00 00	 call	 ?UseCustomTime@CTimer@@QAEXXZ ; CTimer::UseCustomTime

; 59   : 	m_v3CenterPosition = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  004d7	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR $T3[ebp]
  004dc	0f 14 c0	 unpcklps xmm0, xmm0
; File d:\metin2\metin2\client_source_clean\client_source_clean\extern\include\d3dx8math.inl

; 182  :     z = fz;

  004df	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+8], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 59   : 	m_v3CenterPosition = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  004e6	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp+8]
  004e9	66 0f d6 87 64
	ff 01 00	 movq	 QWORD PTR [edi+130916], xmm0
  004f1	c7 87 84 ff 01
	00 20 03 00 00	 mov	 DWORD PTR [edi+130948], 800 ; 00000320H
  004fb	c7 87 88 ff 01
	00 58 02 00 00	 mov	 DWORD PTR [edi+130952], 600 ; 00000258H
  00505	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A, edi ; CPythonApplication::ms_pInstance
  0050b	c7 87 b4 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131252], 0
  00515	89 87 6c ff 01
	00		 mov	 DWORD PTR [edi+130924], eax

; 60   : 	m_dwStartLocalTime = ELTimer_GetMSec();

  0051b	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00520	89 87 90 ff 01
	00		 mov	 DWORD PTR [edi+130960], eax

; 61   : 	m_tServerTime = 0;

  00526	c7 87 94 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130964], 0

; 62   : 	m_tLocalStartTime = 0;

  00530	c7 87 98 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+130968], 0

; 63   : 
; 64   : 	m_iPort = 0;

  0053a	c7 87 ac 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131244], 0

; 65   : 	m_iFPS = 60;

  00544	c7 87 70 ff 01
	00 3c 00 00 00	 mov	 DWORD PTR [edi+130928], 60 ; 0000003cH

; 66   : 
; 67   : 	m_isActivateWnd = false;
; 68   : 	m_isMinimizedWnd = true;

  0054e	66 c7 87 b0 00
	02 00 01 00	 mov	 WORD PTR [edi+131248], 1

; 69   : 
; 70   : 	m_fRotationSpeed = 0.0f;

  00557	c7 87 1c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131100], 0

; 71   : 	m_fPitchSpeed = 0.0f;

  00561	c7 87 20 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131104], 0

; 72   : 	m_fZoomSpeed = 0.0f;

  0056b	c7 87 24 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131108], 0

; 73   : 
; 74   : 	m_fFaceSpd=0.0f;

  00575	c7 87 50 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131152], 0

; 75   : 
; 76   : 	m_dwFaceAccCount=0;

  0057f	c7 87 5c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131164], 0

; 77   : 	m_dwFaceAccTime=0;

  00589	c7 87 60 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131168], 0

; 78   : 
; 79   : 	m_dwFaceSpdSum=0;

  00593	c7 87 54 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131156], 0

; 80   : 	m_dwFaceSpdCount=0;

  0059d	c7 87 58 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131160], 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\gamelib\flyingobjectmanager.h

; 38   : 	void SetMapManagerPtr(CMapManager * pMapManager) { m_pMapManager = pMapManager; }

  005a7	89 b7 78 01 00
	00		 mov	 DWORD PTR [edi+376], esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 84   : 	m_iCursorNum = CURSOR_SHAPE_NORMAL;

  005ad	c7 87 c4 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131268], 0

; 85   : 	m_iContinuousCursorNum = CURSOR_SHAPE_NORMAL;

  005b7	c7 87 c8 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131272], 0

; 86   : 
; 87   : 	m_isSpecialCameraMode = FALSE;

  005c1	c7 87 4c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131148], 0

; 88   : 	m_fCameraRotateSpeed = c_fDefaultCameraRotateSpeed;

  005cb	c7 87 28 00 02
	00 00 00 c0 3f	 mov	 DWORD PTR [edi+131112], 1069547520 ; 3fc00000H

; 89   : 	m_fCameraPitchSpeed = c_fDefaultCameraPitchSpeed;

  005d5	c7 87 2c 00 02
	00 00 00 c0 3f	 mov	 DWORD PTR [edi+131116], 1069547520 ; 3fc00000H

; 90   : 	m_fCameraZoomSpeed = c_fDefaultCameraZoomSpeed;

  005df	c7 87 30 00 02
	00 cd cc 4c 3d	 mov	 DWORD PTR [edi+131120], 1028443341 ; 3d4ccccdH

; 91   : 
; 92   : 	m_iCameraMode = CAMERA_MODE_NORMAL;

  005e9	c7 87 ec ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131052], 0

; 93   : 	m_fBlendCameraStartTime = 0.0f;

  005f3	c7 87 f0 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131056], 0

; 94   : 	m_fBlendCameraBlendTime = 0.0f;

  005fd	c7 87 f4 ff 01
	00 00 00 00 00	 mov	 DWORD PTR [edi+131060], 0

; 95   : 
; 96   : 	m_iForceSightRange = -1;

  00607	c7 87 c0 00 02
	00 ff ff ff ff	 mov	 DWORD PTR [edi+131264], -1

; 97   : 
; 98   : 	CCameraManager::Instance().AddCamera(EVENT_CAMERA_NUMBER);

  00611	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00617	6a 65		 push	 101			; 00000065H
  00619	e8 00 00 00 00	 call	 ?AddCamera@CCameraManager@@QAE_NE@Z ; CCameraManager::AddCamera

; 99   : }

  0061e	8b c7		 mov	 eax, edi
  00620	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00623	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0062a	59		 pop	 ecx
  0062b	5f		 pop	 edi
  0062c	5e		 pop	 esi
  0062d	8b e5		 mov	 esp, ebp
  0062f	5d		 pop	 ebp
  00630	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CPythonApplication@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMSApplication@@UAE@XZ ; CMSApplication::~CMSApplication
__unwindfunclet$??0CPythonApplication@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0000e	e9 00 00 00 00	 jmp	 ??1CInputKeyboard@@UAE@XZ ; CInputKeyboard::~CInputKeyboard
__unwindfunclet$??0CPythonApplication@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 20	 add	 ecx, 32			; 00000020H
  00019	e9 00 00 00 00	 jmp	 ??1IAbstractApplication@@UAE@XZ ; IAbstractApplication::~IAbstractApplication
__unwindfunclet$??0CPythonApplication@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 60	 add	 ecx, 96			; 00000060H
  00024	e9 00 00 00 00	 jmp	 ??1CTimer@@UAE@XZ	; CTimer::~CTimer
__unwindfunclet$??0CPythonApplication@@QAE@XZ$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0002f	e9 00 00 00 00	 jmp	 ??1CLightManager@@UAE@XZ ; CLightManager::~CLightManager
__unwindfunclet$??0CPythonApplication@@QAE@XZ$5:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  0003d	e9 00 00 00 00	 jmp	 ??1CSoundManager@@UAE@XZ ; CSoundManager::~CSoundManager
__unwindfunclet$??0CPythonApplication@@QAE@XZ$6:
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
  0004b	e9 00 00 00 00	 jmp	 ??1CFlyingManager@@UAE@XZ ; CFlyingManager::~CFlyingManager
__unwindfunclet$??0CPythonApplication@@QAE@XZ$7:
  00050	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	81 c1 80 01 00
	00		 add	 ecx, 384		; 00000180H
  00059	e9 00 00 00 00	 jmp	 ??1CRaceManager@@UAE@XZ	; CRaceManager::~CRaceManager
__unwindfunclet$??0CPythonApplication@@QAE@XZ$8:
  0005e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	81 c1 b8 01 00
	00		 add	 ecx, 440		; 000001b8H
  00067	e9 00 00 00 00	 jmp	 ??1CGameEventManager@@UAE@XZ ; CGameEventManager::~CGameEventManager
__unwindfunclet$??0CPythonApplication@@QAE@XZ$9:
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	81 c1 cc 01 00
	00		 add	 ecx, 460		; 000001ccH
  00075	e9 00 00 00 00	 jmp	 ??1CItemManager@@UAE@XZ	; CItemManager::~CItemManager
__unwindfunclet$??0CPythonApplication@@QAE@XZ$10:
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	81 c1 e8 01 00
	00		 add	 ecx, 488		; 000001e8H
  00083	e9 00 00 00 00	 jmp	 ??1CMovieMan@@UAE@XZ	; CMovieMan::~CMovieMan
__unwindfunclet$??0CPythonApplication@@QAE@XZ$11:
  00088	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	81 c1 10 02 00
	00		 add	 ecx, 528		; 00000210H
  00091	e9 00 00 00 00	 jmp	 ??1CWindowManager@UI@@UAE@XZ ; UI::CWindowManager::~CWindowManager
__unwindfunclet$??0CPythonApplication@@QAE@XZ$12:
  00096	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	81 c1 b0 02 00
	00		 add	 ecx, 688		; 000002b0H
  0009f	e9 00 00 00 00	 jmp	 ??1CEffectManager@@UAE@XZ ; CEffectManager::~CEffectManager
__unwindfunclet$??0CPythonApplication@@QAE@XZ$13:
  000a4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  000ad	e9 00 00 00 00	 jmp	 ??1CPythonCharacterManager@@UAE@XZ ; CPythonCharacterManager::~CPythonCharacterManager
__unwindfunclet$??0CPythonApplication@@QAE@XZ$14:
  000b2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	81 c1 10 07 00
	00		 add	 ecx, 1808		; 00000710H
  000bb	e9 00 00 00 00	 jmp	 ??1CServerStateChecker@@UAE@XZ ; CServerStateChecker::~CServerStateChecker
__unwindfunclet$??0CPythonApplication@@QAE@XZ$15:
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	81 c1 9c 07 00
	00		 add	 ecx, 1948		; 0000079cH
  000c9	e9 00 00 00 00	 jmp	 ??1CPythonGraphic@@UAE@XZ ; CPythonGraphic::~CPythonGraphic
__unwindfunclet$??0CPythonApplication@@QAE@XZ$16:
  000ce	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	81 c1 40 08 00
	00		 add	 ecx, 2112		; 00000840H
  000d7	e9 00 00 00 00	 jmp	 ??1CPythonNetworkStream@@UAE@XZ ; CPythonNetworkStream::~CPythonNetworkStream
__unwindfunclet$??0CPythonApplication@@QAE@XZ$17:
  000dc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	81 c1 90 81 00
	00		 add	 ecx, 33168		; 00008190H
  000e5	e9 00 00 00 00	 jmp	 ??1CPythonPlayer@@UAE@XZ ; CPythonPlayer::~CPythonPlayer
__unwindfunclet$??0CPythonApplication@@QAE@XZ$18:
  000ea	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	81 c1 dc 8b 01
	00		 add	 ecx, 101340		; 00018bdcH
  000f3	e9 00 00 00 00	 jmp	 ??1CPythonIME@@UAE@XZ	; CPythonIME::~CPythonIME
__unwindfunclet$??0CPythonApplication@@QAE@XZ$19:
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	81 c1 08 94 01
	00		 add	 ecx, 103432		; 00019408H
  00101	e9 00 00 00 00	 jmp	 ??1CPythonItem@@UAE@XZ	; CPythonItem::~CPythonItem
__unwindfunclet$??0CPythonApplication@@QAE@XZ$20:
  00106	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	81 c1 14 95 01
	00		 add	 ecx, 103700		; 00019514H
  0010f	e9 00 00 00 00	 jmp	 ??1CPythonShop@@UAE@XZ	; CPythonShop::~CPythonShop
__unwindfunclet$??0CPythonApplication@@QAE@XZ$21:
  00114	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	81 c1 ac a9 01
	00		 add	 ecx, 108972		; 0001a9acH
  0011d	e9 00 00 00 00	 jmp	 ??1CPythonExchange@@UAE@XZ ; CPythonExchange::~CPythonExchange
__unwindfunclet$??0CPythonApplication@@QAE@XZ$22:
  00122	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	81 c1 8c ad 01
	00		 add	 ecx, 109964		; 0001ad8cH
  0012b	e9 00 00 00 00	 jmp	 ??1CPythonChat@@UAE@XZ	; CPythonChat::~CPythonChat
__unwindfunclet$??0CPythonApplication@@QAE@XZ$23:
  00130	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00133	81 c1 60 ae 01
	00		 add	 ecx, 110176		; 0001ae60H
  00139	e9 00 00 00 00	 jmp	 ??1CPythonTextTail@@UAE@XZ ; CPythonTextTail::~CPythonTextTail
__unwindfunclet$??0CPythonApplication@@QAE@XZ$24:
  0013e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	81 c1 b0 ae 01
	00		 add	 ecx, 110256		; 0001aeb0H
  00147	e9 00 00 00 00	 jmp	 ??1CPythonNonPlayer@@UAE@XZ ; CPythonNonPlayer::~CPythonNonPlayer
__unwindfunclet$??0CPythonApplication@@QAE@XZ$25:
  0014c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	81 c1 bc ae 01
	00		 add	 ecx, 110268		; 0001aebcH
  00155	e9 00 00 00 00	 jmp	 ??1CPythonMiniMap@@UAE@XZ ; CPythonMiniMap::~CPythonMiniMap
__unwindfunclet$??0CPythonApplication@@QAE@XZ$26:
  0015a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015d	81 c1 f4 ba 01
	00		 add	 ecx, 113396		; 0001baf4H
  00163	e9 00 00 00 00	 jmp	 ??1CPythonEventManager@@UAE@XZ ; CPythonEventManager::~CPythonEventManager
__unwindfunclet$??0CPythonApplication@@QAE@XZ$27:
  00168	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016b	81 c1 74 bb 01
	00		 add	 ecx, 113524		; 0001bb74H
  00171	e9 00 00 00 00	 jmp	 ??1CPythonBackground@@UAE@XZ ; CPythonBackground::~CPythonBackground
__unwindfunclet$??0CPythonApplication@@QAE@XZ$28:
  00176	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00179	81 c1 7c d1 01
	00		 add	 ecx, 119164		; 0001d17cH
  0017f	e9 00 00 00 00	 jmp	 ??1CPythonSkill@@UAE@XZ	; CPythonSkill::~CPythonSkill
__unwindfunclet$??0CPythonApplication@@QAE@XZ$29:
  00184	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00187	81 c1 c8 d1 01
	00		 add	 ecx, 119240		; 0001d1c8H
  0018d	e9 00 00 00 00	 jmp	 ??1CPythonResource@@UAE@XZ ; CPythonResource::~CPythonResource
__unwindfunclet$??0CPythonApplication@@QAE@XZ$30:
  00192	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00195	81 c1 10 d2 01
	00		 add	 ecx, 119312		; 0001d210H
  0019b	e9 00 00 00 00	 jmp	 ??1CPythonQuest@@UAE@XZ	; CPythonQuest::~CPythonQuest
__unwindfunclet$??0CPythonApplication@@QAE@XZ$31:
  001a0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	81 c1 20 d2 01
	00		 add	 ecx, 119328		; 0001d220H
  001a9	e9 00 00 00 00	 jmp	 ??1CPythonMessenger@@UAE@XZ ; CPythonMessenger::~CPythonMessenger
__unwindfunclet$??0CPythonApplication@@QAE@XZ$32:
  001ae	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	81 c1 38 d2 01
	00		 add	 ecx, 119352		; 0001d238H
  001b7	e9 00 00 00 00	 jmp	 ??1CPythonSafeBox@@UAE@XZ ; CPythonSafeBox::~CPythonSafeBox
__unwindfunclet$??0CPythonApplication@@QAE@XZ$33:
  001bc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001bf	81 c1 58 d2 01
	00		 add	 ecx, 119384		; 0001d258H
  001c5	e9 00 00 00 00	 jmp	 ??1CPythonGuild@@UAE@XZ	; CPythonGuild::~CPythonGuild
__unwindfunclet$??0CPythonApplication@@QAE@XZ$34:
  001ca	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	81 c1 f0 d2 01
	00		 add	 ecx, 119536		; 0001d2f0H
  001d3	e9 00 00 00 00	 jmp	 ??1CGuildMarkManager@@UAE@XZ ; CGuildMarkManager::~CGuildMarkManager
__unwindfunclet$??0CPythonApplication@@QAE@XZ$35:
  001d8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	81 c1 2c d3 01
	00		 add	 ecx, 119596		; 0001d32cH
  001e1	e9 00 00 00 00	 jmp	 ??1CGuildMarkDownloader@@UAE@XZ ; CGuildMarkDownloader::~CGuildMarkDownloader
__unwindfunclet$??0CPythonApplication@@QAE@XZ$36:
  001e6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e9	81 c1 dc d3 01
	00		 add	 ecx, 119772		; 0001d3dcH
  001ef	e9 00 00 00 00	 jmp	 ??1CGuildMarkUploader@@UAE@XZ ; CGuildMarkUploader::~CGuildMarkUploader
__unwindfunclet$??0CPythonApplication@@QAE@XZ$37:
  001f4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001f7	81 c1 7c d7 01
	00		 add	 ecx, 120700		; 0001d77cH
  001fd	e9 00 00 00 00	 jmp	 ??1CAccountConnector@@UAE@XZ ; CAccountConnector::~CAccountConnector
__unwindfunclet$??0CPythonApplication@@QAE@XZ$38:
  00202	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00205	81 c1 54 d8 01
	00		 add	 ecx, 120916		; 0001d854H
  0020b	e9 00 00 00 00	 jmp	 ??1CGraphicDevice@@UAE@XZ ; CGraphicDevice::~CGraphicDevice
__unwindfunclet$??0CPythonApplication@@QAE@XZ$39:
  00210	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00213	81 c1 68 d8 01
	00		 add	 ecx, 120936		; 0001d868H
  00219	e9 00 00 00 00	 jmp	 ??1CNetworkDevice@@UAE@XZ ; CNetworkDevice::~CNetworkDevice
__unwindfunclet$??0CPythonApplication@@QAE@XZ$40:
  0021e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00221	81 c1 70 d8 01
	00		 add	 ecx, 120944		; 0001d870H
  00227	e9 00 00 00 00	 jmp	 ??1CPythonSystem@@UAE@XZ ; CPythonSystem::~CPythonSystem
__unwindfunclet$??0CPythonApplication@@QAE@XZ$41:
  0022c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0022f	81 c1 78 00 02
	00		 add	 ecx, 131192		; 00020078H
  00235	e9 00 00 00 00	 jmp	 ??1?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CPythonApplication@@QAE@XZ$42:
  0023a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0023d	81 c1 94 00 02
	00		 add	 ecx, 131220		; 00020094H
  00243	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0CPythonApplication@@QAE@XZ:
  00248	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0024c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0024f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00252	33 c8		 xor	 ecx, eax
  00254	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00259	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CPythonApplication@@QAE@XZ
  0025e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CPythonApplication@@QAE@XZ ENDP			; CPythonApplication::CPythonApplication
; Function compile flags: /Ogtp
;	COMDAT ??_GCPythonApplication@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPythonApplication@@UAEPAXI@Z PROC			; CPythonApplication::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPythonApplication@@UAE@XZ ; CPythonApplication::~CPythonApplication
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCPythonApplication@@UAEPAXI@Z ENDP			; CPythonApplication::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ PROC ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::~map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::~map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ??1CPythonApplication@@UAE@XZ
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CPythonApplication@@UAE@XZ PROC			; CPythonApplication::~CPythonApplication, COMDAT
; _this$ = ecx

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CPythonApplication@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CPythonApplication@@6BCMSApplication@@@
  00033	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], OFFSET ??_7CPythonApplication@@6BCInputKeyboard@@@
  0003a	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], OFFSET ??_7CPythonApplication@@6BIAbstractApplication@@@
  00041	c7 45 fc 26 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 38 ; 00000026H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00048	83 bf a8 00 02
	00 10		 cmp	 DWORD PTR [edi+131240], 16 ; 00000010H
  0004f	72 0e		 jb	 SHORT $LN66@CPythonApp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00051	ff b7 94 00 02
	00		 push	 DWORD PTR [edi+131220]
  00057	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005c	83 c4 04	 add	 esp, 4
$LN66@CPythonApp:
  0005f	c7 87 a8 00 02
	00 0f 00 00 00	 mov	 DWORD PTR [edi+131240], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00069	8d 8f 78 00 02
	00		 lea	 ecx, DWORD PTR [edi+131192]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0006f	c7 87 a4 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edi+131236], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00079	c6 87 94 00 02
	00 00		 mov	 BYTE PTR [edi+131220], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

  00080	8b 87 78 00 02
	00		 mov	 eax, DWORD PTR [edi+131192]

; 2230 : 		erase(begin(), end());

  00086	50		 push	 eax
  00087	ff 30		 push	 DWORD PTR [eax]
  00089	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00092	ff b7 78 00 02
	00		 push	 DWORD PTR [edi+131192]
  00098	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009d	83 c4 04	 add	 esp, 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 103  : }

  000a0	8d 8f 70 d8 01
	00		 lea	 ecx, DWORD PTR [edi+120944]
  000a6	e8 00 00 00 00	 call	 ??1CPythonSystem@@UAE@XZ ; CPythonSystem::~CPythonSystem
  000ab	8d 8f 68 d8 01
	00		 lea	 ecx, DWORD PTR [edi+120936]
  000b1	e8 00 00 00 00	 call	 ??1CNetworkDevice@@UAE@XZ ; CNetworkDevice::~CNetworkDevice
  000b6	8d 8f 54 d8 01
	00		 lea	 ecx, DWORD PTR [edi+120916]
  000bc	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+8], 37 ; 00000025H
  000c0	e8 00 00 00 00	 call	 ??1CGraphicDevice@@UAE@XZ ; CGraphicDevice::~CGraphicDevice
  000c5	8d 8f 7c d7 01
	00		 lea	 ecx, DWORD PTR [edi+120700]
  000cb	c6 45 fc 24	 mov	 BYTE PTR __$EHRec$[ebp+8], 36 ; 00000024H
  000cf	e8 00 00 00 00	 call	 ??1CAccountConnector@@UAE@XZ ; CAccountConnector::~CAccountConnector
  000d4	8d 8f dc d3 01
	00		 lea	 ecx, DWORD PTR [edi+119772]
  000da	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+8], 35 ; 00000023H
  000de	e8 00 00 00 00	 call	 ??1CGuildMarkUploader@@UAE@XZ ; CGuildMarkUploader::~CGuildMarkUploader
  000e3	8d 8f 2c d3 01
	00		 lea	 ecx, DWORD PTR [edi+119596]
  000e9	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
  000ed	e8 00 00 00 00	 call	 ??1CGuildMarkDownloader@@UAE@XZ ; CGuildMarkDownloader::~CGuildMarkDownloader
  000f2	8d 8f f0 d2 01
	00		 lea	 ecx, DWORD PTR [edi+119536]
  000f8	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
  000fc	e8 00 00 00 00	 call	 ??1CGuildMarkManager@@UAE@XZ ; CGuildMarkManager::~CGuildMarkManager
  00101	8d 8f 58 d2 01
	00		 lea	 ecx, DWORD PTR [edi+119384]
  00107	e8 00 00 00 00	 call	 ??1CPythonGuild@@UAE@XZ	; CPythonGuild::~CPythonGuild
  0010c	8d 8f 38 d2 01
	00		 lea	 ecx, DWORD PTR [edi+119352]
  00112	e8 00 00 00 00	 call	 ??1CPythonSafeBox@@UAE@XZ ; CPythonSafeBox::~CPythonSafeBox
  00117	8d 8f 20 d2 01
	00		 lea	 ecx, DWORD PTR [edi+119328]
  0011d	e8 00 00 00 00	 call	 ??1CPythonMessenger@@UAE@XZ ; CPythonMessenger::~CPythonMessenger
  00122	8d 8f 10 d2 01
	00		 lea	 ecx, DWORD PTR [edi+119312]
  00128	e8 00 00 00 00	 call	 ??1CPythonQuest@@UAE@XZ	; CPythonQuest::~CPythonQuest
  0012d	8d 8f c8 d1 01
	00		 lea	 ecx, DWORD PTR [edi+119240]
  00133	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  00137	e8 00 00 00 00	 call	 ??1CPythonResource@@UAE@XZ ; CPythonResource::~CPythonResource
  0013c	8d 8f 7c d1 01
	00		 lea	 ecx, DWORD PTR [edi+119164]
  00142	e8 00 00 00 00	 call	 ??1CPythonSkill@@UAE@XZ	; CPythonSkill::~CPythonSkill
  00147	8d 8f 74 bb 01
	00		 lea	 ecx, DWORD PTR [edi+113524]
  0014d	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  00151	e8 00 00 00 00	 call	 ??1CPythonBackground@@UAE@XZ ; CPythonBackground::~CPythonBackground
  00156	8d 8f f4 ba 01
	00		 lea	 ecx, DWORD PTR [edi+113396]
  0015c	e8 00 00 00 00	 call	 ??1CPythonEventManager@@UAE@XZ ; CPythonEventManager::~CPythonEventManager
  00161	8d 8f bc ae 01
	00		 lea	 ecx, DWORD PTR [edi+110268]
  00167	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  0016b	e8 00 00 00 00	 call	 ??1CPythonMiniMap@@UAE@XZ ; CPythonMiniMap::~CPythonMiniMap
  00170	8d 8f b0 ae 01
	00		 lea	 ecx, DWORD PTR [edi+110256]
  00176	e8 00 00 00 00	 call	 ??1CPythonNonPlayer@@UAE@XZ ; CPythonNonPlayer::~CPythonNonPlayer
  0017b	8d 8f 60 ae 01
	00		 lea	 ecx, DWORD PTR [edi+110176]
  00181	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  00185	e8 00 00 00 00	 call	 ??1CPythonTextTail@@UAE@XZ ; CPythonTextTail::~CPythonTextTail
  0018a	8d 8f 8c ad 01
	00		 lea	 ecx, DWORD PTR [edi+109964]
  00190	e8 00 00 00 00	 call	 ??1CPythonChat@@UAE@XZ	; CPythonChat::~CPythonChat
  00195	8d 8f ac a9 01
	00		 lea	 ecx, DWORD PTR [edi+108972]
  0019b	e8 00 00 00 00	 call	 ??1CPythonExchange@@UAE@XZ ; CPythonExchange::~CPythonExchange
  001a0	8d 8f 14 95 01
	00		 lea	 ecx, DWORD PTR [edi+103700]
  001a6	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  001aa	e8 00 00 00 00	 call	 ??1CPythonShop@@UAE@XZ	; CPythonShop::~CPythonShop
  001af	8d 8f 08 94 01
	00		 lea	 ecx, DWORD PTR [edi+103432]
  001b5	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  001b9	e8 00 00 00 00	 call	 ??1CPythonItem@@UAE@XZ	; CPythonItem::~CPythonItem
  001be	8d 8f dc 8b 01
	00		 lea	 ecx, DWORD PTR [edi+101340]
  001c4	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  001c8	e8 00 00 00 00	 call	 ??1CPythonIME@@UAE@XZ	; CPythonIME::~CPythonIME
  001cd	8d 8f 90 81 00
	00		 lea	 ecx, DWORD PTR [edi+33168]
  001d3	e8 00 00 00 00	 call	 ??1CPythonPlayer@@UAE@XZ ; CPythonPlayer::~CPythonPlayer
  001d8	8d 8f 40 08 00
	00		 lea	 ecx, DWORD PTR [edi+2112]
  001de	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  001e2	e8 00 00 00 00	 call	 ??1CPythonNetworkStream@@UAE@XZ ; CPythonNetworkStream::~CPythonNetworkStream
  001e7	8d 8f 9c 07 00
	00		 lea	 ecx, DWORD PTR [edi+1948]
  001ed	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  001f1	e8 00 00 00 00	 call	 ??1CPythonGraphic@@UAE@XZ ; CPythonGraphic::~CPythonGraphic
  001f6	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  001fa	8d 8f 10 07 00
	00		 lea	 ecx, DWORD PTR [edi+1808]
  00200	e8 00 00 00 00	 call	 ??1CServerStateChecker@@UAE@XZ ; CServerStateChecker::~CServerStateChecker
  00205	8d 8f d8 02 00
	00		 lea	 ecx, DWORD PTR [edi+728]
  0020b	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  0020f	e8 00 00 00 00	 call	 ??1CPythonCharacterManager@@UAE@XZ ; CPythonCharacterManager::~CPythonCharacterManager
  00214	8d 8f b0 02 00
	00		 lea	 ecx, DWORD PTR [edi+688]
  0021a	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  0021e	e8 00 00 00 00	 call	 ??1CEffectManager@@UAE@XZ ; CEffectManager::~CEffectManager
  00223	8d 8f 10 02 00
	00		 lea	 ecx, DWORD PTR [edi+528]
  00229	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  0022d	e8 00 00 00 00	 call	 ??1CWindowManager@UI@@UAE@XZ ; UI::CWindowManager::~CWindowManager
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\movieman.h

; 36   : 	{

  00232	c7 87 e8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+488], OFFSET ??_7CMovieMan@@6B@

; 37   : 		CoUninitialize();

  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 103  : }

  00242	8d 8f cc 01 00
	00		 lea	 ecx, DWORD PTR [edi+460]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 19   : 	{ 

  00248	c7 87 e8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+488], OFFSET ??_7?$CSingleton@VCMovieMan@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00252	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A, 0 ; CSingleton<CMovieMan>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 103  : }

  0025c	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00260	e8 00 00 00 00	 call	 ??1CItemManager@@UAE@XZ	; CItemManager::~CItemManager
  00265	8d 8f b8 01 00
	00		 lea	 ecx, DWORD PTR [edi+440]
  0026b	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0026f	e8 00 00 00 00	 call	 ??1CGameEventManager@@UAE@XZ ; CGameEventManager::~CGameEventManager
  00274	8d 8f 80 01 00
	00		 lea	 ecx, DWORD PTR [edi+384]
  0027a	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0027e	e8 00 00 00 00	 call	 ??1CRaceManager@@UAE@XZ	; CRaceManager::~CRaceManager
  00283	8d 8f 5c 01 00
	00		 lea	 ecx, DWORD PTR [edi+348]
  00289	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0028d	e8 00 00 00 00	 call	 ??1CFlyingManager@@UAE@XZ ; CFlyingManager::~CFlyingManager
  00292	8d 8f e8 00 00
	00		 lea	 ecx, DWORD PTR [edi+232]
  00298	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0029c	e8 00 00 00 00	 call	 ??1CSoundManager@@UAE@XZ ; CSoundManager::~CSoundManager
  002a1	8d 4f 7c	 lea	 ecx, DWORD PTR [edi+124]
  002a4	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  002a8	e8 00 00 00 00	 call	 ??1CLightManager@@UAE@XZ ; CLightManager::~CLightManager
  002ad	8d 4f 60	 lea	 ecx, DWORD PTR [edi+96]
  002b0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  002b4	e8 00 00 00 00	 call	 ??1CTimer@@UAE@XZ	; CTimer::~CTimer
  002b9	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h

; 17   : 	{ 

  002bc	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], OFFSET ??_7?$TAbstractSingleton@VIAbstractApplication@@@@6B@

; 18   : 		assert(ms_singleton);
; 19   : 		ms_singleton = 0; 

  002c3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A, 0 ; TAbstractSingleton<IAbstractApplication>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 103  : }

  002cd	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002d1	e8 00 00 00 00	 call	 ??1CInputKeyboard@@UAE@XZ ; CInputKeyboard::~CInputKeyboard
  002d6	8b cf		 mov	 ecx, edi
  002d8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002df	e8 00 00 00 00	 call	 ??1CMSApplication@@UAE@XZ ; CMSApplication::~CMSApplication
  002e4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002e7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002ee	59		 pop	 ecx
  002ef	5f		 pop	 edi
  002f0	5e		 pop	 esi
  002f1	5b		 pop	 ebx
  002f2	8b e5		 mov	 esp, ebp
  002f4	5d		 pop	 ebp
  002f5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CPythonApplication@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMSApplication@@UAE@XZ ; CMSApplication::~CMSApplication
__unwindfunclet$??1CPythonApplication@@UAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0000e	e9 00 00 00 00	 jmp	 ??1CInputKeyboard@@UAE@XZ ; CInputKeyboard::~CInputKeyboard
__unwindfunclet$??1CPythonApplication@@UAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 20	 add	 ecx, 32			; 00000020H
  00019	e9 00 00 00 00	 jmp	 ??1IAbstractApplication@@UAE@XZ ; IAbstractApplication::~IAbstractApplication
__unwindfunclet$??1CPythonApplication@@UAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 60	 add	 ecx, 96			; 00000060H
  00024	e9 00 00 00 00	 jmp	 ??1CTimer@@UAE@XZ	; CTimer::~CTimer
__unwindfunclet$??1CPythonApplication@@UAE@XZ$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0002f	e9 00 00 00 00	 jmp	 ??1CLightManager@@UAE@XZ ; CLightManager::~CLightManager
__unwindfunclet$??1CPythonApplication@@UAE@XZ$5:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  0003d	e9 00 00 00 00	 jmp	 ??1CSoundManager@@UAE@XZ ; CSoundManager::~CSoundManager
__unwindfunclet$??1CPythonApplication@@UAE@XZ$6:
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	81 c1 5c 01 00
	00		 add	 ecx, 348		; 0000015cH
  0004b	e9 00 00 00 00	 jmp	 ??1CFlyingManager@@UAE@XZ ; CFlyingManager::~CFlyingManager
__unwindfunclet$??1CPythonApplication@@UAE@XZ$7:
  00050	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	81 c1 80 01 00
	00		 add	 ecx, 384		; 00000180H
  00059	e9 00 00 00 00	 jmp	 ??1CRaceManager@@UAE@XZ	; CRaceManager::~CRaceManager
__unwindfunclet$??1CPythonApplication@@UAE@XZ$8:
  0005e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	81 c1 b8 01 00
	00		 add	 ecx, 440		; 000001b8H
  00067	e9 00 00 00 00	 jmp	 ??1CGameEventManager@@UAE@XZ ; CGameEventManager::~CGameEventManager
__unwindfunclet$??1CPythonApplication@@UAE@XZ$9:
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	81 c1 cc 01 00
	00		 add	 ecx, 460		; 000001ccH
  00075	e9 00 00 00 00	 jmp	 ??1CItemManager@@UAE@XZ	; CItemManager::~CItemManager
__unwindfunclet$??1CPythonApplication@@UAE@XZ$10:
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	81 c1 e8 01 00
	00		 add	 ecx, 488		; 000001e8H
  00083	e9 00 00 00 00	 jmp	 ??1CMovieMan@@UAE@XZ	; CMovieMan::~CMovieMan
__unwindfunclet$??1CPythonApplication@@UAE@XZ$11:
  00088	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	81 c1 10 02 00
	00		 add	 ecx, 528		; 00000210H
  00091	e9 00 00 00 00	 jmp	 ??1CWindowManager@UI@@UAE@XZ ; UI::CWindowManager::~CWindowManager
__unwindfunclet$??1CPythonApplication@@UAE@XZ$12:
  00096	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	81 c1 b0 02 00
	00		 add	 ecx, 688		; 000002b0H
  0009f	e9 00 00 00 00	 jmp	 ??1CEffectManager@@UAE@XZ ; CEffectManager::~CEffectManager
__unwindfunclet$??1CPythonApplication@@UAE@XZ$13:
  000a4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  000ad	e9 00 00 00 00	 jmp	 ??1CPythonCharacterManager@@UAE@XZ ; CPythonCharacterManager::~CPythonCharacterManager
__unwindfunclet$??1CPythonApplication@@UAE@XZ$14:
  000b2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	81 c1 10 07 00
	00		 add	 ecx, 1808		; 00000710H
  000bb	e9 00 00 00 00	 jmp	 ??1CServerStateChecker@@UAE@XZ ; CServerStateChecker::~CServerStateChecker
__unwindfunclet$??1CPythonApplication@@UAE@XZ$15:
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	81 c1 9c 07 00
	00		 add	 ecx, 1948		; 0000079cH
  000c9	e9 00 00 00 00	 jmp	 ??1CPythonGraphic@@UAE@XZ ; CPythonGraphic::~CPythonGraphic
__unwindfunclet$??1CPythonApplication@@UAE@XZ$16:
  000ce	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	81 c1 40 08 00
	00		 add	 ecx, 2112		; 00000840H
  000d7	e9 00 00 00 00	 jmp	 ??1CPythonNetworkStream@@UAE@XZ ; CPythonNetworkStream::~CPythonNetworkStream
__unwindfunclet$??1CPythonApplication@@UAE@XZ$17:
  000dc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	81 c1 90 81 00
	00		 add	 ecx, 33168		; 00008190H
  000e5	e9 00 00 00 00	 jmp	 ??1CPythonPlayer@@UAE@XZ ; CPythonPlayer::~CPythonPlayer
__unwindfunclet$??1CPythonApplication@@UAE@XZ$18:
  000ea	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	81 c1 dc 8b 01
	00		 add	 ecx, 101340		; 00018bdcH
  000f3	e9 00 00 00 00	 jmp	 ??1CPythonIME@@UAE@XZ	; CPythonIME::~CPythonIME
__unwindfunclet$??1CPythonApplication@@UAE@XZ$19:
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	81 c1 08 94 01
	00		 add	 ecx, 103432		; 00019408H
  00101	e9 00 00 00 00	 jmp	 ??1CPythonItem@@UAE@XZ	; CPythonItem::~CPythonItem
__unwindfunclet$??1CPythonApplication@@UAE@XZ$20:
  00106	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	81 c1 14 95 01
	00		 add	 ecx, 103700		; 00019514H
  0010f	e9 00 00 00 00	 jmp	 ??1CPythonShop@@UAE@XZ	; CPythonShop::~CPythonShop
__unwindfunclet$??1CPythonApplication@@UAE@XZ$21:
  00114	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	81 c1 ac a9 01
	00		 add	 ecx, 108972		; 0001a9acH
  0011d	e9 00 00 00 00	 jmp	 ??1CPythonExchange@@UAE@XZ ; CPythonExchange::~CPythonExchange
__unwindfunclet$??1CPythonApplication@@UAE@XZ$22:
  00122	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	81 c1 8c ad 01
	00		 add	 ecx, 109964		; 0001ad8cH
  0012b	e9 00 00 00 00	 jmp	 ??1CPythonChat@@UAE@XZ	; CPythonChat::~CPythonChat
__unwindfunclet$??1CPythonApplication@@UAE@XZ$23:
  00130	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00133	81 c1 60 ae 01
	00		 add	 ecx, 110176		; 0001ae60H
  00139	e9 00 00 00 00	 jmp	 ??1CPythonTextTail@@UAE@XZ ; CPythonTextTail::~CPythonTextTail
__unwindfunclet$??1CPythonApplication@@UAE@XZ$24:
  0013e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	81 c1 b0 ae 01
	00		 add	 ecx, 110256		; 0001aeb0H
  00147	e9 00 00 00 00	 jmp	 ??1CPythonNonPlayer@@UAE@XZ ; CPythonNonPlayer::~CPythonNonPlayer
__unwindfunclet$??1CPythonApplication@@UAE@XZ$25:
  0014c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	81 c1 bc ae 01
	00		 add	 ecx, 110268		; 0001aebcH
  00155	e9 00 00 00 00	 jmp	 ??1CPythonMiniMap@@UAE@XZ ; CPythonMiniMap::~CPythonMiniMap
__unwindfunclet$??1CPythonApplication@@UAE@XZ$26:
  0015a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015d	81 c1 f4 ba 01
	00		 add	 ecx, 113396		; 0001baf4H
  00163	e9 00 00 00 00	 jmp	 ??1CPythonEventManager@@UAE@XZ ; CPythonEventManager::~CPythonEventManager
__unwindfunclet$??1CPythonApplication@@UAE@XZ$27:
  00168	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016b	81 c1 74 bb 01
	00		 add	 ecx, 113524		; 0001bb74H
  00171	e9 00 00 00 00	 jmp	 ??1CPythonBackground@@UAE@XZ ; CPythonBackground::~CPythonBackground
__unwindfunclet$??1CPythonApplication@@UAE@XZ$28:
  00176	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00179	81 c1 7c d1 01
	00		 add	 ecx, 119164		; 0001d17cH
  0017f	e9 00 00 00 00	 jmp	 ??1CPythonSkill@@UAE@XZ	; CPythonSkill::~CPythonSkill
__unwindfunclet$??1CPythonApplication@@UAE@XZ$29:
  00184	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00187	81 c1 c8 d1 01
	00		 add	 ecx, 119240		; 0001d1c8H
  0018d	e9 00 00 00 00	 jmp	 ??1CPythonResource@@UAE@XZ ; CPythonResource::~CPythonResource
__unwindfunclet$??1CPythonApplication@@UAE@XZ$30:
  00192	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00195	81 c1 10 d2 01
	00		 add	 ecx, 119312		; 0001d210H
  0019b	e9 00 00 00 00	 jmp	 ??1CPythonQuest@@UAE@XZ	; CPythonQuest::~CPythonQuest
__unwindfunclet$??1CPythonApplication@@UAE@XZ$31:
  001a0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	81 c1 20 d2 01
	00		 add	 ecx, 119328		; 0001d220H
  001a9	e9 00 00 00 00	 jmp	 ??1CPythonMessenger@@UAE@XZ ; CPythonMessenger::~CPythonMessenger
__unwindfunclet$??1CPythonApplication@@UAE@XZ$32:
  001ae	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	81 c1 38 d2 01
	00		 add	 ecx, 119352		; 0001d238H
  001b7	e9 00 00 00 00	 jmp	 ??1CPythonSafeBox@@UAE@XZ ; CPythonSafeBox::~CPythonSafeBox
__unwindfunclet$??1CPythonApplication@@UAE@XZ$33:
  001bc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001bf	81 c1 58 d2 01
	00		 add	 ecx, 119384		; 0001d258H
  001c5	e9 00 00 00 00	 jmp	 ??1CPythonGuild@@UAE@XZ	; CPythonGuild::~CPythonGuild
__unwindfunclet$??1CPythonApplication@@UAE@XZ$34:
  001ca	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	81 c1 f0 d2 01
	00		 add	 ecx, 119536		; 0001d2f0H
  001d3	e9 00 00 00 00	 jmp	 ??1CGuildMarkManager@@UAE@XZ ; CGuildMarkManager::~CGuildMarkManager
__unwindfunclet$??1CPythonApplication@@UAE@XZ$35:
  001d8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	81 c1 2c d3 01
	00		 add	 ecx, 119596		; 0001d32cH
  001e1	e9 00 00 00 00	 jmp	 ??1CGuildMarkDownloader@@UAE@XZ ; CGuildMarkDownloader::~CGuildMarkDownloader
__unwindfunclet$??1CPythonApplication@@UAE@XZ$36:
  001e6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e9	81 c1 dc d3 01
	00		 add	 ecx, 119772		; 0001d3dcH
  001ef	e9 00 00 00 00	 jmp	 ??1CGuildMarkUploader@@UAE@XZ ; CGuildMarkUploader::~CGuildMarkUploader
__unwindfunclet$??1CPythonApplication@@UAE@XZ$37:
  001f4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001f7	81 c1 7c d7 01
	00		 add	 ecx, 120700		; 0001d77cH
  001fd	e9 00 00 00 00	 jmp	 ??1CAccountConnector@@UAE@XZ ; CAccountConnector::~CAccountConnector
__unwindfunclet$??1CPythonApplication@@UAE@XZ$38:
  00202	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00205	81 c1 54 d8 01
	00		 add	 ecx, 120916		; 0001d854H
  0020b	e9 00 00 00 00	 jmp	 ??1CGraphicDevice@@UAE@XZ ; CGraphicDevice::~CGraphicDevice
__ehhandler$??1CPythonApplication@@UAE@XZ:
  00210	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00214	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00217	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0021a	33 c8		 xor	 ecx, eax
  0021c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00221	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CPythonApplication@@UAE@XZ
  00226	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CPythonApplication@@UAE@XZ ENDP			; CPythonApplication::~CPythonApplication
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?GetMousePosition@CPythonApplication@@UAEXPAUtagPOINT@@@Z
_TEXT	SEGMENT
_ppt$ = 8						; size = 4
?GetMousePosition@CPythonApplication@@UAEXPAUtagPOINT@@@Z PROC ; CPythonApplication::GetMousePosition, COMDAT
; _this$ = ecx

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  : 	CMSApplication::GetMousePosition(ppt);

  00003	83 c1 e0	 add	 ecx, -32		; ffffffe0H

; 108  : }

  00006	5d		 pop	 ebp

; 107  : 	CMSApplication::GetMousePosition(ppt);

  00007	e9 00 00 00 00	 jmp	 ?GetMousePosition@CMSWindow@@QAEXPAUtagPOINT@@@Z ; CMSWindow::GetMousePosition
?GetMousePosition@CPythonApplication@@UAEXPAUtagPOINT@@@Z ENDP ; CPythonApplication::GetMousePosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?SetMinFog@CPythonApplication@@QAEXM@Z
_TEXT	SEGMENT
?SetMinFog@CPythonApplication@@QAEXM@Z PROC		; CPythonApplication::SetMinFog, COMDAT
; _this$dead$ = ecx
; _fMinFog$ = xmm1s

; 112  : 	MIN_FOG = fMinFog;

  00000	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR ?MIN_FOG@@3MA, xmm1

; 113  : }

  00008	c3		 ret	 0
?SetMinFog@CPythonApplication@@QAEXM@Z ENDP		; CPythonApplication::SetMinFog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?SetFrameSkip@CPythonApplication@@QAEX_N@Z
_TEXT	SEGMENT
_isEnable$ = 8						; size = 1
?SetFrameSkip@CPythonApplication@@QAEX_N@Z PROC		; CPythonApplication::SetFrameSkip, COMDAT
; _this$ = ecx

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 117  : 	if (isEnable)

  00003	80 7d 08 00	 cmp	 BYTE PTR _isEnable$[ebp], 0
  00007	0f 94 c0	 sete	 al
  0000a	88 81 91 00 02
	00		 mov	 BYTE PTR [ecx+131217], al

; 118  : 		m_isFrameSkipDisable=false;
; 119  : 	else
; 120  : 		m_isFrameSkipDisable=true;
; 121  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?SetFrameSkip@CPythonApplication@@QAEX_N@Z ENDP		; CPythonApplication::SetFrameSkip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?GetInfo@CPythonApplication@@QAEXIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_eInfo$ = 8						; size = 4
_pstInfo$ = 12						; size = 4
?GetInfo@CPythonApplication@@QAEXIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CPythonApplication::GetInfo, COMDAT
; _this$ = ecx

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  : 	switch (eInfo)

  00003	8b 45 08	 mov	 eax, DWORD PTR _eInfo$[ebp]
  00006	83 f8 03	 cmp	 eax, 3
  00009	77 4b		 ja	 SHORT $LN5@GetInfo
  0000b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN10@GetInfo[eax*4]
$LN4@GetInfo:

; 137  : 	{
; 138  : 	case INFO_ACTOR:
; 139  : 		m_kChrMgr.GetInfo(pstInfo);

  00012	ff 75 0c	 push	 DWORD PTR _pstInfo$[ebp]
  00015	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  0001b	e8 00 00 00 00	 call	 ?GetInfo@CPythonCharacterManager@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPythonCharacterManager::GetInfo

; 149  : 		break;
; 150  : 	}
; 151  : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN3@GetInfo:

; 140  : 		break;
; 141  : 	case INFO_EFFECT:
; 142  : 		m_kEftMgr.GetInfo(pstInfo);			

  00024	ff 75 0c	 push	 DWORD PTR _pstInfo$[ebp]
  00027	81 c1 b0 02 00
	00		 add	 ecx, 688		; 000002b0H
  0002d	e8 00 00 00 00	 call	 ?GetInfo@CEffectManager@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CEffectManager::GetInfo

; 149  : 		break;
; 150  : 	}
; 151  : }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
$LN2@GetInfo:

; 143  : 		break;
; 144  : 	case INFO_ITEM:
; 145  : 		m_pyItem.GetInfo(pstInfo);

  00036	ff 75 0c	 push	 DWORD PTR _pstInfo$[ebp]
  00039	81 c1 08 94 01
	00		 add	 ecx, 103432		; 00019408H
  0003f	e8 00 00 00 00	 call	 ?GetInfo@CPythonItem@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPythonItem::GetInfo

; 149  : 		break;
; 150  : 	}
; 151  : }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
$LN1@GetInfo:

; 146  : 		break;
; 147  : 	case INFO_TEXTTAIL:
; 148  : 		m_pyTextTail.GetInfo(pstInfo);

  00048	ff 75 0c	 push	 DWORD PTR _pstInfo$[ebp]
  0004b	81 c1 60 ae 01
	00		 add	 ecx, 110176		; 0001ae60H
  00051	e8 00 00 00 00	 call	 ?GetInfo@CPythonTextTail@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPythonTextTail::GetInfo
$LN5@GetInfo:

; 149  : 		break;
; 150  : 	}
; 151  : }

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
  0005a	8b ff		 npad	 2
$LN10@GetInfo:
  0005c	00 00 00 00	 DD	 $LN4@GetInfo
  00060	00 00 00 00	 DD	 $LN3@GetInfo
  00064	00 00 00 00	 DD	 $LN2@GetInfo
  00068	00 00 00 00	 DD	 $LN1@GetInfo
?GetInfo@CPythonApplication@@QAEXIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CPythonApplication::GetInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?Abort@CPythonApplication@@QAEXXZ
_TEXT	SEGMENT
?Abort@CPythonApplication@@QAEXXZ PROC			; CPythonApplication::Abort, COMDAT
; _this$dead$ = ecx

; 155  : 	TraceError("============================================================================================================");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0GN@LLBDNFAM@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
  00005	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError

; 156  : 	TraceError("Abort!!!!\n\n");

  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EHJKIBDK@Abort?$CB?$CB?$CB?$CB?6?6?$AA@
  0000f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00014	83 c4 08	 add	 esp, 8

; 157  : 
; 158  : 	PostQuitMessage(0);

  00017	6a 00		 push	 0
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 159  : }

  0001f	c3		 ret	 0
?Abort@CPythonApplication@@QAEXXZ ENDP			; CPythonApplication::Abort
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?Exit@CPythonApplication@@QAEXXZ
_TEXT	SEGMENT
?Exit@CPythonApplication@@QAEXXZ PROC			; CPythonApplication::Exit, COMDAT
; _this$dead$ = ecx

; 163  : 	PostQuitMessage(0);

  00000	6a 00		 push	 0
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 164  : }

  00008	c3		 ret	 0
?Exit@CPythonApplication@@QAEXXZ ENDP			; CPythonApplication::Exit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?RenderGame@CPythonApplication@@QAEXXZ
_TEXT	SEGMENT
_t9$1$ = -68						; size = 4
_t8$1$ = -64						; size = 4
_lx$1 = -64						; size = 4
_ly$2 = -64						; size = 4
_fAspect$3 = -64					; size = 4
_t7$1$ = -60						; size = 4
_ly$4 = -60						; size = 4
_fAspect$ = -60						; size = 4
_lx$5 = -60						; size = 4
_t1$1$ = -56						; size = 4
_t2$1$ = -52						; size = 4
_t3$1$ = -48						; size = 4
_t4$1$ = -44						; size = 4
_t5$1$ = -40						; size = 4
_t6$1$ = -36						; size = 4
_t10$1$ = -32						; size = 4
_t11$1$ = -28						; size = 4
_t12$1$ = -24						; size = 4
_t13$1$ = -20						; size = 4
_t14$1$ = -16						; size = 4
_t15$1$ = -12						; size = 4
_t16$1$ = -8						; size = 4
_t17$1$ = -4						; size = 4
?RenderGame@CPythonApplication@@QAEXXZ PROC		; CPythonApplication::RenderGame, COMDAT
; _this$ = ecx

; 169  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 44	 sub	 esp, 68			; 00000044H

; 170  : 	if (!PERF_CHECKER_RENDER_GAME)

  00009	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?PERF_CHECKER_RENDER_GAME@@3_NA, 0 ; PERF_CHECKER_RENDER_GAME
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b f1		 mov	 esi, ecx
  00015	0f 85 5b 01 00
	00		 jne	 $LN4@RenderGame

; 171  : 	{
; 172  : 		float fAspect=m_kWndMgr.GetAspect();

  0001b	8d 8e 10 02 00
	00		 lea	 ecx, DWORD PTR [esi+528]
  00021	e8 00 00 00 00	 call	 ?GetAspect@CWindowManager@UI@@QAEMXZ ; UI::CWindowManager::GetAspect

; 173  : 		float fFarClip=m_pyBackground.GetFarClip();

  00026	8d 8e 74 bb 01
	00		 lea	 ecx, DWORD PTR [esi+113524]
  0002c	d9 5c 24 10	 fstp	 DWORD PTR _fAspect$3[esp+80]
  00030	e8 00 00 00 00	 call	 ?GetFarClip@CPythonBackground@@QAEMXZ ; CPythonBackground::GetFarClip

; 174  : 
; 175  : 		m_pyGraphic.SetPerspective(30.0f, fAspect, 100.0, fFarClip);

  00035	83 ec 10	 sub	 esp, 16			; 00000010H
  00038	8d 8e 9c 07 00
	00		 lea	 ecx, DWORD PTR [esi+1948]
  0003e	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00044	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR _fAspect$3[esp+96]
  0004a	c7 44 24 08 00
	00 c8 42	 mov	 DWORD PTR [esp+8], 1120403456 ; 42c80000H
  00052	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00058	c7 04 24 00 00
	f0 41		 mov	 DWORD PTR [esp], 1106247680 ; 41f00000H
  0005f	e8 00 00 00 00	 call	 ?SetPerspective@CGraphicBase@@QAEXMMMM@Z ; CGraphicBase::SetPerspective

; 176  : 
; 177  : 		CCullingManager::Instance().Process();

  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  0006a	e8 00 00 00 00	 call	 ?Process@CCullingManager@@QAEXXZ ; CCullingManager::Process

; 178  : 
; 179  : 		m_kChrMgr.Deform();

  0006f	8d 8e d8 02 00
	00		 lea	 ecx, DWORD PTR [esi+728]
  00075	e8 00 00 00 00	 call	 ?Deform@CPythonCharacterManager@@QAEXXZ ; CPythonCharacterManager::Deform

; 180  : 		m_kEftMgr.Update();

  0007a	8b ce		 mov	 ecx, esi
  0007c	8d 89 b0 02 00
	00		 lea	 ecx, DWORD PTR [ecx+688]
  00082	e8 00 00 00 00	 call	 ?Update@CEffectManager@@QAEXXZ ; CEffectManager::Update

; 181  : 
; 182  : 		m_pyBackground.RenderCharacterShadowToTexture();

  00087	8b ce		 mov	 ecx, esi
  00089	8d 89 74 bb 01
	00		 lea	 ecx, DWORD PTR [ecx+113524]
  0008f	e8 00 00 00 00	 call	 ?RenderCharacterShadowToTexture@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderCharacterShadowToTexture

; 183  : 
; 184  : 		m_pyGraphic.SetGameRenderState();

  00094	8d 8e 9c 07 00
	00		 lea	 ecx, DWORD PTR [esi+1948]
  0009a	e8 00 00 00 00	 call	 ?SetGameRenderState@CPythonGraphic@@QAEXXZ ; CPythonGraphic::SetGameRenderState

; 185  : 		m_pyGraphic.PushState();

  0009f	8d 8e 9c 07 00
	00		 lea	 ecx, DWORD PTR [esi+1948]
  000a5	e8 00 00 00 00	 call	 ?PushState@CPythonGraphic@@QAEXXZ ; CPythonGraphic::PushState

; 186  : 
; 187  : 		{
; 188  : 			long lx, ly;
; 189  : 			m_kWndMgr.GetMousePosition(lx, ly);

  000aa	8d 44 24 10	 lea	 eax, DWORD PTR _ly$2[esp+80]
  000ae	50		 push	 eax
  000af	8d 44 24 18	 lea	 eax, DWORD PTR _lx$5[esp+84]
  000b3	50		 push	 eax
  000b4	8d 8e 10 02 00
	00		 lea	 ecx, DWORD PTR [esi+528]
  000ba	e8 00 00 00 00	 call	 ?GetMousePosition@CWindowManager@UI@@QAEXAAJ0@Z ; UI::CWindowManager::GetMousePosition

; 190  : 			m_pyGraphic.SetCursorPosition(lx, ly);

  000bf	ff 74 24 10	 push	 DWORD PTR _ly$2[esp+80]
  000c3	8d 8e 9c 07 00
	00		 lea	 ecx, DWORD PTR [esi+1948]
  000c9	ff 74 24 18	 push	 DWORD PTR _lx$5[esp+84]
  000cd	e8 00 00 00 00	 call	 ?SetCursorPosition@CPythonGraphic@@QAEXHH@Z ; CPythonGraphic::SetCursorPosition

; 191  : 		}
; 192  : 
; 193  : 		m_pyBackground.RenderSky();

  000d2	8b fe		 mov	 edi, esi
  000d4	8d 9f 74 bb 01
	00		 lea	 ebx, DWORD PTR [edi+113524]
  000da	8b cb		 mov	 ecx, ebx
  000dc	e8 00 00 00 00	 call	 ?RenderSky@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderSky

; 194  : 
; 195  : 		m_pyBackground.RenderBeforeLensFlare();

  000e1	8b cb		 mov	 ecx, ebx
  000e3	e8 00 00 00 00	 call	 ?RenderBeforeLensFlare@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderBeforeLensFlare

; 196  : 
; 197  : 		m_pyBackground.RenderCloud();

  000e8	8b cb		 mov	 ecx, ebx
  000ea	e8 00 00 00 00	 call	 ?RenderCloud@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderCloud

; 198  : 
; 199  : 		m_pyBackground.BeginEnvironment();

  000ef	8b cb		 mov	 ecx, ebx
  000f1	e8 00 00 00 00	 call	 ?BeginEnvironment@CMapManager@@QAEXXZ ; CMapManager::BeginEnvironment

; 200  : 		m_pyBackground.Render();

  000f6	8b cb		 mov	 ecx, ebx
  000f8	e8 00 00 00 00	 call	 ?Render@CPythonBackground@@QAEXXZ ; CPythonBackground::Render

; 201  : 
; 202  : 		m_pyBackground.SetCharacterDirLight();

  000fd	8b cb		 mov	 ecx, ebx
  000ff	e8 00 00 00 00	 call	 ?SetCharacterDirLight@CPythonBackground@@QAEXXZ ; CPythonBackground::SetCharacterDirLight

; 203  : 		m_kChrMgr.Render();

  00104	8d 8e d8 02 00
	00		 lea	 ecx, DWORD PTR [esi+728]
  0010a	e8 00 00 00 00	 call	 ?Render@CPythonCharacterManager@@QAEXXZ ; CPythonCharacterManager::Render

; 204  : 
; 205  : 		m_pyBackground.SetBackgroundDirLight();

  0010f	8b cb		 mov	 ecx, ebx
  00111	e8 00 00 00 00	 call	 ?SetBackgroundDirLight@CPythonBackground@@QAEXXZ ; CPythonBackground::SetBackgroundDirLight

; 206  : 		m_pyBackground.RenderWater();

  00116	8b cb		 mov	 ecx, ebx
  00118	e8 00 00 00 00	 call	 ?RenderWater@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderWater

; 207  : 		m_pyBackground.RenderSnow();

  0011d	8b cb		 mov	 ecx, ebx
  0011f	e8 00 00 00 00	 call	 ?RenderSnow@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderSnow

; 208  : 		m_pyBackground.RenderEffect();

  00124	8b cb		 mov	 ecx, ebx
  00126	e8 00 00 00 00	 call	 ?RenderEffect@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderEffect

; 209  : 
; 210  : 		m_pyBackground.EndEnvironment();

  0012b	8b cb		 mov	 ecx, ebx
  0012d	e8 00 00 00 00	 call	 ?EndEnvironment@CMapManager@@QAEXXZ ; CMapManager::EndEnvironment

; 211  : 
; 212  : 		m_kEftMgr.Render();

  00132	8d 8f b0 02 00
	00		 lea	 ecx, DWORD PTR [edi+688]
  00138	e8 00 00 00 00	 call	 ?Render@CEffectManager@@QAEXXZ ; CEffectManager::Render

; 213  : 		m_pyItem.Render();

  0013d	8d 8f 08 94 01
	00		 lea	 ecx, DWORD PTR [edi+103432]
  00143	e8 00 00 00 00	 call	 ?Render@CPythonItem@@QAEXXZ ; CPythonItem::Render

; 214  : 		m_FlyingManager.Render();

  00148	8d 8f 5c 01 00
	00		 lea	 ecx, DWORD PTR [edi+348]
  0014e	e8 00 00 00 00	 call	 ?Render@CFlyingManager@@QAEXXZ ; CFlyingManager::Render

; 215  : 
; 216  : 		m_pyBackground.BeginEnvironment();

  00153	8b cb		 mov	 ecx, ebx
  00155	e8 00 00 00 00	 call	 ?BeginEnvironment@CMapManager@@QAEXXZ ; CMapManager::BeginEnvironment

; 217  : 		m_pyBackground.RenderPCBlocker();

  0015a	8b cb		 mov	 ecx, ebx
  0015c	e8 00 00 00 00	 call	 ?RenderPCBlocker@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderPCBlocker

; 218  : 		m_pyBackground.EndEnvironment();

  00161	8b cb		 mov	 ecx, ebx
  00163	e8 00 00 00 00	 call	 ?EndEnvironment@CMapManager@@QAEXXZ ; CMapManager::EndEnvironment

; 219  : 
; 220  : 		m_pyBackground.RenderAfterLensFlare();

  00168	8b cb		 mov	 ecx, ebx
  0016a	e8 00 00 00 00	 call	 ?RenderAfterLensFlare@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderAfterLensFlare

; 319  : }

  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	5b		 pop	 ebx
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
$LN4@RenderGame:

; 221  : 
; 222  : 		return;
; 223  : 	}
; 224  : 
; 225  : 	//if (GetAsyncKeyState(VK_Z))
; 226  : 	//	STATEMANAGER.SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
; 227  : 
; 228  : 	DWORD t1=ELTimer_GetMSec();

  00176	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 229  : 	m_kChrMgr.Deform();

  0017b	8d 9e d8 02 00
	00		 lea	 ebx, DWORD PTR [esi+728]
  00181	89 44 24 18	 mov	 DWORD PTR _t1$1$[esp+80], eax
  00185	8b cb		 mov	 ecx, ebx
  00187	e8 00 00 00 00	 call	 ?Deform@CPythonCharacterManager@@QAEXXZ ; CPythonCharacterManager::Deform

; 230  : 	DWORD t2=ELTimer_GetMSec();

  0018c	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 231  : 	m_kEftMgr.Update();

  00191	8d 8e b0 02 00
	00		 lea	 ecx, DWORD PTR [esi+688]
  00197	89 44 24 1c	 mov	 DWORD PTR _t2$1$[esp+80], eax
  0019b	e8 00 00 00 00	 call	 ?Update@CEffectManager@@QAEXXZ ; CEffectManager::Update

; 232  : 	DWORD t3=ELTimer_GetMSec();

  001a0	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 233  : 	m_pyBackground.RenderCharacterShadowToTexture();

  001a5	8d 8e 74 bb 01
	00		 lea	 ecx, DWORD PTR [esi+113524]
  001ab	89 44 24 20	 mov	 DWORD PTR _t3$1$[esp+80], eax
  001af	e8 00 00 00 00	 call	 ?RenderCharacterShadowToTexture@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderCharacterShadowToTexture

; 234  : 	DWORD t4=ELTimer_GetMSec();

  001b4	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 235  : 
; 236  : 	m_pyGraphic.SetGameRenderState();

  001b9	8d 8e 9c 07 00
	00		 lea	 ecx, DWORD PTR [esi+1948]
  001bf	89 44 24 24	 mov	 DWORD PTR _t4$1$[esp+80], eax
  001c3	e8 00 00 00 00	 call	 ?SetGameRenderState@CPythonGraphic@@QAEXXZ ; CPythonGraphic::SetGameRenderState

; 237  : 	m_pyGraphic.PushState();

  001c8	8d 8e 9c 07 00
	00		 lea	 ecx, DWORD PTR [esi+1948]
  001ce	e8 00 00 00 00	 call	 ?PushState@CPythonGraphic@@QAEXXZ ; CPythonGraphic::PushState

; 238  : 
; 239  : 	float fAspect=m_kWndMgr.GetAspect();

  001d3	8d 8e 10 02 00
	00		 lea	 ecx, DWORD PTR [esi+528]
  001d9	e8 00 00 00 00	 call	 ?GetAspect@CWindowManager@UI@@QAEMXZ ; UI::CWindowManager::GetAspect

; 240  : 	float fFarClip=m_pyBackground.GetFarClip();

  001de	8b ce		 mov	 ecx, esi
  001e0	d9 5c 24 14	 fstp	 DWORD PTR _fAspect$[esp+80]
  001e4	8d 89 74 bb 01
	00		 lea	 ecx, DWORD PTR [ecx+113524]
  001ea	e8 00 00 00 00	 call	 ?GetFarClip@CPythonBackground@@QAEMXZ ; CPythonBackground::GetFarClip

; 241  : 
; 242  : 	m_pyGraphic.SetPerspective(30.0f, fAspect, 100.0, fFarClip);

  001ef	83 ec 10	 sub	 esp, 16			; 00000010H
  001f2	8d 8e 9c 07 00
	00		 lea	 ecx, DWORD PTR [esi+1948]
  001f8	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  001fe	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR _fAspect$[esp+96]
  00204	c7 44 24 08 00
	00 c8 42	 mov	 DWORD PTR [esp+8], 1120403456 ; 42c80000H
  0020c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00212	c7 04 24 00 00
	f0 41		 mov	 DWORD PTR [esp], 1106247680 ; 41f00000H
  00219	e8 00 00 00 00	 call	 ?SetPerspective@CGraphicBase@@QAEXMMMM@Z ; CGraphicBase::SetPerspective

; 243  : 
; 244  : 	DWORD t5=ELTimer_GetMSec();

  0021e	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 245  : 
; 246  : 	CCullingManager::Instance().Process();

  00223	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  00229	89 44 24 28	 mov	 DWORD PTR _t5$1$[esp+80], eax
  0022d	e8 00 00 00 00	 call	 ?Process@CCullingManager@@QAEXXZ ; CCullingManager::Process

; 247  : 
; 248  : 	DWORD t6=ELTimer_GetMSec();

  00232	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00237	89 44 24 2c	 mov	 DWORD PTR _t6$1$[esp+80], eax

; 249  : 
; 250  : 	{
; 251  : 		long lx, ly;
; 252  : 		m_kWndMgr.GetMousePosition(lx, ly);

  0023b	8d 8e 10 02 00
	00		 lea	 ecx, DWORD PTR [esi+528]
  00241	8d 44 24 14	 lea	 eax, DWORD PTR _ly$4[esp+80]
  00245	50		 push	 eax
  00246	8d 44 24 14	 lea	 eax, DWORD PTR _lx$1[esp+84]
  0024a	50		 push	 eax
  0024b	e8 00 00 00 00	 call	 ?GetMousePosition@CWindowManager@UI@@QAEXAAJ0@Z ; UI::CWindowManager::GetMousePosition

; 253  : 		m_pyGraphic.SetCursorPosition(lx, ly);

  00250	ff 74 24 14	 push	 DWORD PTR _ly$4[esp+80]
  00254	8d 8e 9c 07 00
	00		 lea	 ecx, DWORD PTR [esi+1948]
  0025a	ff 74 24 14	 push	 DWORD PTR _lx$1[esp+84]
  0025e	e8 00 00 00 00	 call	 ?SetCursorPosition@CPythonGraphic@@QAEXHH@Z ; CPythonGraphic::SetCursorPosition

; 254  : 	}
; 255  : 
; 256  : 	m_pyBackground.RenderSky();

  00263	8b fe		 mov	 edi, esi
  00265	8d b7 74 bb 01
	00		 lea	 esi, DWORD PTR [edi+113524]
  0026b	8b ce		 mov	 ecx, esi
  0026d	e8 00 00 00 00	 call	 ?RenderSky@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderSky

; 257  : 	DWORD t7=ELTimer_GetMSec();

  00272	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 258  : 	m_pyBackground.RenderBeforeLensFlare();

  00277	8b ce		 mov	 ecx, esi
  00279	89 44 24 14	 mov	 DWORD PTR _t7$1$[esp+80], eax
  0027d	e8 00 00 00 00	 call	 ?RenderBeforeLensFlare@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderBeforeLensFlare

; 259  : 	DWORD t8=ELTimer_GetMSec();

  00282	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 260  : 	m_pyBackground.RenderCloud();

  00287	8b ce		 mov	 ecx, esi
  00289	89 44 24 10	 mov	 DWORD PTR _t8$1$[esp+80], eax
  0028d	e8 00 00 00 00	 call	 ?RenderCloud@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderCloud

; 261  : 	DWORD t9=ELTimer_GetMSec();

  00292	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 262  : 	m_pyBackground.BeginEnvironment();

  00297	8b ce		 mov	 ecx, esi
  00299	89 44 24 0c	 mov	 DWORD PTR _t9$1$[esp+80], eax
  0029d	e8 00 00 00 00	 call	 ?BeginEnvironment@CMapManager@@QAEXXZ ; CMapManager::BeginEnvironment

; 263  : 	m_pyBackground.Render();

  002a2	8b ce		 mov	 ecx, esi
  002a4	e8 00 00 00 00	 call	 ?Render@CPythonBackground@@QAEXXZ ; CPythonBackground::Render

; 264  : 
; 265  : 	m_pyBackground.SetCharacterDirLight();

  002a9	8b ce		 mov	 ecx, esi
  002ab	e8 00 00 00 00	 call	 ?SetCharacterDirLight@CPythonBackground@@QAEXXZ ; CPythonBackground::SetCharacterDirLight

; 266  : 	DWORD t10=ELTimer_GetMSec();

  002b0	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 267  : 	m_kChrMgr.Render();

  002b5	8b cb		 mov	 ecx, ebx
  002b7	89 44 24 30	 mov	 DWORD PTR _t10$1$[esp+80], eax
  002bb	e8 00 00 00 00	 call	 ?Render@CPythonCharacterManager@@QAEXXZ ; CPythonCharacterManager::Render

; 268  : 	DWORD t11=ELTimer_GetMSec();

  002c0	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 269  : 
; 270  : 	m_pyBackground.SetBackgroundDirLight();

  002c5	8b ce		 mov	 ecx, esi
  002c7	89 44 24 34	 mov	 DWORD PTR _t11$1$[esp+80], eax
  002cb	e8 00 00 00 00	 call	 ?SetBackgroundDirLight@CPythonBackground@@QAEXXZ ; CPythonBackground::SetBackgroundDirLight

; 271  : 	m_pyBackground.RenderWater();

  002d0	8b ce		 mov	 ecx, esi
  002d2	e8 00 00 00 00	 call	 ?RenderWater@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderWater

; 272  : 	DWORD t12=ELTimer_GetMSec();

  002d7	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  002dc	89 44 24 38	 mov	 DWORD PTR _t12$1$[esp+80], eax

; 273  : 	m_pyBackground.RenderEffect();

  002e0	8b ce		 mov	 ecx, esi
  002e2	e8 00 00 00 00	 call	 ?RenderEffect@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderEffect

; 274  : 	DWORD t13=ELTimer_GetMSec();

  002e7	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 275  : 	m_pyBackground.EndEnvironment();

  002ec	8b ce		 mov	 ecx, esi
  002ee	89 44 24 3c	 mov	 DWORD PTR _t13$1$[esp+80], eax
  002f2	e8 00 00 00 00	 call	 ?EndEnvironment@CMapManager@@QAEXXZ ; CMapManager::EndEnvironment

; 276  : 	m_kEftMgr.Render();

  002f7	8d 8f b0 02 00
	00		 lea	 ecx, DWORD PTR [edi+688]
  002fd	e8 00 00 00 00	 call	 ?Render@CEffectManager@@QAEXXZ ; CEffectManager::Render

; 277  : 	DWORD t14=ELTimer_GetMSec();

  00302	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 278  : 	m_pyItem.Render();

  00307	8d 8f 08 94 01
	00		 lea	 ecx, DWORD PTR [edi+103432]
  0030d	89 44 24 40	 mov	 DWORD PTR _t14$1$[esp+80], eax
  00311	e8 00 00 00 00	 call	 ?Render@CPythonItem@@QAEXXZ ; CPythonItem::Render

; 279  : 	DWORD t15=ELTimer_GetMSec();

  00316	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 280  : 	m_FlyingManager.Render();

  0031b	8d 8f 5c 01 00
	00		 lea	 ecx, DWORD PTR [edi+348]
  00321	89 44 24 44	 mov	 DWORD PTR _t15$1$[esp+80], eax
  00325	e8 00 00 00 00	 call	 ?Render@CFlyingManager@@QAEXXZ ; CFlyingManager::Render

; 281  : 	DWORD t16=ELTimer_GetMSec();

  0032a	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 282  : 	m_pyBackground.BeginEnvironment();

  0032f	8b ce		 mov	 ecx, esi
  00331	89 44 24 48	 mov	 DWORD PTR _t16$1$[esp+80], eax
  00335	e8 00 00 00 00	 call	 ?BeginEnvironment@CMapManager@@QAEXXZ ; CMapManager::BeginEnvironment

; 283  : 	m_pyBackground.RenderPCBlocker();

  0033a	8b ce		 mov	 ecx, esi
  0033c	e8 00 00 00 00	 call	 ?RenderPCBlocker@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderPCBlocker

; 284  : 	m_pyBackground.EndEnvironment();

  00341	8b ce		 mov	 ecx, esi
  00343	e8 00 00 00 00	 call	 ?EndEnvironment@CMapManager@@QAEXXZ ; CMapManager::EndEnvironment

; 285  : 	DWORD t17=ELTimer_GetMSec();

  00348	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 286  : 	m_pyBackground.RenderAfterLensFlare();

  0034d	8b ce		 mov	 ecx, esi
  0034f	89 44 24 4c	 mov	 DWORD PTR _t17$1$[esp+80], eax
  00353	e8 00 00 00 00	 call	 ?RenderAfterLensFlare@CPythonBackground@@QAEXXZ ; CPythonBackground::RenderAfterLensFlare

; 287  : 	DWORD t18=ELTimer_GetMSec();

  00358	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0035d	8b f8		 mov	 edi, eax

; 288  : 	DWORD tEnd=ELTimer_GetMSec();

  0035f	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 289  : 
; 290  : 	if (GetAsyncKeyState(VK_Z))

  00364	6a 5a		 push	 90			; 0000005aH
  00366	8b f0		 mov	 esi, eax
  00368	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetAsyncKeyState@4
  0036e	66 85 c0	 test	 ax, ax
  00371	74 0f		 je	 SHORT $LN3@RenderGame

; 291  : 		STATEMANAGER.SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

  00373	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00379	6a 03		 push	 3
  0037b	6a 08		 push	 8
  0037d	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
$LN3@RenderGame:

; 292  : 
; 293  : 	if (tEnd-t1<3)

  00382	8b 5c 24 18	 mov	 ebx, DWORD PTR _t1$1$[esp+80]
  00386	2b f3		 sub	 esi, ebx
  00388	83 fe 03	 cmp	 esi, 3
  0038b	0f 82 23 02 00
	00		 jb	 $LN5@RenderGame

; 294  : 		return;
; 295  : 
; 296  : 	static FILE* fp=fopen("perf_game_render.txt", "w");

  00391	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?L@??RenderGame@CPythonApplication@@QAEXXZ@4IA
  00396	a8 01		 test	 al, 1
  00398	75 1f		 jne	 SHORT $LN1@RenderGame
  0039a	83 c8 01	 or	 eax, 1
  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  003a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OHHAPIAL@perf_game_render?4txt?$AA@
  003a7	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?L@??RenderGame@CPythonApplication@@QAEXXZ@4IA, eax
  003ac	e8 00 00 00 00	 call	 _fopen
  003b1	83 c4 08	 add	 esp, 8
  003b4	a3 00 00 00 00	 mov	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A, eax
$LN1@RenderGame:

; 297  : 
; 298  : 	fprintf(fp, "GR.Total %d (Time %d)\n", tEnd-t1, ELTimer_GetMSec());

  003b9	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  003be	50		 push	 eax
  003bf	56		 push	 esi
  003c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GCCBAEAA@GR?4Total?5?$CFd?5?$CITime?5?$CFd?$CJ?6?$AA@
  003c5	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  003cb	e8 00 00 00 00	 call	 _fprintf

; 299  : 	fprintf(fp, "GR.DFM %d\n", t2-t1);

  003d0	8b 44 24 2c	 mov	 eax, DWORD PTR _t2$1$[esp+96]
  003d4	2b c3		 sub	 eax, ebx
  003d6	50		 push	 eax
  003d7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGAPCDKD@GR?4DFM?5?$CFd?6?$AA@
  003dc	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  003e2	e8 00 00 00 00	 call	 _fprintf

; 300  : 	fprintf(fp, "GR.EFT.UP %d\n", t3-t2);

  003e7	8b 44 24 3c	 mov	 eax, DWORD PTR _t3$1$[esp+108]
  003eb	83 c4 1c	 add	 esp, 28			; 0000001cH
  003ee	2b 44 24 1c	 sub	 eax, DWORD PTR _t2$1$[esp+80]
  003f2	50		 push	 eax
  003f3	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PLGAMGBI@GR?4EFT?4UP?5?$CFd?6?$AA@
  003f8	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  003fe	e8 00 00 00 00	 call	 _fprintf

; 301  : 	fprintf(fp, "GR.SHW %d\n", t4-t3);

  00403	8b 44 24 30	 mov	 eax, DWORD PTR _t4$1$[esp+92]
  00407	83 c4 0c	 add	 esp, 12			; 0000000cH
  0040a	2b 44 24 20	 sub	 eax, DWORD PTR _t3$1$[esp+80]
  0040e	50		 push	 eax
  0040f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MCADEBDB@GR?4SHW?5?$CFd?6?$AA@
  00414	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  0041a	e8 00 00 00 00	 call	 _fprintf

; 302  : 	fprintf(fp, "GR.STT %d\n", t5-t4);

  0041f	8b 44 24 34	 mov	 eax, DWORD PTR _t5$1$[esp+92]
  00423	83 c4 0c	 add	 esp, 12			; 0000000cH
  00426	2b 44 24 24	 sub	 eax, DWORD PTR _t4$1$[esp+80]
  0042a	50		 push	 eax
  0042b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OEOJMFCF@GR?4STT?5?$CFd?6?$AA@
  00430	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  00436	e8 00 00 00 00	 call	 _fprintf

; 303  : 	fprintf(fp, "GR.CLL %d\n", t6-t5);

  0043b	8b 44 24 38	 mov	 eax, DWORD PTR _t6$1$[esp+92]
  0043f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00442	2b 44 24 28	 sub	 eax, DWORD PTR _t5$1$[esp+80]
  00446	50		 push	 eax
  00447	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CDOGKGFB@GR?4CLL?5?$CFd?6?$AA@
  0044c	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  00452	e8 00 00 00 00	 call	 _fprintf

; 304  : 	fprintf(fp, "GR.BG.SKY %d\n", t7-t6);

  00457	8b 44 24 20	 mov	 eax, DWORD PTR _t7$1$[esp+92]
  0045b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0045e	2b 44 24 2c	 sub	 eax, DWORD PTR _t6$1$[esp+80]
  00462	50		 push	 eax
  00463	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HPKPMDPE@GR?4BG?4SKY?5?$CFd?6?$AA@
  00468	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  0046e	e8 00 00 00 00	 call	 _fprintf

; 305  : 	fprintf(fp, "GR.BG.LEN %d\n", t8-t7);

  00473	8b 44 24 1c	 mov	 eax, DWORD PTR _t8$1$[esp+92]
  00477	83 c4 0c	 add	 esp, 12			; 0000000cH
  0047a	2b 44 24 14	 sub	 eax, DWORD PTR _t7$1$[esp+80]
  0047e	50		 push	 eax
  0047f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JENIKJAN@GR?4BG?4LEN?5?$CFd?6?$AA@
  00484	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  0048a	e8 00 00 00 00	 call	 _fprintf

; 306  : 	fprintf(fp, "GR.BG.CLD %d\n", t9-t8);

  0048f	8b 44 24 18	 mov	 eax, DWORD PTR _t9$1$[esp+92]
  00493	83 c4 0c	 add	 esp, 12			; 0000000cH
  00496	2b 44 24 10	 sub	 eax, DWORD PTR _t8$1$[esp+80]
  0049a	50		 push	 eax
  0049b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HJPLNNBE@GR?4BG?4CLD?5?$CFd?6?$AA@
  004a0	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  004a6	e8 00 00 00 00	 call	 _fprintf

; 307  : 	fprintf(fp, "GR.BG.MAIN %d\n", t10-t9);		

  004ab	8b 44 24 3c	 mov	 eax, DWORD PTR _t10$1$[esp+92]
  004af	83 c4 0c	 add	 esp, 12			; 0000000cH
  004b2	2b 44 24 0c	 sub	 eax, DWORD PTR _t9$1$[esp+80]
  004b6	50		 push	 eax
  004b7	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EJKDFAIB@GR?4BG?4MAIN?5?$CFd?6?$AA@
  004bc	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  004c2	e8 00 00 00 00	 call	 _fprintf

; 308  : 	fprintf(fp, "GR.CHR %d\n",	t11-t10);

  004c7	8b 44 24 40	 mov	 eax, DWORD PTR _t11$1$[esp+92]
  004cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ce	2b 44 24 30	 sub	 eax, DWORD PTR _t10$1$[esp+80]
  004d2	50		 push	 eax
  004d3	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OOHFOBKJ@GR?4CHR?5?$CFd?6?$AA@
  004d8	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  004de	e8 00 00 00 00	 call	 _fprintf

; 309  : 	fprintf(fp, "GR.BG.WTR %d\n", t12-t11);

  004e3	8b 44 24 44	 mov	 eax, DWORD PTR _t12$1$[esp+92]
  004e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ea	2b 44 24 34	 sub	 eax, DWORD PTR _t11$1$[esp+80]
  004ee	50		 push	 eax
  004ef	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LENBOK@GR?4BG?4WTR?5?$CFd?6?$AA@
  004f4	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  004fa	e8 00 00 00 00	 call	 _fprintf

; 310  : 	fprintf(fp, "GR.BG.EFT %d\n", t13-t12);

  004ff	8b 44 24 48	 mov	 eax, DWORD PTR _t13$1$[esp+92]
  00503	83 c4 0c	 add	 esp, 12			; 0000000cH
  00506	2b 44 24 38	 sub	 eax, DWORD PTR _t12$1$[esp+80]
  0050a	50		 push	 eax
  0050b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BIDCIJEG@GR?4BG?4EFT?5?$CFd?6?$AA@
  00510	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  00516	e8 00 00 00 00	 call	 _fprintf

; 311  : 	fprintf(fp, "GR.EFT %d\n", t14-t13);

  0051b	8b 44 24 4c	 mov	 eax, DWORD PTR _t14$1$[esp+92]
  0051f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00522	2b 44 24 3c	 sub	 eax, DWORD PTR _t13$1$[esp+80]
  00526	50		 push	 eax
  00527	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KOHMHAGO@GR?4EFT?5?$CFd?6?$AA@
  0052c	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  00532	e8 00 00 00 00	 call	 _fprintf

; 312  : 	fprintf(fp, "GR.ITM %d\n", t15-t14);

  00537	8b 44 24 50	 mov	 eax, DWORD PTR _t15$1$[esp+92]
  0053b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0053e	2b 44 24 40	 sub	 eax, DWORD PTR _t14$1$[esp+80]
  00542	50		 push	 eax
  00543	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CNELLLJF@GR?4ITM?5?$CFd?6?$AA@
  00548	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  0054e	e8 00 00 00 00	 call	 _fprintf

; 313  : 	fprintf(fp, "GR.FLY %d\n", t16-t15);

  00553	8b 44 24 54	 mov	 eax, DWORD PTR _t16$1$[esp+92]
  00557	83 c4 0c	 add	 esp, 12			; 0000000cH
  0055a	2b 44 24 44	 sub	 eax, DWORD PTR _t15$1$[esp+80]
  0055e	50		 push	 eax
  0055f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DIBNDLBN@GR?4FLY?5?$CFd?6?$AA@
  00564	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  0056a	e8 00 00 00 00	 call	 _fprintf

; 314  : 	fprintf(fp, "GR.BG.BLK %d\n", t17-t16);

  0056f	8b 44 24 58	 mov	 eax, DWORD PTR _t17$1$[esp+92]
  00573	83 c4 0c	 add	 esp, 12			; 0000000cH
  00576	2b 44 24 48	 sub	 eax, DWORD PTR _t16$1$[esp+80]
  0057a	50		 push	 eax
  0057b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@EEAHGPFP@GR?4BG?4BLK?5?$CFd?6?$AA@
  00580	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  00586	e8 00 00 00 00	 call	 _fprintf

; 315  : 	fprintf(fp, "GR.BG.LEN %d\n", t18-t17);

  0058b	2b 7c 24 58	 sub	 edi, DWORD PTR _t17$1$[esp+92]
  0058f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00592	57		 push	 edi
  00593	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JENIKJAN@GR?4BG?4LEN?5?$CFd?6?$AA@
  00598	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  0059e	e8 00 00 00 00	 call	 _fprintf
  005a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 316  : 
; 317  : 
; 318  : 	fflush(fp);

  005a6	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?L@??RenderGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  005ac	e8 00 00 00 00	 call	 _fflush
  005b1	83 c4 04	 add	 esp, 4
$LN5@RenderGame:

; 319  : }

  005b4	5f		 pop	 edi
  005b5	5e		 pop	 esi
  005b6	5b		 pop	 ebx
  005b7	8b e5		 mov	 esp, ebp
  005b9	5d		 pop	 ebp
  005ba	c3		 ret	 0
?RenderGame@CPythonApplication@@QAEXXZ ENDP		; CPythonApplication::RenderGame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?UpdateGame@CPythonApplication@@QAEXXZ
_TEXT	SEGMENT
_s$2 = -84						; size = 4
_t3$1$ = -80						; size = 4
_fAspect$3 = -80					; size = 4
_t1$1$ = -76						; size = 4
_t2$1$ = -72						; size = 4
_t4$1$ = -68						; size = 4
_t5$1$ = -64						; size = 4
_t6$1$ = -60						; size = 4
_t7$1$ = -56						; size = 4
_t8$1$ = -52						; size = 4
_t9$1$ = -48						; size = 4
_t10$1$ = -44						; size = 4
_t11$1$ = -40						; size = 4
_ptMouse$ = -36						; size = 8
_kPPosMainActor$ = -28					; size = 12
__$EHRec$ = -12						; size = 12
?UpdateGame@CPythonApplication@@QAEXXZ PROC		; CPythonApplication::UpdateGame, COMDAT
; _this$ = ecx

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?UpdateGame@CPythonApplication@@QAEXXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 48	 sub	 esp, 72			; 00000048H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	50		 push	 eax
  00022	8d 44 24 58	 lea	 eax, DWORD PTR __$EHRec$[esp+100]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	8b f9		 mov	 edi, ecx

; 323  : 	DWORD t1=ELTimer_GetMSec();

  0002e	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 324  : 	POINT ptMouse;
; 325  : 	GetMousePosition(&ptMouse);

  00033	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  00036	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00039	89 44 24 18	 mov	 DWORD PTR _t1$1$[esp+100], eax
  0003d	8d 44 24 40	 lea	 eax, DWORD PTR _ptMouse$[esp+100]
  00041	50		 push	 eax
  00042	ff 52 04	 call	 DWORD PTR [edx+4]

; 326  : 
; 327  : 	CGraphicTextInstance::Hyperlink_UpdateMousePos(ptMouse.x, ptMouse.y);

  00045	ff 74 24 44	 push	 DWORD PTR _ptMouse$[esp+104]
  00049	ff 74 24 44	 push	 DWORD PTR _ptMouse$[esp+104]
  0004d	e8 00 00 00 00	 call	 ?Hyperlink_UpdateMousePos@CGraphicTextInstance@@SAXHH@Z ; CGraphicTextInstance::Hyperlink_UpdateMousePos
  00052	83 c4 08	 add	 esp, 8

; 328  : 
; 329  : 	DWORD t2=ELTimer_GetMSec();

  00055	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 330  : 
; 331  : 	//!@# Alt+Tab  SetTransfor      - [levites]
; 332  : 	//if (m_isActivateWnd)
; 333  : 	{
; 334  : 		CScreen s;

  0005a	8d 4c 24 10	 lea	 ecx, DWORD PTR _s$2[esp+100]
  0005e	89 44 24 1c	 mov	 DWORD PTR _t2$1$[esp+100], eax
  00062	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00067	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+108], 0

; 335  : 		float fAspect = UI::CWindowManager::Instance().GetAspect();

  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  00075	e8 00 00 00 00	 call	 ?GetAspect@CWindowManager@UI@@QAEMXZ ; UI::CWindowManager::GetAspect

; 336  : 		float fFarClip = CPythonBackground::Instance().GetFarClip();

  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00080	d9 5c 24 14	 fstp	 DWORD PTR _fAspect$3[esp+100]
  00084	e8 00 00 00 00	 call	 ?GetFarClip@CPythonBackground@@QAEMXZ ; CPythonBackground::GetFarClip

; 337  : 
; 338  : 		s.SetPerspective(30.0f,fAspect, 100.0f, fFarClip);

  00089	83 ec 10	 sub	 esp, 16			; 00000010H
  0008c	8d 4c 24 20	 lea	 ecx, DWORD PTR _s$2[esp+116]
  00090	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00096	f3 0f 10 44 24
	24		 movss	 xmm0, DWORD PTR _fAspect$3[esp+116]
  0009c	c7 44 24 08 00
	00 c8 42	 mov	 DWORD PTR [esp+8], 1120403456 ; 42c80000H
  000a4	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000aa	c7 04 24 00 00
	f0 41		 mov	 DWORD PTR [esp], 1106247680 ; 41f00000H
  000b1	e8 00 00 00 00	 call	 ?SetPerspective@CGraphicBase@@QAEXMMMM@Z ; CGraphicBase::SetPerspective

; 339  : 		s.BuildViewFrustum();

  000b6	8d 4c 24 10	 lea	 ecx, DWORD PTR _s$2[esp+100]
  000ba	e8 00 00 00 00	 call	 ?BuildViewFrustum@CScreen@@QAEXXZ ; CScreen::BuildViewFrustum

; 340  : 	}

  000bf	8d 4c 24 10	 lea	 ecx, DWORD PTR _s$2[esp+100]
  000c3	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+108], -1
  000cb	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen

; 341  : 
; 342  : 	DWORD t3=ELTimer_GetMSec();

  000d0	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  000d5	89 44 24 14	 mov	 DWORD PTR _t3$1$[esp+100], eax

; 343  : 	TPixelPosition kPPosMainActor;
; 344  : 	m_pyPlayer.NEW_GetMainActorPosition(&kPPosMainActor);

  000d9	8d 44 24 48	 lea	 eax, DWORD PTR _kPPosMainActor$[esp+100]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ?NEW_GetMainActorPosition@CPythonPlayer@@QAEXPAUD3DXVECTOR3@@@Z ; CPythonPlayer::NEW_GetMainActorPosition

; 345  : 
; 346  : 	DWORD t4=ELTimer_GetMSec();

  000e3	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 347  : 	m_pyBackground.Update(kPPosMainActor.x, kPPosMainActor.y, kPPosMainActor.z);

  000e8	f3 0f 10 5c 24
	50		 movss	 xmm3, DWORD PTR _kPPosMainActor$[esp+108]
  000ee	8d 8f 74 bb 01
	00		 lea	 ecx, DWORD PTR [edi+113524]
  000f4	f3 0f 10 54 24
	4c		 movss	 xmm2, DWORD PTR _kPPosMainActor$[esp+104]
  000fa	f3 0f 10 4c 24
	48		 movss	 xmm1, DWORD PTR _kPPosMainActor$[esp+100]
  00100	89 44 24 20	 mov	 DWORD PTR _t4$1$[esp+100], eax
  00104	e8 00 00 00 00	 call	 ?Update@CPythonBackground@@QAEXMMM@Z ; CPythonBackground::Update

; 348  : 
; 349  : 	DWORD t5=ELTimer_GetMSec();

  00109	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 350  : 	m_GameEventManager.SetCenterPosition(kPPosMainActor.x, kPPosMainActor.y, kPPosMainActor.z);

  0010e	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR _kPPosMainActor$[esp+108]
  00114	8d 8f b8 01 00
	00		 lea	 ecx, DWORD PTR [edi+440]
  0011a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0011d	89 44 24 30	 mov	 DWORD PTR _t5$1$[esp+112], eax
  00121	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00127	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR _kPPosMainActor$[esp+116]
  0012d	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00133	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR _kPPosMainActor$[esp+112]
  00139	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013e	e8 00 00 00 00	 call	 ?SetCenterPosition@CGameEventManager@@QAEXMMM@Z ; CGameEventManager::SetCenterPosition

; 351  : 	m_GameEventManager.Update();

  00143	8d 8f b8 01 00
	00		 lea	 ecx, DWORD PTR [edi+440]
  00149	e8 00 00 00 00	 call	 ?Update@CGameEventManager@@QAEXXZ ; CGameEventManager::Update

; 352  : 
; 353  : 	DWORD t6=ELTimer_GetMSec();

  0014e	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 354  : 	m_kChrMgr.Update();	

  00153	8d 8f d8 02 00
	00		 lea	 ecx, DWORD PTR [edi+728]
  00159	89 44 24 28	 mov	 DWORD PTR _t6$1$[esp+100], eax
  0015d	e8 00 00 00 00	 call	 ?Update@CPythonCharacterManager@@QAEXXZ ; CPythonCharacterManager::Update

; 355  : 	DWORD t7=ELTimer_GetMSec();

  00162	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 356  : 	m_kEftMgr.UpdateSound();

  00167	8d 8f b0 02 00
	00		 lea	 ecx, DWORD PTR [edi+688]
  0016d	89 44 24 2c	 mov	 DWORD PTR _t7$1$[esp+100], eax
  00171	e8 00 00 00 00	 call	 ?UpdateSound@CEffectManager@@QAEXXZ ; CEffectManager::UpdateSound

; 357  : 	DWORD t8=ELTimer_GetMSec();

  00176	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 358  : 	m_FlyingManager.Update();

  0017b	8d 8f 5c 01 00
	00		 lea	 ecx, DWORD PTR [edi+348]
  00181	89 44 24 30	 mov	 DWORD PTR _t8$1$[esp+100], eax
  00185	e8 00 00 00 00	 call	 ?Update@CFlyingManager@@QAEXXZ ; CFlyingManager::Update

; 359  : 	DWORD t9=ELTimer_GetMSec();

  0018a	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0018f	89 44 24 34	 mov	 DWORD PTR _t9$1$[esp+100], eax

; 360  : 	m_pyItem.Update(ptMouse);

  00193	8d 8f 08 94 01
	00		 lea	 ecx, DWORD PTR [edi+103432]
  00199	8d 44 24 40	 lea	 eax, DWORD PTR _ptMouse$[esp+100]
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 ?Update@CPythonItem@@QAEXABUtagPOINT@@@Z ; CPythonItem::Update

; 361  : 	DWORD t10=ELTimer_GetMSec();

  001a3	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  001a8	89 44 24 38	 mov	 DWORD PTR _t10$1$[esp+100], eax

; 362  : 	m_pyPlayer.Update();

  001ac	8d 8f 90 81 00
	00		 lea	 ecx, DWORD PTR [edi+33168]
  001b2	e8 00 00 00 00	 call	 ?Update@CPythonPlayer@@QAEXXZ ; CPythonPlayer::Update

; 363  : 	DWORD t11=ELTimer_GetMSec();

  001b7	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  001bc	89 44 24 3c	 mov	 DWORD PTR _t11$1$[esp+100], eax

; 364  : 
; 365  : 	// NOTE : Update        - [levites]
; 366  : 	//             Sound      .
; 367  : 	m_pyPlayer.NEW_GetMainActorPosition(&kPPosMainActor);

  001c0	8d 44 24 48	 lea	 eax, DWORD PTR _kPPosMainActor$[esp+100]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 ?NEW_GetMainActorPosition@CPythonPlayer@@QAEXPAUD3DXVECTOR3@@@Z ; CPythonPlayer::NEW_GetMainActorPosition

; 368  : 	SetCenterPosition(kPPosMainActor.x, kPPosMainActor.y, kPPosMainActor.z);

  001ca	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR _kPPosMainActor$[esp+108]
  001d0	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  001d3	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  001d6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001d9	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001df	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR _kPPosMainActor$[esp+116]
  001e5	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001eb	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR _kPPosMainActor$[esp+112]
  001f1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f6	ff 52 18	 call	 DWORD PTR [edx+24]

; 369  : 	DWORD t12=ELTimer_GetMSec();

  001f9	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 370  : 
; 371  : 	if (PERF_CHECKER_RENDER_GAME)

  001fe	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?PERF_CHECKER_RENDER_GAME@@3_NA, 0 ; PERF_CHECKER_RENDER_GAME
  00205	8b f8		 mov	 edi, eax
  00207	0f 84 8f 01 00
	00		 je	 $LN2@UpdateGame

; 372  : 	{
; 373  : 		if (t12-t1>5)

  0020d	8b 5c 24 18	 mov	 ebx, DWORD PTR _t1$1$[esp+100]
  00211	8b f7		 mov	 esi, edi
  00213	2b f3		 sub	 esi, ebx
  00215	83 fe 05	 cmp	 esi, 5
  00218	0f 86 7e 01 00
	00		 jbe	 $LN2@UpdateGame

; 374  : 		{
; 375  : 			static FILE* fp=fopen("perf_game_update.txt", "w");

  0021e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$S2@?8??UpdateGame@CPythonApplication@@QAEXXZ@4IA
  00224	f6 c1 01	 test	 cl, 1
  00227	75 20		 jne	 SHORT $LN1@UpdateGame
  00229	83 c9 01	 or	 ecx, 1
  0022c	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  00231	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NHIIGIH@perf_game_update?4txt?$AA@
  00236	89 0d 00 00 00
	00		 mov	 DWORD PTR ?$S2@?8??UpdateGame@CPythonApplication@@QAEXXZ@4IA, ecx
  0023c	e8 00 00 00 00	 call	 _fopen
  00241	83 c4 08	 add	 esp, 8
  00244	a3 00 00 00 00	 mov	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A, eax
$LN1@UpdateGame:

; 376  : 
; 377  : 			fprintf(fp, "GU.Total %d (Time %d)\n", t12-t1, ELTimer_GetMSec());

  00249	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0024e	50		 push	 eax
  0024f	56		 push	 esi
  00250	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@HPIDKEA@GU?4Total?5?$CFd?5?$CITime?5?$CFd?$CJ?6?$AA@
  00255	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  0025b	e8 00 00 00 00	 call	 _fprintf

; 378  : 			fprintf(fp, "GU.GMP %d\n", t2-t1);

  00260	8b 44 24 2c	 mov	 eax, DWORD PTR _t2$1$[esp+116]
  00264	2b c3		 sub	 eax, ebx
  00266	50		 push	 eax
  00267	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JHBDHKIG@GU?4GMP?5?$CFd?6?$AA@
  0026c	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  00272	e8 00 00 00 00	 call	 _fprintf

; 379  : 			fprintf(fp, "GU.SCR %d\n", t3-t2);

  00277	8b 44 24 30	 mov	 eax, DWORD PTR _t3$1$[esp+128]
  0027b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0027e	2b 44 24 1c	 sub	 eax, DWORD PTR _t2$1$[esp+100]
  00282	50		 push	 eax
  00283	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HCBFJPAB@GU?4SCR?5?$CFd?6?$AA@
  00288	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  0028e	e8 00 00 00 00	 call	 _fprintf

; 380  : 			fprintf(fp, "GU.MPS %d\n", t4-t3);

  00293	8b 44 24 2c	 mov	 eax, DWORD PTR _t4$1$[esp+112]
  00297	83 c4 0c	 add	 esp, 12			; 0000000cH
  0029a	2b 44 24 14	 sub	 eax, DWORD PTR _t3$1$[esp+100]
  0029e	50		 push	 eax
  0029f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGEOOJOO@GU?4MPS?5?$CFd?6?$AA@
  002a4	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  002aa	e8 00 00 00 00	 call	 _fprintf

; 381  : 			fprintf(fp, "GU.BG %d\n", t5-t4);

  002af	8b 44 24 30	 mov	 eax, DWORD PTR _t5$1$[esp+112]
  002b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b6	2b 44 24 20	 sub	 eax, DWORD PTR _t4$1$[esp+100]
  002ba	50		 push	 eax
  002bb	68 00 00 00 00	 push	 OFFSET ??_C@_09JGPPFKPH@GU?4BG?5?$CFd?6?$AA@
  002c0	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  002c6	e8 00 00 00 00	 call	 _fprintf

; 382  : 			fprintf(fp, "GU.GEM %d\n", t6-t5);

  002cb	8b 44 24 34	 mov	 eax, DWORD PTR _t6$1$[esp+112]
  002cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d2	2b 44 24 24	 sub	 eax, DWORD PTR _t5$1$[esp+100]
  002d6	50		 push	 eax
  002d7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BLLECFKE@GU?4GEM?5?$CFd?6?$AA@
  002dc	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  002e2	e8 00 00 00 00	 call	 _fprintf

; 383  : 			fprintf(fp, "GU.CHR %d\n", t7-t6);

  002e7	8b 44 24 38	 mov	 eax, DWORD PTR _t7$1$[esp+112]
  002eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ee	2b 44 24 28	 sub	 eax, DWORD PTR _t6$1$[esp+100]
  002f2	50		 push	 eax
  002f3	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MKJPKNA@GU?4CHR?5?$CFd?6?$AA@
  002f8	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  002fe	e8 00 00 00 00	 call	 _fprintf

; 384  : 			fprintf(fp, "GU.EFT %d\n", t8-t7);

  00303	8b 44 24 3c	 mov	 eax, DWORD PTR _t8$1$[esp+112]
  00307	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030a	2b 44 24 2c	 sub	 eax, DWORD PTR _t7$1$[esp+100]
  0030e	50		 push	 eax
  0030f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EMKAGLBH@GU?4EFT?5?$CFd?6?$AA@
  00314	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  0031a	e8 00 00 00 00	 call	 _fprintf

; 385  : 			fprintf(fp, "GU.FLY %d\n", t9-t8);

  0031f	8b 44 24 40	 mov	 eax, DWORD PTR _t9$1$[esp+112]
  00323	83 c4 0c	 add	 esp, 12			; 0000000cH
  00326	2b 44 24 30	 sub	 eax, DWORD PTR _t8$1$[esp+100]
  0032a	50		 push	 eax
  0032b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NKMBCAGE@GU?4FLY?5?$CFd?6?$AA@
  00330	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  00336	e8 00 00 00 00	 call	 _fprintf

; 386  : 			fprintf(fp, "GU.ITM %d\n", t10-t9);

  0033b	8b 44 24 44	 mov	 eax, DWORD PTR _t10$1$[esp+112]
  0033f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00342	2b 44 24 34	 sub	 eax, DWORD PTR _t9$1$[esp+100]
  00346	50		 push	 eax
  00347	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MPJHKAOM@GU?4ITM?5?$CFd?6?$AA@
  0034c	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  00352	e8 00 00 00 00	 call	 _fprintf

; 387  : 			fprintf(fp, "GU.PLR %d\n", t11-t10);

  00357	8b 44 24 48	 mov	 eax, DWORD PTR _t11$1$[esp+112]
  0035b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0035e	2b 44 24 38	 sub	 eax, DWORD PTR _t10$1$[esp+100]
  00362	50		 push	 eax
  00363	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KNCOIAL@GU?4PLR?5?$CFd?6?$AA@
  00368	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  0036e	e8 00 00 00 00	 call	 _fprintf

; 388  : 			fprintf(fp, "GU.POS %d\n", t12-t11);

  00373	2b 7c 24 48	 sub	 edi, DWORD PTR _t11$1$[esp+112]
  00377	83 c4 0c	 add	 esp, 12			; 0000000cH
  0037a	57		 push	 edi
  0037b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PAGGCBDD@GU?4POS?5?$CFd?6?$AA@
  00380	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  00386	e8 00 00 00 00	 call	 _fprintf
  0038b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 389  : 			fflush(fp);

  0038e	ff 35 00 00 00
	00		 push	 DWORD PTR ?fp@?8??UpdateGame@CPythonApplication@@QAEXXZ@4PAU_iobuf@@A
  00394	e8 00 00 00 00	 call	 _fflush
  00399	83 c4 04	 add	 esp, 4
$LN2@UpdateGame:

; 390  : 		}
; 391  : 	}
; 392  : }

  0039c	8b 4c 24 58	 mov	 ecx, DWORD PTR __$EHRec$[esp+100]
  003a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003a7	59		 pop	 ecx
  003a8	5f		 pop	 edi
  003a9	5e		 pop	 esi
  003aa	5b		 pop	 ebx
  003ab	8b e5		 mov	 esp, ebp
  003ad	5d		 pop	 ebp
  003ae	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateGame@CPythonApplication@@QAEXXZ$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR _s$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
__ehhandler$?UpdateGame@CPythonApplication@@QAEXXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 ac	 lea	 eax, DWORD PTR [edx-84]
  0000f	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?UpdateGame@CPythonApplication@@QAEXXZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?UpdateGame@CPythonApplication@@QAEXXZ ENDP		; CPythonApplication::UpdateGame
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?SkipRenderBuffering@CPythonApplication@@UAEXK@Z
_TEXT	SEGMENT
_dwSleepMSec$ = 8					; size = 4
?SkipRenderBuffering@CPythonApplication@@UAEXK@Z PROC	; CPythonApplication::SkipRenderBuffering, COMDAT
; _this$ = ecx

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 396  : 	m_dwBufSleepSkipTime=ELTimer_GetMSec()+dwSleepMSec;

  00006	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0000b	03 45 08	 add	 eax, DWORD PTR _dwSleepMSec$[ebp]
  0000e	89 86 9c 00 02
	00		 mov	 DWORD PTR [esi+131228], eax
  00014	5e		 pop	 esi

; 397  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?SkipRenderBuffering@CPythonApplication@@UAEXK@Z ENDP	; CPythonApplication::SkipRenderBuffering
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?Process@CPythonApplication@@QAE_NXZ
_TEXT	SEGMENT
_dwCurFaceCount$1$ = -44				; size = 4
_rkBG$1$ = -44						; size = 4
_bCurrentLateUpdate$1$ = -40				; size = 4
_dwRenderStartTime$1$ = -36				; size = 4
_fRatio$2 = -36						; size = 4
_fCurRenderTime$1$ = -32				; size = 4
_dwStart$1$ = -28					; size = 4
_Point$ = -24						; size = 8
__$EHRec$ = -12						; size = 12
?Process@CPythonApplication@@QAE_NXZ PROC		; CPythonApplication::Process, COMDAT
; _this$ = ecx

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?Process@CPythonApplication@@QAE_NXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 20	 sub	 esp, 32			; 00000020H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	50		 push	 eax
  00022	8d 44 24 30	 lea	 eax, DWORD PTR __$EHRec$[esp+60]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	8b f9		 mov	 edi, ecx

; 401  : #if defined(CHECK_LATEST_DATA_FILES)
; 402  : 	if (CheckLatestFiles_PollEvent())
; 403  : 		return false;
; 404  : #endif
; 405  : #ifdef USE_AHNLAB_HACKSHIELD
; 406  : 	if (HackShield_PollEvent())
; 407  : 		return false;
; 408  : #endif
; 409  : #ifdef XTRAP_CLIENT_ENABLE
; 410  : 	XTrap_PollEvent();
; 411  : #endif
; 412  : 	ELTimer_SetFrameMSec();

  0002e	e8 00 00 00 00	 call	 ?ELTimer_SetFrameMSec@@YAXXZ ; ELTimer_SetFrameMSec

; 413  : 
; 414  : 	// 	m_Profiler.Clear();
; 415  : 	DWORD dwStart = ELTimer_GetMSec();

  00033	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 416  : 
; 417  : 	///////////////////////////////////////////////////////////////////////////////////////////////////
; 418  : 	static DWORD	s_dwUpdateFrameCount = 0;
; 419  : 	static DWORD	s_dwRenderFrameCount = 0;
; 420  : 	static DWORD	s_dwFaceCount = 0;
; 421  : 	static UINT		s_uiLoad = 0;
; 422  : 	static DWORD	s_dwCheckTime = ELTimer_GetMSec();

  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA
  0003e	89 44 24 20	 mov	 DWORD PTR _dwStart$1$[esp+60], eax
  00042	f6 c1 01	 test	 cl, 1
  00045	75 23		 jne	 SHORT $LN37@Process
  00047	83 c9 01	 or	 ecx, 1
  0004a	89 0d 00 00 00
	00		 mov	 DWORD PTR ?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA, ecx
  00050	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+68], 0
  00058	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0005d	a3 00 00 00 00	 mov	 DWORD PTR ?s_dwCheckTime@?1??Process@CPythonApplication@@QAE_NXZ@4KA, eax
  00062	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+68], -1
$LN37@Process:

; 423  : 
; 424  : 	if (ELTimer_GetMSec() - s_dwCheckTime > 1000)

  0006a	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0006f	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?s_dwCheckTime@?1??Process@CPythonApplication@@QAE_NXZ@4KA
  00075	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  0007a	76 6d		 jbe	 SHORT $LN36@Process

; 425  : 	{
; 426  : 		m_dwUpdateFPS		= s_dwUpdateFrameCount;

  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_dwUpdateFrameCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA

; 427  : 		m_dwRenderFPS		= s_dwRenderFrameCount;

  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_dwRenderFrameCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA
  00087	89 87 64 00 02
	00		 mov	 DWORD PTR [edi+131172], eax

; 428  : 		m_dwLoad			= s_uiLoad;

  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_uiLoad@?1??Process@CPythonApplication@@QAE_NXZ@4IA
  00092	89 87 80 ff 01
	00		 mov	 DWORD PTR [edi+130944], eax

; 429  : 
; 430  : 		m_dwFaceCount		= s_dwFaceCount / max(1, s_dwRenderFrameCount);

  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	3b c8		 cmp	 ecx, eax
  0009f	89 8f 68 00 02
	00		 mov	 DWORD PTR [edi+131176], ecx
  000a5	0f 42 c8	 cmovb	 ecx, eax
  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_dwFaceCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA
  000ad	33 d2		 xor	 edx, edx
  000af	f7 f1		 div	 ecx
  000b1	89 87 6c 00 02
	00		 mov	 DWORD PTR [edi+131180], eax

; 431  : 
; 432  : 		s_dwCheckTime		= ELTimer_GetMSec();

  000b7	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  000bc	a3 00 00 00 00	 mov	 DWORD PTR ?s_dwCheckTime@?1??Process@CPythonApplication@@QAE_NXZ@4KA, eax

; 433  : 
; 434  : 		s_uiLoad = s_dwFaceCount = s_dwUpdateFrameCount = s_dwRenderFrameCount = 0;

  000c1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_dwRenderFrameCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA, 0
  000cb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_dwUpdateFrameCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA, 0
  000d5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_dwFaceCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA, 0
  000df	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_uiLoad@?1??Process@CPythonApplication@@QAE_NXZ@4IA, 0
$LN36@Process:

; 435  : 	}
; 436  : 
; 437  : 	// Update Time
; 438  : 	static BOOL s_bFrameSkip = false;
; 439  : 	static UINT s_uiNextFrameTime = ELTimer_GetMSec();

  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA
  000ee	a8 02		 test	 al, 2
  000f0	75 22		 jne	 SHORT $LN35@Process
  000f2	83 c8 02	 or	 eax, 2
  000f5	a3 00 00 00 00	 mov	 DWORD PTR ?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA, eax
  000fa	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+68], 1
  00102	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00107	a3 00 00 00 00	 mov	 DWORD PTR ?s_uiNextFrameTime@?4??Process@CPythonApplication@@QAE_NXZ@4IA, eax
  0010c	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+68], -1
$LN35@Process:

; 440  : 
; 441  : #ifdef __PERFORMANCE_CHECK__
; 442  : 	DWORD dwUpdateTime1=ELTimer_GetMSec();
; 443  : #endif
; 444  : 	CTimer& rkTimer=CTimer::Instance();

  00114	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton

; 445  : 	rkTimer.Advance();

  0011a	8b ce		 mov	 ecx, esi
  0011c	e8 00 00 00 00	 call	 ?Advance@CTimer@@QAEXXZ	; CTimer::Advance

; 446  : 
; 447  : 	m_fGlobalTime = rkTimer.GetCurrentSecond();

  00121	8b ce		 mov	 ecx, esi
  00123	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
  00128	d9 9f 9c ff 01
	00		 fstp	 DWORD PTR [edi+130972]

; 448  : 	m_fGlobalElapsedTime = rkTimer.GetElapsedSecond();

  0012e	8b ce		 mov	 ecx, esi
  00130	e8 00 00 00 00	 call	 ?GetElapsedSecond@CTimer@@QAEMXZ ; CTimer::GetElapsedSecond

; 449  : 
; 450  : 	UINT uiFrameTime = rkTimer.GetElapsedMilliecond();

  00135	8b ce		 mov	 ecx, esi
  00137	d9 9f a0 ff 01
	00		 fstp	 DWORD PTR [edi+130976]
  0013d	e8 00 00 00 00	 call	 ?GetElapsedMilliecond@CTimer@@QAEKXZ ; CTimer::GetElapsedMilliecond
  00142	8b f0		 mov	 esi, eax

; 451  : 	s_uiNextFrameTime += uiFrameTime;	//17 - 1 60fps.

  00144	01 35 00 00 00
	00		 add	 DWORD PTR ?s_uiNextFrameTime@?4??Process@CPythonApplication@@QAE_NXZ@4IA, esi

; 452  : 
; 453  : 	DWORD updatestart = ELTimer_GetMSec();

  0014a	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 454  : #ifdef __PERFORMANCE_CHECK__
; 455  : 	DWORD dwUpdateTime2=ELTimer_GetMSec();
; 456  : #endif
; 457  : 	// Network I/O	
; 458  : 	m_pyNetworkStream.Process();	

  0014f	8d 8f 40 08 00
	00		 lea	 ecx, DWORD PTR [edi+2112]
  00155	8b d8		 mov	 ebx, eax
  00157	e8 00 00 00 00	 call	 ?Process@CNetworkStream@@QAEXXZ ; CNetworkStream::Process

; 459  : 	//m_pyNetworkDatagram.Process();
; 460  : 
; 461  : 	m_kGuildMarkUploader.Process();

  0015c	8d 8f dc d3 01
	00		 lea	 ecx, DWORD PTR [edi+119772]
  00162	e8 00 00 00 00	 call	 ?Process@CGuildMarkUploader@@QAEXXZ ; CGuildMarkUploader::Process

; 462  : 
; 463  : #ifdef USE_NPROTECT_GAMEGUARD
; 464  : 	if (GameGuard_IsError())
; 465  : 		return false;
; 466  : #endif
; 467  : 
; 468  : 	m_kGuildMarkDownloader.Process();

  00167	8d 8f 2c d3 01
	00		 lea	 ecx, DWORD PTR [edi+119596]
  0016d	e8 00 00 00 00	 call	 ?Process@CGuildMarkDownloader@@QAEXXZ ; CGuildMarkDownloader::Process

; 469  : 	m_kAccountConnector.Process();

  00172	8d 8f 7c d7 01
	00		 lea	 ecx, DWORD PTR [edi+120700]
  00178	e8 00 00 00 00	 call	 ?Process@CAccountConnector@@QAEXXZ ; CAccountConnector::Process

; 470  : 
; 471  : #ifdef __PERFORMANCE_CHECK__		
; 472  : 	DWORD dwUpdateTime3=ELTimer_GetMSec();
; 473  : #endif
; 474  : 	//////////////////////
; 475  : 	// Input Process
; 476  : 	// Keyboard
; 477  : 	UpdateKeyboard();

  0017d	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  00180	e8 00 00 00 00	 call	 ?UpdateKeyboard@CInputKeyboard@@QAEXXZ ; CInputKeyboard::UpdateKeyboard

; 478  : #ifdef __PERFORMANCE_CHECK__
; 479  : 	DWORD dwUpdateTime4=ELTimer_GetMSec();
; 480  : #endif
; 481  : 	// Mouse
; 482  : 	POINT Point;
; 483  : 	if (GetCursorPos(&Point))

  00185	8d 44 24 24	 lea	 eax, DWORD PTR _Point$[esp+60]
  00189	50		 push	 eax
  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4
  00190	85 c0		 test	 eax, eax
  00192	74 1d		 je	 SHORT $LN34@Process

; 484  : 	{
; 485  : 		ScreenToClient(m_hWnd, &Point);

  00194	8d 44 24 24	 lea	 eax, DWORD PTR _Point$[esp+60]
  00198	50		 push	 eax
  00199	ff 77 04	 push	 DWORD PTR [edi+4]
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ScreenToClient@8

; 486  : 		OnMouseMove(Point.x, Point.y);		

  001a2	ff 74 24 28	 push	 DWORD PTR _Point$[esp+64]
  001a6	8b cf		 mov	 ecx, edi
  001a8	ff 74 24 28	 push	 DWORD PTR _Point$[esp+64]
  001ac	e8 00 00 00 00	 call	 ?OnMouseMove@CPythonApplication@@IAEXHH@Z ; CPythonApplication::OnMouseMove
$LN34@Process:

; 487  : 	}
; 488  : 	//////////////////////
; 489  : #ifdef __PERFORMANCE_CHECK__
; 490  : 	DWORD dwUpdateTime5=ELTimer_GetMSec();
; 491  : #endif
; 492  : 	//!@# Alt+Tab  SetTransfor      - [levites]
; 493  : 	//if (m_isActivateWnd)
; 494  : 	__UpdateCamera();

  001b1	8b cf		 mov	 ecx, edi
  001b3	e8 00 00 00 00	 call	 ?__UpdateCamera@CPythonApplication@@IAEXXZ ; CPythonApplication::__UpdateCamera

; 495  : #ifdef __PERFORMANCE_CHECK__
; 496  : 	DWORD dwUpdateTime6=ELTimer_GetMSec();
; 497  : #endif
; 498  : 	// Update Game Playing
; 499  : 	CResourceManager::Instance().Update();

  001b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  001be	e8 00 00 00 00	 call	 ?Update@CResourceManager@@QAEXXZ ; CResourceManager::Update

; 500  : #ifdef __PERFORMANCE_CHECK__
; 501  : 	DWORD dwUpdateTime7=ELTimer_GetMSec();
; 502  : #endif
; 503  : 	OnCameraUpdate();

  001c3	8b cf		 mov	 ecx, edi
  001c5	e8 00 00 00 00	 call	 ?OnCameraUpdate@CPythonApplication@@IAEXXZ ; CPythonApplication::OnCameraUpdate

; 504  : #ifdef __PERFORMANCE_CHECK__
; 505  : 	DWORD dwUpdateTime8=ELTimer_GetMSec();
; 506  : #endif
; 507  : 	OnMouseUpdate();

  001ca	8b cf		 mov	 ecx, edi
  001cc	e8 00 00 00 00	 call	 ?OnMouseUpdate@CPythonApplication@@IAEXXZ ; CPythonApplication::OnMouseUpdate

; 508  : #ifdef __PERFORMANCE_CHECK__
; 509  : 	DWORD dwUpdateTime9=ELTimer_GetMSec();
; 510  : #endif
; 511  : 	OnUIUpdate();

  001d1	e8 00 00 00 00	 call	 ?OnUIUpdate@CPythonApplication@@IAEXXZ ; CPythonApplication::OnUIUpdate

; 512  : 
; 513  : #ifdef __PERFORMANCE_CHECK__		
; 514  : 	DWORD dwUpdateTime10=ELTimer_GetMSec();
; 515  : 
; 516  : 	if (dwUpdateTime10-dwUpdateTime1>10)
; 517  : 	{			
; 518  : 		static FILE* fp=fopen("perf_app_update.txt", "w");
; 519  : 
; 520  : 		fprintf(fp, "AU.Total %d (Time %d)\n", dwUpdateTime9-dwUpdateTime1, ELTimer_GetMSec());
; 521  : 		fprintf(fp, "AU.TU %d\n", dwUpdateTime2-dwUpdateTime1);
; 522  : 		fprintf(fp, "AU.NU %d\n", dwUpdateTime3-dwUpdateTime2);
; 523  : 		fprintf(fp, "AU.KU %d\n", dwUpdateTime4-dwUpdateTime3);
; 524  : 		fprintf(fp, "AU.MP %d\n", dwUpdateTime5-dwUpdateTime4);
; 525  : 		fprintf(fp, "AU.CP %d\n", dwUpdateTime6-dwUpdateTime5);
; 526  : 		fprintf(fp, "AU.RU %d\n", dwUpdateTime7-dwUpdateTime6);
; 527  : 		fprintf(fp, "AU.CU %d\n", dwUpdateTime8-dwUpdateTime7);
; 528  : 		fprintf(fp, "AU.MU %d\n", dwUpdateTime9-dwUpdateTime8);
; 529  : 		fprintf(fp, "AU.UU %d\n", dwUpdateTime10-dwUpdateTime9);			
; 530  : 		fprintf(fp, "----------------------------------\n");
; 531  : 		fflush(fp);
; 532  : 	}		
; 533  : #endif
; 534  : 
; 535  : 	//Update .delta
; 536  : 	m_dwCurUpdateTime = ELTimer_GetMSec() - updatestart;

  001d6	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  001db	2b c3		 sub	 eax, ebx
  001dd	89 87 7c ff 01
	00		 mov	 DWORD PTR [edi+130940], eax

; 537  : 
; 538  : 	DWORD dwCurrentTime = ELTimer_GetMSec();

  001e3	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 539  : 	BOOL  bCurrentLateUpdate = FALSE;
; 540  : 
; 541  : 	s_bFrameSkip = false;
; 542  : 
; 543  : 	if (dwCurrentTime > s_uiNextFrameTime)

  001e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_uiNextFrameTime@?4??Process@CPythonApplication@@QAE_NXZ@4IA
  001ee	33 d2		 xor	 edx, edx
  001f0	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _bCurrentLateUpdate$1$[esp+60], 0
  001f8	89 15 00 00 00
	00		 mov	 DWORD PTR ?s_bFrameSkip@?4??Process@CPythonApplication@@QAE_NXZ@4HA, edx
  001fe	3b c1		 cmp	 eax, ecx
  00200	76 65		 jbe	 SHORT $LN33@Process

; 544  : 	{
; 545  : 		int dt = dwCurrentTime - s_uiNextFrameTime;

  00202	66 0f 6e c6	 movd	 xmm0, esi
  00206	2b c1		 sub	 eax, ecx

; 546  : 		int nAdjustTime = ((float)dt / (float)uiFrameTime) * uiFrameTime; 

  00208	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0020c	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0020f	f2 0f 58 04 f5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[esi*8]
  00218	66 0f 5a c8	 cvtpd2ps xmm1, xmm0
  0021c	66 0f 6e c0	 movd	 xmm0, eax
  00220	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00223	f3 0f 5e c1	 divss	 xmm0, xmm1
  00227	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0022b	f3 0f 2c f0	 cvttss2si esi, xmm0

; 547  : 
; 548  : 		if ( dt >= 500 )

  0022f	3d f4 01 00 00	 cmp	 eax, 500		; 000001f4H
  00234	7c 22		 jl	 SHORT $LN32@Process

; 549  : 		{
; 550  : 			s_uiNextFrameTime += nAdjustTime; 

  00236	03 ce		 add	 ecx, esi

; 551  : 			printf("FrameSkip  %d\n",nAdjustTime);

  00238	56		 push	 esi
  00239	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OJBILBDC@FrameSkip?5?$LK?$LI?A?$KE?5?$CFd?6?$AA@
  0023e	89 0d 00 00 00
	00		 mov	 DWORD PTR ?s_uiNextFrameTime@?4??Process@CPythonApplication@@QAE_NXZ@4IA, ecx
  00244	e8 00 00 00 00	 call	 _printf

; 552  : 			CTimer::Instance().Adjust(nAdjustTime);

  00249	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  0024f	83 c4 08	 add	 esp, 8
  00252	56		 push	 esi
  00253	e8 00 00 00 00	 call	 ?Adjust@CTimer@@QAEXH@Z	; CTimer::Adjust
$LN32@Process:

; 553  : 		}
; 554  : 
; 555  : 		s_bFrameSkip = true;

  00258	ba 01 00 00 00	 mov	 edx, 1
  0025d	89 15 00 00 00
	00		 mov	 DWORD PTR ?s_bFrameSkip@?4??Process@CPythonApplication@@QAE_NXZ@4HA, edx

; 556  : 		bCurrentLateUpdate = TRUE;

  00263	89 54 24 14	 mov	 DWORD PTR _bCurrentLateUpdate$1$[esp+60], edx
$LN33@Process:

; 557  : 	}
; 558  : 
; 559  : 	//s_bFrameSkip = false;
; 560  : 
; 561  : 	//if (dwCurrentTime > s_uiNextFrameTime)
; 562  : 	//{
; 563  : 	//	int dt = dwCurrentTime - s_uiNextFrameTime;
; 564  : 
; 565  : 	//	//   .
; 566  : 	//	// m_dwCurUpdateTime delta delta absolute time  ?
; 567  : 	//	//if (dt >= 500 || m_dwCurUpdateTime > s_uiNextFrameTime)
; 568  : 
; 569  : 	//	//  0.5    update   rendering frame skip
; 570  : 	//	if (dt >= 500 || m_dwCurUpdateTime > s_uiNextFrameTime)
; 571  : 	//	{
; 572  : 	//		s_uiNextFrameTime += dt / uiFrameTime * uiFrameTime; 
; 573  : 	//		printf("FrameSkip  %d\n", dt / uiFrameTime * uiFrameTime);
; 574  : 	//		CTimer::Instance().Adjust((dt / uiFrameTime) * uiFrameTime);
; 575  : 	//		s_bFrameSkip = true;
; 576  : 	//	}
; 577  : 	//}
; 578  : 
; 579  : 	if (m_isFrameSkipDisable)

  00267	80 bf 91 00 02
	00 00		 cmp	 BYTE PTR [edi+131217], 0
  0026e	74 0c		 je	 SHORT $LN31@Process

; 580  : 		s_bFrameSkip = false;

  00270	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_bFrameSkip@?4??Process@CPythonApplication@@QAE_NXZ@4HA, 0

; 581  : 
; 582  : #ifdef __VTUNE__
; 583  : 	s_bFrameSkip = false;
; 584  : #endif
; 585  : 	/*
; 586  : 	static bool s_isPrevFrameSkip=false;
; 587  : 	static DWORD s_dwFrameSkipCount=0;
; 588  : 	static DWORD s_dwFrameSkipEndTime=0;
; 589  : 
; 590  : 	static DWORD ERROR_FRAME_SKIP_COUNT = 60*5;
; 591  : 	static DWORD ERROR_FRAME_SKIP_TIME = ERROR_FRAME_SKIP_COUNT*18;
; 592  : 
; 593  : 	//static DWORD MAX_FRAME_SKIP=0;
; 594  : 
; 595  : 	if (IsActive())
; 596  : 	{
; 597  : 	DWORD dwFrameSkipCurTime=ELTimer_GetMSec();
; 598  : 
; 599  : 	if (s_bFrameSkip)
; 600  : 	{
; 601  : 	//   ..
; 602  : 	if (s_isPrevFrameSkip)
; 603  : 	{
; 604  : 	if (s_dwFrameSkipEndTime==0)
; 605  : 	{
; 606  : 	s_dwFrameSkipCount=0; //    
; 607  : 	s_dwFrameSkipEndTime=dwFrameSkipCurTime+ERROR_FRAME_SKIP_TIME; //      
; 608  : 
; 609  : 	//printf("FrameSkipCheck Start\n");
; 610  : 	}
; 611  : 	++s_dwFrameSkipCount;
; 612  : 
; 613  : 	//if (MAX_FRAME_SKIP<s_dwFrameSkipCount)
; 614  : 	//	MAX_FRAME_SKIP=s_dwFrameSkipCount;
; 615  : 
; 616  : 	//printf("u %d c %d/%d t %d\n", 
; 617  : 	//	dwUpdateTime9-dwUpdateTime1,
; 618  : 	//	s_dwFrameSkipCount, 
; 619  : 	//	MAX_FRAME_SKIP,
; 620  : 	//	s_dwFrameSkipEndTime);
; 621  : 
; 622  : 	//#ifndef _DEBUG
; 623  : 	//      ...
; 624  : 	if (s_dwFrameSkipCount>ERROR_FRAME_SKIP_COUNT && s_dwFrameSkipEndTime<dwFrameSkipCurTime)
; 625  : 	{
; 626  : 	s_isPrevFrameSkip=false;
; 627  : 	s_dwFrameSkipEndTime=0;
; 628  : 	s_dwFrameSkipCount=0;
; 629  : 
; 630  : 	//m_pyNetworkStream.AbsoluteExitGame();
; 631  : 
; 632  : 	/*
; 633  : 	TraceError("    ");
; 634  : 
; 635  : 	{
; 636  : 	FILE* fp=fopen("errorlog.txt", "w");
; 637  : 	if (fp)
; 638  : 	{
; 639  : 	fprintf(fp, "FRAMESKIP\n");
; 640  : 	fprintf(fp, "Total %d\n",		dwUpdateTime9-dwUpdateTime1);
; 641  : 	fprintf(fp, "Timer %d\n",		dwUpdateTime2-dwUpdateTime1);
; 642  : 	fprintf(fp, "Network %d\n",		dwUpdateTime3-dwUpdateTime2);
; 643  : 	fprintf(fp, "Keyboard %d\n",	dwUpdateTime4-dwUpdateTime3);
; 644  : 	fprintf(fp, "Controll %d\n",	dwUpdateTime5-dwUpdateTime4);
; 645  : 	fprintf(fp, "Resource %d\n",	dwUpdateTime6-dwUpdateTime5);
; 646  : 	fprintf(fp, "Camera %d\n",		dwUpdateTime7-dwUpdateTime6);
; 647  : 	fprintf(fp, "Mouse %d\n",		dwUpdateTime8-dwUpdateTime7);
; 648  : 	fprintf(fp, "UI %d\n",			dwUpdateTime9-dwUpdateTime8);
; 649  : 	fclose(fp);
; 650  : 
; 651  : 	WinExec("errorlog.exe", SW_SHOW);
; 652  : 	}
; 653  : 	}
; 654  : 	}
; 655  : 	}
; 656  : 
; 657  : 	s_isPrevFrameSkip=true;
; 658  : 	}
; 659  : 	else
; 660  : 	{
; 661  : 	s_isPrevFrameSkip=false;
; 662  : 	s_dwFrameSkipCount=0;
; 663  : 	s_dwFrameSkipEndTime=0;
; 664  : 	}
; 665  : 	}
; 666  : 	else
; 667  : 	{
; 668  : 	s_isPrevFrameSkip=false;
; 669  : 	s_dwFrameSkipCount=0;
; 670  : 	s_dwFrameSkipEndTime=0;
; 671  : 	}
; 672  : 	*/
; 673  : 	if (!s_bFrameSkip)

  0027a	eb 08		 jmp	 SHORT $LN56@Process
$LN31@Process:
  0027c	85 d2		 test	 edx, edx
  0027e	0f 85 b2 03 00
	00		 jne	 $LN21@Process
$LN56@Process:
  00284	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR ?g_specularSpd@@3NA

; 674  : 	{
; 675  : 		//		static double pos=0.0f;
; 676  : 		//		CGrannyMaterial::TranslateSpecularMatrix(fabs(sin(pos)*0.005), fabs(cos(pos)*0.005), 0.0f);
; 677  : 		//		pos+=0.01f;
; 678  : 
; 679  : 		CGrannyMaterial::TranslateSpecularMatrix(g_specularSpd, g_specularSpd, 0.0f);

  0028c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0028f	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00293	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  0029b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  002a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a6	e8 00 00 00 00	 call	 ?TranslateSpecularMatrix@CGrannyMaterial@@SAXMMM@Z ; CGrannyMaterial::TranslateSpecularMatrix
  002ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 680  : 
; 681  : 		DWORD dwRenderStartTime = ELTimer_GetMSec();		

  002ae	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 682  : 
; 683  : 		bool canRender = true;
; 684  : 
; 685  : 		if (m_isMinimizedWnd)

  002b3	80 bf b0 00 02
	00 00		 cmp	 BYTE PTR [edi+131248], 0
  002ba	b3 01		 mov	 bl, 1
  002bc	89 44 24 18	 mov	 DWORD PTR _dwRenderStartTime$1$[esp+60], eax
  002c0	75 39		 jne	 SHORT $LN26@Process

; 686  : 		{
; 687  : 			canRender = false;
; 688  : 		}
; 689  : 		else
; 690  : 		{
; 691  : 			if (m_pyGraphic.IsLostDevice())

  002c2	8d 8f 9c 07 00
	00		 lea	 ecx, DWORD PTR [edi+1948]
  002c8	e8 00 00 00 00	 call	 ?IsLostDevice@CScreen@@QAEHXZ ; CScreen::IsLostDevice
  002cd	85 c0		 test	 eax, eax
  002cf	74 2c		 je	 SHORT $LN25@Process

; 692  : 			{
; 693  : 				CPythonBackground& rkBG = CPythonBackground::Instance();

  002d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton

; 694  : 				rkBG.ReleaseCharacterShadowTexture();

  002d6	8b c8		 mov	 ecx, eax
  002d8	89 44 24 10	 mov	 DWORD PTR _rkBG$1$[esp+60], eax
  002dc	e8 00 00 00 00	 call	 ?ReleaseCharacterShadowTexture@CPythonBackground@@QAEXXZ ; CPythonBackground::ReleaseCharacterShadowTexture

; 695  : 
; 696  : 				if (m_pyGraphic.RestoreDevice())					

  002e1	8d 8f 9c 07 00
	00		 lea	 ecx, DWORD PTR [edi+1948]
  002e7	e8 00 00 00 00	 call	 ?RestoreDevice@CScreen@@QAEHXZ ; CScreen::RestoreDevice
  002ec	85 c0		 test	 eax, eax
  002ee	74 0b		 je	 SHORT $LN26@Process

; 697  : 					rkBG.CreateCharacterShadowTexture();

  002f0	8b 4c 24 10	 mov	 ecx, DWORD PTR _rkBG$1$[esp+60]
  002f4	e8 00 00 00 00	 call	 ?CreateCharacterShadowTexture@CPythonBackground@@QAEXXZ ; CPythonBackground::CreateCharacterShadowTexture

; 698  : 				else

  002f9	eb 02		 jmp	 SHORT $LN25@Process
$LN26@Process:

; 699  : 					canRender = false;				

  002fb	32 db		 xor	 bl, bl
$LN25@Process:

; 700  : 			}
; 701  : 		}
; 702  : 
; 703  : 		if (!IsActive())

  002fd	8b cf		 mov	 ecx, edi
  002ff	e8 00 00 00 00	 call	 ?IsActive@CMSWindow@@QAE_NXZ ; CMSWindow::IsActive
  00304	84 c0		 test	 al, al
  00306	75 0e		 jne	 SHORT $LN24@Process

; 704  : 		{
; 705  : 			SkipRenderBuffering(3000);

  00308	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0030b	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  0030e	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  00313	ff 50 10	 call	 DWORD PTR [eax+16]
$LN24@Process:

; 706  : 		}
; 707  : 
; 708  : 		//        
; 709  : 		if (!canRender)

  00316	84 db		 test	 bl, bl
  00318	75 13		 jne	 SHORT $LN23@Process

; 710  : 		{
; 711  : 			SkipRenderBuffering(3000);

  0031a	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0031d	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00320	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  00325	ff 50 10	 call	 DWORD PTR [eax+16]

; 712  : 		}
; 713  : 		else

  00328	e9 09 03 00 00	 jmp	 $LN21@Process
$LN23@Process:

; 714  : 		{
; 715  : 			// RestoreLostDevice
; 716  : 			CCullingManager::Instance().Update();

  0032d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  00333	e8 00 00 00 00	 call	 ?Update@CCullingManager@@QAEXXZ ; CCullingManager::Update

; 717  : 			if (m_pyGraphic.Begin())

  00338	8d b7 9c 07 00
	00		 lea	 esi, DWORD PTR [edi+1948]
  0033e	8b ce		 mov	 ecx, esi
  00340	e8 00 00 00 00	 call	 ?Begin@CScreen@@QAE_NXZ	; CScreen::Begin
  00345	84 c0		 test	 al, al
  00347	0f 84 e9 02 00
	00		 je	 $LN21@Process

; 718  : 			{
; 719  : 
; 720  : 				m_pyGraphic.ClearDepthBuffer();

  0034d	8b ce		 mov	 ecx, esi
  0034f	e8 00 00 00 00	 call	 ?ClearDepthBuffer@CScreen@@QAEXXZ ; CScreen::ClearDepthBuffer

; 721  : 
; 722  : #ifdef _DEBUG
; 723  : 				m_pyGraphic.SetClearColor(0.3f, 0.3f, 0.3f);
; 724  : 				m_pyGraphic.Clear();
; 725  : #endif
; 726  : 
; 727  : 				/////////////////////
; 728  : 				// Interface
; 729  : 				m_pyGraphic.SetInterfaceRenderState();

  00354	8b ce		 mov	 ecx, esi
  00356	e8 00 00 00 00	 call	 ?SetInterfaceRenderState@CPythonGraphic@@QAEXXZ ; CPythonGraphic::SetInterfaceRenderState

; 730  : 
; 731  : 				OnUIRender();

  0035b	e8 00 00 00 00	 call	 ?OnUIRender@CPythonApplication@@IAEXXZ ; CPythonApplication::OnUIRender

; 732  : 				OnMouseRender();

  00360	8b cf		 mov	 ecx, edi
  00362	e8 00 00 00 00	 call	 ?OnMouseRender@CPythonApplication@@IAEXXZ ; CPythonApplication::OnMouseRender

; 733  : 				/////////////////////
; 734  : 
; 735  : 				m_pyGraphic.End();

  00367	8b ce		 mov	 ecx, esi
  00369	e8 00 00 00 00	 call	 ?End@CScreen@@QAEXXZ	; CScreen::End

; 736  : 
; 737  : 				//DWORD t1 = ELTimer_GetMSec();
; 738  : 				m_pyGraphic.Show();

  0036e	6a 00		 push	 0
  00370	8b ce		 mov	 ecx, esi
  00372	e8 00 00 00 00	 call	 ?Show@CScreen@@QAEXPAUHWND__@@@Z ; CScreen::Show

; 739  : 				//DWORD t2 = ELTimer_GetMSec();
; 740  : 
; 741  : 				DWORD dwRenderEndTime = ELTimer_GetMSec();

  00377	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec

; 742  : 
; 743  : 				static DWORD s_dwRenderCheckTime = dwRenderEndTime;

  0037c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA
  00382	8b d8		 mov	 ebx, eax
  00384	f6 c1 04	 test	 cl, 4
  00387	75 0f		 jne	 SHORT $LN57@Process
  00389	83 c9 04	 or	 ecx, 4
  0038c	89 1d 00 00 00
	00		 mov	 DWORD PTR ?s_dwRenderCheckTime@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA, ebx
  00392	89 0d 00 00 00
	00		 mov	 DWORD PTR ?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA, ecx
$LN57@Process:

; 744  : 				static DWORD s_dwRenderRangeTime = 0;
; 745  : 				static DWORD s_dwRenderRangeFrame = 0;
; 746  : 
; 747  : 				m_dwCurRenderTime = dwRenderEndTime - dwRenderStartTime;			
; 748  : 				s_dwRenderRangeTime += m_dwCurRenderTime;				

  00398	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_dwRenderRangeTime@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA
  0039e	8b c3		 mov	 eax, ebx
  003a0	2b 44 24 18	 sub	 eax, DWORD PTR _dwRenderStartTime$1$[esp+60]

; 749  : 				++s_dwRenderRangeFrame;			

  003a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?s_dwRenderRangeFrame@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA
  003aa	03 c8		 add	 ecx, eax
  003ac	89 87 78 ff 01
	00		 mov	 DWORD PTR [edi+130936], eax
  003b2	42		 inc	 edx

; 750  : 
; 751  : 				if (dwRenderEndTime-s_dwRenderCheckTime>1000)

  003b3	8b c3		 mov	 eax, ebx
  003b5	89 0d 00 00 00
	00		 mov	 DWORD PTR ?s_dwRenderRangeTime@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA, ecx
  003bb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?s_dwRenderCheckTime@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA
  003c1	89 15 00 00 00
	00		 mov	 DWORD PTR ?s_dwRenderRangeFrame@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA, edx
  003c7	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  003cc	76 56		 jbe	 SHORT $LN19@Process

; 752  : 				{
; 753  : 					m_fAveRenderTime=float(double(s_dwRenderRangeTime)/double(s_dwRenderRangeFrame));

  003ce	66 0f 6e c9	 movd	 xmm1, ecx
  003d2	66 0f 6e c2	 movd	 xmm0, edx
  003d6	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  003da	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  003dd	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  003e0	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  003e4	f2 0f 58 0c cd
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  003ed	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  003f6	f2 0f 5e c8	 divsd	 xmm1, xmm0
  003fa	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  003fe	f3 0f 11 87 74
	ff 01 00	 movss	 DWORD PTR [edi+130932], xmm0

; 754  : 
; 755  : 					s_dwRenderCheckTime=ELTimer_GetMSec();

  00406	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0040b	a3 00 00 00 00	 mov	 DWORD PTR ?s_dwRenderCheckTime@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA, eax

; 756  : 					s_dwRenderRangeTime=0;

  00410	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_dwRenderRangeTime@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA, 0

; 757  : 					s_dwRenderRangeFrame=0;

  0041a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_dwRenderRangeFrame@?CJ@??Process@CPythonApplication@@QAE_NXZ@4KA, 0
$LN19@Process:

; 758  : 				}										
; 759  : 
; 760  : 				DWORD dwCurFaceCount=m_pyGraphic.GetFaceCount();

  00424	8b ce		 mov	 ecx, esi
  00426	e8 00 00 00 00	 call	 ?GetFaceCount@CGraphicBase@@QAEKXZ ; CGraphicBase::GetFaceCount

; 761  : 				m_pyGraphic.ResetFaceCount();

  0042b	8b ce		 mov	 ecx, esi
  0042d	89 44 24 10	 mov	 DWORD PTR _dwCurFaceCount$1$[esp+60], eax
  00431	e8 00 00 00 00	 call	 ?ResetFaceCount@CGraphicBase@@QAEXXZ ; CGraphicBase::ResetFaceCount

; 762  : 				s_dwFaceCount += dwCurFaceCount;

  00436	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwCurFaceCount$1$[esp+60]
  0043a	01 0d 00 00 00
	00		 add	 DWORD PTR ?s_dwFaceCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA, ecx

; 763  : 
; 764  : 				if (dwCurFaceCount > 5000)

  00440	81 f9 88 13 00
	00		 cmp	 ecx, 5000		; 00001388H
  00446	0f 86 cf 01 00
	00		 jbe	 $LN18@Process

; 765  : 				{
; 766  : 					//   
; 767  : 					if (dwRenderEndTime > m_dwBufSleepSkipTime)

  0044c	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@42c80000
  00454	3b 9f bc 00 02
	00		 cmp	 ebx, DWORD PTR [edi+131260]
  0045a	0f 86 c8 00 00
	00		 jbe	 $LN17@Process

; 768  : 					{	
; 769  : 						static float s_fBufRenderTime = 0.0f;
; 770  : 
; 771  : 						float fCurRenderTime = m_dwCurRenderTime;

  00460	8b 87 78 ff 01
	00		 mov	 eax, DWORD PTR [edi+130936]

; 772  : 
; 773  : 						if (fCurRenderTime > s_fBufRenderTime)

  00466	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR ?s_fBufRenderTime@?DC@??Process@CPythonApplication@@QAE_NXZ@4MA
  0046e	66 0f 6e c0	 movd	 xmm0, eax
  00472	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00476	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00479	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00482	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00486	0f 2f c1	 comiss	 xmm0, xmm1
  00489	f3 0f 11 44 24
	1c		 movss	 DWORD PTR _fCurRenderTime$1$[esp+60], xmm0
  0048f	76 5f		 jbe	 SHORT $LN16@Process

; 774  : 						{
; 775  : 							float fRatio = fMAX(0.5f, (fCurRenderTime - s_fBufRenderTime) / 30.0f);

  00491	f3 0f 5c c1	 subss	 xmm0, xmm1
  00495	83 ec 08	 sub	 esp, 8
  00498	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41f00000
  004a0	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  004a6	c7 04 24 00 00
	00 3f		 mov	 DWORD PTR [esp], 1056964608 ; 3f000000H
  004ad	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX

; 776  : 							s_fBufRenderTime = (s_fBufRenderTime * (100.0f - fRatio) + (fCurRenderTime + 5) * fRatio) / 100.0f;

  004b2	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@42c80000
  004ba	83 c4 08	 add	 esp, 8
  004bd	f3 0f 10 54 24
	1c		 movss	 xmm2, DWORD PTR _fCurRenderTime$1$[esp+60]
  004c3	0f 28 cb	 movaps	 xmm1, xmm3
  004c6	f3 0f 58 15 00
	00 00 00	 addss	 xmm2, DWORD PTR __real@40a00000

; 777  : 						}
; 778  : 						else

  004ce	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwCurFaceCount$1$[esp+60]
  004d2	d9 5c 24 18	 fstp	 DWORD PTR _fRatio$2[esp+60]
  004d6	f3 0f 5c 4c 24
	18		 subss	 xmm1, DWORD PTR _fRatio$2[esp+60]
  004dc	f3 0f 59 54 24
	18		 mulss	 xmm2, DWORD PTR _fRatio$2[esp+60]
  004e2	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR ?s_fBufRenderTime@?DC@??Process@CPythonApplication@@QAE_NXZ@4MA
  004ea	f3 0f 58 ca	 addss	 xmm1, xmm2
  004ee	eb 14		 jmp	 SHORT $LN59@Process
$LN16@Process:

; 779  : 						{
; 780  : 							float fRatio = 0.5f;
; 781  : 							s_fBufRenderTime = (s_fBufRenderTime * (100.0f - fRatio) + fCurRenderTime * fRatio) / 100.0f;

  004f0	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@42c70000
  004f8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00500	f3 0f 58 c8	 addss	 xmm1, xmm0
$LN59@Process:
  00504	f3 0f 5e cb	 divss	 xmm1, xmm3

; 782  : 						}
; 783  : 
; 784  : 						//  
; 785  : 						if (s_fBufRenderTime > 100.0f)

  00508	0f 2f cb	 comiss	 xmm1, xmm3
  0050b	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR ?s_fBufRenderTime@?DC@??Process@CPythonApplication@@QAE_NXZ@4MA, xmm1
  00513	76 0b		 jbe	 SHORT $LN14@Process

; 786  : 							s_fBufRenderTime = 100.0f;

  00515	0f 28 cb	 movaps	 xmm1, xmm3
  00518	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR ?s_fBufRenderTime@?DC@??Process@CPythonApplication@@QAE_NXZ@4MA, xmm1
$LN14@Process:

; 787  : 
; 788  : 						DWORD dwBufRenderTime = s_fBufRenderTime;
; 789  : 
; 790  : 						if (m_isWindowed)
; 791  : 						{						
; 792  : 							if (dwBufRenderTime>58)
; 793  : 								dwBufRenderTime=64;
; 794  : 							else if (dwBufRenderTime>42)
; 795  : 								dwBufRenderTime=48;
; 796  : 							else if (dwBufRenderTime>26)
; 797  : 								dwBufRenderTime=32;
; 798  : 							else if (dwBufRenderTime>10)
; 799  : 								dwBufRenderTime=16;
; 800  : 							else
; 801  : 								dwBufRenderTime=8;
; 802  : 						}
; 803  : 
; 804  : 						//      
; 805  : 						//    ?
; 806  : 						//if (m_dwCurRenderTime<dwBufRenderTime)
; 807  : 						//	Sleep(dwBufRenderTime-m_dwCurRenderTime);			
; 808  : 
; 809  : 						m_fAveRenderTime=s_fBufRenderTime;

  00520	f3 0f 11 8f 74
	ff 01 00	 movss	 DWORD PTR [edi+130932], xmm1
$LN17@Process:

; 810  : 					}
; 811  : 
; 812  : 					m_dwFaceAccCount += dwCurFaceCount;

  00528	01 8f 5c 00 02
	00		 add	 DWORD PTR [edi+131164], ecx

; 813  : 					m_dwFaceAccTime += m_dwCurRenderTime;
; 814  : 
; 815  : 					m_fFaceSpd=(m_dwFaceAccCount/m_dwFaceAccTime);

  0052e	33 d2		 xor	 edx, edx
  00530	8b 8f 78 ff 01
	00		 mov	 ecx, DWORD PTR [edi+130936]
  00536	01 8f 60 00 02
	00		 add	 DWORD PTR [edi+131168], ecx
  0053c	8b 87 5c 00 02
	00		 mov	 eax, DWORD PTR [edi+131164]
  00542	f7 b7 60 00 02
	00		 div	 DWORD PTR [edi+131168]
  00548	66 0f 6e c0	 movd	 xmm0, eax
  0054c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00550	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00553	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 816  : 
; 817  : 					//   
; 818  : 					if (-1 == m_iForceSightRange)

  0055c	8b 87 c0 00 02
	00		 mov	 eax, DWORD PTR [edi+131264]
  00562	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00566	f3 0f 11 87 50
	00 02 00	 movss	 DWORD PTR [edi+131152], xmm0
  0056e	83 f8 ff	 cmp	 eax, -1
  00571	0f 85 9b 00 00
	00		 jne	 $LN4@Process

; 819  : 					{
; 820  : 						static float s_fAveRenderTime = 16.0f;
; 821  : 						float fRatio=0.3f;
; 822  : 						s_fAveRenderTime=(s_fAveRenderTime*(100.0f-fRatio)+max(16.0f, m_dwCurRenderTime)*fRatio)/100.0f;

  00577	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@41800000
  0057f	66 0f 6e c1	 movd	 xmm0, ecx
  00583	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00587	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0058a	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00593	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00597	0f 2f c8	 comiss	 xmm1, xmm0
  0059a	77 03		 ja	 SHORT $LN41@Process
  0059c	0f 28 c8	 movaps	 xmm1, xmm0
$LN41@Process:
  0059f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?s_fAveRenderTime@?EL@??Process@CPythonApplication@@QAE_NXZ@4MA
  005a7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42c76666
  005af	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3e99999a
  005b7	f3 0f 58 c8	 addss	 xmm1, xmm0

; 823  : 
; 824  : 
; 825  : 						float fFar=25600.0f;
; 826  : 						float fNear=MIN_FOG;
; 827  : 						double dbAvePow=double(1000.0f/s_fAveRenderTime);

  005bb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@447a0000
  005c3	f3 0f 5e cb	 divss	 xmm1, xmm3
  005c7	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR ?MIN_FOG@@3MA
  005cf	f3 0f 5e c1	 divss	 xmm0, xmm1
  005d3	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR ?s_fAveRenderTime@?EL@??Process@CPythonApplication@@QAE_NXZ@4MA, xmm1
  005db	0f 5a c8	 cvtps2pd xmm1, xmm0

; 828  : 						double dbMaxPow=60.0;
; 829  : 						float fDistance=max(fNear+(fFar-fNear)*(dbAvePow)/dbMaxPow, fNear);

  005de	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@46c80000
  005e6	f3 0f 5c c3	 subss	 xmm0, xmm3
  005ea	0f 5a d0	 cvtps2pd xmm2, xmm0
  005ed	0f 5a c3	 cvtps2pd xmm0, xmm3
  005f0	f2 0f 59 d1	 mulsd	 xmm2, xmm1
  005f4	f2 0f 5e 15 00
	00 00 00	 divsd	 xmm2, QWORD PTR __real@404e000000000000
  005fc	f2 0f 58 d0	 addsd	 xmm2, xmm0
  00600	0f 5a c3	 cvtps2pd xmm0, xmm3
  00603	66 0f 2f d0	 comisd	 xmm2, xmm0
  00607	77 03		 ja	 SHORT $LN43@Process
  00609	0f 5a d3	 cvtps2pd xmm2, xmm3
$LN43@Process:
  0060c	66 0f 5a d2	 cvtpd2ps xmm2, xmm2

; 830  : 						m_pyBackground.SetViewDistanceSet(0, fDistance);
; 831  : 					}
; 832  : 					//   
; 833  : 					else

  00610	eb 11		 jmp	 SHORT $LN60@Process
$LN4@Process:
  00612	66 0f 6e d0	 movd	 xmm2, eax

; 834  : 					{
; 835  : 						m_pyBackground.SetViewDistanceSet(0, float(m_iForceSightRange));

  00616	0f 5b d2	 cvtdq2ps xmm2, xmm2

; 836  : 					}
; 837  : 				}
; 838  : 				else

  00619	eb 08		 jmp	 SHORT $LN60@Process
$LN18@Process:

; 839  : 				{
; 840  : 					// 10000       
; 841  : 					m_pyBackground.SetViewDistanceSet(0, 25600.0f);

  0061b	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@46c80000
$LN60@Process:
  00623	6a 00		 push	 0
  00625	8d 8f 74 bb 01
	00		 lea	 ecx, DWORD PTR [edi+113524]
  0062b	e8 00 00 00 00	 call	 ?SetViewDistanceSet@CPythonBackground@@QAEXHM@Z ; CPythonBackground::SetViewDistanceSet

; 842  : 				}
; 843  : 
; 844  : 				++s_dwRenderFrameCount;

  00630	ff 05 00 00 00
	00		 inc	 DWORD PTR ?s_dwRenderFrameCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA
$LN21@Process:

; 845  : 			}
; 846  : 		}
; 847  : 	}
; 848  : 
; 849  : 	int rest = s_uiNextFrameTime - ELTimer_GetMSec();

  00636	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0063b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_uiNextFrameTime@?4??Process@CPythonApplication@@QAE_NXZ@4IA
  00641	2b c8		 sub	 ecx, eax

; 850  : 
; 851  : 	if (rest > 0 && !bCurrentLateUpdate )

  00643	85 c9		 test	 ecx, ecx
  00645	7e 14		 jle	 SHORT $LN1@Process
  00647	83 7c 24 14 00	 cmp	 DWORD PTR _bCurrentLateUpdate$1$[esp+60], 0
  0064c	75 0d		 jne	 SHORT $LN1@Process

; 852  : 	{
; 853  : 		s_uiLoad -= rest;	//    ..

  0064e	29 0d 00 00 00
	00		 sub	 DWORD PTR ?s_uiLoad@?1??Process@CPythonApplication@@QAE_NXZ@4IA, ecx

; 854  : 		Sleep(rest);

  00654	51		 push	 ecx
  00655	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN1@Process:

; 855  : 	}	
; 856  : 
; 857  : 	++s_dwUpdateFrameCount;

  0065b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?s_dwUpdateFrameCount@?1??Process@CPythonApplication@@QAE_NXZ@4KA

; 858  : 
; 859  : 	s_uiLoad += ELTimer_GetMSec() - dwStart;

  00661	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00666	2b 44 24 20	 sub	 eax, DWORD PTR _dwStart$1$[esp+60]
  0066a	01 05 00 00 00
	00		 add	 DWORD PTR ?s_uiLoad@?1??Process@CPythonApplication@@QAE_NXZ@4IA, eax

; 860  : 	//m_Profiler.ProfileByScreen();	
; 861  : 	return true;

  00670	b0 01		 mov	 al, 1

; 862  : }

  00672	8b 4c 24 30	 mov	 ecx, DWORD PTR __$EHRec$[esp+60]
  00676	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0067d	59		 pop	 ecx
  0067e	5f		 pop	 edi
  0067f	5e		 pop	 esi
  00680	5b		 pop	 ebx
  00681	8b e5		 mov	 esp, ebp
  00683	5d		 pop	 ebp
  00684	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Process@CPythonApplication@@QAE_NXZ$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA, eax
  0000d	c3		 ret	 0
__unwindfunclet$?Process@CPythonApplication@@QAE_NXZ$1:
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA
  00013	83 e0 fd	 and	 eax, -3			; fffffffdH
  00016	a3 00 00 00 00	 mov	 DWORD PTR ?$S3@?1??Process@CPythonApplication@@QAE_NXZ@4IA, eax
  0001b	c3		 ret	 0
__ehhandler$?Process@CPythonApplication@@QAE_NXZ:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 d4	 lea	 eax, DWORD PTR [edx-44]
  00023	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Process@CPythonApplication@@QAE_NXZ
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Process@CPythonApplication@@QAE_NXZ ENDP		; CPythonApplication::Process
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?SetMouseHandler@CPythonApplication@@QAEXPAU_object@@@Z
_TEXT	SEGMENT
_poMouseHandler$ = 8					; size = 4
?SetMouseHandler@CPythonApplication@@QAEXPAU_object@@@Z PROC ; CPythonApplication::SetMouseHandler, COMDAT
; _this$ = ecx

; 872  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 873  : 	m_poMouseHandler = poMouseHandler;

  00003	8b 45 08	 mov	 eax, DWORD PTR _poMouseHandler$[ebp]
  00006	89 81 60 ff 01
	00		 mov	 DWORD PTR [ecx+130912], eax

; 874  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetMouseHandler@CPythonApplication@@QAEXPAU_object@@@Z ENDP ; CPythonApplication::SetMouseHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?CreateDevice@CPythonApplication@@QAE_NHHHHH@Z
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_Windowed$ = 16						; size = 4
_bit$ = 20						; size = 4
_frequency$ = 24					; size = 4
?CreateDevice@CPythonApplication@@QAE_NHHHHH@Z PROC	; CPythonApplication::CreateDevice, COMDAT
; _this$ = ecx

; 902  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 903  : 	int iRet;
; 904  : 
; 905  : 	m_grpDevice.InitBackBufferCount(2);

  00007	6a 02		 push	 2
  00009	8d 8e 54 d8 01
	00		 lea	 ecx, DWORD PTR [esi+120916]
  0000f	e8 00 00 00 00	 call	 ?InitBackBufferCount@CGraphicDevice@@QAEXI@Z ; CGraphicDevice::InitBackBufferCount

; 906  : 	m_grpDevice.RegisterWarningString(CGraphicDevice::CREATE_BAD_DRIVER, ApplicationStringTable_GetStringz(IDS_WARN_BAD_DRIVER, "WARN_BAD_DRIVER"));

  00014	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BA@NOHKOOIE@WARN_BAD_DRIVER?$AA@
  00019	b9 03 00 00 00	 mov	 ecx, 3
  0001e	e8 00 00 00 00	 call	 ?ApplicationStringTable_GetStringz@@YAPBDKPBD@Z ; ApplicationStringTable_GetStringz
  00023	50		 push	 eax
  00024	68 00 02 00 00	 push	 512			; 00000200H
  00029	8d 8e 54 d8 01
	00		 lea	 ecx, DWORD PTR [esi+120916]
  0002f	e8 00 00 00 00	 call	 ?RegisterWarningString@CGraphicDevice@@QAEXIPBD@Z ; CGraphicDevice::RegisterWarningString

; 907  : 	m_grpDevice.RegisterWarningString(CGraphicDevice::CREATE_NO_TNL, ApplicationStringTable_GetStringz(IDS_WARN_NO_TNL, "WARN_NO_TNL"));

  00034	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@MOGGPFAH@WARN_NO_TNL?$AA@
  00039	b9 04 00 00 00	 mov	 ecx, 4
  0003e	e8 00 00 00 00	 call	 ?ApplicationStringTable_GetStringz@@YAPBDKPBD@Z ; ApplicationStringTable_GetStringz
  00043	50		 push	 eax
  00044	68 00 01 00 00	 push	 256			; 00000100H
  00049	8d 8e 54 d8 01
	00		 lea	 ecx, DWORD PTR [esi+120916]
  0004f	e8 00 00 00 00	 call	 ?RegisterWarningString@CGraphicDevice@@QAEXIPBD@Z ; CGraphicDevice::RegisterWarningString

; 908  : 
; 909  : 	iRet = m_grpDevice.Create(GetWindowHandle(), width, height, Windowed ? true : false, bit,frequency);

  00054	ff 75 18	 push	 DWORD PTR _frequency$[ebp]
  00057	83 7d 10 00	 cmp	 DWORD PTR _Windowed$[ebp], 0
  0005b	8b ce		 mov	 ecx, esi
  0005d	ff 75 14	 push	 DWORD PTR _bit$[ebp]
  00060	0f 95 c0	 setne	 al
  00063	0f b6 c0	 movzx	 eax, al
  00066	50		 push	 eax
  00067	ff 75 0c	 push	 DWORD PTR _height$[ebp]
  0006a	ff 75 08	 push	 DWORD PTR _width$[ebp]
  0006d	e8 00 00 00 00	 call	 ?GetWindowHandle@CMSWindow@@QAEPAUHWND__@@XZ ; CMSWindow::GetWindowHandle
  00072	50		 push	 eax
  00073	8d 8e 54 d8 01
	00		 lea	 ecx, DWORD PTR [esi+120916]
  00079	e8 00 00 00 00	 call	 ?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z ; CGraphicDevice::Create
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 910  : 
; 911  : 	switch (iRet)

  00080	83 f8 10	 cmp	 eax, 16			; 00000010H
  00083	0f 8f b3 00 00
	00		 jg	 $LN16@CreateDevi
  00089	0f 84 88 00 00
	00		 je	 $LN7@CreateDevi
  0008f	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00092	83 f9 07	 cmp	 ecx, 7
  00095	0f 87 e4 00 00
	00		 ja	 $LN3@CreateDevi
  0009b	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN20@CreateDevi[ecx*4]
$LN11@CreateDevi:

; 912  : 	{
; 913  : 	case CGraphicDevice::CREATE_OK:
; 914  : 		return true;

  000a2	b0 01		 mov	 al, 1

; 976  : 		return false;
; 977  : 	}
; 978  : }

  000a4	5d		 pop	 ebp
  000a5	c2 14 00	 ret	 20			; 00000014H
$LN8@CreateDevi:

; 923  : 		return false;
; 924  : 
; 925  : 	case CGraphicDevice::CREATE_NO_DIRECTX:
; 926  : 		//PyErr_SetString(PyExc_RuntimeError, "DirectX 8.1 or greater required to run game");
; 927  : 		SET_EXCEPTION(CREATE_NO_DIRECTX);

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NKAKBNDM@CREATE_NO_DIRECTX?$AA@
  000b2	ff 30		 push	 DWORD PTR [eax]
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString

; 928  : 		TraceError("CreateDevice: DirectX 8.1 or greater required to run game");

  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@GACPAJMM@CreateDevice?3?5DirectX?58?41?5or?5gre@

; 939  : 		TraceError("CreateDevice: Change the screen format");

  000bf	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 940  : 		return false;

  000c7	32 c0		 xor	 al, al

; 976  : 		return false;
; 977  : 	}
; 978  : }

  000c9	5d		 pop	 ebp
  000ca	c2 14 00	 ret	 20			; 00000014H
$LN5@CreateDevi:

; 941  : 
; 942  : 		/*case CGraphicDevice::CREATE_GET_ADAPTER_DISPLAY_MODE:
; 943  : 		//PyErr_SetString(PyExc_RuntimeError, "GetAdapterDisplayMode failed");
; 944  : 		SET_EXCEPTION(CREATE_GET_ADAPTER_DISPLAY_MODE);
; 945  : 		TraceError("CreateDevice: GetAdapterDisplayMode failed");
; 946  : 		return false;*/
; 947  : 
; 948  : 	case CGraphicDevice::CREATE_GET_DEVICE_CAPS:
; 949  : 		PyErr_SetString(PyExc_RuntimeError, "GetDevCaps failed");

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@IMJEDJEA@GetDevCaps?5failed?$AA@
  000d7	ff 30		 push	 DWORD PTR [eax]
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString

; 950  : 		TraceError("CreateDevice: GetDevCaps failed");

  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DLHDILBB@CreateDevice?3?5GetDevCaps?5failed?$AA@
  000e4	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ec	32 c0		 xor	 al, al

; 976  : 		return false;
; 977  : 	}
; 978  : }

  000ee	5d		 pop	 ebp
  000ef	c2 14 00	 ret	 20			; 00000014H
$LN4@CreateDevi:

; 951  : 		return false;
; 952  : 
; 953  : 	case CGraphicDevice::CREATE_GET_DEVICE_CAPS2:
; 954  : 		PyErr_SetString(PyExc_RuntimeError, "GetDevCaps2 failed");

  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IHNLMMLJ@GetDevCaps2?5failed?$AA@
  000fc	ff 30		 push	 DWORD PTR [eax]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString

; 955  : 		TraceError("CreateDevice: GetDevCaps2 failed");

  00104	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JLAAEKGJ@CreateDevice?3?5GetDevCaps2?5failed@
  00109	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	32 c0		 xor	 al, al

; 976  : 		return false;
; 977  : 	}
; 978  : }

  00113	5d		 pop	 ebp
  00114	c2 14 00	 ret	 20			; 00000014H
$LN7@CreateDevi:

; 929  : 		return false;
; 930  : 
; 931  : 	case CGraphicDevice::CREATE_DEVICE:
; 932  : 		//PyErr_SetString(PyExc_RuntimeError, "GraphicDevice create failed");
; 933  : 		SET_EXCEPTION(CREATE_DEVICE);

  00117	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CMPMDOEH@CREATE_DEVICE?$AA@
  00121	ff 30		 push	 DWORD PTR [eax]
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString

; 934  : 		TraceError("CreateDevice: GraphicDevice create failed");

  00129	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KMPBIDGP@CreateDevice?3?5GraphicDevice?5crea@

; 939  : 		TraceError("CreateDevice: Change the screen format");

  0012e	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH

; 940  : 		return false;

  00136	32 c0		 xor	 al, al

; 976  : 		return false;
; 977  : 	}
; 978  : }

  00138	5d		 pop	 ebp
  00139	c2 14 00	 ret	 20			; 00000014H
$LN16@CreateDevi:

; 910  : 
; 911  : 	switch (iRet)

  0013c	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00141	7f 35		 jg	 SHORT $LN17@CreateDevi
  00143	74 0e		 je	 SHORT $LN9@CreateDevi
  00145	83 f8 20	 cmp	 eax, 32			; 00000020H
  00148	0f 84 54 ff ff
	ff		 je	 $LN11@CreateDevi
  0014e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00151	75 2c		 jne	 SHORT $LN3@CreateDevi
$LN9@CreateDevi:

; 915  : 
; 916  : 	case CGraphicDevice::CREATE_REFRESHRATE:
; 917  : 		return true;
; 918  : 
; 919  : 	case CGraphicDevice::CREATE_ENUM:
; 920  : 	case CGraphicDevice::CREATE_DETECT:
; 921  : 		SET_EXCEPTION(CREATE_NO_APPROPRIATE_DEVICE);

  00153	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@OAKBEJJN@CREATE_NO_APPROPRIATE_DEVICE?$AA@
  0015d	ff 30		 push	 DWORD PTR [eax]
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString

; 922  : 		TraceError("CreateDevice: Enum & Detect failed");

  00165	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GGLEAAKE@CreateDevice?3?5Enum?5?$CG?5Detect?5fail@

; 939  : 		TraceError("CreateDevice: Change the screen format");

  0016a	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0016f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 940  : 		return false;

  00172	32 c0		 xor	 al, al

; 976  : 		return false;
; 977  : 	}
; 978  : }

  00174	5d		 pop	 ebp
  00175	c2 14 00	 ret	 20			; 00000014H
$LN17@CreateDevi:

; 910  : 
; 911  : 	switch (iRet)

  00178	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0017d	74 40		 je	 SHORT $LN6@CreateDevi
$LN3@CreateDevi:

; 956  : 		return false;
; 957  : 
; 958  : 	default:
; 959  : 		if (iRet & CGraphicDevice::CREATE_OK)

  0017f	a8 01		 test	 al, 1
  00181	74 17		 je	 SHORT $LN2@CreateDevi

; 960  : 		{
; 961  : 			//if (iRet & CGraphicDevice::CREATE_BAD_DRIVER)
; 962  : 			//{
; 963  : 			//	LogBox(ApplicationStringTable_GetStringz(IDS_WARN_BAD_DRIVER), NULL, GetWindowHandle());
; 964  : 			//}
; 965  : 			if (iRet & CGraphicDevice::CREATE_NO_TNL)

  00183	a9 00 01 00 00	 test	 eax, 256		; 00000100H
  00188	74 0a		 je	 SHORT $LN1@CreateDevi

; 966  : 			{
; 967  : 				CGrannyLODController::SetMinLODMode(true);

  0018a	6a 01		 push	 1
  0018c	e8 00 00 00 00	 call	 ?SetMinLODMode@CGrannyLODController@@SAX_N@Z ; CGrannyLODController::SetMinLODMode
  00191	83 c4 04	 add	 esp, 4
$LN1@CreateDevi:

; 968  : 				//LogBox(ApplicationStringTable_GetStringz(IDS_WARN_NO_TNL), NULL, GetWindowHandle());
; 969  : 			}
; 970  : 			return true;

  00194	b0 01		 mov	 al, 1

; 976  : 		return false;
; 977  : 	}
; 978  : }

  00196	5d		 pop	 ebp
  00197	c2 14 00	 ret	 20			; 00000014H
$LN2@CreateDevi:

; 971  : 		}
; 972  : 
; 973  : 		//PyErr_SetString(PyExc_RuntimeError, "Unknown Error!");
; 974  : 		SET_EXCEPTION(UNKNOWN_ERROR);

  0019a	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BAEJJDKB@UNKNOWN_ERROR?$AA@
  001a4	ff 30		 push	 DWORD PTR [eax]
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString

; 975  : 		TraceError("CreateDevice: Unknown Error!");

  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JAHEKIGK@CreateDevice?3?5Unknown?5Error?$CB?$AA@
  001b1	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b9	32 c0		 xor	 al, al

; 976  : 		return false;
; 977  : 	}
; 978  : }

  001bb	5d		 pop	 ebp
  001bc	c2 14 00	 ret	 20			; 00000014H
$LN6@CreateDevi:

; 935  : 		return false;
; 936  : 
; 937  : 	case CGraphicDevice::CREATE_FORMAT:
; 938  : 		SET_EXCEPTION(CREATE_FORMAT);

  001bf	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  001c4	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DAEHMKOB@CREATE_FORMAT?$AA@
  001c9	ff 30		 push	 DWORD PTR [eax]
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString

; 939  : 		TraceError("CreateDevice: Change the screen format");

  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DEBFNBPL@CreateDevice?3?5Change?5the?5screen?5@
  001d6	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 940  : 		return false;

  001de	32 c0		 xor	 al, al

; 976  : 		return false;
; 977  : 	}
; 978  : }

  001e0	5d		 pop	 ebp
  001e1	c2 14 00	 ret	 20			; 00000014H
$LN20@CreateDevi:
  001e4	00 00 00 00	 DD	 $LN11@CreateDevi
  001e8	00 00 00 00	 DD	 $LN8@CreateDevi
  001ec	00 00 00 00	 DD	 $LN3@CreateDevi
  001f0	00 00 00 00	 DD	 $LN5@CreateDevi
  001f4	00 00 00 00	 DD	 $LN3@CreateDevi
  001f8	00 00 00 00	 DD	 $LN3@CreateDevi
  001fc	00 00 00 00	 DD	 $LN3@CreateDevi
  00200	00 00 00 00	 DD	 $LN4@CreateDevi
?CreateDevice@CPythonApplication@@QAE_NHHHHH@Z ENDP	; CPythonApplication::CreateDevice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?Loop@CPythonApplication@@QAEXXZ
_TEXT	SEGMENT
?Loop@CPythonApplication@@QAEXXZ PROC			; CPythonApplication::Loop, COMDAT
; _this$ = ecx

; 981  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL6@Loop:

; 982  : 	while (1)
; 983  : 	{	
; 984  : 		if (IsMessage())

  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?IsMessage@CMSApplication@@QAE_NXZ ; CMSApplication::IsMessage

; 985  : 		{
; 986  : 			if (!MessageProcess())

  00017	8b ce		 mov	 ecx, esi
  00019	84 c0		 test	 al, al
  0001b	74 0e		 je	 SHORT $LN4@Loop
  0001d	e8 00 00 00 00	 call	 ?MessageProcess@CMSApplication@@QAE_NXZ ; CMSApplication::MessageProcess
  00022	84 c0		 test	 al, al
  00024	75 ea		 jne	 SHORT $LL6@Loop
$LN11@Loop:

; 997  : }

  00026	5e		 pop	 esi
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN4@Loop:

; 987  : 				break;
; 988  : 		}
; 989  : 		else
; 990  : 		{
; 991  : 			if (!Process())

  0002b	e8 00 00 00 00	 call	 ?Process@CPythonApplication@@QAE_NXZ ; CPythonApplication::Process
  00030	84 c0		 test	 al, al
  00032	74 f2		 je	 SHORT $LN11@Loop

; 992  : 				break;
; 993  : 
; 994  : 			m_dwLastIdleTime=ELTimer_GetMSec();

  00034	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00039	89 86 8c ff 01
	00		 mov	 DWORD PTR [esi+130956], eax

; 995  : 		}
; 996  : 	}

  0003f	eb cf		 jmp	 SHORT $LL6@Loop
?Loop@CPythonApplication@@QAEXXZ ENDP			; CPythonApplication::Loop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?LoadLocaleData@@YA_NPBD@Z
_TEXT	SEGMENT
_rkSkillMgr$1$ = -2064					; size = 4
_rkNPCMgr$1$ = -2060					; size = 4
_szMobProto$ = -2056					; size = 256
_szItemProto$ = -1800					; size = 256
_szInsultList$ = -1544					; size = 256
_szEmpireTextConvFile$1 = -1288				; size = 256
_szItemDesc$ = -1032					; size = 256
_szItemList$ = -776					; size = 256
_szSkillDescFileName$ = -520				; size = 256
_szSkillTableFileName$ = -264				; size = 256
__$ArrayPad$ = -4					; size = 4
?LoadLocaleData@@YA_NPBD@Z PROC				; LoadLocaleData, COMDAT
; _localePath$ = ecx

; 1001 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 14 08 00
	00		 sub	 esp, 2068		; 00000814H
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 10 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2068], eax
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8b f9		 mov	 edi, ecx

; 1002 : 	NANOBEGIN

  0001f	eb		 DB	 -21			; ffffffebH
  00020	03		 DB	 3
  00021	d6		 DB	 -42			; ffffffd6H
  00022	d7		 DB	 -41			; ffffffd7H
  00023	01		 DB	 1

; 1003 : 		CPythonNonPlayer&	rkNPCMgr	= CPythonNonPlayer::Instance();

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNonPlayer@@@@0PAVCPythonNonPlayer@@A ; CSingleton<CPythonNonPlayer>::ms_singleton

; 1004 : 	CItemManager&		rkItemMgr	= CItemManager::Instance();	

  00029	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton

; 1005 : 	CPythonSkill&		rkSkillMgr	= CPythonSkill::Instance();
; 1006 : 	CPythonNetworkStream& rkNetStream = CPythonNetworkStream::Instance();

  0002f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton

; 1007 : 
; 1008 : 	char szItemList[256];
; 1009 : 	char szItemProto[256];
; 1010 : 	char szItemDesc[256];	
; 1011 : 	char szMobProto[256];
; 1012 : 	char szSkillDescFileName[256];
; 1013 : 	char szSkillTableFileName[256];
; 1014 : 	char szInsultList[256];
; 1015 : 	snprintf(szItemList,	sizeof(szItemList) ,	"%s/item_list.txt",	localePath);		

  00035	57		 push	 edi
  00036	89 44 24 18	 mov	 DWORD PTR _rkNPCMgr$1$[esp+2084], eax
  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonSkill@@@@0PAVCPythonSkill@@A ; CSingleton<CPythonSkill>::ms_singleton
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EOELDOLA@?$CFs?1item_list?4txt?$AA@
  00044	89 44 24 18	 mov	 DWORD PTR _rkSkillMgr$1$[esp+2088], eax
  00048	8d 84 24 20 05
	00 00		 lea	 eax, DWORD PTR _szItemList$[esp+2088]
  0004f	68 00 01 00 00	 push	 256			; 00000100H
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 __snprintf

; 1016 : 	snprintf(szItemProto,	sizeof(szItemProto),	"%s/item_proto",	localePath);

  0005a	57		 push	 edi
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MEMEPBB@?$CFs?1item_proto?$AA@
  00060	8d 84 24 30 01
	00 00		 lea	 eax, DWORD PTR _szItemProto$[esp+2104]
  00067	68 00 01 00 00	 push	 256			; 00000100H
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 __snprintf

; 1017 : 	snprintf(szItemDesc,	sizeof(szItemDesc),	"%s/itemdesc.txt",	localePath);	

  00072	57		 push	 edi
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BIDKFLDM@?$CFs?1itemdesc?4txt?$AA@
  00078	8d 84 24 40 04
	00 00		 lea	 eax, DWORD PTR _szItemDesc$[esp+2120]
  0007f	68 00 01 00 00	 push	 256			; 00000100H
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 __snprintf

; 1018 : 	snprintf(szMobProto,	sizeof(szMobProto),	"%s/mob_proto",		localePath);	

  0008a	57		 push	 edi
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KCBCHIHM@?$CFs?1mob_proto?$AA@
  00090	8d 44 24 50	 lea	 eax, DWORD PTR _szMobProto$[esp+2136]
  00094	68 00 01 00 00	 push	 256			; 00000100H
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 __snprintf
  0009f	83 c4 40	 add	 esp, 64			; 00000040H

; 1019 : 	snprintf(szSkillDescFileName, sizeof(szSkillDescFileName),	"%s/SkillDesc.txt", localePath);

  000a2	8d 84 24 18 06
	00 00		 lea	 eax, DWORD PTR _szSkillDescFileName$[esp+2080]
  000a9	57		 push	 edi
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JDMIHPNN@?$CFs?1SkillDesc?4txt?$AA@
  000af	68 00 01 00 00	 push	 256			; 00000100H
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 __snprintf

; 1020 : 	snprintf(szSkillTableFileName, sizeof(szSkillTableFileName),	"%s/SkillTable.txt", localePath);	

  000ba	57		 push	 edi
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NLEJCAEF@?$CFs?1SkillTable?4txt?$AA@
  000c0	8d 84 24 30 07
	00 00		 lea	 eax, DWORD PTR _szSkillTableFileName$[esp+2104]
  000c7	68 00 01 00 00	 push	 256			; 00000100H
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 __snprintf

; 1021 : 	snprintf(szInsultList,	sizeof(szInsultList),	"%s/insult.txt", localePath);

  000d2	57		 push	 edi
  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JEIJHCCG@?$CFs?1insult?4txt?$AA@
  000d8	8d 84 24 40 02
	00 00		 lea	 eax, DWORD PTR _szInsultList$[esp+2120]
  000df	68 00 01 00 00	 push	 256			; 00000100H
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 __snprintf

; 1022 : 
; 1023 : 	rkNPCMgr.Destroy();

  000ea	8b 4c 24 44	 mov	 ecx, DWORD PTR _rkNPCMgr$1$[esp+2128]
  000ee	83 c4 30	 add	 esp, 48			; 00000030H
  000f1	e8 00 00 00 00	 call	 ?Destroy@CPythonNonPlayer@@QAEXXZ ; CPythonNonPlayer::Destroy

; 1024 : 	rkItemMgr.Destroy();	

  000f6	8b ce		 mov	 ecx, esi
  000f8	e8 00 00 00 00	 call	 ?Destroy@CItemManager@@QAEXXZ ; CItemManager::Destroy

; 1025 : 	rkSkillMgr.Destroy();

  000fd	8b 4c 24 10	 mov	 ecx, DWORD PTR _rkSkillMgr$1$[esp+2080]
  00101	e8 00 00 00 00	 call	 ?Destroy@CPythonSkill@@QAEXXZ ; CPythonSkill::Destroy

; 1026 : 
; 1027 : 	if (!rkItemMgr.LoadItemList(szItemList))

  00106	8d 84 24 18 05
	00 00		 lea	 eax, DWORD PTR _szItemList$[esp+2080]
  0010d	8b ce		 mov	 ecx, esi
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ?LoadItemList@CItemManager@@QAE_NPBD@Z ; CItemManager::LoadItemList
  00115	84 c0		 test	 al, al
  00117	75 15		 jne	 SHORT $LN12@LoadLocale

; 1028 : 	{
; 1029 : 		TraceError("LoadLocaleData - LoadItemList(%s) Error", szItemList);

  00119	8d 84 24 18 05
	00 00		 lea	 eax, DWORD PTR _szItemList$[esp+2080]
  00120	50		 push	 eax
  00121	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@MGBDCDJE@LoadLocaleData?5?9?5LoadItemList?$CI?$CFs@
  00126	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0012b	83 c4 08	 add	 esp, 8
$LN12@LoadLocale:

; 1030 : 	}	
; 1031 : 
; 1032 : 	if (!rkItemMgr.LoadItemTable(szItemProto))

  0012e	8d 84 24 18 01
	00 00		 lea	 eax, DWORD PTR _szItemProto$[esp+2080]
  00135	8b ce		 mov	 ecx, esi
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ?LoadItemTable@CItemManager@@QAE_NPBD@Z ; CItemManager::LoadItemTable
  0013d	84 c0		 test	 al, al
  0013f	75 2c		 jne	 SHORT $LN11@LoadLocale

; 1033 : 	{
; 1034 : 		TraceError("LoadLocaleData - LoadItemProto(%s) Error", szItemProto);

  00141	8d 84 24 18 01
	00 00		 lea	 eax, DWORD PTR _szItemProto$[esp+2080]
  00148	50		 push	 eax
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@MIFDPICO@LoadLocaleData?5?9?5LoadItemProto?$CI?$CF@
  0014e	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00153	83 c4 08	 add	 esp, 8

; 1035 : 		return false;

  00156	32 c0		 xor	 al, al

; 1080 : 		return true;
; 1081 : }

  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx
  0015b	8b 8c 24 10 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2068]
  00162	33 cc		 xor	 ecx, esp
  00164	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
$LN11@LoadLocale:

; 1036 : 	}
; 1037 : 
; 1038 : 	if (!rkItemMgr.LoadItemDesc(szItemDesc))

  0016d	8d 84 24 18 04
	00 00		 lea	 eax, DWORD PTR _szItemDesc$[esp+2080]
  00174	8b ce		 mov	 ecx, esi
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 ?LoadItemDesc@CItemManager@@QAE_NPBD@Z ; CItemManager::LoadItemDesc
  0017c	84 c0		 test	 al, al
  0017e	75 15		 jne	 SHORT $LN10@LoadLocale

; 1039 : 	{
; 1040 : 		Tracenf("LoadLocaleData - LoadItemDesc(%s) Error", szItemDesc);	

  00180	8d 84 24 18 04
	00 00		 lea	 eax, DWORD PTR _szItemDesc$[esp+2080]
  00187	50		 push	 eax
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FLOPHKEN@LoadLocaleData?5?9?5LoadItemDesc?$CI?$CFs@
  0018d	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00192	83 c4 08	 add	 esp, 8
$LN10@LoadLocale:

; 1041 : 	}
; 1042 : 
; 1043 : 	if (!rkNPCMgr.LoadNonPlayerData(szMobProto))

  00195	8b 4c 24 14	 mov	 ecx, DWORD PTR _rkNPCMgr$1$[esp+2080]
  00199	8d 44 24 18	 lea	 eax, DWORD PTR _szMobProto$[esp+2080]
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 ?LoadNonPlayerData@CPythonNonPlayer@@QAE_NPBD@Z ; CPythonNonPlayer::LoadNonPlayerData
  001a3	84 c0		 test	 al, al
  001a5	75 29		 jne	 SHORT $LN9@LoadLocale

; 1044 : 	{
; 1045 : 		TraceError("LoadLocaleData - LoadMobProto(%s) Error", szMobProto);

  001a7	8d 44 24 18	 lea	 eax, DWORD PTR _szMobProto$[esp+2080]
  001ab	50		 push	 eax
  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PNCAMHEJ@LoadLocaleData?5?9?5LoadMobProto?$CI?$CFs@
  001b1	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001b6	83 c4 08	 add	 esp, 8

; 1046 : 		return false;

  001b9	32 c0		 xor	 al, al

; 1080 : 		return true;
; 1081 : }

  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5b		 pop	 ebx
  001be	8b 8c 24 10 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2068]
  001c5	33 cc		 xor	 ecx, esp
  001c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001cc	8b e5		 mov	 esp, ebp
  001ce	5d		 pop	 ebp
  001cf	c3		 ret	 0
$LN9@LoadLocale:

; 1047 : 	}
; 1048 : 
; 1049 : 	if (!rkSkillMgr.RegisterSkillDesc(szSkillDescFileName))

  001d0	8b 74 24 10	 mov	 esi, DWORD PTR _rkSkillMgr$1$[esp+2080]
  001d4	8d 84 24 18 06
	00 00		 lea	 eax, DWORD PTR _szSkillDescFileName$[esp+2080]
  001db	50		 push	 eax
  001dc	8b ce		 mov	 ecx, esi
  001de	e8 00 00 00 00	 call	 ?RegisterSkillDesc@CPythonSkill@@QAE_NPBD@Z ; CPythonSkill::RegisterSkillDesc
  001e3	84 c0		 test	 al, al
  001e5	75 29		 jne	 SHORT $LN8@LoadLocale

; 1050 : 	{
; 1051 : 		TraceError("LoadLocaleData - RegisterSkillDesc(%s) Error", szMobProto);

  001e7	8d 44 24 18	 lea	 eax, DWORD PTR _szMobProto$[esp+2080]
  001eb	50		 push	 eax
  001ec	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@NIKOAAJF@LoadLocaleData?5?9?5RegisterSkillDe@
  001f1	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001f6	83 c4 08	 add	 esp, 8

; 1052 : 		return false;

  001f9	32 c0		 xor	 al, al

; 1080 : 		return true;
; 1081 : }

  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
  001fe	8b 8c 24 10 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2068]
  00205	33 cc		 xor	 ecx, esp
  00207	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020c	8b e5		 mov	 esp, ebp
  0020e	5d		 pop	 ebp
  0020f	c3		 ret	 0
$LN8@LoadLocale:

; 1053 : 	}
; 1054 : 
; 1055 : 	if (!rkSkillMgr.RegisterSkillTable(szSkillTableFileName))

  00210	8d 84 24 18 07
	00 00		 lea	 eax, DWORD PTR _szSkillTableFileName$[esp+2080]
  00217	8b ce		 mov	 ecx, esi
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 ?RegisterSkillTable@CPythonSkill@@QAE_NPBD@Z ; CPythonSkill::RegisterSkillTable
  0021f	84 c0		 test	 al, al
  00221	75 29		 jne	 SHORT $LN7@LoadLocale

; 1056 : 	{
; 1057 : 		TraceError("LoadLocaleData - RegisterSkillTable(%s) Error", szMobProto);

  00223	8d 44 24 18	 lea	 eax, DWORD PTR _szMobProto$[esp+2080]
  00227	50		 push	 eax
  00228	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@HCDPLHIO@LoadLocaleData?5?9?5RegisterSkillTa@
  0022d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00232	83 c4 08	 add	 esp, 8

; 1058 : 		return false;

  00235	32 c0		 xor	 al, al

; 1080 : 		return true;
; 1081 : }

  00237	5f		 pop	 edi
  00238	5e		 pop	 esi
  00239	5b		 pop	 ebx
  0023a	8b 8c 24 10 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2068]
  00241	33 cc		 xor	 ecx, esp
  00243	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00248	8b e5		 mov	 esp, ebp
  0024a	5d		 pop	 ebp
  0024b	c3		 ret	 0
$LN7@LoadLocale:

; 1059 : 	}
; 1060 : 
; 1061 : 	if (!rkNetStream.LoadInsultList(szInsultList))

  0024c	8d 84 24 18 02
	00 00		 lea	 eax, DWORD PTR _szInsultList$[esp+2080]
  00253	8b cb		 mov	 ecx, ebx
  00255	50		 push	 eax
  00256	e8 00 00 00 00	 call	 ?LoadInsultList@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::LoadInsultList
  0025b	84 c0		 test	 al, al
  0025d	75 15		 jne	 SHORT $LN6@LoadLocale

; 1062 : 	{
; 1063 : 		Tracenf("CPythonApplication - CPythonNetworkStream::LoadInsultList(%s)", szInsultList);				

  0025f	8d 84 24 18 02
	00 00		 lea	 eax, DWORD PTR _szInsultList$[esp+2080]
  00266	50		 push	 eax
  00267	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@PNDPPMDH@CPythonApplication?5?9?5CPythonNetw@
  0026c	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00271	83 c4 08	 add	 esp, 8
$LN6@LoadLocale:

; 1064 : 	}
; 1065 : 
; 1066 : 	if (LocaleService_IsYMIR())

  00274	e8 00 00 00 00	 call	 ?LocaleService_IsYMIR@@YA_NXZ ; LocaleService_IsYMIR
  00279	84 c0		 test	 al, al
  0027b	74 4c		 je	 SHORT $LN2@LoadLocale

; 1067 : 	{	
; 1068 : 		char szEmpireTextConvFile[256];
; 1069 : 		for (DWORD dwEmpireID=1; dwEmpireID<=3; ++dwEmpireID)

  0027d	be 01 00 00 00	 mov	 esi, 1
$LL4@LoadLocale:

; 1070 : 		{			
; 1071 : 			sprintf(szEmpireTextConvFile, "%s/lang%d.cvt", localePath, dwEmpireID);

  00282	56		 push	 esi
  00283	57		 push	 edi
  00284	8d 84 24 20 03
	00 00		 lea	 eax, DWORD PTR _szEmpireTextConvFile$1[esp+2088]
  0028b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GCNBGGIE@?$CFs?1lang?$CFd?4cvt?$AA@
  00290	50		 push	 eax
  00291	e8 00 00 00 00	 call	 _sprintf
  00296	83 c4 10	 add	 esp, 16			; 00000010H

; 1072 : 			if (!rkNetStream.LoadConvertTable(dwEmpireID, szEmpireTextConvFile))

  00299	8d 84 24 18 03
	00 00		 lea	 eax, DWORD PTR _szEmpireTextConvFile$1[esp+2080]
  002a0	8b cb		 mov	 ecx, ebx
  002a2	50		 push	 eax
  002a3	56		 push	 esi
  002a4	e8 00 00 00 00	 call	 ?LoadConvertTable@CPythonNetworkStream@@QAE_NKPBD@Z ; CPythonNetworkStream::LoadConvertTable
  002a9	84 c0		 test	 al, al
  002ab	75 16		 jne	 SHORT $LN3@LoadLocale

; 1073 : 			{
; 1074 : 				TraceError("LoadLocaleData - CPythonNetworkStream::LoadConvertTable(%d, %s) FAILURE", dwEmpireID, szEmpireTextConvFile);			

  002ad	8d 84 24 18 03
	00 00		 lea	 eax, DWORD PTR _szEmpireTextConvFile$1[esp+2080]
  002b4	50		 push	 eax
  002b5	56		 push	 esi
  002b6	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@FFMLHANM@LoadLocaleData?5?9?5CPythonNetworkS@
  002bb	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  002c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@LoadLocale:

; 1067 : 	{	
; 1068 : 		char szEmpireTextConvFile[256];
; 1069 : 		for (DWORD dwEmpireID=1; dwEmpireID<=3; ++dwEmpireID)

  002c3	46		 inc	 esi
  002c4	83 fe 03	 cmp	 esi, 3
  002c7	76 b9		 jbe	 SHORT $LL4@LoadLocale
$LN2@LoadLocale:

; 1075 : 			}
; 1076 : 		}
; 1077 : 	}
; 1078 : 
; 1079 : 	NANOEND

  002c9	eb		 DB	 -21			; ffffffebH
  002ca	03		 DB	 3
  002cb	d6		 DB	 -42			; ffffffd6H
  002cc	d7		 DB	 -41			; ffffffd7H
  002cd	00		 DB	 0

; 1080 : 		return true;
; 1081 : }

  002ce	8b 8c 24 1c 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2080]
  002d5	b0 01		 mov	 al, 1
  002d7	5f		 pop	 edi
  002d8	5e		 pop	 esi
  002d9	5b		 pop	 ebx
  002da	33 cc		 xor	 ecx, esp
  002dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e1	8b e5		 mov	 esp, ebp
  002e3	5d		 pop	 ebp
  002e4	c3		 ret	 0
?LoadLocaleData@@YA_NPBD@Z ENDP				; LoadLocaleData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?__GetWindowMode@@YAI_N@Z
_TEXT	SEGMENT
?__GetWindowMode@@YAI_N@Z PROC				; __GetWindowMode, COMDAT
; _windowed$ = cl

; 1086 : 	if (windowed)

  00000	84 c9		 test	 cl, cl
  00002	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00007	ba 00 00 ca 00	 mov	 edx, 13238272		; 00ca0000H
  0000c	0f 45 c2	 cmovne	 eax, edx

; 1087 : 		return WS_OVERLAPPED | WS_CAPTION |   WS_SYSMENU | WS_MINIMIZEBOX;
; 1088 : 
; 1089 : 	return WS_POPUP;
; 1090 : }

  0000f	c3		 ret	 0
?__GetWindowMode@@YAI_N@Z ENDP				; __GetWindowMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?Create@CPythonApplication@@QAE_NPAU_object@@PBDHHH@Z
_TEXT	SEGMENT
_bAnotherWindow$1$ = -37				; size = 1
_Windowed$1$ = -36					; size = 4
_sStickKeys$ = -32					; size = 8
tv162 = -24						; size = 4
_rc$1 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_c_szName$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_Windowed$ = 24						; size = 4
?Create@CPythonApplication@@QAE_NPAU_object@@PBDHHH@Z PROC ; CPythonApplication::Create, COMDAT
; _this$ = ecx

; 1093 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 28	 mov	 DWORD PTR __$ArrayPad$[esp+44], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b d9		 mov	 ebx, ecx

; 1094 : 	NANOBEGIN

  00019	eb		 DB	 -21			; ffffffebH
  0001a	03		 DB	 3
  0001b	d6		 DB	 -42			; ffffffd6H
  0001c	d7		 DB	 -41			; ffffffd7H
  0001d	01		 DB	 1

; 1095 : 		Windowed = CPythonSystem::Instance().IsWindowed() ? 1 : 0;

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonSystem@@@@0PAVCPythonSystem@@A ; CSingleton<CPythonSystem>::ms_singleton
  00024	e8 00 00 00 00	 call	 ?IsWindowed@CPythonSystem@@QAE_NXZ ; CPythonSystem::IsWindowed

; 1096 : 
; 1097 : 	bool bAnotherWindow = false;
; 1098 : 
; 1099 : 	if (FindWindow(NULL, c_szName))

  00029	8b 75 0c	 mov	 esi, DWORD PTR _c_szName$[ebp]
  0002c	33 c9		 xor	 ecx, ecx
  0002e	84 c0		 test	 al, al
  00030	c6 44 24 13 00	 mov	 BYTE PTR _bAnotherWindow$1$[esp+56], 0
  00035	56		 push	 esi
  00036	0f 95 c1	 setne	 cl
  00039	6a 00		 push	 0
  0003b	89 4c 24 1c	 mov	 DWORD PTR _Windowed$1$[esp+64], ecx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindWindowA@8
  00045	0f b6 4c 24 13	 movzx	 ecx, BYTE PTR _bAnotherWindow$1$[esp+56]
  0004a	85 c0		 test	 eax, eax

; 1100 : 		bAnotherWindow = true;
; 1101 : 
; 1102 : 	m_dwWidth = width;

  0004c	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0004f	ba 01 00 00 00	 mov	 edx, 1
  00054	0f 45 ca	 cmovne	 ecx, edx
  00057	89 83 84 ff 01
	00		 mov	 DWORD PTR [ebx+130948], eax

; 1103 : 	m_dwHeight = height;

  0005d	8b 45 14	 mov	 eax, DWORD PTR _height$[ebp]

; 1104 : 
; 1105 : 	// Window
; 1106 : 	UINT WindowMode = __GetWindowMode(Windowed ? true : false);
; 1107 : 
; 1108 : 	if (!CMSWindow::Create(c_szName, 4, 0, WindowMode, ::LoadIcon( GetInstance(), MAKEINTRESOURCE( IDI_METIN2 ) ), IDC_CURSOR_NORMAL))

  00060	6a 66		 push	 102			; 00000066H
  00062	89 4c 24 24	 mov	 DWORD PTR tv162[esp+60], ecx
  00066	8b cb		 mov	 ecx, ebx
  00068	6a 64		 push	 100			; 00000064H
  0006a	89 83 88 ff 01
	00		 mov	 DWORD PTR [ebx+130952], eax
  00070	e8 00 00 00 00	 call	 ?GetInstance@CMSWindow@@QAEPAUHINSTANCE__@@XZ ; CMSWindow::GetInstance
  00075	50		 push	 eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8
  0007c	8b 7c 24 18	 mov	 edi, DWORD PTR _Windowed$1$[esp+60]
  00080	85 ff		 test	 edi, edi
  00082	50		 push	 eax
  00083	0f 95 c1	 setne	 cl
  00086	e8 00 00 00 00	 call	 ?__GetWindowMode@@YAI_N@Z ; __GetWindowMode
  0008b	50		 push	 eax
  0008c	6a 00		 push	 0
  0008e	6a 04		 push	 4
  00090	56		 push	 esi
  00091	8b cb		 mov	 ecx, ebx
  00093	e8 00 00 00 00	 call	 ?Create@CMSWindow@@QAE_NPBDHKKPAUHICON__@@H@Z ; CMSWindow::Create
  00098	84 c0		 test	 al, al
  0009a	75 38		 jne	 SHORT $LN23@Create

; 1109 : 	{
; 1110 : 		//PyErr_SetString(PyExc_RuntimeError, "CMSWindow::Create failed");
; 1111 : 		TraceError("CMSWindow::Create failed");

  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBNNLGNG@CMSWindow?3?3Create?5failed?$AA@
  000a1	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000a6	83 c4 04	 add	 esp, 4

; 1112 : 		SET_EXCEPTION(CREATE_WINDOW);

  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NOBMPFEG@CREATE_WINDOW?$AA@
$LN39@Create:
  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  000b3	ff 30		 push	 DWORD PTR [eax]
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  000bb	83 c4 08	 add	 esp, 8
$LN40@Create:

; 1113 : 		return false;

  000be	32 c0		 xor	 al, al

; 1276 : 		return true;
; 1277 : }

  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	8b 4c 24 28	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+44]
  000c7	33 cc		 xor	 ecx, esp
  000c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 14 00	 ret	 20			; 00000014H
$LN23@Create:

; 1114 : 	}
; 1115 : 
; 1116 : #ifdef USE_NPROTECT_GAMEGUARD
; 1117 : 	if (!GameGuard_Run(CMSWindow::GetWindowHandle()))
; 1118 : 		return false;
; 1119 : #endif
; 1120 : #ifdef XTRAP_CLIENT_ENABLE
; 1121 : 	if (!XTrap_CheckInit())
; 1122 : 		return false;
; 1123 : #endif
; 1124 : 
; 1125 : 	if (m_pySystem.IsUseDefaultIME())

  000d4	8d b3 70 d8 01
	00		 lea	 esi, DWORD PTR [ebx+120944]
  000da	8b ce		 mov	 ecx, esi
  000dc	e8 00 00 00 00	 call	 ?IsUseDefaultIME@CPythonSystem@@QAE_NXZ ; CPythonSystem::IsUseDefaultIME
  000e1	84 c0		 test	 al, al
  000e3	74 0e		 je	 SHORT $LN22@Create

; 1126 : 	{
; 1127 : 		CPythonIME::Instance().UseDefaultIME();

  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonIME@@@@0PAVCPythonIME@@A ; CSingleton<CPythonIME>::ms_singleton
  000eb	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  000ee	e8 00 00 00 00	 call	 ?UseDefaultIME@CIME@@QAEXXZ ; CIME::UseDefaultIME
$LN22@Create:

; 1128 : 	}
; 1129 : 
; 1130 : 	//  
; 1131 : 	//  IME    
; 1132 : 	//    
; 1133 : 	if (!m_pySystem.IsWindowed() && (m_pySystem.IsUseDefaultIME() || LocaleService_IsEUROPE()))

  000f3	8b ce		 mov	 ecx, esi
  000f5	e8 00 00 00 00	 call	 ?IsWindowed@CPythonSystem@@QAE_NXZ ; CPythonSystem::IsWindowed
  000fa	84 c0		 test	 al, al
  000fc	75 48		 jne	 SHORT $LN21@Create
  000fe	e8 00 00 00 00	 call	 ?IsUseDefaultIME@CPythonSystem@@QAE_NXZ ; CPythonSystem::IsUseDefaultIME
  00103	84 c0		 test	 al, al
  00105	75 09		 jne	 SHORT $LN20@Create
  00107	e8 00 00 00 00	 call	 ?LocaleService_IsEUROPE@@YA_NXZ ; LocaleService_IsEUROPE
  0010c	84 c0		 test	 al, al
  0010e	74 36		 je	 SHORT $LN21@Create
$LN20@Create:

; 1134 : 	{
; 1135 : 		m_isWindowed = false;
; 1136 : 		m_isWindowFullScreenEnable = TRUE;
; 1137 : 		__SetFullScreenWindow(GetWindowHandle(), width, height, m_pySystem.GetBPP());

  00110	8b cb		 mov	 ecx, ebx
  00112	c6 83 90 00 02
	00 00		 mov	 BYTE PTR [ebx+131216], 0
  00119	c7 83 b4 00 02
	00 01 00 00 00	 mov	 DWORD PTR [ebx+131252], 1
  00123	e8 00 00 00 00	 call	 ?GetWindowHandle@CMSWindow@@QAEPAUHWND__@@XZ ; CMSWindow::GetWindowHandle
  00128	8b ce		 mov	 ecx, esi
  0012a	e8 00 00 00 00	 call	 ?GetBPP@CPythonSystem@@QAEKXZ ; CPythonSystem::GetBPP
  0012f	50		 push	 eax
  00130	ff 75 14	 push	 DWORD PTR _height$[ebp]
  00133	ff 75 10	 push	 DWORD PTR _width$[ebp]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 ?__SetFullScreenWindow@CPythonApplication@@IAEXPAUHWND__@@KKK@Z ; CPythonApplication::__SetFullScreenWindow

; 1138 : 
; 1139 : 		Windowed = true;

  0013c	bf 01 00 00 00	 mov	 edi, 1

; 1140 : 	}
; 1141 : 	else

  00141	e9 83 00 00 00	 jmp	 $LN16@Create
$LN21@Create:

; 1142 : 	{
; 1143 : 		AdjustSize(m_pySystem.GetWidth(), m_pySystem.GetHeight());

  00146	8b ce		 mov	 ecx, esi
  00148	e8 00 00 00 00	 call	 ?GetHeight@CPythonSystem@@QAEKXZ ; CPythonSystem::GetHeight
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?GetWidth@CPythonSystem@@QAEKXZ ; CPythonSystem::GetWidth
  00153	50		 push	 eax
  00154	8b cb		 mov	 ecx, ebx
  00156	e8 00 00 00 00	 call	 ?AdjustSize@CMSWindow@@QAEXHH@Z ; CMSWindow::AdjustSize

; 1144 : 
; 1145 : 		if (Windowed)

  0015b	85 ff		 test	 edi, edi
  0015d	74 58		 je	 SHORT $LN18@Create

; 1146 : 		{
; 1147 : 			m_isWindowed = true;
; 1148 : 
; 1149 : 			if (bAnotherWindow)

  0015f	80 7c 24 20 00	 cmp	 BYTE PTR tv162[esp+56], 0
  00164	c6 83 90 00 02
	00 01		 mov	 BYTE PTR [ebx+131216], 1
  0016b	74 5c		 je	 SHORT $LN16@Create

; 1150 : 			{
; 1151 : 				RECT rc;
; 1152 : 
; 1153 : 				GetClientRect(&rc);

  0016d	8d 44 24 24	 lea	 eax, DWORD PTR _rc$1[esp+56]
  00171	8b cb		 mov	 ecx, ebx
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 ?GetClientRect@CMSWindow@@QAEXPAUtagRECT@@@Z ; CMSWindow::GetClientRect

; 1154 : 
; 1155 : 				int windowWidth = rc.right - rc.left;

  00179	8b 7c 24 2c	 mov	 edi, DWORD PTR _rc$1[esp+64]

; 1156 : 				int windowHeight = (rc.bottom - rc.top);
; 1157 : 
; 1158 : 				CMSApplication::SetPosition(GetScreenWidth() - windowWidth, GetScreenHeight() - 60 - windowHeight);

  0017d	8b cb		 mov	 ecx, ebx
  0017f	8b 74 24 30	 mov	 esi, DWORD PTR _rc$1[esp+68]
  00183	2b 7c 24 24	 sub	 edi, DWORD PTR _rc$1[esp+56]
  00187	2b 74 24 28	 sub	 esi, DWORD PTR _rc$1[esp+60]
  0018b	e8 00 00 00 00	 call	 ?GetScreenHeight@CMSWindow@@QAEHXZ ; CMSWindow::GetScreenHeight
  00190	b9 c4 ff ff ff	 mov	 ecx, -60		; ffffffc4H
  00195	2b ce		 sub	 ecx, esi
  00197	03 c1		 add	 eax, ecx
  00199	8b cb		 mov	 ecx, ebx
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?GetScreenWidth@CMSWindow@@QAEHXZ ; CMSWindow::GetScreenWidth
  001a1	2b c7		 sub	 eax, edi
  001a3	8b cb		 mov	 ecx, ebx
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 ?SetPosition@CMSWindow@@QAEXHH@Z ; CMSWindow::SetPosition

; 1159 : 			}
; 1160 : 		}
; 1161 : 		else

  001ab	8b 7c 24 14	 mov	 edi, DWORD PTR _Windowed$1$[esp+56]
  001af	8d b3 70 d8 01
	00		 lea	 esi, DWORD PTR [ebx+120944]
  001b5	eb 12		 jmp	 SHORT $LN16@Create
$LN18@Create:

; 1162 : 		{
; 1163 : 			m_isWindowed = false;
; 1164 : 			SetPosition(0, 0);

  001b7	6a 00		 push	 0
  001b9	6a 00		 push	 0
  001bb	8b cb		 mov	 ecx, ebx
  001bd	c6 83 90 00 02
	00 00		 mov	 BYTE PTR [ebx+131216], 0
  001c4	e8 00 00 00 00	 call	 ?SetPosition@CMSWindow@@QAEXHH@Z ; CMSWindow::SetPosition
$LN16@Create:

; 1165 : 		}
; 1166 : 	}
; 1167 : 
; 1168 : 	NANOEND

  001c9	eb		 DB	 -21			; ffffffebH
  001ca	03		 DB	 3
  001cb	d6		 DB	 -42			; ffffffd6H
  001cc	d7		 DB	 -41			; ffffffd7H
  001cd	00		 DB	 0

; 1169 : 		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 1170 : 		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 1171 : 
; 1172 : 		// Cursor
; 1173 : 		if (!CreateCursors())

  001ce	8b cb		 mov	 ecx, ebx
  001d0	e8 00 00 00 00	 call	 ?CreateCursors@CPythonApplication@@QAE_NXZ ; CPythonApplication::CreateCursors
  001d5	84 c0		 test	 al, al
  001d7	75 17		 jne	 SHORT $LN15@Create

; 1174 : 		{
; 1175 : 			//PyErr_SetString(PyExc_RuntimeError, "CMSWindow::Cursors Create Error");
; 1176 : 			TraceError("CMSWindow::Cursors Create Error");

  001d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FFOMJBHN@CMSWindow?3?3Cursors?5Create?5Error?$AA@
  001de	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001e3	83 c4 04	 add	 esp, 4

; 1177 : 			SET_EXCEPTION("CREATE_CURSOR");

  001e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GLLECKCO@?$CCCREATE_CURSOR?$CC?$AA@

; 1178 : 			return false;

  001eb	e9 be fe ff ff	 jmp	 $LN39@Create
$LN15@Create:

; 1179 : 		}
; 1180 : 
; 1181 : 		if (!m_pySystem.IsNoSoundCard())

  001f0	8b ce		 mov	 ecx, esi
  001f2	e8 00 00 00 00	 call	 ?IsNoSoundCard@CPythonSystem@@QAE_NXZ ; CPythonSystem::IsNoSoundCard
  001f7	84 c0		 test	 al, al
  001f9	75 0b		 jne	 SHORT $LN13@Create

; 1182 : 		{
; 1183 : 			// Sound
; 1184 : 			if (!m_SoundManager.Create())

  001fb	8d 8b e8 00 00
	00		 lea	 ecx, DWORD PTR [ebx+232]
  00201	e8 00 00 00 00	 call	 ?Create@CSoundManager@@QAEHXZ ; CSoundManager::Create
$LN13@Create:

; 1185 : 			{
; 1186 : 				// NOTE :   
; 1187 : 				//		LogBox(ApplicationStringTable_GetStringz(IDS_WARN_NO_SOUND_DEVICE));
; 1188 : 			}
; 1189 : 		}
; 1190 : 
; 1191 : 		extern bool GRAPHICS_CAPS_SOFTWARE_TILING;
; 1192 : 
; 1193 : 		if (!m_pySystem.IsAutoTiling())

  00206	8b ce		 mov	 ecx, esi
  00208	e8 00 00 00 00	 call	 ?IsAutoTiling@CPythonSystem@@QAE_NXZ ; CPythonSystem::IsAutoTiling
  0020d	84 c0		 test	 al, al
  0020f	75 0a		 jne	 SHORT $LN12@Create

; 1194 : 			GRAPHICS_CAPS_SOFTWARE_TILING = m_pySystem.IsSoftwareTiling();

  00211	e8 00 00 00 00	 call	 ?IsSoftwareTiling@CPythonSystem@@QAE_NXZ ; CPythonSystem::IsSoftwareTiling
  00216	a2 00 00 00 00	 mov	 BYTE PTR ?GRAPHICS_CAPS_SOFTWARE_TILING@@3_NA, al ; GRAPHICS_CAPS_SOFTWARE_TILING
$LN12@Create:

; 1195 : 
; 1196 : 		// Device
; 1197 : 		if (!CreateDevice(m_pySystem.GetWidth(), m_pySystem.GetHeight(), Windowed, m_pySystem.GetBPP(), m_pySystem.GetFrequency()))

  0021b	8b ce		 mov	 ecx, esi
  0021d	e8 00 00 00 00	 call	 ?GetFrequency@CPythonSystem@@QAEKXZ ; CPythonSystem::GetFrequency
  00222	50		 push	 eax
  00223	e8 00 00 00 00	 call	 ?GetBPP@CPythonSystem@@QAEKXZ ; CPythonSystem::GetBPP
  00228	50		 push	 eax
  00229	57		 push	 edi
  0022a	e8 00 00 00 00	 call	 ?GetHeight@CPythonSystem@@QAEKXZ ; CPythonSystem::GetHeight
  0022f	50		 push	 eax
  00230	e8 00 00 00 00	 call	 ?GetWidth@CPythonSystem@@QAEKXZ ; CPythonSystem::GetWidth
  00235	50		 push	 eax
  00236	8b cb		 mov	 ecx, ebx
  00238	e8 00 00 00 00	 call	 ?CreateDevice@CPythonApplication@@QAE_NHHHHH@Z ; CPythonApplication::CreateDevice
  0023d	84 c0		 test	 al, al
  0023f	0f 84 79 fe ff
	ff		 je	 $LN40@Create

; 1198 : 			return false;
; 1199 : 
; 1200 : 		GrannyCreateSharedDeformBuffer();

  00245	e8 00 00 00 00	 call	 ?GrannyCreateSharedDeformBuffer@@YAXXZ ; GrannyCreateSharedDeformBuffer

; 1201 : 
; 1202 : 		if (m_pySystem.IsAutoTiling())

  0024a	8b ce		 mov	 ecx, esi
  0024c	e8 00 00 00 00	 call	 ?IsAutoTiling@CPythonSystem@@QAE_NXZ ; CPythonSystem::IsAutoTiling
  00251	84 c0		 test	 al, al
  00253	74 17		 je	 SHORT $LN10@Create

; 1203 : 		{
; 1204 : 			if (m_grpDevice.IsFastTNL())

  00255	e8 00 00 00 00	 call	 ?IsFastTNL@CGraphicBase@@SA_NXZ ; CGraphicBase::IsFastTNL

; 1205 : 			{
; 1206 : 				m_pyBackground.ReserveSoftwareTilingEnable(false);

  0025a	8d 8b 74 bb 01
	00		 lea	 ecx, DWORD PTR [ebx+113524]
  00260	84 c0		 test	 al, al
  00262	74 04		 je	 SHORT $LN9@Create
  00264	6a 00		 push	 0

; 1207 : 			}
; 1208 : 			else

  00266	eb 15		 jmp	 SHORT $LN37@Create
$LN9@Create:

; 1209 : 			{
; 1210 : 				m_pyBackground.ReserveSoftwareTilingEnable(true);

  00268	6a 01		 push	 1

; 1211 : 			}
; 1212 : 		}
; 1213 : 		else

  0026a	eb 11		 jmp	 SHORT $LN37@Create
$LN10@Create:

; 1214 : 		{
; 1215 : 			m_pyBackground.ReserveSoftwareTilingEnable(m_pySystem.IsSoftwareTiling());

  0026c	8b ce		 mov	 ecx, esi
  0026e	e8 00 00 00 00	 call	 ?IsSoftwareTiling@CPythonSystem@@QAE_NXZ ; CPythonSystem::IsSoftwareTiling
  00273	0f b6 c0	 movzx	 eax, al
  00276	8d 8b 74 bb 01
	00		 lea	 ecx, DWORD PTR [ebx+113524]
  0027c	50		 push	 eax
$LN37@Create:
  0027d	e8 00 00 00 00	 call	 ?ReserveSoftwareTilingEnable@CMapManager@@QAEX_N@Z ; CMapManager::ReserveSoftwareTilingEnable

; 1216 : 		}
; 1217 : 
; 1218 : 		SetVisibleMode(true);

  00282	6a 01		 push	 1
  00284	8b cb		 mov	 ecx, ebx
  00286	e8 00 00 00 00	 call	 ?SetVisibleMode@CMSWindow@@QAEX_N@Z ; CMSWindow::SetVisibleMode

; 1219 : 
; 1220 : 		if (m_isWindowFullScreenEnable) //m_pySystem.IsUseDefaultIME() && !m_pySystem.IsWindowed())

  0028b	83 bb b4 00 02
	00 00		 cmp	 DWORD PTR [ebx+131252], 0
  00292	74 1c		 je	 SHORT $LN6@Create

; 1221 : 		{
; 1222 : 			SetWindowPos(GetWindowHandle(), HWND_TOP, 0, 0, width, height, SWP_SHOWWINDOW);

  00294	6a 40		 push	 64			; 00000040H
  00296	ff 75 14	 push	 DWORD PTR _height$[ebp]
  00299	8b cb		 mov	 ecx, ebx
  0029b	ff 75 10	 push	 DWORD PTR _width$[ebp]
  0029e	6a 00		 push	 0
  002a0	6a 00		 push	 0
  002a2	6a 00		 push	 0
  002a4	e8 00 00 00 00	 call	 ?GetWindowHandle@CMSWindow@@QAEPAUHWND__@@XZ ; CMSWindow::GetWindowHandle
  002a9	50		 push	 eax
  002aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
$LN6@Create:

; 1223 : 		}
; 1224 : 
; 1225 : 		if (!InitializeKeyboard(GetWindowHandle()))

  002b0	8b cb		 mov	 ecx, ebx
  002b2	e8 00 00 00 00	 call	 ?GetWindowHandle@CMSWindow@@QAEPAUHWND__@@XZ ; CMSWindow::GetWindowHandle
  002b7	50		 push	 eax
  002b8	8d 4b 1c	 lea	 ecx, DWORD PTR [ebx+28]
  002bb	e8 00 00 00 00	 call	 ?InitializeKeyboard@CInputKeyboard@@QAE_NPAUHWND__@@@Z ; CInputKeyboard::InitializeKeyboard
  002c0	84 c0		 test	 al, al
  002c2	0f 84 f6 fd ff
	ff		 je	 $LN40@Create

; 1226 : 			return false;
; 1227 : 
; 1228 : 		m_pySystem.GetDisplaySettings();

  002c8	8b ce		 mov	 ecx, esi
  002ca	e8 00 00 00 00	 call	 ?GetDisplaySettings@CPythonSystem@@QAEXXZ ; CPythonSystem::GetDisplaySettings

; 1229 : 
; 1230 : 		// Mouse
; 1231 : 		if (m_pySystem.IsSoftwareCursor())

  002cf	8b ce		 mov	 ecx, esi
  002d1	e8 00 00 00 00	 call	 ?IsSoftwareCursor@CPythonSystem@@QAE_NXZ ; CPythonSystem::IsSoftwareCursor

; 1232 : 			SetCursorMode(CURSOR_MODE_SOFTWARE);

  002d6	8b cb		 mov	 ecx, ebx
  002d8	84 c0		 test	 al, al
  002da	74 04		 je	 SHORT $LN4@Create
  002dc	6a 01		 push	 1

; 1233 : 		else

  002de	eb 02		 jmp	 SHORT $LN38@Create
$LN4@Create:

; 1234 : 			SetCursorMode(CURSOR_MODE_HARDWARE);

  002e0	6a 00		 push	 0
$LN38@Create:
  002e2	e8 00 00 00 00	 call	 ?SetCursorMode@CPythonApplication@@QAEXH@Z ; CPythonApplication::SetCursorMode

; 1235 : 
; 1236 : 		// Network
; 1237 : 		if (!m_netDevice.Create())

  002e7	8d 8b 68 d8 01
	00		 lea	 ecx, DWORD PTR [ebx+120936]
  002ed	e8 00 00 00 00	 call	 ?Create@CNetworkDevice@@QAE_NXZ ; CNetworkDevice::Create
  002f2	84 c0		 test	 al, al
  002f4	75 17		 jne	 SHORT $LN2@Create

; 1238 : 		{
; 1239 : 			//PyErr_SetString(PyExc_RuntimeError, "NetDevice::Create failed");
; 1240 : 			TraceError("NetDevice::Create failed");

  002f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CJEBNOLC@NetDevice?3?3Create?5failed?$AA@
  002fb	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00300	83 c4 04	 add	 esp, 4

; 1241 : 			SET_EXCEPTION("CREATE_NETWORK");

  00303	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EJLMKODK@?$CCCREATE_NETWORK?$CC?$AA@

; 1242 : 			return false;

  00308	e9 a1 fd ff ff	 jmp	 $LN39@Create
$LN2@Create:

; 1243 : 		}
; 1244 : 
; 1245 : 		if (!m_grpDevice.IsFastTNL())

  0030d	e8 00 00 00 00	 call	 ?IsFastTNL@CGraphicBase@@SA_NXZ ; CGraphicBase::IsFastTNL
  00312	84 c0		 test	 al, al
  00314	75 0a		 jne	 SHORT $LN1@Create

; 1246 : 			CGrannyLODController::SetMinLODMode(true);

  00316	6a 01		 push	 1
  00318	e8 00 00 00 00	 call	 ?SetMinLODMode@CGrannyLODController@@SAX_N@Z ; CGrannyLODController::SetMinLODMode
  0031d	83 c4 04	 add	 esp, 4
$LN1@Create:

; 1247 : 
; 1248 : 		m_pyItem.Create();

  00320	8d 8b 08 94 01
	00		 lea	 ecx, DWORD PTR [ebx+103432]
  00326	e8 00 00 00 00	 call	 ?Create@CPythonItem@@QAEXXZ ; CPythonItem::Create

; 1249 : 
; 1250 : 		// Other Modules
; 1251 : 		DefaultFont_Startup();

  0032b	e8 00 00 00 00	 call	 ?DefaultFont_Startup@@YAXXZ ; DefaultFont_Startup
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h

; 27   : 		return (*ms_singleton);

  00330	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonIME@@@@0PAVCPythonIME@@A ; CSingleton<CPythonIME>::ms_singleton
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 1253 : 		CPythonIME::Instance().Create(GetWindowHandle());

  00336	8b cb		 mov	 ecx, ebx
  00338	e8 00 00 00 00	 call	 ?GetWindowHandle@CMSWindow@@QAEPAUHWND__@@XZ ; CMSWindow::GetWindowHandle
  0033d	50		 push	 eax
  0033e	8b ce		 mov	 ecx, esi
  00340	e8 00 00 00 00	 call	 ?Create@CPythonIME@@QAEXPAUHWND__@@@Z ; CPythonIME::Create

; 1254 : 		CPythonIME::Instance().SetText("", 0);

  00345	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonIME@@@@0PAVCPythonIME@@A ; CSingleton<CPythonIME>::ms_singleton
  0034b	6a 00		 push	 0
  0034d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00352	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00355	e8 00 00 00 00	 call	 ?SetText@CIME@@QAEXPBDH@Z ; CIME::SetText

; 1255 : 		CPythonTextTail::Instance().Initialize();

  0035a	e8 00 00 00 00	 call	 ?Initialize@CPythonTextTail@@QAEXXZ ; CPythonTextTail::Initialize

; 1256 : 
; 1257 : 		// Light Manager
; 1258 : 		m_LightManager.Initialize();

  0035f	8d 4b 7c	 lea	 ecx, DWORD PTR [ebx+124]
  00362	e8 00 00 00 00	 call	 ?Initialize@CLightManager@@QAEXXZ ; CLightManager::Initialize

; 1259 : 
; 1260 : 		CGraphicImageInstance::CreateSystem(32);

  00367	6a 20		 push	 32			; 00000020H
  00369	e8 00 00 00 00	 call	 ?CreateSystem@CGraphicImageInstance@@SAXI@Z ; CGraphicImageInstance::CreateSystem

; 1261 : 
; 1262 : 		// 
; 1263 : 		STICKYKEYS sStickKeys;
; 1264 : 		memset(&sStickKeys, 0, sizeof(sStickKeys));
; 1265 : 		sStickKeys.cbSize = sizeof(sStickKeys);
; 1266 : 		SystemParametersInfo( SPI_GETSTICKYKEYS, sizeof(sStickKeys), &sStickKeys, 0 );

  0036e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SystemParametersInfoA@16
  00374	8d 44 24 1c	 lea	 eax, DWORD PTR _sStickKeys$[esp+60]
  00378	83 c4 04	 add	 esp, 4
  0037b	0f 57 c0	 xorps	 xmm0, xmm0
  0037e	66 0f d6 44 24
	18		 movq	 QWORD PTR _sStickKeys$[esp+56], xmm0
  00384	c7 44 24 18 08
	00 00 00	 mov	 DWORD PTR _sStickKeys$[esp+56], 8
  0038c	6a 00		 push	 0
  0038e	50		 push	 eax
  0038f	6a 08		 push	 8
  00391	6a 3a		 push	 58			; 0000003aH
  00393	ff d6		 call	 esi

; 1267 : 		m_dwStickyKeysFlag = sStickKeys.dwFlags;

  00395	8b 44 24 1c	 mov	 eax, DWORD PTR _sStickKeys$[esp+60]
  00399	89 83 b8 00 02
	00		 mov	 DWORD PTR [ebx+131256], eax

; 1268 : 
; 1269 : 		// 
; 1270 : 		sStickKeys.dwFlags &= ~(SKF_AVAILABLE|SKF_HOTKEYACTIVE);

  0039f	83 e0 f9	 and	 eax, -7			; fffffff9H

; 1271 : 		SystemParametersInfo( SPI_SETSTICKYKEYS, sizeof(sStickKeys), &sStickKeys, 0 );

  003a2	6a 00		 push	 0
  003a4	89 44 24 20	 mov	 DWORD PTR _sStickKeys$[esp+64], eax
  003a8	8d 44 24 1c	 lea	 eax, DWORD PTR _sStickKeys$[esp+60]
  003ac	50		 push	 eax
  003ad	6a 08		 push	 8
  003af	6a 3b		 push	 59			; 0000003bH
  003b1	ff d6		 call	 esi

; 1272 : 
; 1273 : 		// SphereMap
; 1274 : 		CGrannyMaterial::CreateSphereMap(0, "d:/ymir work/special/spheremap.jpg");

  003b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KIIBIHOG@d?3?1ymir?5work?1special?1spheremap?4j@
  003b8	6a 00		 push	 0
  003ba	e8 00 00 00 00	 call	 ?CreateSphereMap@CGrannyMaterial@@SAXIPBD@Z ; CGrannyMaterial::CreateSphereMap

; 1275 : 		CGrannyMaterial::CreateSphereMap(1, "d:/ymir work/special/spheremap01.jpg");

  003bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CBFEMJII@d?3?1ymir?5work?1special?1spheremap01@
  003c4	6a 01		 push	 1
  003c6	e8 00 00 00 00	 call	 ?CreateSphereMap@CGrannyMaterial@@SAXIPBD@Z ; CGrannyMaterial::CreateSphereMap

; 1276 : 		return true;
; 1277 : }

  003cb	8b 4c 24 44	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+72]
  003cf	83 c4 10	 add	 esp, 16			; 00000010H
  003d2	b0 01		 mov	 al, 1
  003d4	5f		 pop	 edi
  003d5	5e		 pop	 esi
  003d6	5b		 pop	 ebx
  003d7	33 cc		 xor	 ecx, esp
  003d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003de	8b e5		 mov	 esp, ebp
  003e0	5d		 pop	 ebp
  003e1	c2 14 00	 ret	 20			; 00000014H
?Create@CPythonApplication@@QAE_NPAU_object@@PBDHHH@Z ENDP ; CPythonApplication::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?SetGlobalCenterPosition@CPythonApplication@@QAEXJJ@Z
_TEXT	SEGMENT
_z$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SetGlobalCenterPosition@CPythonApplication@@QAEXJJ@Z PROC ; CPythonApplication::SetGlobalCenterPosition, COMDAT
; _this$dead$ = ecx

; 1280 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1281 : 	CPythonBackground& rkBG=CPythonBackground::Instance();
; 1282 : 	rkBG.GlobalPositionToLocalPosition(x, y);

  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0000a	8d 45 0c	 lea	 eax, DWORD PTR _y$[ebp]
  0000d	50		 push	 eax
  0000e	8d 45 08	 lea	 eax, DWORD PTR _x$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?GlobalPositionToLocalPosition@CPythonBackground@@QAEXAAJ0@Z ; CPythonBackground::GlobalPositionToLocalPosition
  00017	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _y$[ebp]

; 1283 : 
; 1284 : 	float z = CPythonBackground::Instance().GetHeight(x, y);

  0001c	83 ec 08	 sub	 esp, 8
  0001f	66 0f 6e 4d 08	 movd	 xmm1, DWORD PTR _x$[ebp]
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0002a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0002d	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00030	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00036	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0003b	e8 00 00 00 00	 call	 ?GetHeight@CMapManager@@QAEMMM@Z ; CMapManager::GetHeight

; 1285 : 
; 1286 : 	CPythonApplication::Instance().SetCenterPosition(x, y, z);

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00046	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00049	d9 5d fc	 fstp	 DWORD PTR _z$[ebp]
  0004c	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _z$[ebp]
  00051	83 c1 20	 add	 ecx, 32			; 00000020H
  00054	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0005a	66 0f 6e 45 0c	 movd	 xmm0, DWORD PTR _y$[ebp]
  0005f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00061	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00064	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0006a	66 0f 6e 45 08	 movd	 xmm0, DWORD PTR _x$[ebp]
  0006f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00072	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00077	ff 50 18	 call	 DWORD PTR [eax+24]

; 1287 : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
?SetGlobalCenterPosition@CPythonApplication@@QAEXJJ@Z ENDP ; CPythonApplication::SetGlobalCenterPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?SetCenterPosition@CPythonApplication@@UAEXMMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
?SetCenterPosition@CPythonApplication@@UAEXMMM@Z PROC	; CPythonApplication::SetCenterPosition, COMDAT
; _this$ = ecx

; 1290 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 	m_v3CenterPosition.x = +fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00008	f3 0f 11 81 44
	ff 01 00	 movss	 DWORD PTR [ecx+130884], xmm0

; 1292 : 	m_v3CenterPosition.y = -fy;

  00010	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00015	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0001c	f3 0f 11 81 48
	ff 01 00	 movss	 DWORD PTR [ecx+130888], xmm0

; 1293 : 	m_v3CenterPosition.z = +fz;

  00024	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00029	f3 0f 11 81 4c
	ff 01 00	 movss	 DWORD PTR [ecx+130892], xmm0

; 1294 : }

  00031	5d		 pop	 ebp
  00032	c2 0c 00	 ret	 12			; 0000000cH
?SetCenterPosition@CPythonApplication@@UAEXMMM@Z ENDP	; CPythonApplication::SetCenterPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?GetCenterPosition@CPythonApplication@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pPixelPosition$ = 8					; size = 4
?GetCenterPosition@CPythonApplication@@QAEXPAUD3DXVECTOR3@@@Z PROC ; CPythonApplication::GetCenterPosition, COMDAT
; _this$ = ecx

; 1297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1298 : 	pPixelPosition->x = +m_v3CenterPosition.x;

  00003	8b 55 08	 mov	 edx, DWORD PTR _pPixelPosition$[ebp]
  00006	8b 81 64 ff 01
	00		 mov	 eax, DWORD PTR [ecx+130916]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 1299 : 	pPixelPosition->y = -m_v3CenterPosition.y;

  0000e	f3 0f 10 81 68
	ff 01 00	 movss	 xmm0, DWORD PTR [ecx+130920]
  00016	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0001d	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0

; 1300 : 	pPixelPosition->z = +m_v3CenterPosition.z;

  00022	8b 81 6c ff 01
	00		 mov	 eax, DWORD PTR [ecx+130924]
  00028	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1301 : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?GetCenterPosition@CPythonApplication@@QAEXPAUD3DXVECTOR3@@@Z ENDP ; CPythonApplication::GetCenterPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?SetServerTime@CPythonApplication@@UAEXJ@Z
_TEXT	SEGMENT
_tTime$ = 8						; size = 4
?SetServerTime@CPythonApplication@@UAEXJ@Z PROC		; CPythonApplication::SetServerTime, COMDAT
; _this$ = ecx

; 1305 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1306 : 	m_dwStartLocalTime	= ELTimer_GetMSec();

  00006	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0000b	89 86 70 ff 01
	00		 mov	 DWORD PTR [esi+130928], eax

; 1307 : 	m_tServerTime		= tTime;

  00011	8b 45 08	 mov	 eax, DWORD PTR _tTime$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl

; 79   :     return _time32(_Time);

  00014	6a 00		 push	 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 1307 : 	m_tServerTime		= tTime;

  00016	89 86 74 ff 01
	00		 mov	 DWORD PTR [esi+130932], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl

; 79   :     return _time32(_Time);

  0001c	e8 00 00 00 00	 call	 __time32
  00021	83 c4 04	 add	 esp, 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 1308 : 	m_tLocalStartTime	= time(0);

  00024	89 86 78 ff 01
	00		 mov	 DWORD PTR [esi+130936], eax
  0002a	5e		 pop	 esi

; 1309 : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?SetServerTime@CPythonApplication@@UAEXJ@Z ENDP		; CPythonApplication::SetServerTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?GetServerTime@CPythonApplication@@QAEJXZ
_TEXT	SEGMENT
?GetServerTime@CPythonApplication@@QAEJXZ PROC		; CPythonApplication::GetServerTime, COMDAT
; _this$ = ecx

; 1312 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1313 : 	return (ELTimer_GetMSec() - m_dwStartLocalTime) + m_tServerTime;

  00003	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00008	8b 96 94 ff 01
	00		 mov	 edx, DWORD PTR [esi+130964]
  0000e	2b 96 90 ff 01
	00		 sub	 edx, DWORD PTR [esi+130960]
  00014	03 c2		 add	 eax, edx
  00016	5e		 pop	 esi

; 1314 : }

  00017	c3		 ret	 0
?GetServerTime@CPythonApplication@@QAEJXZ ENDP		; CPythonApplication::GetServerTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?GetServerTimeStamp@CPythonApplication@@QAEJXZ
_TEXT	SEGMENT
?GetServerTimeStamp@CPythonApplication@@QAEJXZ PROC	; CPythonApplication::GetServerTimeStamp, COMDAT
; _this$ = ecx

; 1319 : {

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl

; 79   :     return _time32(_Time);

  00001	6a 00		 push	 0
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 1319 : {

  00003	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl

; 79   :     return _time32(_Time);

  00005	e8 00 00 00 00	 call	 __time32
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 1320 : 	return (time(0) - m_tLocalStartTime) + m_tServerTime;

  0000a	8b 96 94 ff 01
	00		 mov	 edx, DWORD PTR [esi+130964]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl

; 79   :     return _time32(_Time);

  00010	83 c4 04	 add	 esp, 4
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 1320 : 	return (time(0) - m_tLocalStartTime) + m_tServerTime;

  00013	2b 96 98 ff 01
	00		 sub	 edx, DWORD PTR [esi+130968]
  00019	03 c2		 add	 eax, edx
  0001b	5e		 pop	 esi

; 1321 : }

  0001c	c3		 ret	 0
?GetServerTimeStamp@CPythonApplication@@QAEJXZ ENDP	; CPythonApplication::GetServerTimeStamp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?GetGlobalTime@CPythonApplication@@UAEMXZ
_TEXT	SEGMENT
?GetGlobalTime@CPythonApplication@@UAEMXZ PROC		; CPythonApplication::GetGlobalTime, COMDAT
; _this$ = ecx

; 1325 : 	return m_fGlobalTime;

  00000	d9 81 7c ff 01
	00		 fld	 DWORD PTR [ecx+130940]

; 1326 : }

  00006	c3		 ret	 0
?GetGlobalTime@CPythonApplication@@UAEMXZ ENDP		; CPythonApplication::GetGlobalTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?GetGlobalElapsedTime@CPythonApplication@@UAEMXZ
_TEXT	SEGMENT
?GetGlobalElapsedTime@CPythonApplication@@UAEMXZ PROC	; CPythonApplication::GetGlobalElapsedTime, COMDAT
; _this$ = ecx

; 1330 : 	return m_fGlobalElapsedTime;

  00000	d9 81 80 ff 01
	00		 fld	 DWORD PTR [ecx+130944]

; 1331 : }

  00006	c3		 ret	 0
?GetGlobalElapsedTime@CPythonApplication@@UAEMXZ ENDP	; CPythonApplication::GetGlobalElapsedTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?SetFPS@CPythonApplication@@QAEXH@Z
_TEXT	SEGMENT
_iFPS$ = 8						; size = 4
?SetFPS@CPythonApplication@@QAEXH@Z PROC		; CPythonApplication::SetFPS, COMDAT
; _this$ = ecx

; 1334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1335 : 	m_iFPS = iFPS;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iFPS$[ebp]
  00006	89 81 70 ff 01
	00		 mov	 DWORD PTR [ecx+130928], eax

; 1336 : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetFPS@CPythonApplication@@QAEXH@Z ENDP		; CPythonApplication::SetFPS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?SetConnectData@CPythonApplication@@QAEXPBDH@Z
_TEXT	SEGMENT
_c_szIP$ = 8						; size = 4
_iPort$ = 12						; size = 4
?SetConnectData@CPythonApplication@@QAEXPBDH@Z PROC	; CPythonApplication::SetConnectData, COMDAT
; _this$ = ecx

; 1349 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00004	8b 75 08	 mov	 esi, DWORD PTR _c_szIP$[ebp]
  00007	57		 push	 edi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 1349 : {

  00008	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0000a	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000d	75 04		 jne	 SHORT $LN9@SetConnect
  0000f	33 d2		 xor	 edx, edx
  00011	eb 0e		 jmp	 SHORT $LN10@SetConnect
$LN9@SetConnect:
  00013	8b d6		 mov	 edx, esi
  00015	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL11@SetConnect:
  00018	8a 02		 mov	 al, BYTE PTR [edx]
  0001a	42		 inc	 edx
  0001b	84 c0		 test	 al, al
  0001d	75 f9		 jne	 SHORT $LL11@SetConnect
  0001f	2b d1		 sub	 edx, ecx
$LN10@SetConnect:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00021	52		 push	 edx
  00022	56		 push	 esi
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 1350 : 	m_strIP = c_szIP;

  00023	8d 8f 94 00 02
	00		 lea	 ecx, DWORD PTR [edi+131220]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 1351 : 	m_iPort = iPort;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _iPort$[ebp]
  00031	89 87 ac 00 02
	00		 mov	 DWORD PTR [edi+131244], eax
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 1352 : }

  00039	5d		 pop	 ebp
  0003a	c2 08 00	 ret	 8
?SetConnectData@CPythonApplication@@QAEXPBDH@Z ENDP	; CPythonApplication::SetConnectData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?GetConnectData@CPythonApplication@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAH@Z
_TEXT	SEGMENT
_rstIP$ = 8						; size = 4
_riPort$ = 12						; size = 4
?GetConnectData@CPythonApplication@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAH@Z PROC ; CPythonApplication::GetConnectData, COMDAT
; _this$ = ecx

; 1355 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 998  : 		if (this != &_Right)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _rstIP$[ebp]
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 1356 : 	rstIP	= m_strIP;

  00009	8d 86 94 00 02
	00		 lea	 eax, DWORD PTR [esi+131220]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 998  : 		if (this != &_Right)

  0000f	3b c8		 cmp	 ecx, eax
  00011	74 0a		 je	 SHORT $LN57@GetConnect

; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));

  00013	6a ff		 push	 -1
  00015	6a 00		 push	 0
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN57@GetConnect:
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp

; 1357 : 	riPort	= m_iPort;

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _riPort$[ebp]
  00020	8b 8e ac 00 02
	00		 mov	 ecx, DWORD PTR [esi+131244]
  00026	5e		 pop	 esi
  00027	89 08		 mov	 DWORD PTR [eax], ecx

; 1358 : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?GetConnectData@CPythonApplication@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAH@Z ENDP ; CPythonApplication::GetConnectData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?EnableSpecialCameraMode@CPythonApplication@@QAEXXZ
_TEXT	SEGMENT
?EnableSpecialCameraMode@CPythonApplication@@QAEXXZ PROC ; CPythonApplication::EnableSpecialCameraMode, COMDAT
; _this$ = ecx

; 1362 : 	m_isSpecialCameraMode = TRUE;

  00000	c7 81 4c 00 02
	00 01 00 00 00	 mov	 DWORD PTR [ecx+131148], 1

; 1363 : }

  0000a	c3		 ret	 0
?EnableSpecialCameraMode@CPythonApplication@@QAEXXZ ENDP ; CPythonApplication::EnableSpecialCameraMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?SetCameraSpeed@CPythonApplication@@QAEXH@Z
_TEXT	SEGMENT
_iPercentage$ = 8					; size = 4
?SetCameraSpeed@CPythonApplication@@QAEXH@Z PROC	; CPythonApplication::SetCameraSpeed, COMDAT
; _this$ = ecx

; 1366 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	66 0f 6e 55 08	 movd	 xmm2, DWORD PTR _iPercentage$[ebp]

; 1367 : 	m_fCameraRotateSpeed = c_fDefaultCameraRotateSpeed * float(iPercentage) / 100.0f;

  00008	0f 5b d2	 cvtdq2ps xmm2, xmm2
  0000b	0f 28 c2	 movaps	 xmm0, xmm2

; 1368 : 	m_fCameraPitchSpeed = c_fDefaultCameraPitchSpeed * float(iPercentage) / 100.0f;
; 1369 : 	m_fCameraZoomSpeed = c_fDefaultCameraZoomSpeed * float(iPercentage) / 100.0f;

  0000e	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@3d4ccccd
  00016	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3fc00000
  0001e	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@42c80000
  00026	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0002e	f3 0f 11 91 30
	00 02 00	 movss	 DWORD PTR [ecx+131120], xmm2
  00036	f3 0f 11 81 28
	00 02 00	 movss	 DWORD PTR [ecx+131112], xmm0
  0003e	f3 0f 11 81 2c
	00 02 00	 movss	 DWORD PTR [ecx+131116], xmm0

; 1370 : }

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?SetCameraSpeed@CPythonApplication@@QAEXH@Z ENDP	; CPythonApplication::SetCameraSpeed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?SetForceSightRange@CPythonApplication@@QAEXH@Z
_TEXT	SEGMENT
_iRange$ = 8						; size = 4
?SetForceSightRange@CPythonApplication@@QAEXH@Z PROC	; CPythonApplication::SetForceSightRange, COMDAT
; _this$ = ecx

; 1373 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1374 : 	m_iForceSightRange = iRange;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iRange$[ebp]
  00006	89 81 c0 00 02
	00		 mov	 DWORD PTR [ecx+131264], eax

; 1375 : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetForceSightRange@CPythonApplication@@QAEXH@Z ENDP	; CPythonApplication::SetForceSightRange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?Clear@CPythonApplication@@QAEXXZ
_TEXT	SEGMENT
?Clear@CPythonApplication@@QAEXXZ PROC			; CPythonApplication::Clear, COMDAT
; _this$ = ecx

; 1379 : 	m_pySystem.Clear();

  00000	81 c1 70 d8 01
	00		 add	 ecx, 120944		; 0001d870H
  00006	e9 00 00 00 00	 jmp	 ?Clear@CPythonSystem@@QAEXXZ ; CPythonSystem::Clear
?Clear@CPythonApplication@@QAEXXZ ENDP			; CPythonApplication::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\pythonapplication.cpp
;	COMDAT ?Destroy@CPythonApplication@@QAEXXZ
_TEXT	SEGMENT
_sStickKeys$ = -8					; size = 8
?Destroy@CPythonApplication@@QAEXXZ PROC		; CPythonApplication::Destroy, COMDAT
; _this$ = ecx

; 1383 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1384 : 	WebBrowser_Destroy();

  00009	e8 00 00 00 00	 call	 _WebBrowser_Destroy

; 1385 : 
; 1386 : 	// SphereMap
; 1387 : 	CGrannyMaterial::DestroySphereMap();

  0000e	e8 00 00 00 00	 call	 ?DestroySphereMap@CGrannyMaterial@@SAXXZ ; CGrannyMaterial::DestroySphereMap

; 1388 : 
; 1389 : 	m_kWndMgr.Destroy();

  00013	8d 8e 10 02 00
	00		 lea	 ecx, DWORD PTR [esi+528]
  00019	e8 00 00 00 00	 call	 ?Destroy@CWindowManager@UI@@QAEXXZ ; UI::CWindowManager::Destroy

; 1390 : 
; 1391 : 	CPythonSystem::Instance().SaveConfig();

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonSystem@@@@0PAVCPythonSystem@@A ; CSingleton<CPythonSystem>::ms_singleton
  00024	e8 00 00 00 00	 call	 ?SaveConfig@CPythonSystem@@QAE_NXZ ; CPythonSystem::SaveConfig

; 1392 : 
; 1393 : 	DestroyCollisionInstanceSystem();

  00029	e8 00 00 00 00	 call	 ?DestroyCollisionInstanceSystem@@YAXXZ ; DestroyCollisionInstanceSystem

; 1394 : 
; 1395 : 	m_pySystem.SaveInterfaceStatus();

  0002e	8d 8e 70 d8 01
	00		 lea	 ecx, DWORD PTR [esi+120944]
  00034	e8 00 00 00 00	 call	 ?SaveInterfaceStatus@CPythonSystem@@QAEXXZ ; CPythonSystem::SaveInterfaceStatus

; 1396 : 
; 1397 : 	m_pyEventManager.Destroy();	

  00039	8d 8e f4 ba 01
	00		 lea	 ecx, DWORD PTR [esi+113396]
  0003f	e8 00 00 00 00	 call	 ?Destroy@CPythonEventManager@@QAEXXZ ; CPythonEventManager::Destroy

; 1398 : 	m_FlyingManager.Destroy();

  00044	8d 8e 5c 01 00
	00		 lea	 ecx, DWORD PTR [esi+348]
  0004a	e8 00 00 00 00	 call	 ?Destroy@CFlyingManager@@QAEXXZ ; CFlyingManager::Destroy

; 1399 : 
; 1400 : 	m_pyMiniMap.Destroy();

  0004f	8d 8e bc ae 01
	00		 lea	 ecx, DWORD PTR [esi+110268]
  00055	e8 00 00 00 00	 call	 ?Destroy@CPythonMiniMap@@QAEXXZ ; CPythonMiniMap::Destroy

; 1401 : 
; 1402 : 	m_pyTextTail.Destroy();

  0005a	8d 8e 60 ae 01
	00		 lea	 ecx, DWORD PTR [esi+110176]
  00060	e8 00 00 00 00	 call	 ?Destroy@CPythonTextTail@@QAEXXZ ; CPythonTextTail::Destroy

; 1403 : 	m_pyChat.Destroy();	

  00065	8d 8e 8c ad 01
	00		 lea	 ecx, DWORD PTR [esi+109964]
  0006b	e8 00 00 00 00	 call	 ?Destroy@CPythonChat@@QAEXXZ ; CPythonChat::Destroy

; 1404 : 	m_kChrMgr.Destroy();

  00070	8b 86 dc 02 00
	00		 mov	 eax, DWORD PTR [esi+732]
  00076	8d 8e dc 02 00
	00		 lea	 ecx, DWORD PTR [esi+732]
  0007c	ff 50 04	 call	 DWORD PTR [eax+4]

; 1405 : 	m_RaceManager.Destroy();

  0007f	8d 8e 80 01 00
	00		 lea	 ecx, DWORD PTR [esi+384]
  00085	e8 00 00 00 00	 call	 ?Destroy@CRaceManager@@QAEXXZ ; CRaceManager::Destroy

; 1406 : 
; 1407 : 	m_pyItem.Destroy();

  0008a	8d 8e 08 94 01
	00		 lea	 ecx, DWORD PTR [esi+103432]
  00090	e8 00 00 00 00	 call	 ?Destroy@CPythonItem@@QAEXXZ ; CPythonItem::Destroy

; 1408 : 	m_kItemMgr.Destroy();

  00095	8d 8e cc 01 00
	00		 lea	 ecx, DWORD PTR [esi+460]
  0009b	e8 00 00 00 00	 call	 ?Destroy@CItemManager@@QAEXXZ ; CItemManager::Destroy

; 1409 : 
; 1410 : 	m_pyBackground.Destroy();

  000a0	8d 8e 74 bb 01
	00		 lea	 ecx, DWORD PTR [esi+113524]
  000a6	e8 00 00 00 00	 call	 ?Destroy@CPythonBackground@@QAEXXZ ; CPythonBackground::Destroy

; 1411 : 
; 1412 : 	m_kEftMgr.Destroy();

  000ab	8d 8e b0 02 00
	00		 lea	 ecx, DWORD PTR [esi+688]
  000b1	e8 00 00 00 00	 call	 ?Destroy@CEffectManager@@QAEXXZ ; CEffectManager::Destroy

; 1413 : 	m_LightManager.Destroy();

  000b6	8d 4e 7c	 lea	 ecx, DWORD PTR [esi+124]
  000b9	e8 00 00 00 00	 call	 ?Destroy@CLightManager@@QAEXXZ ; CLightManager::Destroy

; 1414 : 
; 1415 : 	// DEFAULT_FONT
; 1416 : 	DefaultFont_Cleanup();

  000be	e8 00 00 00 00	 call	 ?DefaultFont_Cleanup@@YAXXZ ; DefaultFont_Cleanup

; 1417 : 	// END_OF_DEFAULT_FONT
; 1418 : 
; 1419 : 	GrannyDestroySharedDeformBuffer();

  000c3	e8 00 00 00 00	 call	 ?GrannyDestroySharedDeformBuffer@@YAXXZ ; GrannyDestroySharedDeformBuffer

; 1420 : 
; 1421 : 	m_pyGraphic.Destroy();

  000c8	8d 8e 9c 07 00
	00		 lea	 ecx, DWORD PTR [esi+1948]
  000ce	e8 00 00 00 00	 call	 ?Destroy@CPythonGraphic@@QAEXXZ ; CPythonGraphic::Destroy

; 1422 : 	//m_pyNetworkDatagram.Destroy();	
; 1423 : 
; 1424 : 	m_pyRes.Destroy();

  000d3	8d 8e c8 d1 01
	00		 lea	 ecx, DWORD PTR [esi+119240]
  000d9	e8 00 00 00 00	 call	 ?Destroy@CPythonResource@@QAEXXZ ; CPythonResource::Destroy

; 1425 : 
; 1426 : 	m_kGuildMarkDownloader.Disconnect();

  000de	8d 8e 2c d3 01
	00		 lea	 ecx, DWORD PTR [esi+119596]
  000e4	e8 00 00 00 00	 call	 ?Disconnect@CNetworkStream@@QAEXXZ ; CNetworkStream::Disconnect

; 1427 : 
; 1428 : 	CGrannyModelInstance::DestroySystem();

  000e9	e8 00 00 00 00	 call	 ?DestroySystem@CGrannyModelInstance@@SAXXZ ; CGrannyModelInstance::DestroySystem

; 1429 : 	CGraphicImageInstance::DestroySystem();

  000ee	e8 00 00 00 00	 call	 ?DestroySystem@CGraphicImageInstance@@SAXXZ ; CGraphicImageInstance::DestroySystem

; 1430 : 
; 1431 : 
; 1432 : 	m_SoundManager.Destroy();

  000f3	8d 8e e8 00 00
	00		 lea	 ecx, DWORD PTR [esi+232]
  000f9	e8 00 00 00 00	 call	 ?Destroy@CSoundManager@@QAEXXZ ; CSoundManager::Destroy

; 1433 : 	m_grpDevice.Destroy();

  000fe	8d 8e 54 d8 01
	00		 lea	 ecx, DWORD PTR [esi+120916]
  00104	e8 00 00 00 00	 call	 ?Destroy@CGraphicDevice@@QAEXXZ ; CGraphicDevice::Destroy

; 1434 : 
; 1435 : 	// FIXME :    - [levites]
; 1436 : 	//CSpeedTreeForestDirectX8::Instance().Clear();
; 1437 : 
; 1438 : 	CAttributeInstance::DestroySystem();

  00109	e8 00 00 00 00	 call	 ?DestroySystem@CAttributeInstance@@SAXXZ ; CAttributeInstance::DestroySystem

; 1439 : 	CTextFileLoader::DestroySystem();

  0010e	e8 00 00 00 00	 call	 ?DestroySystem@CTextFileLoader@@SAXXZ ; CTextFileLoader::DestroySystem

; 1440 : 	DestroyCursors();

  00113	8b ce		 mov	 ecx, esi
  00115	e8 00 00 00 00	 call	 ?DestroyCursors@CPythonApplication@@QAEXXZ ; CPythonApplication::DestroyCursors

; 1441 : 
; 1442 : 	CMSApplication::Destroy();

  0011a	8b ce		 mov	 ecx, esi
  0011c	e8 00 00 00 00	 call	 ?Destroy@CMSWindow@@QAEXXZ ; CMSWindow::Destroy

; 1443 : 
; 1444 : 	STICKYKEYS sStickKeys;
; 1445 : 	memset(&sStickKeys, 0, sizeof(sStickKeys));
; 1446 : 	sStickKeys.cbSize = sizeof(sStickKeys);
; 1447 : 	sStickKeys.dwFlags = m_dwStickyKeysFlag;

  00121	8b 86 b8 00 02
	00		 mov	 eax, DWORD PTR [esi+131256]
  00127	0f 57 c0	 xorps	 xmm0, xmm0
  0012a	66 0f d6 45 f8	 movq	 QWORD PTR _sStickKeys$[ebp], xmm0

; 1448 : 	SystemParametersInfo( SPI_SETSTICKYKEYS, sizeof(sStickKeys), &sStickKeys, 0 );

  0012f	6a 00		 push	 0
  00131	89 45 fc	 mov	 DWORD PTR _sStickKeys$[ebp+4], eax
  00134	8d 45 f8	 lea	 eax, DWORD PTR _sStickKeys$[ebp]
  00137	50		 push	 eax
  00138	6a 08		 push	 8
  0013a	6a 3b		 push	 59			; 0000003bH
  0013c	c7 45 f8 08 00
	00 00		 mov	 DWORD PTR _sStickKeys$[ebp], 8
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SystemParametersInfoA@16

; 1449 : }

  00149	5e		 pop	 esi
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
?Destroy@CPythonApplication@@QAEXXZ ENDP		; CPythonApplication::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ PROC	; CSingleton<CTimer>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ENDP	; CSingleton<CTimer>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCWindowManager@UI@@@@SAAAVCWindowManager@UI@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCWindowManager@UI@@@@SAAAVCWindowManager@UI@@XZ PROC ; CSingleton<UI::CWindowManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCWindowManager@UI@@@@SAAAVCWindowManager@UI@@XZ ENDP ; CSingleton<UI::CWindowManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCPythonSkill@@@@SAAAVCPythonSkill@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCPythonSkill@@@@SAAAVCPythonSkill@@XZ PROC ; CSingleton<CPythonSkill>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonSkill@@@@0PAVCPythonSkill@@A ; CSingleton<CPythonSkill>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCPythonSkill@@@@SAAAVCPythonSkill@@XZ ENDP ; CSingleton<CPythonSkill>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCPythonIME@@@@SAAAVCPythonIME@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCPythonIME@@@@SAAAVCPythonIME@@XZ PROC ; CSingleton<CPythonIME>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonIME@@@@0PAVCPythonIME@@A ; CSingleton<CPythonIME>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCPythonIME@@@@SAAAVCPythonIME@@XZ ENDP ; CSingleton<CPythonIME>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
;	COMDAT ??0?$TAbstractSingleton@VIAbstractApplication@@@@QAE@XZ
_TEXT	SEGMENT
??0?$TAbstractSingleton@VIAbstractApplication@@@@QAE@XZ PROC ; TAbstractSingleton<IAbstractApplication>::TAbstractSingleton<IAbstractApplication>, COMDAT
; _this$ = ecx

; 9    : 	TAbstractSingleton()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$TAbstractSingleton@VIAbstractApplication@@@@6B@

; 10   : 	{ 
; 11   : 		assert(!ms_singleton);
; 12   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 
; 13   : 		ms_singleton = (T*) ((int) this + offset);
; 14   : 	} 

  00006	8b c1		 mov	 eax, ecx
  00008	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A, ecx ; TAbstractSingleton<IAbstractApplication>::ms_singleton
  0000e	c3		 ret	 0
??0?$TAbstractSingleton@VIAbstractApplication@@@@QAE@XZ ENDP ; TAbstractSingleton<IAbstractApplication>::TAbstractSingleton<IAbstractApplication>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
;	COMDAT ??1?$TAbstractSingleton@VIAbstractApplication@@@@UAE@XZ
_TEXT	SEGMENT
??1?$TAbstractSingleton@VIAbstractApplication@@@@UAE@XZ PROC ; TAbstractSingleton<IAbstractApplication>::~TAbstractSingleton<IAbstractApplication>, COMDAT
; _this$ = ecx

; 17   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$TAbstractSingleton@VIAbstractApplication@@@@6B@

; 18   : 		assert(ms_singleton);
; 19   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A, 0 ; TAbstractSingleton<IAbstractApplication>::ms_singleton

; 20   : 	}

  00010	c3		 ret	 0
??1?$TAbstractSingleton@VIAbstractApplication@@@@UAE@XZ ENDP ; TAbstractSingleton<IAbstractApplication>::~TAbstractSingleton<IAbstractApplication>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??0?$CSingleton@VCMovieMan@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CSingleton@VCMovieMan@@@@QAE@XZ PROC		; CSingleton<CMovieMan>::CSingleton<CMovieMan>, COMDAT
; _this$ = ecx

; 11   : 	CSingleton()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCMovieMan@@@@6B@

; 12   : 	{ 
; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 
; 15   : 		ms_singleton = (T*) ((int) this + offset);
; 16   : 	} 

  00006	8b c1		 mov	 eax, ecx
  00008	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A, ecx ; CSingleton<CMovieMan>::ms_singleton
  0000e	c3		 ret	 0
??0?$CSingleton@VCMovieMan@@@@QAE@XZ ENDP		; CSingleton<CMovieMan>::CSingleton<CMovieMan>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??1?$CSingleton@VCMovieMan@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CSingleton@VCMovieMan@@@@UAE@XZ PROC		; CSingleton<CMovieMan>::~CSingleton<CMovieMan>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCMovieMan@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A, 0 ; CSingleton<CMovieMan>::ms_singleton

; 22   : 	}

  00010	c3		 ret	 0
??1?$CSingleton@VCMovieMan@@@@UAE@XZ ENDP		; CSingleton<CMovieMan>::~CSingleton<CMovieMan>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??0?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ PROC ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >, COMDAT
; _this$ = ecx

; 95   : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 96   : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c3		 ret	 0
??0?$map@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >::map<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >, COMDAT
; _this$ = ecx

; 1191 : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1193 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\userinterface\abstractsingleton.h
;	COMDAT ??_G?$TAbstractSingleton@VIAbstractApplication@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$TAbstractSingleton@VIAbstractApplication@@@@UAEPAXI@Z PROC ; TAbstractSingleton<IAbstractApplication>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 19   : 		ms_singleton = 0; 

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A, 0 ; TAbstractSingleton<IAbstractApplication>::ms_singleton
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$TAbstractSingleton@VIAbstractApplication@@@@6B@
  0001a	74 09		 je	 SHORT $LN6@scalar
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_G?$TAbstractSingleton@VIAbstractApplication@@@@UAEPAXI@Z ENDP ; TAbstractSingleton<IAbstractApplication>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\metin2\metin2\client_source_clean\client_source_clean\source\eterbase\singleton.h
;	COMDAT ??_G?$CSingleton@VCMovieMan@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CSingleton@VCMovieMan@@@@UAEPAXI@Z PROC		; CSingleton<CMovieMan>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 21   : 		ms_singleton = 0; 

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A, 0 ; CSingleton<CMovieMan>::ms_singleton
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCMovieMan@@@@6B@
  0001a	74 09		 je	 SHORT $LN6@scalar
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_G?$CSingleton@VCMovieMan@@@@UAEPAXI@Z ENDP		; CSingleton<CMovieMan>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_comp@$0A@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp@$0A@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >, COMDAT
; _this$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_Tree_comp@$0A@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::~_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_buy@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_buy@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ PROC ; std::_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >::~_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >, COMDAT
; _this$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_Tree_buy@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@XZ ENDP ; std::_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >::~_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >, COMDAT
; _this$ = ecx

; 1066 : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 1067 : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2229 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2230 : 		erase(begin(), end());

  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	50		 push	 eax
  00007	ff 30		 push	 DWORD PTR [eax]
  00009	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase

; 2231 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAX@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<int const ,void *> >::allocator<std::pair<int const ,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 779  : 		}

  00008	c3		 ret	 0
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::begin, COMDAT
; _this$ = ecx

; 1211 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 44   : 		{	// construct with node pointer _Pnode

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end, COMDAT
; _this$ = ecx

; 1221 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase, COMDAT
; _this$ = ecx

; 1511 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]

; 1512 : 		if (_First == begin() && _Last == end())

  00007	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0000e	8b 37		 mov	 esi, DWORD PTR [edi]

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00010	3b 06		 cmp	 eax, DWORD PTR [esi]

; 1512 : 		if (_First == begin() && _Last == end())

  00012	75 1a		 jne	 SHORT $LN97@erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00014	3b d6		 cmp	 edx, esi

; 1512 : 		if (_First == begin() && _Last == end())

  00016	75 16		 jne	 SHORT $LN97@erase

; 1513 : 			{	// erase all
; 1514 : 			clear();

  00018	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::clear

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi

; 44   : 		{	// construct with node pointer _Pnode

  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00026	89 08		 mov	 DWORD PTR [eax], ecx

; 1522 : 			}
; 1523 : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
$LN97@erase:

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0002e	3b c2		 cmp	 eax, edx

; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

  00030	74 5d		 je	 SHORT $LN1@erase
$LL2@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00032	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;

  00036	8b c8		 mov	 ecx, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00038	75 41		 jne	 SHORT $LN59@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0003a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0003d	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00041	75 19		 jne	 SHORT $LN99@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00043	8b 02		 mov	 eax, DWORD PTR [edx]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00045	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00049	75 2d		 jne	 SHORT $LN109@erase
  0004b	eb 03 8d 49 00	 npad	 5
$LL74@erase:

; 617  : 			_Pnode = _Left(_Pnode);

  00050	8b d0		 mov	 edx, eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00052	8b 02		 mov	 eax, DWORD PTR [edx]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00054	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00058	74 f6		 je	 SHORT $LL74@erase

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else

  0005a	eb 1c		 jmp	 SHORT $LN109@erase
$LN99@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0005c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005f	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00063	75 13		 jne	 SHORT $LN109@erase
$LL58@erase:
  00065	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00068	75 0e		 jne	 SHORT $LN109@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0006a	8b c2		 mov	 eax, edx
  0006c	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
  0006f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00072	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00076	74 ed		 je	 SHORT $LL58@erase
$LN109@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00078	89 55 0c	 mov	 DWORD PTR __First$[ebp], edx
$LN59@erase:

; 1520 : 				erase(_First++);

  0007b	51		 push	 ecx
  0007c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0007f	8b cf		 mov	 ecx, edi
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00087	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0008a	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]

; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

  0008d	75 a3		 jne	 SHORT $LL2@erase
$LN1@erase:

; 44   : 		{	// construct with node pointer _Pnode

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	89 01		 mov	 DWORD PTR [ecx], eax

; 1521 : 			return (iterator(_First._Ptr, this));

  00096	8b c1		 mov	 eax, ecx

; 1522 : 			}
; 1523 : 		}

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp@$0A@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$_Tree_comp@$0A@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >, COMDAT
; _this$ = ecx

; 1002 : 		{	// construct ordering predicate

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 1003 : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 08 00	 ret	 8
??0?$_Tree_comp@$0A@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Tree_comp<0,std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Freeheadnode, COMDAT
; _this$dead$ = ecx

; 857  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 865  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv820 = -8						; size = 4
tv800 = -8						; size = 4
__Pnode$1$ = -8						; size = 4
__Erasednode$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase, COMDAT
; _this$ = ecx

; 1328 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 1328 : 		{	// erase element at _Where

  0000b	8b d9		 mov	 ebx, ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  0000d	89 45 fc	 mov	 DWORD PTR __Erasednode$1$[ebp], eax
  00010	57		 push	 edi

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00014	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00019	8b 55 fc	 mov	 edx, DWORD PTR __Erasednode$1$[ebp]
  0001c	8b 32		 mov	 esi, DWORD PTR [edx]

; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0001e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00022	74 05		 je	 SHORT $LN39@erase

; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00024	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]

; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00027	eb 1a		 jmp	 SHORT $LN308@erase
$LN39@erase:
  00029	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00030	74 04		 je	 SHORT $LN37@erase

; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00032	8b fe		 mov	 edi, esi

; 1349 : 		else

  00034	eb 0d		 jmp	 SHORT $LN308@erase
$LN37@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  00036	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00039	89 4d f8	 mov	 DWORD PTR __Pnode$1$[ebp], ecx

; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  0003c	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)

  0003f	3b ca		 cmp	 ecx, edx
  00041	75 72		 jne	 SHORT $LN35@erase
$LN308@erase:

; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))

  00043	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00047	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0004a	75 03		 jne	 SHORT $LN34@erase

; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  0004c	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0004f	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)

  00051	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  00054	75 05		 jne	 SHORT $LN33@erase

; 1362 : 				_Root() = _Fixnode;	// link down from root

  00056	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00059	eb 0b		 jmp	 SHORT $LN30@erase
$LN33@erase:
  0005b	39 16		 cmp	 DWORD PTR [esi], edx
  0005d	75 04		 jne	 SHORT $LN31@erase

; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0005f	89 3e		 mov	 DWORD PTR [esi], edi

; 1365 : 			else

  00061	eb 03		 jmp	 SHORT $LN30@erase
$LN31@erase:

; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right

  00063	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00066	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)

  00068	39 10		 cmp	 DWORD PTR [eax], edx
  0006a	75 22		 jne	 SHORT $LN29@erase

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0006c	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00070	74 04		 je	 SHORT $LN42@erase
  00072	8b ce		 mov	 ecx, esi
  00074	eb 16		 jmp	 SHORT $LN43@erase
$LN42@erase:

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00076	8b 07		 mov	 eax, DWORD PTR [edi]

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  00078	8b cf		 mov	 ecx, edi

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0007a	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0007e	75 0a		 jne	 SHORT $LN92@erase
$LL93@erase:

; 617  : 			_Pnode = _Left(_Pnode);

  00080	8b c8		 mov	 ecx, eax

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00082	8b 01		 mov	 eax, DWORD PTR [ecx]

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00084	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00088	74 f6		 je	 SHORT $LL93@erase
$LN92@erase:
  0008a	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN43@erase:

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0008c	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0008e	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)

  00090	39 50 08	 cmp	 DWORD PTR [eax+8], edx
  00093	75 7c		 jne	 SHORT $LN170@erase

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  00095	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00099	74 09		 je	 SHORT $LN44@erase
  0009b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0009d	8b c6		 mov	 eax, esi
  0009f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1378 : 			}
; 1379 : 		else

  000a2	eb 6d		 jmp	 SHORT $LN170@erase
$LN44@erase:

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a4	8b cf		 mov	 ecx, edi
  000a6	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Max
  000ab	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ad	8b 55 fc	 mov	 edx, DWORD PTR __Erasednode$1$[ebp]
  000b0	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1378 : 			}
; 1379 : 		else

  000b3	eb 5c		 jmp	 SHORT $LN170@erase
$LN35@erase:

; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up

  000b5	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down

  000b8	8b 02		 mov	 eax, DWORD PTR [edx]
  000ba	89 01		 mov	 DWORD PTR [ecx], eax

; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))

  000bc	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  000bf	75 04		 jne	 SHORT $LN26@erase

; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000c1	8b f1		 mov	 esi, ecx

; 1388 : 			else

  000c3	eb 1a		 jmp	 SHORT $LN25@erase
$LN26@erase:

; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))

  000c5	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000c9	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000cc	75 03		 jne	 SHORT $LN24@erase

; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000ce	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase:

; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000d1	89 3e		 mov	 DWORD PTR [esi], edi

; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down

  000d3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d6	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up

  000d9	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000dc	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN25@erase:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000df	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)

  000e1	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  000e4	75 05		 jne	 SHORT $LN23@erase

; 1402 : 				_Root() = _Pnode;	// link down from root

  000e6	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000e9	eb 0e		 jmp	 SHORT $LN20@erase
$LN23@erase:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  000eb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000ee	39 10		 cmp	 DWORD PTR [eax], edx
  000f0	75 04		 jne	 SHORT $LN21@erase

; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left

  000f2	89 08		 mov	 DWORD PTR [eax], ecx

; 1406 : 			else

  000f4	eb 03		 jmp	 SHORT $LN20@erase
$LN21@erase:

; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right

  000f6	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN20@erase:

; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up

  000f9	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000fc	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  000ff	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  00102	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$1$[ebp]
  00105	8a 49 0c	 mov	 cl, BYTE PTR [ecx+12]
  00108	88 42 0c	 mov	 BYTE PTR [edx+12], al

; 54   : 	_Right = _Move(_Tmp);

  0010b	8b 55 fc	 mov	 edx, DWORD PTR __Erasednode$1$[ebp]
  0010e	88 4a 0c	 mov	 BYTE PTR [edx+12], cl
$LN170@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)

  00111	80 7a 0c 01	 cmp	 BYTE PTR [edx+12], 1
  00115	0f 85 08 01 00
	00		 jne	 $LN19@erase

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  0011b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0011d	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00120	0f 84 f9 00 00
	00		 je	 $LN16@erase
$LL18@erase:
  00126	80 7f 0c 01	 cmp	 BYTE PTR [edi+12], 1
  0012a	0f 85 ec 00 00
	00		 jne	 $LN311@erase

; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00130	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00132	3b f9		 cmp	 edi, ecx
  00134	75 6c		 jne	 SHORT $LN15@erase

; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);

  00136	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1424 : 					if (this->_Color(_Pnode) == this->_Red)

  00139	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0013d	75 13		 jne	 SHORT $LN14@erase

; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;

  0013f	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);

  00143	8b cb		 mov	 ecx, ebx
  00145	56		 push	 esi
  00146	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  0014a	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate

; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);

  0014f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN14@erase:

; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))

  00152	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00156	75 7d		 jne	 SHORT $LN312@erase

; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00158	8b 01		 mov	 eax, DWORD PTR [ecx]
  0015a	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  0015e	75 09		 jne	 SHORT $LN11@erase
  00160	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00163	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00167	74 68		 je	 SHORT $LN313@erase
$LN11@erase:

; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)

  00169	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0016c	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00170	75 15		 jne	 SHORT $LN9@erase

; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  00172	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);

  00174	51		 push	 ecx
  00175	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00179	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  0017d	8b cb		 mov	 ecx, ebx
  0017f	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate

; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);

  00184	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN9@erase:

; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00187	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  0018a	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0018d	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  00191	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1454 : 						_Lrotate(_Fixnodeparent);

  00194	8b cb		 mov	 ecx, ebx
  00196	56		 push	 esi
  00197	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0019b	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate

; 1455 : 						break;	// tree now recolored/rebalanced

  001a0	eb 7a		 jmp	 SHORT $LN311@erase
$LN15@erase:

; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)

  001a2	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001a6	75 12		 jne	 SHORT $LN7@erase

; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;

  001a8	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);

  001ac	8b cb		 mov	 ecx, ebx
  001ae	56		 push	 esi
  001af	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  001b3	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate

; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);

  001b8	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN7@erase:

; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))

  001ba	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001be	75 15		 jne	 SHORT $LN312@erase

; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c0	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001c3	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001c7	75 1e		 jne	 SHORT $LN4@erase
  001c9	8b 01		 mov	 eax, DWORD PTR [ecx]
  001cb	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001cf	75 16		 jne	 SHORT $LN4@erase
$LN313@erase:

; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;

  001d1	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
$LN312@erase:

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001d5	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1476 : 						_Fixnode = _Fixnodeparent;

  001d7	8b fe		 mov	 edi, esi
  001d9	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001dc	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001df	0f 85 41 ff ff
	ff		 jne	 $LL18@erase

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001e5	eb 35		 jmp	 SHORT $LN311@erase
$LN4@erase:

; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001e7	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e9	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001ed	75 15		 jne	 SHORT $LN2@erase

; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001ef	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);

  001f2	51		 push	 ecx
  001f3	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  001f7	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  001fb	8b cb		 mov	 ecx, ebx
  001fd	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate

; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);

  00202	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN2@erase:

; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00204	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  00207	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0020a	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  0020e	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1491 : 						_Rrotate(_Fixnodeparent);

  00210	8b cb		 mov	 ecx, ebx
  00212	56		 push	 esi
  00213	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00217	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate
$LN311@erase:
  0021c	8b 55 fc	 mov	 edx, DWORD PTR __Erasednode$1$[ebp]
$LN16@erase:

; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0021f	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
$LN19@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00223	52		 push	 edx
  00224	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 1504 : 		if (0 < this->_Mysize)

  00229	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0022c	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

  0022f	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]

; 1504 : 		if (0 < this->_Mysize)

  00232	85 c0		 test	 eax, eax
  00234	74 04		 je	 SHORT $LN310@erase

; 1505 : 			--this->_Mysize;

  00236	48		 dec	 eax
  00237	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN310@erase:

; 44   : 		{	// construct with node pointer _Pnode

  0023a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	5b		 pop	 ebx
  00240	89 08		 mov	 DWORD PTR [eax], ecx

; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}

  00242	8b e5		 mov	 esp, ebp
  00244	5d		 pop	 ebp
  00245	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::clear, COMDAT
; _this$ = ecx

; 1535 : 		{	// erase all

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());

  00005	8b 07		 mov	 eax, DWORD PTR [edi]
  00007	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]

; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;

  0000a	8b f3		 mov	 esi, ebx

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000c	80 7b 0d 00	 cmp	 BYTE PTR [ebx+13], 0
  00010	75 1d		 jne	 SHORT $LN7@clear
$LL9@clear:

; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));

  00012	ff 76 08	 push	 DWORD PTR [esi+8]
  00015	8b cf		 mov	 ecx, edi
  00017	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Erase

; 2079 : 			_Pnode = this->_Left(_Pnode);

  0001c	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0001e	53		 push	 ebx
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00027	8b de		 mov	 ebx, esi
  00029	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002d	74 e3		 je	 SHORT $LL9@clear
$LN7@clear:

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]

; 1541 : 		_Root() = this->_Myhead;

  00031	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1542 : 		_Lmost() = this->_Myhead;

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	89 00		 mov	 DWORD PTR [eax], eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00038	8b 07		 mov	 eax, DWORD PTR [edi]

; 1543 : 		_Rmost() = this->_Myhead;

  0003a	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1544 : 		this->_Mysize = 0;

  0003d	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx

; 1545 : 		}

  00047	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2123 : 		return (this->_Left(this->_Myhead));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2124 : 		}

  00002	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_buy@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??0?$_Tree_buy@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >::_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >, COMDAT
; _this$ = ecx

; 889  : 		{	// construct from allocator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 890  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$_Tree_buy@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >::_Tree_buy<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Getal, COMDAT
; _this$dead$ = ecx

; 868  : 		{	// get allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 870  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Left, COMDAT
; __Pnode$ = ecx

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00000	8b c1		 mov	 eax, ecx

; 590  : 		}

  00002	c3		 ret	 0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Parent, COMDAT
; __Pnode$ = ecx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 595  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Right, COMDAT
; __Pnode$ = ecx

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 600  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 385  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator++, COMDAT
; _this$ = ecx

; 276  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 277  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 271  : 		++(*(_Mybase *)this);

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::operator++

; 278  : 		++*this;
; 279  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 280  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator==, COMDAT
; _this$ = ecx

; 322  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 337  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 342  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2074 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	8b f7		 mov	 esi, edi

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 1d		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));

  00013	ff 76 08	 push	 DWORD PTR [esi+8]
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Erase

; 2079 : 			_Pnode = this->_Left(_Pnode);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00028	8b fe		 mov	 edi, esi
  0002a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002e	74 e3		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx

; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2127 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi

; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00007	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Lrotate:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0d		 jne	 SHORT $LN4@Lrotate

; 2136 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0002a	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0002c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002f	5e		 pop	 esi

; 2144 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@Lrotate:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00037	3b 10		 cmp	 edx, DWORD PTR [eax]
  00039	75 0c		 jne	 SHORT $LN2@Lrotate

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003b	89 30		 mov	 DWORD PTR [eax], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0003d	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0003f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00042	5e		 pop	 esi

; 2144 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0004f	5e		 pop	 esi

; 2144 : 		}

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}

  00005	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4

; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}

  00005	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2157 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Rrotate:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0e		 jne	 SHORT $LN4@Rrotate

; 2166 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0002a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  0002d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00030	5e		 pop	 esi

; 2174 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Rrotate:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00038	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003b	75 0e		 jne	 SHORT $LN2@Rrotate

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00043	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00046	5e		 pop	 esi

; 2174 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00053	5e		 pop	 esi

; 2174 : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAXU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,void *,std::less<int>,std::allocator<std::pair<int const ,void *> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >, COMDAT
; _this$ = ecx

; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 774  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAX@std@@@1@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Color, COMDAT
; __Pnode$ = ecx

; 579  : 		return ((char&)_Pnode->_Color);

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]

; 580  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Isnil, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8d 41 0d	 lea	 eax, DWORD PTR [ecx+13]

; 585  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Myval, COMDAT
; __Pnode$ = ecx

; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 605  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAAAU?$pair@$$CBHPAX@2@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Max, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00003	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00007	75 12		 jne	 SHORT $LN15@Max
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL2@Max:

; 610  : 			_Pnode = _Right(_Pnode);

  00010	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN15@Max:

; 611  : 		return (_Pnode);

  0001b	8b c1		 mov	 eax, ecx

; 612  : 		}

  0001d	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Min, COMDAT
; __Pnode$ = ecx

; 584  : 		return ((char&)_Pnode->_Isnil);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00002	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00006	75 0a		 jne	 SHORT $LN15@Min
$LL2@Min:

; 617  : 			_Pnode = _Left(_Pnode);

  00008	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0000c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00010	74 f6		 je	 SHORT $LL2@Min
$LN15@Min:

; 618  : 		return (_Pnode);

  00012	8b c1		 mov	 eax, ecx

; 619  : 		}

  00014	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 215  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator++, COMDAT
; _this$ = ecx

; 256  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 273  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 124  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Buyheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 00 00 00
	00		 je	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00012	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	85 c9		 test	 ecx, ecx
  00019	74 02		 je	 SHORT $LN61@Buyheadnod
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
$LN61@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0001d	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00020	85 c9		 test	 ecx, ecx
  00022	74 02		 je	 SHORT $LN83@Buyheadnod
  00024	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 851  : 		this->_Color(_Pnode) = this->_Black;

  00026	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}

  0002c	c3		 ret	 0
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBHPAX@std@@V?$allocator@U?$pair@$$CBHPAX@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<int const ,void *>,std::allocator<std::pair<int const ,void *> > > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >, COMDAT
; _this$ = ecx

; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 570  : 		this->_Mysize = 0;
; 571  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

  00000	8b d1		 mov	 edx, ecx

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	75 42		 jne	 SHORT $LN41@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00011	75 1c		 jne	 SHORT $LN34@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	75 0f		 jne	 SHORT $LN17@operator
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator:

; 617  : 			_Pnode = _Left(_Pnode);

  00020	8b c8		 mov	 ecx, eax

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00022	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 f6		 je	 SHORT $LL18@operator
$LN17@operator:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0002a	89 0a		 mov	 DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

  0002c	8b c2		 mov	 eax, edx

; 74   : 		}

  0002e	c3		 ret	 0
$LN34@operator:

; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00036	75 12		 jne	 SHORT $LN1@operator
$LL2@operator:
  00038	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003a	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0003d	75 0b		 jne	 SHORT $LN1@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003f	89 02		 mov	 DWORD PTR [edx], eax
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00048	74 ee		 je	 SHORT $LL2@operator
$LN1@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  0004a	89 02		 mov	 DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

  0004c	8b c2		 mov	 eax, edx

; 74   : 		}

  0004e	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAX@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,void *> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN15@allocate

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

  0000e	c2 04 00	 ret	 4
$LN15@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN17@allocate:
$LN14@allocate:
  00016	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN12@allocate

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

  0000e	c2 04 00	 ret	 4
$LN12@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN14@allocate:
$LN11@allocate:
  00016	cc		 int	 3
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<int const ,void *>,void *> *>, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<int const ,void *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,void *>,void *> *>, COMDAT
; _this$dead$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,void *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,void *> >, COMDAT
; __Val$ = ecx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 96   : 	}

  00002	c3		 ret	 0
??$addressof@U?$pair@$$CBHPAX@std@@@std@@YAPAU?$pair@$$CBHPAX@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBHPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBHPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::pair<int const ,void *> >, COMDAT
; _this$dead$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBHPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::pair<int const ,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,void *>,void *> *,std::_Tree_node<std::pair<int const ,void *>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,void *>,void *> *,std::_Tree_node<std::pair<int const ,void *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
??$_Allocate@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_Tree_node<std::pair<int const ,void *>,void *> >, COMDAT
; __Count$ = ecx

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	81 f9 aa aa aa
	0a		 cmp	 ecx, 178956970		; 0aaaaaaaH
  00006	77 13		 ja	 SHORT $LN1@Allocate
  00008	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0000b	c1 e0 03	 shl	 eax, 3
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	75 05		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0001b	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00020	c3		 ret	 0
??$_Allocate@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Tree_node<std::pair<int const ,void *>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z
_TEXT	SEGMENT
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,void *>,void *> *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,void *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBHPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAU?$pair@$$CBHPAX@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBHPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAU?$pair@$$CBHPAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::pair<int const ,void *> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@U?$pair@$$CBHPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAU?$pair@$$CBHPAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::destroy<std::pair<int const ,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<int const ,void *>,void *> * &>, COMDAT
; __Arg$ = ecx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1506 : 	}

  00002	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<int const ,void *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,void *>,void *> *,std::_Tree_node<std::pair<int const ,void *>,void *> * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	85 d2		 test	 edx, edx
  00005	74 07		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 02		 mov	 DWORD PTR [edx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> > >::construct<std::_Tree_node<std::pair<int const ,void *>,void *> *,std::_Tree_node<std::pair<int const ,void *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::destroy<std::_Tree_node<std::pair<int const ,void *>,void *> *>, COMDAT
; _this$dead$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::destroy<std::_Tree_node<std::pair<int const ,void *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBHPAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBHPAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::destroy<std::pair<int const ,void *> >, COMDAT
; _this$dead$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBHPAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBHPAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::destroy<std::pair<int const ,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::construct<std::_Tree_node<std::pair<int const ,void *>,void *> *,std::_Tree_node<std::pair<int const ,void *>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBHPAX@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,void *>,void *> >::construct<std::_Tree_node<std::pair<int const ,void *>,void *> *,std::_Tree_node<std::pair<int const ,void *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_ECPythonApplication@@WBM@AEPAXI@Z
_TEXT	SEGMENT
??_ECPythonApplication@@WBM@AEPAXI@Z PROC		; [thunk]:CPythonApplication::`vector deleting destructor', COMDAT
  00000	83 e9 1c	 sub	 ecx, 28			; 0000001cH
  00003	e9 00 00 00 00	 jmp	 ??_ECPythonApplication@@UAEPAXI@Z
??_ECPythonApplication@@WBM@AEPAXI@Z ENDP		; [thunk]:CPythonApplication::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_ECPythonApplication@@WCA@AEPAXI@Z
_TEXT	SEGMENT
??_ECPythonApplication@@WCA@AEPAXI@Z PROC		; [thunk]:CPythonApplication::`vector deleting destructor', COMDAT
  00000	83 e9 20	 sub	 ecx, 32			; 00000020H
  00003	e9 00 00 00 00	 jmp	 ??_ECPythonApplication@@UAEPAXI@Z
??_ECPythonApplication@@WCA@AEPAXI@Z ENDP		; [thunk]:CPythonApplication::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$dead$ = ecx

; 79   :     return _time32(_Time);

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 __time32
  00007	83 c4 04	 add	 esp, 4

; 80   : }

  0000a	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
END
